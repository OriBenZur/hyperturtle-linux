
ebpf_test:	file format elf64-x86-64

Disassembly of section .init:

0000000000005000 <_init>:
    5000: f3 0f 1e fa                  	endbr64
    5004: 48 83 ec 08                  	subq	$8, %rsp
    5008: 48 8b 05 d9 1f 04 00         	movq	270297(%rip), %rax      # 0x46fe8 <_GLOBAL_OFFSET_TABLE_+0x340>
    500f: 48 85 c0                     	testq	%rax, %rax
    5012: 74 02                        	je	0x5016 <_init+0x16>
    5014: ff d0                        	callq	*%rax
    5016: 48 83 c4 08                  	addq	$8, %rsp
    501a: c3                           	retq

Disassembly of section .plt:

0000000000005020 <.plt>:
    5020: ff 35 8a 1c 04 00            	pushq	269450(%rip)            # 0x46cb0 <_GLOBAL_OFFSET_TABLE_+0x8>
    5026: f2 ff 25 8b 1c 04 00         	repne		jmpq	*269451(%rip)   # 0x46cb8 <_GLOBAL_OFFSET_TABLE_+0x10>
    502d: 0f 1f 00                     	nopl	(%rax)
    5030: f3 0f 1e fa                  	endbr64
    5034: 68 00 00 00 00               	pushq	$0
    5039: f2 e9 e1 ff ff ff            	repne		jmp	0x5020 <.plt>
    503f: 90                           	nop
    5040: f3 0f 1e fa                  	endbr64
    5044: 68 01 00 00 00               	pushq	$1
    5049: f2 e9 d1 ff ff ff            	repne		jmp	0x5020 <.plt>
    504f: 90                           	nop
    5050: f3 0f 1e fa                  	endbr64
    5054: 68 02 00 00 00               	pushq	$2
    5059: f2 e9 c1 ff ff ff            	repne		jmp	0x5020 <.plt>
    505f: 90                           	nop
    5060: f3 0f 1e fa                  	endbr64
    5064: 68 03 00 00 00               	pushq	$3
    5069: f2 e9 b1 ff ff ff            	repne		jmp	0x5020 <.plt>
    506f: 90                           	nop
    5070: f3 0f 1e fa                  	endbr64
    5074: 68 04 00 00 00               	pushq	$4
    5079: f2 e9 a1 ff ff ff            	repne		jmp	0x5020 <.plt>
    507f: 90                           	nop
    5080: f3 0f 1e fa                  	endbr64
    5084: 68 05 00 00 00               	pushq	$5
    5089: f2 e9 91 ff ff ff            	repne		jmp	0x5020 <.plt>
    508f: 90                           	nop
    5090: f3 0f 1e fa                  	endbr64
    5094: 68 06 00 00 00               	pushq	$6
    5099: f2 e9 81 ff ff ff            	repne		jmp	0x5020 <.plt>
    509f: 90                           	nop
    50a0: f3 0f 1e fa                  	endbr64
    50a4: 68 07 00 00 00               	pushq	$7
    50a9: f2 e9 71 ff ff ff            	repne		jmp	0x5020 <.plt>
    50af: 90                           	nop
    50b0: f3 0f 1e fa                  	endbr64
    50b4: 68 08 00 00 00               	pushq	$8
    50b9: f2 e9 61 ff ff ff            	repne		jmp	0x5020 <.plt>
    50bf: 90                           	nop
    50c0: f3 0f 1e fa                  	endbr64
    50c4: 68 09 00 00 00               	pushq	$9
    50c9: f2 e9 51 ff ff ff            	repne		jmp	0x5020 <.plt>
    50cf: 90                           	nop
    50d0: f3 0f 1e fa                  	endbr64
    50d4: 68 0a 00 00 00               	pushq	$10
    50d9: f2 e9 41 ff ff ff            	repne		jmp	0x5020 <.plt>
    50df: 90                           	nop
    50e0: f3 0f 1e fa                  	endbr64
    50e4: 68 0b 00 00 00               	pushq	$11
    50e9: f2 e9 31 ff ff ff            	repne		jmp	0x5020 <.plt>
    50ef: 90                           	nop
    50f0: f3 0f 1e fa                  	endbr64
    50f4: 68 0c 00 00 00               	pushq	$12
    50f9: f2 e9 21 ff ff ff            	repne		jmp	0x5020 <.plt>
    50ff: 90                           	nop
    5100: f3 0f 1e fa                  	endbr64
    5104: 68 0d 00 00 00               	pushq	$13
    5109: f2 e9 11 ff ff ff            	repne		jmp	0x5020 <.plt>
    510f: 90                           	nop
    5110: f3 0f 1e fa                  	endbr64
    5114: 68 0e 00 00 00               	pushq	$14
    5119: f2 e9 01 ff ff ff            	repne		jmp	0x5020 <.plt>
    511f: 90                           	nop
    5120: f3 0f 1e fa                  	endbr64
    5124: 68 0f 00 00 00               	pushq	$15
    5129: f2 e9 f1 fe ff ff            	repne		jmp	0x5020 <.plt>
    512f: 90                           	nop
    5130: f3 0f 1e fa                  	endbr64
    5134: 68 10 00 00 00               	pushq	$16
    5139: f2 e9 e1 fe ff ff            	repne		jmp	0x5020 <.plt>
    513f: 90                           	nop
    5140: f3 0f 1e fa                  	endbr64
    5144: 68 11 00 00 00               	pushq	$17
    5149: f2 e9 d1 fe ff ff            	repne		jmp	0x5020 <.plt>
    514f: 90                           	nop
    5150: f3 0f 1e fa                  	endbr64
    5154: 68 12 00 00 00               	pushq	$18
    5159: f2 e9 c1 fe ff ff            	repne		jmp	0x5020 <.plt>
    515f: 90                           	nop
    5160: f3 0f 1e fa                  	endbr64
    5164: 68 13 00 00 00               	pushq	$19
    5169: f2 e9 b1 fe ff ff            	repne		jmp	0x5020 <.plt>
    516f: 90                           	nop
    5170: f3 0f 1e fa                  	endbr64
    5174: 68 14 00 00 00               	pushq	$20
    5179: f2 e9 a1 fe ff ff            	repne		jmp	0x5020 <.plt>
    517f: 90                           	nop
    5180: f3 0f 1e fa                  	endbr64
    5184: 68 15 00 00 00               	pushq	$21
    5189: f2 e9 91 fe ff ff            	repne		jmp	0x5020 <.plt>
    518f: 90                           	nop
    5190: f3 0f 1e fa                  	endbr64
    5194: 68 16 00 00 00               	pushq	$22
    5199: f2 e9 81 fe ff ff            	repne		jmp	0x5020 <.plt>
    519f: 90                           	nop
    51a0: f3 0f 1e fa                  	endbr64
    51a4: 68 17 00 00 00               	pushq	$23
    51a9: f2 e9 71 fe ff ff            	repne		jmp	0x5020 <.plt>
    51af: 90                           	nop
    51b0: f3 0f 1e fa                  	endbr64
    51b4: 68 18 00 00 00               	pushq	$24
    51b9: f2 e9 61 fe ff ff            	repne		jmp	0x5020 <.plt>
    51bf: 90                           	nop
    51c0: f3 0f 1e fa                  	endbr64
    51c4: 68 19 00 00 00               	pushq	$25
    51c9: f2 e9 51 fe ff ff            	repne		jmp	0x5020 <.plt>
    51cf: 90                           	nop
    51d0: f3 0f 1e fa                  	endbr64
    51d4: 68 1a 00 00 00               	pushq	$26
    51d9: f2 e9 41 fe ff ff            	repne		jmp	0x5020 <.plt>
    51df: 90                           	nop
    51e0: f3 0f 1e fa                  	endbr64
    51e4: 68 1b 00 00 00               	pushq	$27
    51e9: f2 e9 31 fe ff ff            	repne		jmp	0x5020 <.plt>
    51ef: 90                           	nop
    51f0: f3 0f 1e fa                  	endbr64
    51f4: 68 1c 00 00 00               	pushq	$28
    51f9: f2 e9 21 fe ff ff            	repne		jmp	0x5020 <.plt>
    51ff: 90                           	nop
    5200: f3 0f 1e fa                  	endbr64
    5204: 68 1d 00 00 00               	pushq	$29
    5209: f2 e9 11 fe ff ff            	repne		jmp	0x5020 <.plt>
    520f: 90                           	nop
    5210: f3 0f 1e fa                  	endbr64
    5214: 68 1e 00 00 00               	pushq	$30
    5219: f2 e9 01 fe ff ff            	repne		jmp	0x5020 <.plt>
    521f: 90                           	nop
    5220: f3 0f 1e fa                  	endbr64
    5224: 68 1f 00 00 00               	pushq	$31
    5229: f2 e9 f1 fd ff ff            	repne		jmp	0x5020 <.plt>
    522f: 90                           	nop
    5230: f3 0f 1e fa                  	endbr64
    5234: 68 20 00 00 00               	pushq	$32
    5239: f2 e9 e1 fd ff ff            	repne		jmp	0x5020 <.plt>
    523f: 90                           	nop
    5240: f3 0f 1e fa                  	endbr64
    5244: 68 21 00 00 00               	pushq	$33
    5249: f2 e9 d1 fd ff ff            	repne		jmp	0x5020 <.plt>
    524f: 90                           	nop
    5250: f3 0f 1e fa                  	endbr64
    5254: 68 22 00 00 00               	pushq	$34
    5259: f2 e9 c1 fd ff ff            	repne		jmp	0x5020 <.plt>
    525f: 90                           	nop
    5260: f3 0f 1e fa                  	endbr64
    5264: 68 23 00 00 00               	pushq	$35
    5269: f2 e9 b1 fd ff ff            	repne		jmp	0x5020 <.plt>
    526f: 90                           	nop
    5270: f3 0f 1e fa                  	endbr64
    5274: 68 24 00 00 00               	pushq	$36
    5279: f2 e9 a1 fd ff ff            	repne		jmp	0x5020 <.plt>
    527f: 90                           	nop
    5280: f3 0f 1e fa                  	endbr64
    5284: 68 25 00 00 00               	pushq	$37
    5289: f2 e9 91 fd ff ff            	repne		jmp	0x5020 <.plt>
    528f: 90                           	nop
    5290: f3 0f 1e fa                  	endbr64
    5294: 68 26 00 00 00               	pushq	$38
    5299: f2 e9 81 fd ff ff            	repne		jmp	0x5020 <.plt>
    529f: 90                           	nop
    52a0: f3 0f 1e fa                  	endbr64
    52a4: 68 27 00 00 00               	pushq	$39
    52a9: f2 e9 71 fd ff ff            	repne		jmp	0x5020 <.plt>
    52af: 90                           	nop
    52b0: f3 0f 1e fa                  	endbr64
    52b4: 68 28 00 00 00               	pushq	$40
    52b9: f2 e9 61 fd ff ff            	repne		jmp	0x5020 <.plt>
    52bf: 90                           	nop
    52c0: f3 0f 1e fa                  	endbr64
    52c4: 68 29 00 00 00               	pushq	$41
    52c9: f2 e9 51 fd ff ff            	repne		jmp	0x5020 <.plt>
    52cf: 90                           	nop
    52d0: f3 0f 1e fa                  	endbr64
    52d4: 68 2a 00 00 00               	pushq	$42
    52d9: f2 e9 41 fd ff ff            	repne		jmp	0x5020 <.plt>
    52df: 90                           	nop
    52e0: f3 0f 1e fa                  	endbr64
    52e4: 68 2b 00 00 00               	pushq	$43
    52e9: f2 e9 31 fd ff ff            	repne		jmp	0x5020 <.plt>
    52ef: 90                           	nop
    52f0: f3 0f 1e fa                  	endbr64
    52f4: 68 2c 00 00 00               	pushq	$44
    52f9: f2 e9 21 fd ff ff            	repne		jmp	0x5020 <.plt>
    52ff: 90                           	nop
    5300: f3 0f 1e fa                  	endbr64
    5304: 68 2d 00 00 00               	pushq	$45
    5309: f2 e9 11 fd ff ff            	repne		jmp	0x5020 <.plt>
    530f: 90                           	nop
    5310: f3 0f 1e fa                  	endbr64
    5314: 68 2e 00 00 00               	pushq	$46
    5319: f2 e9 01 fd ff ff            	repne		jmp	0x5020 <.plt>
    531f: 90                           	nop
    5320: f3 0f 1e fa                  	endbr64
    5324: 68 2f 00 00 00               	pushq	$47
    5329: f2 e9 f1 fc ff ff            	repne		jmp	0x5020 <.plt>
    532f: 90                           	nop
    5330: f3 0f 1e fa                  	endbr64
    5334: 68 30 00 00 00               	pushq	$48
    5339: f2 e9 e1 fc ff ff            	repne		jmp	0x5020 <.plt>
    533f: 90                           	nop
    5340: f3 0f 1e fa                  	endbr64
    5344: 68 31 00 00 00               	pushq	$49
    5349: f2 e9 d1 fc ff ff            	repne		jmp	0x5020 <.plt>
    534f: 90                           	nop
    5350: f3 0f 1e fa                  	endbr64
    5354: 68 32 00 00 00               	pushq	$50
    5359: f2 e9 c1 fc ff ff            	repne		jmp	0x5020 <.plt>
    535f: 90                           	nop
    5360: f3 0f 1e fa                  	endbr64
    5364: 68 33 00 00 00               	pushq	$51
    5369: f2 e9 b1 fc ff ff            	repne		jmp	0x5020 <.plt>
    536f: 90                           	nop
    5370: f3 0f 1e fa                  	endbr64
    5374: 68 34 00 00 00               	pushq	$52
    5379: f2 e9 a1 fc ff ff            	repne		jmp	0x5020 <.plt>
    537f: 90                           	nop
    5380: f3 0f 1e fa                  	endbr64
    5384: 68 35 00 00 00               	pushq	$53
    5389: f2 e9 91 fc ff ff            	repne		jmp	0x5020 <.plt>
    538f: 90                           	nop
    5390: f3 0f 1e fa                  	endbr64
    5394: 68 36 00 00 00               	pushq	$54
    5399: f2 e9 81 fc ff ff            	repne		jmp	0x5020 <.plt>
    539f: 90                           	nop
    53a0: f3 0f 1e fa                  	endbr64
    53a4: 68 37 00 00 00               	pushq	$55
    53a9: f2 e9 71 fc ff ff            	repne		jmp	0x5020 <.plt>
    53af: 90                           	nop
    53b0: f3 0f 1e fa                  	endbr64
    53b4: 68 38 00 00 00               	pushq	$56
    53b9: f2 e9 61 fc ff ff            	repne		jmp	0x5020 <.plt>
    53bf: 90                           	nop
    53c0: f3 0f 1e fa                  	endbr64
    53c4: 68 39 00 00 00               	pushq	$57
    53c9: f2 e9 51 fc ff ff            	repne		jmp	0x5020 <.plt>
    53cf: 90                           	nop
    53d0: f3 0f 1e fa                  	endbr64
    53d4: 68 3a 00 00 00               	pushq	$58
    53d9: f2 e9 41 fc ff ff            	repne		jmp	0x5020 <.plt>
    53df: 90                           	nop
    53e0: f3 0f 1e fa                  	endbr64
    53e4: 68 3b 00 00 00               	pushq	$59
    53e9: f2 e9 31 fc ff ff            	repne		jmp	0x5020 <.plt>
    53ef: 90                           	nop
    53f0: f3 0f 1e fa                  	endbr64
    53f4: 68 3c 00 00 00               	pushq	$60
    53f9: f2 e9 21 fc ff ff            	repne		jmp	0x5020 <.plt>
    53ff: 90                           	nop
    5400: f3 0f 1e fa                  	endbr64
    5404: 68 3d 00 00 00               	pushq	$61
    5409: f2 e9 11 fc ff ff            	repne		jmp	0x5020 <.plt>
    540f: 90                           	nop
    5410: f3 0f 1e fa                  	endbr64
    5414: 68 3e 00 00 00               	pushq	$62
    5419: f2 e9 01 fc ff ff            	repne		jmp	0x5020 <.plt>
    541f: 90                           	nop
    5420: f3 0f 1e fa                  	endbr64
    5424: 68 3f 00 00 00               	pushq	$63
    5429: f2 e9 f1 fb ff ff            	repne		jmp	0x5020 <.plt>
    542f: 90                           	nop
    5430: f3 0f 1e fa                  	endbr64
    5434: 68 40 00 00 00               	pushq	$64
    5439: f2 e9 e1 fb ff ff            	repne		jmp	0x5020 <.plt>
    543f: 90                           	nop
    5440: f3 0f 1e fa                  	endbr64
    5444: 68 41 00 00 00               	pushq	$65
    5449: f2 e9 d1 fb ff ff            	repne		jmp	0x5020 <.plt>
    544f: 90                           	nop
    5450: f3 0f 1e fa                  	endbr64
    5454: 68 42 00 00 00               	pushq	$66
    5459: f2 e9 c1 fb ff ff            	repne		jmp	0x5020 <.plt>
    545f: 90                           	nop
    5460: f3 0f 1e fa                  	endbr64
    5464: 68 43 00 00 00               	pushq	$67
    5469: f2 e9 b1 fb ff ff            	repne		jmp	0x5020 <.plt>
    546f: 90                           	nop
    5470: f3 0f 1e fa                  	endbr64
    5474: 68 44 00 00 00               	pushq	$68
    5479: f2 e9 a1 fb ff ff            	repne		jmp	0x5020 <.plt>
    547f: 90                           	nop
    5480: f3 0f 1e fa                  	endbr64
    5484: 68 45 00 00 00               	pushq	$69
    5489: f2 e9 91 fb ff ff            	repne		jmp	0x5020 <.plt>
    548f: 90                           	nop
    5490: f3 0f 1e fa                  	endbr64
    5494: 68 46 00 00 00               	pushq	$70
    5499: f2 e9 81 fb ff ff            	repne		jmp	0x5020 <.plt>
    549f: 90                           	nop
    54a0: f3 0f 1e fa                  	endbr64
    54a4: 68 47 00 00 00               	pushq	$71
    54a9: f2 e9 71 fb ff ff            	repne		jmp	0x5020 <.plt>
    54af: 90                           	nop
    54b0: f3 0f 1e fa                  	endbr64
    54b4: 68 48 00 00 00               	pushq	$72
    54b9: f2 e9 61 fb ff ff            	repne		jmp	0x5020 <.plt>
    54bf: 90                           	nop
    54c0: f3 0f 1e fa                  	endbr64
    54c4: 68 49 00 00 00               	pushq	$73
    54c9: f2 e9 51 fb ff ff            	repne		jmp	0x5020 <.plt>
    54cf: 90                           	nop
    54d0: f3 0f 1e fa                  	endbr64
    54d4: 68 4a 00 00 00               	pushq	$74
    54d9: f2 e9 41 fb ff ff            	repne		jmp	0x5020 <.plt>
    54df: 90                           	nop
    54e0: f3 0f 1e fa                  	endbr64
    54e4: 68 4b 00 00 00               	pushq	$75
    54e9: f2 e9 31 fb ff ff            	repne		jmp	0x5020 <.plt>
    54ef: 90                           	nop
    54f0: f3 0f 1e fa                  	endbr64
    54f4: 68 4c 00 00 00               	pushq	$76
    54f9: f2 e9 21 fb ff ff            	repne		jmp	0x5020 <.plt>
    54ff: 90                           	nop
    5500: f3 0f 1e fa                  	endbr64
    5504: 68 4d 00 00 00               	pushq	$77
    5509: f2 e9 11 fb ff ff            	repne		jmp	0x5020 <.plt>
    550f: 90                           	nop
    5510: f3 0f 1e fa                  	endbr64
    5514: 68 4e 00 00 00               	pushq	$78
    5519: f2 e9 01 fb ff ff            	repne		jmp	0x5020 <.plt>
    551f: 90                           	nop
    5520: f3 0f 1e fa                  	endbr64
    5524: 68 4f 00 00 00               	pushq	$79
    5529: f2 e9 f1 fa ff ff            	repne		jmp	0x5020 <.plt>
    552f: 90                           	nop
    5530: f3 0f 1e fa                  	endbr64
    5534: 68 50 00 00 00               	pushq	$80
    5539: f2 e9 e1 fa ff ff            	repne		jmp	0x5020 <.plt>
    553f: 90                           	nop
    5540: f3 0f 1e fa                  	endbr64
    5544: 68 51 00 00 00               	pushq	$81
    5549: f2 e9 d1 fa ff ff            	repne		jmp	0x5020 <.plt>
    554f: 90                           	nop
    5550: f3 0f 1e fa                  	endbr64
    5554: 68 52 00 00 00               	pushq	$82
    5559: f2 e9 c1 fa ff ff            	repne		jmp	0x5020 <.plt>
    555f: 90                           	nop
    5560: f3 0f 1e fa                  	endbr64
    5564: 68 53 00 00 00               	pushq	$83
    5569: f2 e9 b1 fa ff ff            	repne		jmp	0x5020 <.plt>
    556f: 90                           	nop
    5570: f3 0f 1e fa                  	endbr64
    5574: 68 54 00 00 00               	pushq	$84
    5579: f2 e9 a1 fa ff ff            	repne		jmp	0x5020 <.plt>
    557f: 90                           	nop
    5580: f3 0f 1e fa                  	endbr64
    5584: 68 55 00 00 00               	pushq	$85
    5589: f2 e9 91 fa ff ff            	repne		jmp	0x5020 <.plt>
    558f: 90                           	nop
    5590: f3 0f 1e fa                  	endbr64
    5594: 68 56 00 00 00               	pushq	$86
    5599: f2 e9 81 fa ff ff            	repne		jmp	0x5020 <.plt>
    559f: 90                           	nop
    55a0: f3 0f 1e fa                  	endbr64
    55a4: 68 57 00 00 00               	pushq	$87
    55a9: f2 e9 71 fa ff ff            	repne		jmp	0x5020 <.plt>
    55af: 90                           	nop
    55b0: f3 0f 1e fa                  	endbr64
    55b4: 68 58 00 00 00               	pushq	$88
    55b9: f2 e9 61 fa ff ff            	repne		jmp	0x5020 <.plt>
    55bf: 90                           	nop
    55c0: f3 0f 1e fa                  	endbr64
    55c4: 68 59 00 00 00               	pushq	$89
    55c9: f2 e9 51 fa ff ff            	repne		jmp	0x5020 <.plt>
    55cf: 90                           	nop
    55d0: f3 0f 1e fa                  	endbr64
    55d4: 68 5a 00 00 00               	pushq	$90
    55d9: f2 e9 41 fa ff ff            	repne		jmp	0x5020 <.plt>
    55df: 90                           	nop
    55e0: f3 0f 1e fa                  	endbr64
    55e4: 68 5b 00 00 00               	pushq	$91
    55e9: f2 e9 31 fa ff ff            	repne		jmp	0x5020 <.plt>
    55ef: 90                           	nop
    55f0: f3 0f 1e fa                  	endbr64
    55f4: 68 5c 00 00 00               	pushq	$92
    55f9: f2 e9 21 fa ff ff            	repne		jmp	0x5020 <.plt>
    55ff: 90                           	nop
    5600: f3 0f 1e fa                  	endbr64
    5604: 68 5d 00 00 00               	pushq	$93
    5609: f2 e9 11 fa ff ff            	repne		jmp	0x5020 <.plt>
    560f: 90                           	nop
    5610: f3 0f 1e fa                  	endbr64
    5614: 68 5e 00 00 00               	pushq	$94
    5619: f2 e9 01 fa ff ff            	repne		jmp	0x5020 <.plt>
    561f: 90                           	nop
    5620: f3 0f 1e fa                  	endbr64
    5624: 68 5f 00 00 00               	pushq	$95
    5629: f2 e9 f1 f9 ff ff            	repne		jmp	0x5020 <.plt>
    562f: 90                           	nop
    5630: f3 0f 1e fa                  	endbr64
    5634: 68 60 00 00 00               	pushq	$96
    5639: f2 e9 e1 f9 ff ff            	repne		jmp	0x5020 <.plt>
    563f: 90                           	nop
    5640: f3 0f 1e fa                  	endbr64
    5644: 68 61 00 00 00               	pushq	$97
    5649: f2 e9 d1 f9 ff ff            	repne		jmp	0x5020 <.plt>
    564f: 90                           	nop
    5650: f3 0f 1e fa                  	endbr64
    5654: 68 62 00 00 00               	pushq	$98
    5659: f2 e9 c1 f9 ff ff            	repne		jmp	0x5020 <.plt>
    565f: 90                           	nop

Disassembly of section .plt.got:

0000000000005660 <.plt.got>:
    5660: f3 0f 1e fa                  	endbr64
    5664: f2 ff 25 8d 19 04 00         	repne		jmpq	*268685(%rip)   # 0x46ff8 <_GLOBAL_OFFSET_TABLE_+0x350>
    566b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

Disassembly of section .plt.sec:

0000000000005670 <.plt.sec>:
    5670: f3 0f 1e fa                  	endbr64
    5674: f2 ff 25 45 16 04 00         	repne		jmpq	*267845(%rip)   # 0x46cc0 <_GLOBAL_OFFSET_TABLE_+0x18>
    567b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5680: f3 0f 1e fa                  	endbr64
    5684: f2 ff 25 3d 16 04 00         	repne		jmpq	*267837(%rip)   # 0x46cc8 <_GLOBAL_OFFSET_TABLE_+0x20>
    568b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5690: f3 0f 1e fa                  	endbr64
    5694: f2 ff 25 35 16 04 00         	repne		jmpq	*267829(%rip)   # 0x46cd0 <_GLOBAL_OFFSET_TABLE_+0x28>
    569b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    56a0: f3 0f 1e fa                  	endbr64
    56a4: f2 ff 25 2d 16 04 00         	repne		jmpq	*267821(%rip)   # 0x46cd8 <_GLOBAL_OFFSET_TABLE_+0x30>
    56ab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    56b0: f3 0f 1e fa                  	endbr64
    56b4: f2 ff 25 25 16 04 00         	repne		jmpq	*267813(%rip)   # 0x46ce0 <_GLOBAL_OFFSET_TABLE_+0x38>
    56bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    56c0: f3 0f 1e fa                  	endbr64
    56c4: f2 ff 25 1d 16 04 00         	repne		jmpq	*267805(%rip)   # 0x46ce8 <_GLOBAL_OFFSET_TABLE_+0x40>
    56cb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    56d0: f3 0f 1e fa                  	endbr64
    56d4: f2 ff 25 15 16 04 00         	repne		jmpq	*267797(%rip)   # 0x46cf0 <_GLOBAL_OFFSET_TABLE_+0x48>
    56db: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    56e0: f3 0f 1e fa                  	endbr64
    56e4: f2 ff 25 0d 16 04 00         	repne		jmpq	*267789(%rip)   # 0x46cf8 <_GLOBAL_OFFSET_TABLE_+0x50>
    56eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    56f0: f3 0f 1e fa                  	endbr64
    56f4: f2 ff 25 05 16 04 00         	repne		jmpq	*267781(%rip)   # 0x46d00 <_GLOBAL_OFFSET_TABLE_+0x58>
    56fb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5700: f3 0f 1e fa                  	endbr64
    5704: f2 ff 25 fd 15 04 00         	repne		jmpq	*267773(%rip)   # 0x46d08 <_GLOBAL_OFFSET_TABLE_+0x60>
    570b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5710: f3 0f 1e fa                  	endbr64
    5714: f2 ff 25 f5 15 04 00         	repne		jmpq	*267765(%rip)   # 0x46d10 <_GLOBAL_OFFSET_TABLE_+0x68>
    571b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5720: f3 0f 1e fa                  	endbr64
    5724: f2 ff 25 ed 15 04 00         	repne		jmpq	*267757(%rip)   # 0x46d18 <_GLOBAL_OFFSET_TABLE_+0x70>
    572b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5730: f3 0f 1e fa                  	endbr64
    5734: f2 ff 25 e5 15 04 00         	repne		jmpq	*267749(%rip)   # 0x46d20 <_GLOBAL_OFFSET_TABLE_+0x78>
    573b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5740: f3 0f 1e fa                  	endbr64
    5744: f2 ff 25 dd 15 04 00         	repne		jmpq	*267741(%rip)   # 0x46d28 <_GLOBAL_OFFSET_TABLE_+0x80>
    574b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5750: f3 0f 1e fa                  	endbr64
    5754: f2 ff 25 d5 15 04 00         	repne		jmpq	*267733(%rip)   # 0x46d30 <_GLOBAL_OFFSET_TABLE_+0x88>
    575b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5760: f3 0f 1e fa                  	endbr64
    5764: f2 ff 25 cd 15 04 00         	repne		jmpq	*267725(%rip)   # 0x46d38 <_GLOBAL_OFFSET_TABLE_+0x90>
    576b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5770: f3 0f 1e fa                  	endbr64
    5774: f2 ff 25 c5 15 04 00         	repne		jmpq	*267717(%rip)   # 0x46d40 <_GLOBAL_OFFSET_TABLE_+0x98>
    577b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5780: f3 0f 1e fa                  	endbr64
    5784: f2 ff 25 bd 15 04 00         	repne		jmpq	*267709(%rip)   # 0x46d48 <_GLOBAL_OFFSET_TABLE_+0xa0>
    578b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5790: f3 0f 1e fa                  	endbr64
    5794: f2 ff 25 b5 15 04 00         	repne		jmpq	*267701(%rip)   # 0x46d50 <_GLOBAL_OFFSET_TABLE_+0xa8>
    579b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    57a0: f3 0f 1e fa                  	endbr64
    57a4: f2 ff 25 ad 15 04 00         	repne		jmpq	*267693(%rip)   # 0x46d58 <_GLOBAL_OFFSET_TABLE_+0xb0>
    57ab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    57b0: f3 0f 1e fa                  	endbr64
    57b4: f2 ff 25 a5 15 04 00         	repne		jmpq	*267685(%rip)   # 0x46d60 <_GLOBAL_OFFSET_TABLE_+0xb8>
    57bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    57c0: f3 0f 1e fa                  	endbr64
    57c4: f2 ff 25 9d 15 04 00         	repne		jmpq	*267677(%rip)   # 0x46d68 <_GLOBAL_OFFSET_TABLE_+0xc0>
    57cb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    57d0: f3 0f 1e fa                  	endbr64
    57d4: f2 ff 25 95 15 04 00         	repne		jmpq	*267669(%rip)   # 0x46d70 <_GLOBAL_OFFSET_TABLE_+0xc8>
    57db: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    57e0: f3 0f 1e fa                  	endbr64
    57e4: f2 ff 25 8d 15 04 00         	repne		jmpq	*267661(%rip)   # 0x46d78 <_GLOBAL_OFFSET_TABLE_+0xd0>
    57eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    57f0: f3 0f 1e fa                  	endbr64
    57f4: f2 ff 25 85 15 04 00         	repne		jmpq	*267653(%rip)   # 0x46d80 <_GLOBAL_OFFSET_TABLE_+0xd8>
    57fb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5800: f3 0f 1e fa                  	endbr64
    5804: f2 ff 25 7d 15 04 00         	repne		jmpq	*267645(%rip)   # 0x46d88 <_GLOBAL_OFFSET_TABLE_+0xe0>
    580b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5810: f3 0f 1e fa                  	endbr64
    5814: f2 ff 25 75 15 04 00         	repne		jmpq	*267637(%rip)   # 0x46d90 <_GLOBAL_OFFSET_TABLE_+0xe8>
    581b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5820: f3 0f 1e fa                  	endbr64
    5824: f2 ff 25 6d 15 04 00         	repne		jmpq	*267629(%rip)   # 0x46d98 <_GLOBAL_OFFSET_TABLE_+0xf0>
    582b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5830: f3 0f 1e fa                  	endbr64
    5834: f2 ff 25 65 15 04 00         	repne		jmpq	*267621(%rip)   # 0x46da0 <_GLOBAL_OFFSET_TABLE_+0xf8>
    583b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5840: f3 0f 1e fa                  	endbr64
    5844: f2 ff 25 5d 15 04 00         	repne		jmpq	*267613(%rip)   # 0x46da8 <_GLOBAL_OFFSET_TABLE_+0x100>
    584b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5850: f3 0f 1e fa                  	endbr64
    5854: f2 ff 25 55 15 04 00         	repne		jmpq	*267605(%rip)   # 0x46db0 <_GLOBAL_OFFSET_TABLE_+0x108>
    585b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5860: f3 0f 1e fa                  	endbr64
    5864: f2 ff 25 4d 15 04 00         	repne		jmpq	*267597(%rip)   # 0x46db8 <_GLOBAL_OFFSET_TABLE_+0x110>
    586b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5870: f3 0f 1e fa                  	endbr64
    5874: f2 ff 25 45 15 04 00         	repne		jmpq	*267589(%rip)   # 0x46dc0 <_GLOBAL_OFFSET_TABLE_+0x118>
    587b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5880: f3 0f 1e fa                  	endbr64
    5884: f2 ff 25 3d 15 04 00         	repne		jmpq	*267581(%rip)   # 0x46dc8 <_GLOBAL_OFFSET_TABLE_+0x120>
    588b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5890: f3 0f 1e fa                  	endbr64
    5894: f2 ff 25 35 15 04 00         	repne		jmpq	*267573(%rip)   # 0x46dd0 <_GLOBAL_OFFSET_TABLE_+0x128>
    589b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    58a0: f3 0f 1e fa                  	endbr64
    58a4: f2 ff 25 2d 15 04 00         	repne		jmpq	*267565(%rip)   # 0x46dd8 <_GLOBAL_OFFSET_TABLE_+0x130>
    58ab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    58b0: f3 0f 1e fa                  	endbr64
    58b4: f2 ff 25 25 15 04 00         	repne		jmpq	*267557(%rip)   # 0x46de0 <_GLOBAL_OFFSET_TABLE_+0x138>
    58bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    58c0: f3 0f 1e fa                  	endbr64
    58c4: f2 ff 25 1d 15 04 00         	repne		jmpq	*267549(%rip)   # 0x46de8 <_GLOBAL_OFFSET_TABLE_+0x140>
    58cb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    58d0: f3 0f 1e fa                  	endbr64
    58d4: f2 ff 25 15 15 04 00         	repne		jmpq	*267541(%rip)   # 0x46df0 <_GLOBAL_OFFSET_TABLE_+0x148>
    58db: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    58e0: f3 0f 1e fa                  	endbr64
    58e4: f2 ff 25 0d 15 04 00         	repne		jmpq	*267533(%rip)   # 0x46df8 <_GLOBAL_OFFSET_TABLE_+0x150>
    58eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    58f0: f3 0f 1e fa                  	endbr64
    58f4: f2 ff 25 05 15 04 00         	repne		jmpq	*267525(%rip)   # 0x46e00 <_GLOBAL_OFFSET_TABLE_+0x158>
    58fb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5900: f3 0f 1e fa                  	endbr64
    5904: f2 ff 25 fd 14 04 00         	repne		jmpq	*267517(%rip)   # 0x46e08 <_GLOBAL_OFFSET_TABLE_+0x160>
    590b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5910: f3 0f 1e fa                  	endbr64
    5914: f2 ff 25 f5 14 04 00         	repne		jmpq	*267509(%rip)   # 0x46e10 <_GLOBAL_OFFSET_TABLE_+0x168>
    591b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5920: f3 0f 1e fa                  	endbr64
    5924: f2 ff 25 ed 14 04 00         	repne		jmpq	*267501(%rip)   # 0x46e18 <_GLOBAL_OFFSET_TABLE_+0x170>
    592b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5930: f3 0f 1e fa                  	endbr64
    5934: f2 ff 25 e5 14 04 00         	repne		jmpq	*267493(%rip)   # 0x46e20 <_GLOBAL_OFFSET_TABLE_+0x178>
    593b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5940: f3 0f 1e fa                  	endbr64
    5944: f2 ff 25 dd 14 04 00         	repne		jmpq	*267485(%rip)   # 0x46e28 <_GLOBAL_OFFSET_TABLE_+0x180>
    594b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5950: f3 0f 1e fa                  	endbr64
    5954: f2 ff 25 d5 14 04 00         	repne		jmpq	*267477(%rip)   # 0x46e30 <_GLOBAL_OFFSET_TABLE_+0x188>
    595b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5960: f3 0f 1e fa                  	endbr64
    5964: f2 ff 25 cd 14 04 00         	repne		jmpq	*267469(%rip)   # 0x46e38 <_GLOBAL_OFFSET_TABLE_+0x190>
    596b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5970: f3 0f 1e fa                  	endbr64
    5974: f2 ff 25 c5 14 04 00         	repne		jmpq	*267461(%rip)   # 0x46e40 <_GLOBAL_OFFSET_TABLE_+0x198>
    597b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5980: f3 0f 1e fa                  	endbr64
    5984: f2 ff 25 bd 14 04 00         	repne		jmpq	*267453(%rip)   # 0x46e48 <_GLOBAL_OFFSET_TABLE_+0x1a0>
    598b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5990: f3 0f 1e fa                  	endbr64
    5994: f2 ff 25 b5 14 04 00         	repne		jmpq	*267445(%rip)   # 0x46e50 <_GLOBAL_OFFSET_TABLE_+0x1a8>
    599b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    59a0: f3 0f 1e fa                  	endbr64
    59a4: f2 ff 25 ad 14 04 00         	repne		jmpq	*267437(%rip)   # 0x46e58 <_GLOBAL_OFFSET_TABLE_+0x1b0>
    59ab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    59b0: f3 0f 1e fa                  	endbr64
    59b4: f2 ff 25 a5 14 04 00         	repne		jmpq	*267429(%rip)   # 0x46e60 <_GLOBAL_OFFSET_TABLE_+0x1b8>
    59bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    59c0: f3 0f 1e fa                  	endbr64
    59c4: f2 ff 25 9d 14 04 00         	repne		jmpq	*267421(%rip)   # 0x46e68 <_GLOBAL_OFFSET_TABLE_+0x1c0>
    59cb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    59d0: f3 0f 1e fa                  	endbr64
    59d4: f2 ff 25 95 14 04 00         	repne		jmpq	*267413(%rip)   # 0x46e70 <_GLOBAL_OFFSET_TABLE_+0x1c8>
    59db: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    59e0: f3 0f 1e fa                  	endbr64
    59e4: f2 ff 25 8d 14 04 00         	repne		jmpq	*267405(%rip)   # 0x46e78 <_GLOBAL_OFFSET_TABLE_+0x1d0>
    59eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    59f0: f3 0f 1e fa                  	endbr64
    59f4: f2 ff 25 85 14 04 00         	repne		jmpq	*267397(%rip)   # 0x46e80 <_GLOBAL_OFFSET_TABLE_+0x1d8>
    59fb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a00: f3 0f 1e fa                  	endbr64
    5a04: f2 ff 25 7d 14 04 00         	repne		jmpq	*267389(%rip)   # 0x46e88 <_GLOBAL_OFFSET_TABLE_+0x1e0>
    5a0b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a10: f3 0f 1e fa                  	endbr64
    5a14: f2 ff 25 75 14 04 00         	repne		jmpq	*267381(%rip)   # 0x46e90 <_GLOBAL_OFFSET_TABLE_+0x1e8>
    5a1b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a20: f3 0f 1e fa                  	endbr64
    5a24: f2 ff 25 6d 14 04 00         	repne		jmpq	*267373(%rip)   # 0x46e98 <_GLOBAL_OFFSET_TABLE_+0x1f0>
    5a2b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a30: f3 0f 1e fa                  	endbr64
    5a34: f2 ff 25 65 14 04 00         	repne		jmpq	*267365(%rip)   # 0x46ea0 <_GLOBAL_OFFSET_TABLE_+0x1f8>
    5a3b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a40: f3 0f 1e fa                  	endbr64
    5a44: f2 ff 25 5d 14 04 00         	repne		jmpq	*267357(%rip)   # 0x46ea8 <_GLOBAL_OFFSET_TABLE_+0x200>
    5a4b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a50: f3 0f 1e fa                  	endbr64
    5a54: f2 ff 25 55 14 04 00         	repne		jmpq	*267349(%rip)   # 0x46eb0 <_GLOBAL_OFFSET_TABLE_+0x208>
    5a5b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a60: f3 0f 1e fa                  	endbr64
    5a64: f2 ff 25 4d 14 04 00         	repne		jmpq	*267341(%rip)   # 0x46eb8 <_GLOBAL_OFFSET_TABLE_+0x210>
    5a6b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a70: f3 0f 1e fa                  	endbr64
    5a74: f2 ff 25 45 14 04 00         	repne		jmpq	*267333(%rip)   # 0x46ec0 <_GLOBAL_OFFSET_TABLE_+0x218>
    5a7b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a80: f3 0f 1e fa                  	endbr64
    5a84: f2 ff 25 3d 14 04 00         	repne		jmpq	*267325(%rip)   # 0x46ec8 <_GLOBAL_OFFSET_TABLE_+0x220>
    5a8b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5a90: f3 0f 1e fa                  	endbr64
    5a94: f2 ff 25 35 14 04 00         	repne		jmpq	*267317(%rip)   # 0x46ed0 <_GLOBAL_OFFSET_TABLE_+0x228>
    5a9b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5aa0: f3 0f 1e fa                  	endbr64
    5aa4: f2 ff 25 2d 14 04 00         	repne		jmpq	*267309(%rip)   # 0x46ed8 <_GLOBAL_OFFSET_TABLE_+0x230>
    5aab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5ab0: f3 0f 1e fa                  	endbr64
    5ab4: f2 ff 25 25 14 04 00         	repne		jmpq	*267301(%rip)   # 0x46ee0 <_GLOBAL_OFFSET_TABLE_+0x238>
    5abb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5ac0: f3 0f 1e fa                  	endbr64
    5ac4: f2 ff 25 1d 14 04 00         	repne		jmpq	*267293(%rip)   # 0x46ee8 <_GLOBAL_OFFSET_TABLE_+0x240>
    5acb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5ad0: f3 0f 1e fa                  	endbr64
    5ad4: f2 ff 25 15 14 04 00         	repne		jmpq	*267285(%rip)   # 0x46ef0 <_GLOBAL_OFFSET_TABLE_+0x248>
    5adb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5ae0: f3 0f 1e fa                  	endbr64
    5ae4: f2 ff 25 0d 14 04 00         	repne		jmpq	*267277(%rip)   # 0x46ef8 <_GLOBAL_OFFSET_TABLE_+0x250>
    5aeb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5af0: f3 0f 1e fa                  	endbr64
    5af4: f2 ff 25 05 14 04 00         	repne		jmpq	*267269(%rip)   # 0x46f00 <_GLOBAL_OFFSET_TABLE_+0x258>
    5afb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b00: f3 0f 1e fa                  	endbr64
    5b04: f2 ff 25 fd 13 04 00         	repne		jmpq	*267261(%rip)   # 0x46f08 <_GLOBAL_OFFSET_TABLE_+0x260>
    5b0b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b10: f3 0f 1e fa                  	endbr64
    5b14: f2 ff 25 f5 13 04 00         	repne		jmpq	*267253(%rip)   # 0x46f10 <_GLOBAL_OFFSET_TABLE_+0x268>
    5b1b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b20: f3 0f 1e fa                  	endbr64
    5b24: f2 ff 25 ed 13 04 00         	repne		jmpq	*267245(%rip)   # 0x46f18 <_GLOBAL_OFFSET_TABLE_+0x270>
    5b2b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b30: f3 0f 1e fa                  	endbr64
    5b34: f2 ff 25 e5 13 04 00         	repne		jmpq	*267237(%rip)   # 0x46f20 <_GLOBAL_OFFSET_TABLE_+0x278>
    5b3b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b40: f3 0f 1e fa                  	endbr64
    5b44: f2 ff 25 dd 13 04 00         	repne		jmpq	*267229(%rip)   # 0x46f28 <_GLOBAL_OFFSET_TABLE_+0x280>
    5b4b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b50: f3 0f 1e fa                  	endbr64
    5b54: f2 ff 25 d5 13 04 00         	repne		jmpq	*267221(%rip)   # 0x46f30 <_GLOBAL_OFFSET_TABLE_+0x288>
    5b5b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b60: f3 0f 1e fa                  	endbr64
    5b64: f2 ff 25 cd 13 04 00         	repne		jmpq	*267213(%rip)   # 0x46f38 <_GLOBAL_OFFSET_TABLE_+0x290>
    5b6b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b70: f3 0f 1e fa                  	endbr64
    5b74: f2 ff 25 c5 13 04 00         	repne		jmpq	*267205(%rip)   # 0x46f40 <_GLOBAL_OFFSET_TABLE_+0x298>
    5b7b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b80: f3 0f 1e fa                  	endbr64
    5b84: f2 ff 25 bd 13 04 00         	repne		jmpq	*267197(%rip)   # 0x46f48 <_GLOBAL_OFFSET_TABLE_+0x2a0>
    5b8b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5b90: f3 0f 1e fa                  	endbr64
    5b94: f2 ff 25 b5 13 04 00         	repne		jmpq	*267189(%rip)   # 0x46f50 <_GLOBAL_OFFSET_TABLE_+0x2a8>
    5b9b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5ba0: f3 0f 1e fa                  	endbr64
    5ba4: f2 ff 25 ad 13 04 00         	repne		jmpq	*267181(%rip)   # 0x46f58 <_GLOBAL_OFFSET_TABLE_+0x2b0>
    5bab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5bb0: f3 0f 1e fa                  	endbr64
    5bb4: f2 ff 25 a5 13 04 00         	repne		jmpq	*267173(%rip)   # 0x46f60 <_GLOBAL_OFFSET_TABLE_+0x2b8>
    5bbb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5bc0: f3 0f 1e fa                  	endbr64
    5bc4: f2 ff 25 9d 13 04 00         	repne		jmpq	*267165(%rip)   # 0x46f68 <_GLOBAL_OFFSET_TABLE_+0x2c0>
    5bcb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5bd0: f3 0f 1e fa                  	endbr64
    5bd4: f2 ff 25 95 13 04 00         	repne		jmpq	*267157(%rip)   # 0x46f70 <_GLOBAL_OFFSET_TABLE_+0x2c8>
    5bdb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5be0: f3 0f 1e fa                  	endbr64
    5be4: f2 ff 25 8d 13 04 00         	repne		jmpq	*267149(%rip)   # 0x46f78 <_GLOBAL_OFFSET_TABLE_+0x2d0>
    5beb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5bf0: f3 0f 1e fa                  	endbr64
    5bf4: f2 ff 25 85 13 04 00         	repne		jmpq	*267141(%rip)   # 0x46f80 <_GLOBAL_OFFSET_TABLE_+0x2d8>
    5bfb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c00: f3 0f 1e fa                  	endbr64
    5c04: f2 ff 25 7d 13 04 00         	repne		jmpq	*267133(%rip)   # 0x46f88 <_GLOBAL_OFFSET_TABLE_+0x2e0>
    5c0b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c10: f3 0f 1e fa                  	endbr64
    5c14: f2 ff 25 75 13 04 00         	repne		jmpq	*267125(%rip)   # 0x46f90 <_GLOBAL_OFFSET_TABLE_+0x2e8>
    5c1b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c20: f3 0f 1e fa                  	endbr64
    5c24: f2 ff 25 6d 13 04 00         	repne		jmpq	*267117(%rip)   # 0x46f98 <_GLOBAL_OFFSET_TABLE_+0x2f0>
    5c2b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c30: f3 0f 1e fa                  	endbr64
    5c34: f2 ff 25 65 13 04 00         	repne		jmpq	*267109(%rip)   # 0x46fa0 <_GLOBAL_OFFSET_TABLE_+0x2f8>
    5c3b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c40: f3 0f 1e fa                  	endbr64
    5c44: f2 ff 25 5d 13 04 00         	repne		jmpq	*267101(%rip)   # 0x46fa8 <_GLOBAL_OFFSET_TABLE_+0x300>
    5c4b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c50: f3 0f 1e fa                  	endbr64
    5c54: f2 ff 25 55 13 04 00         	repne		jmpq	*267093(%rip)   # 0x46fb0 <_GLOBAL_OFFSET_TABLE_+0x308>
    5c5b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c60: f3 0f 1e fa                  	endbr64
    5c64: f2 ff 25 4d 13 04 00         	repne		jmpq	*267085(%rip)   # 0x46fb8 <_GLOBAL_OFFSET_TABLE_+0x310>
    5c6b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c70: f3 0f 1e fa                  	endbr64
    5c74: f2 ff 25 45 13 04 00         	repne		jmpq	*267077(%rip)   # 0x46fc0 <_GLOBAL_OFFSET_TABLE_+0x318>
    5c7b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c80: f3 0f 1e fa                  	endbr64
    5c84: f2 ff 25 3d 13 04 00         	repne		jmpq	*267069(%rip)   # 0x46fc8 <_GLOBAL_OFFSET_TABLE_+0x320>
    5c8b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    5c90: f3 0f 1e fa                  	endbr64
    5c94: f2 ff 25 35 13 04 00         	repne		jmpq	*267061(%rip)   # 0x46fd0 <_GLOBAL_OFFSET_TABLE_+0x328>
    5c9b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

Disassembly of section .text:

0000000000005ca0 <bpf_object_open.part.0.cold>:
; 		if (sym->st_shndx != sec_idx)
    5ca0: 0f b7 04 25 06 00 00 00      	movzwl	6, %eax
    5ca8: 0f 0b                        	ud2
; 		if (ELF64_ST_TYPE(sym->st_info) != STT_OBJECT)
    5caa: 0f b6 04 25 04 00 00 00      	movzbl	4, %eax
    5cb2: 0f 0b                        	ud2

0000000000005cb4 <probe_prog_load.constprop.0.cold>:
; 	switch (prog_type) {
    5cb4: b8 a1 ff ff ff               	movl	$4294967201, %eax       # imm = 0xFFFFFFA1
    5cb9: e9 4b 7e 01 00               	jmp	0x1db09 <probe_prog_load.constprop.0+0xc9>

0000000000005cbe <btf_dedup_is_equiv.cold>:
; 		return errno = EINVAL, NULL;
    5cbe: e8 2d fa ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5cc3: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return BTF_INFO_KIND(t->info);
    5cc9: 8b 04 25 04 00 00 00         	movl	4, %eax
    5cd0: 0f 0b                        	ud2

0000000000005cd2 <determine_ptr_size.cold>:
; 		return errno = EINVAL, NULL;
    5cd2: e8 19 fa ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5cd7: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return BTF_INFO_KIND(t->info);
    5cdd: 8b 04 25 04 00 00 00         	movl	4, %eax
    5ce4: 0f 0b                        	ud2

0000000000005ce6 <btf__align_of.cold>:
; 		return errno = EINVAL, NULL;
    5ce6: e8 05 fa ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5ceb: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return BTF_INFO_KIND(t->info);
    5cf1: 8b 04 25 04 00 00 00         	movl	4, %eax
    5cf8: 0f 0b                        	ud2

0000000000005cfa <btf__find_by_name.cold>:
; 		return errno = EINVAL, NULL;
    5cfa: e8 f1 f9 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5cff: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		const char *name = btf__name_by_offset(btf, t->name_off);
    5d05: 8b 04 25 00 00 00 00         	movl	0, %eax
    5d0c: 0f 0b                        	ud2

0000000000005d0e <btf_find_by_name_kind.cold>:
; 		return errno = EINVAL, NULL;
    5d0e: e8 dd f9 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5d13: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return BTF_INFO_KIND(t->info);
    5d19: 8b 04 25 04 00 00 00         	movl	4, %eax
    5d20: 0f 0b                        	ud2

0000000000005d22 <btf__dedup.cold>:
; 		return errno = EINVAL, NULL;
    5d22: e8 c9 f9 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5d27: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return BTF_INFO_KIND(t->info);
    5d2d: 8b 04 25 04 00 00 00         	movl	4, %eax
    5d34: 0f 0b                        	ud2
; 		return errno = EINVAL, NULL;
    5d36: e8 b5 f9 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5d3b: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return BTF_INFO_KIND(t->info);
    5d41: 8b 04 25 04 00 00 00         	movl	4, %eax
    5d48: 0f 0b                        	ud2
; 		return errno = EINVAL, NULL;
    5d4a: e8 a1 f9 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5d4f: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		len = btf_type_size(t);
    5d55: 8b 04 25 04 00 00 00         	movl	4, %eax
    5d5c: 0f 0b                        	ud2
    5d5e: 66 90                        	nop

0000000000005d60 <_start>:
    5d60: f3 0f 1e fa                  	endbr64
    5d64: 31 ed                        	xorl	%ebp, %ebp
    5d66: 49 89 d1                     	movq	%rdx, %r9
    5d69: 5e                           	popq	%rsi
    5d6a: 48 89 e2                     	movq	%rsp, %rdx
    5d6d: 48 83 e4 f0                  	andq	$-16, %rsp
    5d71: 50                           	pushq	%rax
    5d72: 54                           	pushq	%rsp
    5d73: 45 31 c0                     	xorl	%r8d, %r8d
    5d76: 31 c9                        	xorl	%ecx, %ecx
    5d78: 48 8d 3d 0c 04 00 00         	leaq	1036(%rip), %rdi        # 0x618b <main>
    5d7f: ff 15 53 12 04 00            	callq	*266835(%rip)           # 0x46fd8 <_GLOBAL_OFFSET_TABLE_+0x330>
    5d85: f4                           	hlt
    5d86: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000005d90 <deregister_tm_clones>:
    5d90: 48 8d 3d 61 14 04 00         	leaq	267361(%rip), %rdi      # 0x471f8 <_edata>
    5d97: 48 8d 05 5a 14 04 00         	leaq	267354(%rip), %rax      # 0x471f8 <_edata>
    5d9e: 48 39 f8                     	cmpq	%rdi, %rax
    5da1: 74 15                        	je	0x5db8 <deregister_tm_clones+0x28>
    5da3: 48 8b 05 36 12 04 00         	movq	266806(%rip), %rax      # 0x46fe0 <_GLOBAL_OFFSET_TABLE_+0x338>
    5daa: 48 85 c0                     	testq	%rax, %rax
    5dad: 74 09                        	je	0x5db8 <deregister_tm_clones+0x28>
    5daf: ff e0                        	jmpq	*%rax
    5db1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    5db8: c3                           	retq
    5db9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000005dc0 <register_tm_clones>:
    5dc0: 48 8d 3d 31 14 04 00         	leaq	267313(%rip), %rdi      # 0x471f8 <_edata>
    5dc7: 48 8d 35 2a 14 04 00         	leaq	267306(%rip), %rsi      # 0x471f8 <_edata>
    5dce: 48 29 fe                     	subq	%rdi, %rsi
    5dd1: 48 89 f0                     	movq	%rsi, %rax
    5dd4: 48 c1 ee 3f                  	shrq	$63, %rsi
    5dd8: 48 c1 f8 03                  	sarq	$3, %rax
    5ddc: 48 01 c6                     	addq	%rax, %rsi
    5ddf: 48 d1 fe                     	sarq	%rsi
    5de2: 74 14                        	je	0x5df8 <register_tm_clones+0x38>
    5de4: 48 8b 05 05 12 04 00         	movq	266757(%rip), %rax      # 0x46ff0 <_GLOBAL_OFFSET_TABLE_+0x348>
    5deb: 48 85 c0                     	testq	%rax, %rax
    5dee: 74 08                        	je	0x5df8 <register_tm_clones+0x38>
    5df0: ff e0                        	jmpq	*%rax
    5df2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
    5df8: c3                           	retq
    5df9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000005e00 <__do_global_dtors_aux>:
    5e00: f3 0f 1e fa                  	endbr64
    5e04: 80 3d fd 13 04 00 00         	cmpb	$0, 267261(%rip)        # 0x47208 <completed.0>
    5e0b: 75 2b                        	jne	0x5e38 <__do_global_dtors_aux+0x38>
    5e0d: 55                           	pushq	%rbp
    5e0e: 48 83 3d e2 11 04 00 00      	cmpq	$0, 266722(%rip)        # 0x46ff8 <_GLOBAL_OFFSET_TABLE_+0x350>
    5e16: 48 89 e5                     	movq	%rsp, %rbp
    5e19: 74 0c                        	je	0x5e27 <__do_global_dtors_aux+0x27>
    5e1b: 48 8b 3d e6 11 04 00         	movq	266726(%rip), %rdi      # 0x47008 <__dso_handle>
    5e22: e8 39 f8 ff ff               	callq	0x5660 <.plt.got>
    5e27: e8 64 ff ff ff               	callq	0x5d90 <deregister_tm_clones>
    5e2c: c6 05 d5 13 04 00 01         	movb	$1, 267221(%rip)        # 0x47208 <completed.0>
    5e33: 5d                           	popq	%rbp
    5e34: c3                           	retq
    5e35: 0f 1f 00                     	nopl	(%rax)
    5e38: c3                           	retq
    5e39: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000005e40 <frame_dummy>:
    5e40: f3 0f 1e fa                  	endbr64
    5e44: e9 77 ff ff ff               	jmp	0x5dc0 <register_tm_clones>

0000000000005e49 <ebpf_test_bpf__destroy>:
; {
    5e49: f3 0f 1e fa                  	endbr64
    5e4d: 55                           	pushq	%rbp
    5e4e: 48 89 e5                     	movq	%rsp, %rbp
    5e51: 48 83 ec 10                  	subq	$16, %rsp
    5e55: 48 89 7d f8                  	movq	%rdi, -8(%rbp)
; 	if (!obj)
    5e59: 48 83 7d f8 00               	cmpq	$0, -8(%rbp)
    5e5e: 74 29                        	je	0x5e89 <ebpf_test_bpf__destroy+0x40>
; 	if (obj->skeleton)
    5e60: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5e64: 48 8b 00                     	movq	(%rax), %rax
    5e67: 48 85 c0                     	testq	%rax, %rax
    5e6a: 74 0f                        	je	0x5e7b <ebpf_test_bpf__destroy+0x32>
; 		bpf_object__destroy_skeleton(obj->skeleton);
    5e6c: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5e70: 48 8b 00                     	movq	(%rax), %rax
    5e73: 48 89 c7                     	movq	%rax, %rdi
    5e76: e8 f5 7a 01 00               	callq	0x1d970 <bpf_object__destroy_skeleton>
; 	free(obj);
    5e7b: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5e7f: 48 89 c7                     	movq	%rax, %rdi
    5e82: e8 39 f8 ff ff               	callq	0x56c0 <.plt.sec+0x50>
    5e87: eb 01                        	jmp	0x5e8a <ebpf_test_bpf__destroy+0x41>
; 		return;
    5e89: 90                           	nop
; }
    5e8a: c9                           	leave
    5e8b: c3                           	retq

0000000000005e8c <ebpf_test_bpf__open_opts>:
; {
    5e8c: 55                           	pushq	%rbp
    5e8d: 48 89 e5                     	movq	%rsp, %rbp
    5e90: 48 83 ec 20                  	subq	$32, %rsp
    5e94: 48 89 7d e8                  	movq	%rdi, -24(%rbp)
; 	obj = (struct ebpf_test_bpf *)calloc(1, sizeof(*obj));
    5e98: be 28 00 00 00               	movl	$40, %esi
    5e9d: bf 01 00 00 00               	movl	$1, %edi
    5ea2: e8 e9 fa ff ff               	callq	0x5990 <.plt.sec+0x320>
    5ea7: 48 89 45 f8                  	movq	%rax, -8(%rbp)
; 	if (!obj) {
    5eab: 48 83 7d f8 00               	cmpq	$0, -8(%rbp)
    5eb0: 75 12                        	jne	0x5ec4 <ebpf_test_bpf__open_opts+0x38>
; 		errno = ENOMEM;
    5eb2: e8 39 f8 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5eb7: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return NULL;
    5ebd: b8 00 00 00 00               	movl	$0, %eax
    5ec2: eb 5b                        	jmp	0x5f1f <ebpf_test_bpf__open_opts+0x93>
; 	err = ebpf_test_bpf__create_skeleton(obj);
    5ec4: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5ec8: 48 89 c7                     	movq	%rax, %rdi
    5ecb: e8 b9 00 00 00               	callq	0x5f89 <ebpf_test_bpf__create_skeleton>
    5ed0: 89 45 f4                     	movl	%eax, -12(%rbp)
; 	if (err)
    5ed3: 83 7d f4 00                  	cmpl	$0, -12(%rbp)
    5ed7: 75 25                        	jne	0x5efe <ebpf_test_bpf__open_opts+0x72>
; 	err = bpf_object__open_skeleton(obj->skeleton, opts);
    5ed9: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5edd: 48 8b 00                     	movq	(%rax), %rax
    5ee0: 48 8b 55 e8                  	movq	-24(%rbp), %rdx
    5ee4: 48 89 d6                     	movq	%rdx, %rsi
    5ee7: 48 89 c7                     	movq	%rax, %rdi
    5eea: e8 11 73 01 00               	callq	0x1d200 <bpf_object__open_skeleton>
    5eef: 89 45 f4                     	movl	%eax, -12(%rbp)
; 	if (err)
    5ef2: 83 7d f4 00                  	cmpl	$0, -12(%rbp)
    5ef6: 75 09                        	jne	0x5f01 <ebpf_test_bpf__open_opts+0x75>
; 	return obj;
    5ef8: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5efc: eb 21                        	jmp	0x5f1f <ebpf_test_bpf__open_opts+0x93>
; 		goto err_out;
    5efe: 90                           	nop
    5eff: eb 01                        	jmp	0x5f02 <ebpf_test_bpf__open_opts+0x76>
; 		goto err_out;
    5f01: 90                           	nop
; 	ebpf_test_bpf__destroy(obj);
    5f02: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5f06: 48 89 c7                     	movq	%rax, %rdi
    5f09: e8 3b ff ff ff               	callq	0x5e49 <ebpf_test_bpf__destroy>
; 	errno = -err;
    5f0e: e8 dd f7 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    5f13: 8b 55 f4                     	movl	-12(%rbp), %edx
    5f16: f7 da                        	negl	%edx
    5f18: 89 10                        	movl	%edx, (%rax)
; 	return NULL;
    5f1a: b8 00 00 00 00               	movl	$0, %eax
; }
    5f1f: c9                           	leave
    5f20: c3                           	retq

0000000000005f21 <ebpf_test_bpf__open>:
; {
    5f21: 55                           	pushq	%rbp
    5f22: 48 89 e5                     	movq	%rsp, %rbp
; 	return ebpf_test_bpf__open_opts(NULL);
    5f25: bf 00 00 00 00               	movl	$0, %edi
    5f2a: e8 5d ff ff ff               	callq	0x5e8c <ebpf_test_bpf__open_opts>
; }
    5f2f: 5d                           	popq	%rbp
    5f30: c3                           	retq

0000000000005f31 <ebpf_test_bpf__load>:
; {
    5f31: 55                           	pushq	%rbp
    5f32: 48 89 e5                     	movq	%rsp, %rbp
    5f35: 48 83 ec 10                  	subq	$16, %rsp
    5f39: 48 89 7d f8                  	movq	%rdi, -8(%rbp)
; 	return bpf_object__load_skeleton(obj->skeleton);
    5f3d: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5f41: 48 8b 00                     	movq	(%rax), %rax
    5f44: 48 89 c7                     	movq	%rax, %rdi
    5f47: e8 74 77 01 00               	callq	0x1d6c0 <bpf_object__load_skeleton>
; }
    5f4c: c9                           	leave
    5f4d: c3                           	retq

0000000000005f4e <ebpf_test_bpf__attach>:
; {
    5f4e: 55                           	pushq	%rbp
    5f4f: 48 89 e5                     	movq	%rsp, %rbp
    5f52: 48 83 ec 10                  	subq	$16, %rsp
    5f56: 48 89 7d f8                  	movq	%rdi, -8(%rbp)
; 	return bpf_object__attach_skeleton(obj->skeleton);
    5f5a: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5f5e: 48 8b 00                     	movq	(%rax), %rax
    5f61: 48 89 c7                     	movq	%rax, %rdi
    5f64: e8 d7 78 01 00               	callq	0x1d840 <bpf_object__attach_skeleton>
; }
    5f69: c9                           	leave
    5f6a: c3                           	retq

0000000000005f6b <ebpf_test_bpf__detach>:
; {
    5f6b: 55                           	pushq	%rbp
    5f6c: 48 89 e5                     	movq	%rsp, %rbp
    5f6f: 48 83 ec 10                  	subq	$16, %rsp
    5f73: 48 89 7d f8                  	movq	%rdi, -8(%rbp)
; 	bpf_object__detach_skeleton(obj->skeleton);
    5f77: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5f7b: 48 8b 00                     	movq	(%rax), %rax
    5f7e: 48 89 c7                     	movq	%rax, %rdi
    5f81: e8 7a 79 01 00               	callq	0x1d900 <bpf_object__detach_skeleton>
; }
    5f86: 90                           	nop
    5f87: c9                           	leave
    5f88: c3                           	retq

0000000000005f89 <ebpf_test_bpf__create_skeleton>:
; {
    5f89: 55                           	pushq	%rbp
    5f8a: 48 89 e5                     	movq	%rsp, %rbp
    5f8d: 48 83 ec 20                  	subq	$32, %rsp
    5f91: 48 89 7d e8                  	movq	%rdi, -24(%rbp)
; 	s = (struct bpf_object_skeleton *)calloc(1, sizeof(*s));
    5f95: be 48 00 00 00               	movl	$72, %esi
    5f9a: bf 01 00 00 00               	movl	$1, %edi
    5f9f: e8 ec f9 ff ff               	callq	0x5990 <.plt.sec+0x320>
    5fa4: 48 89 45 f8                  	movq	%rax, -8(%rbp)
; 	if (!s)	{
    5fa8: 48 83 7d f8 00               	cmpq	$0, -8(%rbp)
    5fad: 75 0c                        	jne	0x5fbb <ebpf_test_bpf__create_skeleton+0x32>
; 		err = -ENOMEM;
    5faf: c7 45 f4 f4 ff ff ff         	movl	$4294967284, -12(%rbp)  # imm = 0xFFFFFFF4
; 		goto err;
    5fb6: e9 61 01 00 00               	jmp	0x611c <ebpf_test_bpf__create_skeleton+0x193>
; 	s->sz = sizeof(*s);
    5fbb: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5fbf: 48 c7 00 48 00 00 00         	movq	$72, (%rax)
; 	s->name = "ebpf_test_bpf";
    5fc6: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5fca: 48 8d 15 37 a0 02 00         	leaq	172087(%rip), %rdx      # 0x30008 <_IO_stdin_used+0x8>
    5fd1: 48 89 50 08                  	movq	%rdx, 8(%rax)
; 	s->obj = &obj->obj;
    5fd5: 48 8b 45 e8                  	movq	-24(%rbp), %rax
    5fd9: 48 8d 50 08                  	leaq	8(%rax), %rdx
    5fdd: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5fe1: 48 89 50 20                  	movq	%rdx, 32(%rax)
; 	s->map_cnt = 1;
    5fe5: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5fe9: c7 40 28 01 00 00 00         	movl	$1, 40(%rax)
; 	s->map_skel_sz = sizeof(*s->maps);
    5ff0: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5ff4: c7 40 2c 18 00 00 00         	movl	$24, 44(%rax)
; 	s->maps = (struct bpf_map_skeleton *)calloc(s->map_cnt, s->map_skel_sz);
    5ffb: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    5fff: 8b 40 2c                     	movl	44(%rax), %eax
    6002: 48 63 d0                     	movslq	%eax, %rdx
    6005: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6009: 8b 40 28                     	movl	40(%rax), %eax
    600c: 48 98                        	cltq
    600e: 48 89 d6                     	movq	%rdx, %rsi
    6011: 48 89 c7                     	movq	%rax, %rdi
    6014: e8 77 f9 ff ff               	callq	0x5990 <.plt.sec+0x320>
    6019: 48 89 c2                     	movq	%rax, %rdx
    601c: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6020: 48 89 50 30                  	movq	%rdx, 48(%rax)
; 	if (!s->maps) {
    6024: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6028: 48 8b 40 30                  	movq	48(%rax), %rax
    602c: 48 85 c0                     	testq	%rax, %rax
    602f: 75 0c                        	jne	0x603d <ebpf_test_bpf__create_skeleton+0xb4>
; 		err = -ENOMEM;
    6031: c7 45 f4 f4 ff ff ff         	movl	$4294967284, -12(%rbp)  # imm = 0xFFFFFFF4
; 		goto err;
    6038: e9 df 00 00 00               	jmp	0x611c <ebpf_test_bpf__create_skeleton+0x193>
; 	s->maps[0].name = "packets";
    603d: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6041: 48 8b 40 30                  	movq	48(%rax), %rax
    6045: 48 8d 15 ca 9f 02 00         	leaq	171978(%rip), %rdx      # 0x30016 <_IO_stdin_used+0x16>
    604c: 48 89 10                     	movq	%rdx, (%rax)
; 	s->maps[0].map = &obj->maps.packets;
    604f: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6053: 48 8b 40 30                  	movq	48(%rax), %rax
    6057: 48 8b 55 e8                  	movq	-24(%rbp), %rdx
    605b: 48 83 c2 10                  	addq	$16, %rdx
    605f: 48 89 50 08                  	movq	%rdx, 8(%rax)
; 	s->prog_cnt = 1;
    6063: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6067: c7 40 38 01 00 00 00         	movl	$1, 56(%rax)
; 	s->prog_skel_sz = sizeof(*s->progs);
    606e: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6072: c7 40 3c 18 00 00 00         	movl	$24, 60(%rax)
; 	s->progs = (struct bpf_prog_skeleton *)calloc(s->prog_cnt, s->prog_skel_sz);
    6079: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    607d: 8b 40 3c                     	movl	60(%rax), %eax
    6080: 48 63 d0                     	movslq	%eax, %rdx
    6083: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6087: 8b 40 38                     	movl	56(%rax), %eax
    608a: 48 98                        	cltq
    608c: 48 89 d6                     	movq	%rdx, %rsi
    608f: 48 89 c7                     	movq	%rax, %rdi
    6092: e8 f9 f8 ff ff               	callq	0x5990 <.plt.sec+0x320>
    6097: 48 89 c2                     	movq	%rax, %rdx
    609a: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    609e: 48 89 50 40                  	movq	%rdx, 64(%rax)
; 	if (!s->progs) {
    60a2: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    60a6: 48 8b 40 40                  	movq	64(%rax), %rax
    60aa: 48 85 c0                     	testq	%rax, %rax
    60ad: 75 09                        	jne	0x60b8 <ebpf_test_bpf__create_skeleton+0x12f>
; 		err = -ENOMEM;
    60af: c7 45 f4 f4 ff ff ff         	movl	$4294967284, -12(%rbp)  # imm = 0xFFFFFFF4
; 		goto err;
    60b6: eb 64                        	jmp	0x611c <ebpf_test_bpf__create_skeleton+0x193>
; 	s->progs[0].name = "xdp_prog_simple";
    60b8: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    60bc: 48 8b 40 40                  	movq	64(%rax), %rax
    60c0: 48 8d 15 57 9f 02 00         	leaq	171863(%rip), %rdx      # 0x3001e <_IO_stdin_used+0x1e>
    60c7: 48 89 10                     	movq	%rdx, (%rax)
; 	s->progs[0].prog = &obj->progs.xdp_prog_simple;
    60ca: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    60ce: 48 8b 40 40                  	movq	64(%rax), %rax
    60d2: 48 8b 55 e8                  	movq	-24(%rbp), %rdx
    60d6: 48 83 c2 18                  	addq	$24, %rdx
    60da: 48 89 50 08                  	movq	%rdx, 8(%rax)
; 	s->progs[0].link = &obj->links.xdp_prog_simple;
    60de: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    60e2: 48 8b 40 40                  	movq	64(%rax), %rax
    60e6: 48 8b 55 e8                  	movq	-24(%rbp), %rdx
    60ea: 48 83 c2 20                  	addq	$32, %rdx
    60ee: 48 89 50 10                  	movq	%rdx, 16(%rax)
; 	s->data = (void *)ebpf_test_bpf__elf_bytes(&s->data_sz);
    60f2: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    60f6: 48 83 c0 18                  	addq	$24, %rax
    60fa: 48 89 c7                     	movq	%rax, %rdi
    60fd: e8 2b 00 00 00               	callq	0x612d <ebpf_test_bpf__elf_bytes>
    6102: 48 8b 55 f8                  	movq	-8(%rbp), %rdx
    6106: 48 89 42 10                  	movq	%rax, 16(%rdx)
; 	obj->skeleton = s;
    610a: 48 8b 45 e8                  	movq	-24(%rbp), %rax
    610e: 48 8b 55 f8                  	movq	-8(%rbp), %rdx
    6112: 48 89 10                     	movq	%rdx, (%rax)
; 	return 0;
    6115: b8 00 00 00 00               	movl	$0, %eax
    611a: eb 0f                        	jmp	0x612b <ebpf_test_bpf__create_skeleton+0x1a2>
; 	bpf_object__destroy_skeleton(s);
    611c: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6120: 48 89 c7                     	movq	%rax, %rdi
    6123: e8 48 78 01 00               	callq	0x1d970 <bpf_object__destroy_skeleton>
; 	return err;
    6128: 8b 45 f4                     	movl	-12(%rbp), %eax
; }
    612b: c9                           	leave
    612c: c3                           	retq

000000000000612d <ebpf_test_bpf__elf_bytes>:
; {
    612d: 55                           	pushq	%rbp
    612e: 48 89 e5                     	movq	%rsp, %rbp
    6131: 48 89 7d f8                  	movq	%rdi, -8(%rbp)
; 	*sz = 6864;
    6135: 48 8b 45 f8                  	movq	-8(%rbp), %rax
    6139: 48 c7 00 d0 1a 00 00         	movq	$6864, (%rax)           # imm = 0x1AD0
; 	return (const void *)"\
    6140: 48 8d 05 e9 9e 02 00         	leaq	171753(%rip), %rax      # 0x30030 <_IO_stdin_used+0x30>
; }
    6147: 5d                           	popq	%rbp
    6148: c3                           	retq

0000000000006149 <ebpf_test_bpf__assert>:
; {
    6149: f3 0f 1e fa                  	endbr64
    614d: 55                           	pushq	%rbp
    614e: 48 89 e5                     	movq	%rsp, %rbp
    6151: 48 89 7d f8                  	movq	%rdi, -8(%rbp)
; }
    6155: 90                           	nop
    6156: 5d                           	popq	%rbp
    6157: c3                           	retq

0000000000006158 <libbpf_print_fn>:
; {
    6158: f3 0f 1e fa                  	endbr64
    615c: 55                           	pushq	%rbp
    615d: 48 89 e5                     	movq	%rsp, %rbp
    6160: 48 83 ec 20                  	subq	$32, %rsp
    6164: 89 7d fc                     	movl	%edi, -4(%rbp)
    6167: 48 89 75 f0                  	movq	%rsi, -16(%rbp)
    616b: 48 89 55 e8                  	movq	%rdx, -24(%rbp)
; 	return vfprintf(stderr, format, args);
    616f: 48 8b 05 8a 10 04 00         	movq	266378(%rip), %rax      # 0x47200 <stderr@GLIBC_2.2.5>
    6176: 48 8b 55 e8                  	movq	-24(%rbp), %rdx
    617a: 48 8b 4d f0                  	movq	-16(%rbp), %rcx
    617e: 48 89 ce                     	movq	%rcx, %rsi
    6181: 48 89 c7                     	movq	%rax, %rdi
    6184: e8 37 fa ff ff               	callq	0x5bc0 <.plt.sec+0x550>
; }
    6189: c9                           	leave
    618a: c3                           	retq

000000000000618b <main>:
; {
    618b: f3 0f 1e fa                  	endbr64
    618f: 55                           	pushq	%rbp
    6190: 48 89 e5                     	movq	%rsp, %rbp
    6193: 48 83 ec 40                  	subq	$64, %rsp
    6197: 89 7d cc                     	movl	%edi, -52(%rbp)
    619a: 48 89 75 c0                  	movq	%rsi, -64(%rbp)
    619e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    61a7: 48 89 45 f8                  	movq	%rax, -8(%rbp)
    61ab: 31 c0                        	xorl	%eax, %eax
; 	skel = ebpf_test_bpf__open();
    61ad: e8 6f fd ff ff               	callq	0x5f21 <ebpf_test_bpf__open>
    61b2: 48 89 45 e8                  	movq	%rax, -24(%rbp)
;     if (!skel) {
    61b6: 48 83 7d e8 00               	cmpq	$0, -24(%rbp)
    61bb: 75 2d                        	jne	0x61ea <main+0x5f>
; 		fprintf(stderr, "Failed to open BPF skeleton\n");
    61bd: 48 8b 05 3c 10 04 00         	movq	266300(%rip), %rax      # 0x47200 <stderr@GLIBC_2.2.5>
    61c4: 48 89 c1                     	movq	%rax, %rcx
    61c7: ba 1c 00 00 00               	movl	$28, %edx
    61cc: be 01 00 00 00               	movl	$1, %esi
    61d1: 48 8d 05 29 b9 02 00         	leaq	178473(%rip), %rax      # 0x31b01 <_IO_stdin_used+0x1b01>
    61d8: 48 89 c7                     	movq	%rax, %rdi
    61db: e8 10 fa ff ff               	callq	0x5bf0 <.plt.sec+0x580>
; 		return 1;
    61e0: b8 01 00 00 00               	movl	$1, %eax
    61e5: e9 87 01 00 00               	jmp	0x6371 <main+0x1e6>
; 	err = ebpf_test_bpf__load(skel);
    61ea: 48 8b 45 e8                  	movq	-24(%rbp), %rax
    61ee: 48 89 c7                     	movq	%rax, %rdi
    61f1: e8 3b fd ff ff               	callq	0x5f31 <ebpf_test_bpf__load>
    61f6: 89 45 d0                     	movl	%eax, -48(%rbp)
; 	if (err) {
    61f9: 83 7d d0 00                  	cmpl	$0, -48(%rbp)
    61fd: 74 28                        	je	0x6227 <main+0x9c>
; 		fprintf(stderr, "Failed to load and verify BPF skeleton\n");
    61ff: 48 8b 05 fa 0f 04 00         	movq	266234(%rip), %rax      # 0x47200 <stderr@GLIBC_2.2.5>
    6206: 48 89 c1                     	movq	%rax, %rcx
    6209: ba 27 00 00 00               	movl	$39, %edx
    620e: be 01 00 00 00               	movl	$1, %esi
    6213: 48 8d 05 06 b9 02 00         	leaq	178438(%rip), %rax      # 0x31b20 <_IO_stdin_used+0x1b20>
    621a: 48 89 c7                     	movq	%rax, %rdi
    621d: e8 ce f9 ff ff               	callq	0x5bf0 <.plt.sec+0x580>
; 		goto cleanup;
    6222: e9 39 01 00 00               	jmp	0x6360 <main+0x1d5>
;     err = ebpf_test_bpf__attach(skel);
    6227: 48 8b 45 e8                  	movq	-24(%rbp), %rax
    622b: 48 89 c7                     	movq	%rax, %rdi
    622e: e8 1b fd ff ff               	callq	0x5f4e <ebpf_test_bpf__attach>
    6233: 89 45 d0                     	movl	%eax, -48(%rbp)
; 	if (err) {
    6236: 83 7d d0 00                  	cmpl	$0, -48(%rbp)
    623a: 74 28                        	je	0x6264 <main+0xd9>
; 		fprintf(stderr, "Failed to attach BPF skeleton\n");
    623c: 48 8b 05 bd 0f 04 00         	movq	266173(%rip), %rax      # 0x47200 <stderr@GLIBC_2.2.5>
    6243: 48 89 c1                     	movq	%rax, %rcx
    6246: ba 1e 00 00 00               	movl	$30, %edx
    624b: be 01 00 00 00               	movl	$1, %esi
    6250: 48 8d 05 f1 b8 02 00         	leaq	178417(%rip), %rax      # 0x31b48 <_IO_stdin_used+0x1b48>
    6257: 48 89 c7                     	movq	%rax, %rdi
    625a: e8 91 f9 ff ff               	callq	0x5bf0 <.plt.sec+0x580>
; 		goto cleanup;
    625f: e9 fc 00 00 00               	jmp	0x6360 <main+0x1d5>
;     struct bpf_map* map = bpf_object__find_map_by_name(skel->obj, "packets");
    6264: 48 8b 45 e8                  	movq	-24(%rbp), %rax
    6268: 48 8b 40 08                  	movq	8(%rax), %rax
    626c: 48 8d 15 a3 9d 02 00         	leaq	171427(%rip), %rdx      # 0x30016 <_IO_stdin_used+0x16>
    6273: 48 89 d6                     	movq	%rdx, %rsi
    6276: 48 89 c7                     	movq	%rax, %rdi
    6279: e8 32 b4 00 00               	callq	0x116b0 <bpf_object__find_map_by_name>
    627e: 48 89 45 f0                  	movq	%rax, -16(%rbp)
; 	if (!map) {
    6282: 48 83 7d f0 00               	cmpq	$0, -16(%rbp)
    6287: 75 23                        	jne	0x62ac <main+0x121>
; 		fprintf(stderr, "Failed to find map 'packets'\n");
    6289: 48 8b 05 70 0f 04 00         	movq	266096(%rip), %rax      # 0x47200 <stderr@GLIBC_2.2.5>
    6290: 48 89 c1                     	movq	%rax, %rcx
    6293: ba 1d 00 00 00               	movl	$29, %edx
    6298: be 01 00 00 00               	movl	$1, %esi
    629d: 48 8d 05 c3 b8 02 00         	leaq	178371(%rip), %rax      # 0x31b67 <_IO_stdin_used+0x1b67>
    62a4: 48 89 c7                     	movq	%rax, %rdi
    62a7: e8 44 f9 ff ff               	callq	0x5bf0 <.plt.sec+0x580>
;     unsigned long long key = 0, value = -1;
    62ac: 48 c7 45 d8 00 00 00 00      	movq	$0, -40(%rbp)
    62b4: 48 c7 45 e0 ff ff ff ff      	movq	$-1, -32(%rbp)
;     for (int i = 0; i < 10; i++) {
    62bc: c7 45 d4 00 00 00 00         	movl	$0, -44(%rbp)
    62c3: e9 82 00 00 00               	jmp	0x634a <main+0x1bf>
;         sleep(2);
    62c8: bf 02 00 00 00               	movl	$2, %edi
    62cd: e8 5e f9 ff ff               	callq	0x5c30 <.plt.sec+0x5c0>
;         if (bpf_map__lookup_elem(map, &key, sizeof(key), &value, sizeof(value), 0) < 0) {
    62d2: 48 8d 55 e0                  	leaq	-32(%rbp), %rdx
    62d6: 48 8d 75 d8                  	leaq	-40(%rbp), %rsi
    62da: 48 8b 45 f0                  	movq	-16(%rbp), %rax
    62de: 41 b9 00 00 00 00            	movl	$0, %r9d
    62e4: 41 b8 08 00 00 00            	movl	$8, %r8d
    62ea: 48 89 d1                     	movq	%rdx, %rcx
    62ed: ba 08 00 00 00               	movl	$8, %edx
    62f2: 48 89 c7                     	movq	%rax, %rdi
    62f5: b8 00 00 00 00               	movl	$0, %eax
    62fa: e8 31 63 01 00               	callq	0x1c630 <bpf_map__lookup_elem>
    62ff: 85 c0                        	testl	%eax, %eax
    6301: 79 24                        	jns	0x6327 <main+0x19c>
; 			fprintf(stderr, "Failed to lookup key %llu\n", key);
    6303: 48 8b 55 d8                  	movq	-40(%rbp), %rdx
    6307: 48 8b 05 f2 0e 04 00         	movq	265970(%rip), %rax      # 0x47200 <stderr@GLIBC_2.2.5>
    630e: 48 8d 0d 70 b8 02 00         	leaq	178288(%rip), %rcx      # 0x31b85 <_IO_stdin_used+0x1b85>
    6315: 48 89 ce                     	movq	%rcx, %rsi
    6318: 48 89 c7                     	movq	%rax, %rdi
    631b: b8 00 00 00 00               	movl	$0, %eax
    6320: e8 ab f6 ff ff               	callq	0x59d0 <.plt.sec+0x360>
    6325: eb 1f                        	jmp	0x6346 <main+0x1bb>
;         	printf("key: %llu, value: %llu\n", key, value);
    6327: 48 8b 55 e0                  	movq	-32(%rbp), %rdx
    632b: 48 8b 45 d8                  	movq	-40(%rbp), %rax
    632f: 48 89 c6                     	movq	%rax, %rsi
    6332: 48 8d 05 67 b8 02 00         	leaq	178279(%rip), %rax      # 0x31ba0 <_IO_stdin_used+0x1ba0>
    6339: 48 89 c7                     	movq	%rax, %rdi
    633c: b8 00 00 00 00               	movl	$0, %eax
    6341: e8 ea f4 ff ff               	callq	0x5830 <.plt.sec+0x1c0>
;     for (int i = 0; i < 10; i++) {
    6346: 83 45 d4 01                  	addl	$1, -44(%rbp)
    634a: 83 7d d4 09                  	cmpl	$9, -44(%rbp)
    634e: 0f 8e 74 ff ff ff            	jle	0x62c8 <main+0x13d>
;     ebpf_test_bpf__detach(skel);
    6354: 48 8b 45 e8                  	movq	-24(%rbp), %rax
    6358: 48 89 c7                     	movq	%rax, %rdi
    635b: e8 0b fc ff ff               	callq	0x5f6b <ebpf_test_bpf__detach>
;     ebpf_test_bpf__destroy(skel);
    6360: 48 8b 45 e8                  	movq	-24(%rbp), %rax
    6364: 48 89 c7                     	movq	%rax, %rdi
    6367: e8 dd fa ff ff               	callq	0x5e49 <ebpf_test_bpf__destroy>
; 	return -err;
    636c: 8b 45 d0                     	movl	-48(%rbp), %eax
    636f: f7 d8                        	negl	%eax
; }
    6371: 48 8b 55 f8                  	movq	-8(%rbp), %rdx
    6375: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    637e: 74 05                        	je	0x6385 <main+0x1fa>
    6380: e8 7b f4 ff ff               	callq	0x5800 <.plt.sec+0x190>
    6385: c9                           	leave
    6386: c3                           	retq
    6387: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000006390 <__btf_kind_str>:
; 	switch (kind) {
    6390: 66 83 ff 13                  	cmpw	$19, %di
    6394: 0f 87 4e 01 00 00            	ja	0x64e8 <__btf_kind_str+0x158>
    639a: 48 8d 15 bf c9 02 00         	leaq	182719(%rip), %rdx      # 0x32d60 <_IO_stdin_used+0x2d60>
    63a1: 0f b7 ff                     	movzwl	%di, %edi
    63a4: 48 63 04 ba                  	movslq	(%rdx,%rdi,4), %rax
    63a8: 48 01 d0                     	addq	%rdx, %rax
    63ab: 3e ff e0                     	jmpq	*%rax
    63ae: 66 90                        	nop
    63b0: 48 8d 05 a0 58 03 00         	leaq	219296(%rip), %rax      # 0x3bc57 <CSWTCH.126+0x2357>
    63b7: c3                           	retq
    63b8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_UNKN: return "void";
    63c0: 48 8d 05 f1 b7 02 00         	leaq	178161(%rip), %rax      # 0x31bb8 <_IO_stdin_used+0x1bb8>
; }
    63c7: c3                           	retq
    63c8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_ENUM64: return "enum64";
    63d0: 48 8d 05 54 b8 02 00         	leaq	178260(%rip), %rax      # 0x31c2b <_IO_stdin_used+0x1c2b>
    63d7: c3                           	retq
    63d8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_TYPE_TAG: return "type_tag";
    63e0: 48 8d 05 3b b8 02 00         	leaq	178235(%rip), %rax      # 0x31c22 <_IO_stdin_used+0x1c22>
    63e7: c3                           	retq
    63e8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_DECL_TAG: return "decl_tag";
    63f0: 48 8d 05 22 b8 02 00         	leaq	178210(%rip), %rax      # 0x31c19 <_IO_stdin_used+0x1c19>
    63f7: c3                           	retq
    63f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_FUNC: return "func";
    6400: 48 8d 05 f0 b7 02 00         	leaq	178160(%rip), %rax      # 0x31bf7 <_IO_stdin_used+0x1bf7>
    6407: c3                           	retq
    6408: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_RESTRICT: return "restrict";
    6410: 48 8d 05 d7 b7 02 00         	leaq	178135(%rip), %rax      # 0x31bee <_IO_stdin_used+0x1bee>
    6417: c3                           	retq
    6418: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_CONST: return "const";
    6420: 48 8d 05 c1 b7 02 00         	leaq	178113(%rip), %rax      # 0x31be8 <_IO_stdin_used+0x1be8>
    6427: c3                           	retq
    6428: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_FUNC_PROTO: return "func_proto";
    6430: 48 8d 05 c5 b7 02 00         	leaq	178117(%rip), %rax      # 0x31bfc <_IO_stdin_used+0x1bfc>
    6437: c3                           	retq
    6438: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_STRUCT: return "struct";
    6440: 48 8d 05 7a b7 02 00         	leaq	178042(%rip), %rax      # 0x31bc1 <_IO_stdin_used+0x1bc1>
    6447: c3                           	retq
    6448: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_ARRAY: return "array";
    6450: 48 8d 05 6c c5 02 00         	leaq	181612(%rip), %rax      # 0x329c3 <_IO_stdin_used+0x29c3>
    6457: c3                           	retq
    6458: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_PTR: return "ptr";
    6460: 48 8d 05 56 b7 02 00         	leaq	178006(%rip), %rax      # 0x31bbd <_IO_stdin_used+0x1bbd>
    6467: c3                           	retq
    6468: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_VOLATILE: return "volatile";
    6470: 48 8d 05 68 b7 02 00         	leaq	178024(%rip), %rax      # 0x31bdf <_IO_stdin_used+0x1bdf>
    6477: c3                           	retq
    6478: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_TYPEDEF: return "typedef";
    6480: 48 8d 05 50 b7 02 00         	leaq	178000(%rip), %rax      # 0x31bd7 <_IO_stdin_used+0x1bd7>
    6487: c3                           	retq
    6488: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_FWD: return "fwd";
    6490: 48 8d 05 3c b7 02 00         	leaq	177980(%rip), %rax      # 0x31bd3 <_IO_stdin_used+0x1bd3>
    6497: c3                           	retq
    6498: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_ENUM: return "enum";
    64a0: 48 8d 05 27 b7 02 00         	leaq	177959(%rip), %rax      # 0x31bce <_IO_stdin_used+0x1bce>
    64a7: c3                           	retq
    64a8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_UNION: return "union";
    64b0: 48 8d 05 11 b7 02 00         	leaq	177937(%rip), %rax      # 0x31bc8 <_IO_stdin_used+0x1bc8>
    64b7: c3                           	retq
    64b8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_FLOAT: return "float";
    64c0: 48 8d 05 4c b7 02 00         	leaq	177996(%rip), %rax      # 0x31c13 <_IO_stdin_used+0x1c13>
    64c7: c3                           	retq
    64c8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_DATASEC: return "datasec";
    64d0: 48 8d 05 34 b7 02 00         	leaq	177972(%rip), %rax      # 0x31c0b <_IO_stdin_used+0x1c0b>
    64d7: c3                           	retq
    64d8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BTF_KIND_VAR: return "var";
    64e0: 48 8d 05 20 b7 02 00         	leaq	177952(%rip), %rax      # 0x31c07 <_IO_stdin_used+0x1c07>
    64e7: c3                           	retq
; 	default: return "unknown";
    64e8: 48 8d 05 43 b7 02 00         	leaq	177987(%rip), %rax      # 0x31c32 <_IO_stdin_used+0x1c32>
    64ef: c3                           	retq

00000000000064f0 <compare_vsi_off>:
; {
    64f0: f3 0f 1e fa                  	endbr64
; 	return a->offset - b->offset;
    64f4: 8b 47 04                     	movl	4(%rdi), %eax
    64f7: 2b 46 04                     	subl	4(%rsi), %eax
; }
    64fa: c3                           	retq
    64fb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000006500 <cmp_progs>:
; {
    6500: f3 0f 1e fa                  	endbr64
; 	if (a->sec_idx != b->sec_idx)
    6504: 48 8b 46 10                  	movq	16(%rsi), %rax
    6508: 48 39 47 10                  	cmpq	%rax, 16(%rdi)
    650c: 75 08                        	jne	0x6516 <cmp_progs+0x16>
; 		return a->sec_idx < b->sec_idx ? -1 : 1;
    650e: 48 8b 46 20                  	movq	32(%rsi), %rax
    6512: 48 39 47 20                  	cmpq	%rax, 32(%rdi)
    6516: 19 c0                        	sbbl	%eax, %eax
    6518: 83 c8 01                     	orl	$1, %eax
; }
    651b: c3                           	retq
    651c: 0f 1f 40 00                  	nopl	(%rax)

0000000000006520 <find_prog_by_sec_insn>:
; 	int l = 0, r = obj->nr_programs - 1, m;
    6520: 8b 47 60                     	movl	96(%rdi), %eax
; {
    6523: 49 89 f1                     	movq	%rsi, %r9
; 	prog = &obj->programs[l];
    6526: 4c 8b 47 58                  	movq	88(%rdi), %r8
; {
    652a: 49 89 d2                     	movq	%rdx, %r10
; 	int l = 0, r = obj->nr_programs - 1, m;
    652d: 8d 70 ff                     	leal	-1(%rax), %esi
; 	while (l < r) {
    6530: 85 f6                        	testl	%esi, %esi
    6532: 7e 46                        	jle	0x657a <find_prog_by_sec_insn+0x5a>
; 	int l = 0, r = obj->nr_programs - 1, m;
    6534: 31 c9                        	xorl	%ecx, %ecx
    6536: eb 11                        	jmp	0x6549 <find_prog_by_sec_insn+0x29>
    6538: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		if (prog->sec_idx < sec_idx ||
    6540: 74 4e                        	je	0x6590 <find_prog_by_sec_insn+0x70>
; 			r = m - 1;
    6542: 8d 70 ff                     	leal	-1(%rax), %esi
; 	while (l < r) {
    6545: 39 ce                        	cmpl	%ecx, %esi
    6547: 7e 26                        	jle	0x656f <find_prog_by_sec_insn+0x4f>
; 		m = l + (r - l + 1) / 2;
    6549: 89 f0                        	movl	%esi, %eax
    654b: 29 c8                        	subl	%ecx, %eax
    654d: 83 c0 01                     	addl	$1, %eax
    6550: d1 f8                        	sarl	%eax
    6552: 01 c8                        	addl	%ecx, %eax
; 		prog = &obj->programs[m];
    6554: 48 63 d0                     	movslq	%eax, %rdx
    6557: 48 8d 14 52                  	leaq	(%rdx,%rdx,2), %rdx
    655b: 48 c1 e2 06                  	shlq	$6, %rdx
    655f: 4c 01 c2                     	addq	%r8, %rdx
; 		if (prog->sec_idx < sec_idx ||
    6562: 4c 39 4a 10                  	cmpq	%r9, 16(%rdx)
    6566: 73 d8                        	jae	0x6540 <find_prog_by_sec_insn+0x20>
; 			l = m;
    6568: 48 63 c8                     	movslq	%eax, %rcx
; 	while (l < r) {
    656b: 39 ce                        	cmpl	%ecx, %esi
    656d: 7f da                        	jg	0x6549 <find_prog_by_sec_insn+0x29>
; 	prog = &obj->programs[l];
    656f: 48 8d 04 49                  	leaq	(%rcx,%rcx,2), %rax
    6573: 48 c1 e0 06                  	shlq	$6, %rax
    6577: 49 01 c0                     	addq	%rax, %r8
; 	if (prog->sec_idx == sec_idx && prog_contains_insn(prog, insn_idx))
    657a: 4d 39 48 10                  	cmpq	%r9, 16(%r8)
    657e: 75 09                        	jne	0x6589 <find_prog_by_sec_insn+0x69>
; 	return insn_idx >= prog->sec_insn_off &&
    6580: 49 8b 40 20                  	movq	32(%r8), %rax
    6584: 49 39 c2                     	cmpq	%rax, %r10
    6587: 73 17                        	jae	0x65a0 <find_prog_by_sec_insn+0x80>
; 	return NULL;
    6589: 45 31 c0                     	xorl	%r8d, %r8d
; }
    658c: 4c 89 c0                     	movq	%r8, %rax
    658f: c3                           	retq
; 		    (prog->sec_idx == sec_idx && prog->sec_insn_off <= insn_idx))
    6590: 4c 39 52 20                  	cmpq	%r10, 32(%rdx)
    6594: 77 ac                        	ja	0x6542 <find_prog_by_sec_insn+0x22>
; 			l = m;
    6596: 48 63 c8                     	movslq	%eax, %rcx
    6599: eb d0                        	jmp	0x656b <find_prog_by_sec_insn+0x4b>
    659b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	       insn_idx < prog->sec_insn_off + prog->sec_insn_cnt;
    65a0: 49 03 40 28                  	addq	40(%r8), %rax
; 	return NULL;
    65a4: 49 39 c2                     	cmpq	%rax, %r10
    65a7: b8 00 00 00 00               	movl	$0, %eax
    65ac: 4c 0f 43 c0                  	cmovaeq	%rax, %r8
; }
    65b0: 4c 89 c0                     	movq	%r8, %rax
    65b3: c3                           	retq
    65b4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    65bf: 90                           	nop

00000000000065c0 <bpf_core_hash_fn>:
; {
    65c0: f3 0f 1e fa                  	endbr64
    65c4: 48 89 f8                     	movq	%rdi, %rax
; }
    65c7: c3                           	retq
    65c8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

00000000000065d0 <bpf_core_equal_fn>:
; {
    65d0: f3 0f 1e fa                  	endbr64
; 	return k1 == k2;
    65d4: 48 39 fe                     	cmpq	%rdi, %rsi
    65d7: 0f 94 c0                     	sete	%al
; }
    65da: c3                           	retq
    65db: 0f 1f 44 00 00               	nopl	(%rax,%rax)

00000000000065e0 <glob_match>:
; {
    65e0: 55                           	pushq	%rbp
    65e1: 53                           	pushq	%rbx
    65e2: 48 83 ec 08                  	subq	$8, %rsp
; 	while (*str && *pat && *pat != '*') {
    65e6: 44 0f b6 17                  	movzbl	(%rdi), %r10d
    65ea: 45 84 d2                     	testb	%r10b, %r10b
    65ed: 74 69                        	je	0x6658 <glob_match+0x78>
    65ef: 4c 8d 47 01                  	leaq	1(%rdi), %r8
    65f3: 48 8d 56 01                  	leaq	1(%rsi), %rdx
    65f7: eb 29                        	jmp	0x6622 <glob_match+0x42>
    65f9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (*pat == '?') {      /* Matches any single character */
    6600: 80 f9 3f                     	cmpb	$63, %cl
    6603: 74 09                        	je	0x660e <glob_match+0x2e>
; 		if (*str != *pat)
    6605: 44 38 d1                     	cmpb	%r10b, %cl
    6608: 0f 85 8d 00 00 00            	jne	0x669b <glob_match+0xbb>
; 	while (*str && *pat && *pat != '*') {
    660e: 45 0f b6 10                  	movzbl	(%r8), %r10d
; 		str++;
    6612: 4c 89 c7                     	movq	%r8, %rdi
; 	while (*str && *pat && *pat != '*') {
    6615: 48 83 c2 01                  	addq	$1, %rdx
    6619: 49 83 c0 01                  	addq	$1, %r8
    661d: 45 84 d2                     	testb	%r10b, %r10b
    6620: 74 36                        	je	0x6658 <glob_match+0x78>
    6622: 0f b6 4a ff                  	movzbl	-1(%rdx), %ecx
    6626: 48 8d 5a ff                  	leaq	-1(%rdx), %rbx
    662a: 49 8d 78 ff                  	leaq	-1(%r8), %rdi
    662e: 48 89 d6                     	movq	%rdx, %rsi
    6631: 80 f9 2a                     	cmpb	$42, %cl
    6634: 0f 95 c0                     	setne	%al
    6637: 84 c9                        	testb	%cl, %cl
    6639: 41 0f 95 c1                  	setne	%r9b
    663d: 44 20 c8                     	andb	%r9b, %al
    6640: 75 be                        	jne	0x6600 <glob_match+0x20>
; 	if (*pat == '*') {
    6642: 80 f9 2a                     	cmpb	$42, %cl
    6645: 74 21                        	je	0x6668 <glob_match+0x88>
; 	return !*str && !*pat;
    6647: 80 3f 00                     	cmpb	$0, (%rdi)
    664a: 74 5c                        	je	0x66a8 <glob_match+0xc8>
; }
    664c: 48 83 c4 08                  	addq	$8, %rsp
    6650: 5b                           	popq	%rbx
    6651: 5d                           	popq	%rbp
    6652: c3                           	retq
    6653: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	if (*pat == '*') {
    6658: 0f b6 0e                     	movzbl	(%rsi), %ecx
    665b: 80 f9 2a                     	cmpb	$42, %cl
    665e: 75 48                        	jne	0x66a8 <glob_match+0xc8>
    6660: 48 89 f3                     	movq	%rsi, %rbx
; 		while (*pat == '*')
    6663: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    6668: 0f b6 53 01                  	movzbl	1(%rbx), %edx
; 			pat++;
    666c: 48 83 c3 01                  	addq	$1, %rbx
; 		while (*pat == '*')
    6670: 80 fa 2a                     	cmpb	$42, %dl
    6673: 74 f3                        	je	0x6668 <glob_match+0x88>
; 			return true;
    6675: b8 01 00 00 00               	movl	$1, %eax
; 		if (!*pat) /* Tail wild card matches all */
    667a: 84 d2                        	testb	%dl, %dl
    667c: 74 ce                        	je	0x664c <glob_match+0x6c>
; 		while (*str)
    667e: 80 3f 00                     	cmpb	$0, (%rdi)
    6681: 74 18                        	je	0x669b <glob_match+0xbb>
; 			if (glob_match(str++, pat))
    6683: 48 89 de                     	movq	%rbx, %rsi
    6686: 48 8d 6f 01                  	leaq	1(%rdi), %rbp
    668a: e8 51 ff ff ff               	callq	0x65e0 <glob_match>
    668f: 84 c0                        	testb	%al, %al
    6691: 75 b9                        	jne	0x664c <glob_match+0x6c>
    6693: 48 89 ef                     	movq	%rbp, %rdi
; 		while (*str)
    6696: 80 3f 00                     	cmpb	$0, (%rdi)
    6699: 75 e8                        	jne	0x6683 <glob_match+0xa3>
; }
    669b: 48 83 c4 08                  	addq	$8, %rsp
; 			return false;
    669f: 31 c0                        	xorl	%eax, %eax
; }
    66a1: 5b                           	popq	%rbx
    66a2: 5d                           	popq	%rbp
    66a3: c3                           	retq
    66a4: 0f 1f 40 00                  	nopl	(%rax)
; 	return !*str && !*pat;
    66a8: 84 c9                        	testb	%cl, %cl
    66aa: 0f 94 c0                     	sete	%al
; }
    66ad: 48 83 c4 08                  	addq	$8, %rsp
    66b1: 5b                           	popq	%rbx
    66b2: 5d                           	popq	%rbp
    66b3: c3                           	retq
    66b4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    66bf: 90                           	nop

00000000000066c0 <bpf_link_perf_dealloc>:
; {
    66c0: f3 0f 1e fa                  	endbr64
    66c4: 55                           	pushq	%rbp
    66c5: 48 89 fd                     	movq	%rdi, %rbp
; 	free(perf_link->legacy_probe_name);
    66c8: 48 8b 7f 28                  	movq	40(%rdi), %rdi
    66cc: e8 ef ef ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(perf_link);
    66d1: 48 89 ef                     	movq	%rbp, %rdi
; }
    66d4: 5d                           	popq	%rbp
; 	free(perf_link);
    66d5: e9 e6 ef ff ff               	jmp	0x56c0 <.plt.sec+0x50>
    66da: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

00000000000066e0 <cmp_externs>:
; {
    66e0: f3 0f 1e fa                  	endbr64
; 	if (a->type != b->type)
    66e4: 8b 07                        	movl	(%rdi), %eax
    66e6: 3b 06                        	cmpl	(%rsi), %eax
    66e8: 74 06                        	je	0x66f0 <cmp_externs+0x10>
; 		return a->type < b->type ? -1 : 1;
    66ea: 19 c0                        	sbbl	%eax, %eax
    66ec: 83 c8 01                     	orl	$1, %eax
    66ef: c3                           	retq
; 	if (a->type == EXT_KCFG) {
    66f0: 83 f8 01                     	cmpl	$1, %eax
    66f3: 74 13                        	je	0x6708 <cmp_externs+0x28>
; 	return strcmp(a->name, b->name);
    66f5: 48 8b 76 10                  	movq	16(%rsi), %rsi
    66f9: 48 8b 7f 10                  	movq	16(%rdi), %rdi
    66fd: e9 ae f2 ff ff               	jmp	0x59b0 <.plt.sec+0x340>
    6702: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		if (a->kcfg.align != b->kcfg.align)
    6708: 8b 46 28                     	movl	40(%rsi), %eax
    670b: 39 47 28                     	cmpl	%eax, 40(%rdi)
    670e: 74 10                        	je	0x6720 <cmp_externs+0x40>
; 		return a->type < b->type ? -1 : 1;
    6710: 0f 9e c0                     	setle	%al
    6713: 0f b6 c0                     	movzbl	%al, %eax
    6716: 8d 44 00 ff                  	leal	-1(%rax,%rax), %eax
    671a: c3                           	retq
    671b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		if (a->kcfg.sz != b->kcfg.sz)
    6720: 8b 46 24                     	movl	36(%rsi), %eax
    6723: 39 47 24                     	cmpl	%eax, 36(%rdi)
    6726: 74 cd                        	je	0x66f5 <cmp_externs+0x15>
; 		return a->type < b->type ? -1 : 1;
    6728: 0f 9d c0                     	setge	%al
    672b: 0f b6 c0                     	movzbl	%al, %eax
    672e: 8d 44 00 ff                  	leal	-1(%rax,%rax), %eax
; }
    6732: c3                           	retq
    6733: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    673e: 66 90                        	nop

0000000000006740 <adjust_ringbuf_sz>:
; {
    6740: 41 54                        	pushq	%r12
    6742: 49 89 fc                     	movq	%rdi, %r12
; 	__u32 page_sz = sysconf(_SC_PAGE_SIZE);
    6745: bf 1e 00 00 00               	movl	$30, %edi
    674a: e8 61 f4 ff ff               	callq	0x5bb0 <.plt.sec+0x540>
; 	if (sz == 0)
    674f: 4d 85 e4                     	testq	%r12, %r12
    6752: 74 2e                        	je	0x6782 <adjust_ringbuf_sz+0x42>
; 	if ((sz % page_sz) == 0 && is_pow_of_2(sz / page_sz))
    6754: 89 c1                        	movl	%eax, %ecx
; 	__u32 page_sz = sysconf(_SC_PAGE_SIZE);
    6756: 89 c6                        	movl	%eax, %esi
; 	if ((sz % page_sz) == 0 && is_pow_of_2(sz / page_sz))
    6758: 31 d2                        	xorl	%edx, %edx
    675a: 4c 89 e0                     	movq	%r12, %rax
    675d: 48 f7 f1                     	divq	%rcx
    6760: 48 85 d2                     	testq	%rdx, %rdx
    6763: 74 2b                        	je	0x6790 <adjust_ringbuf_sz+0x50>
; 		if (mul * page_sz > sz)
    6765: 4c 39 e1                     	cmpq	%r12, %rcx
    6768: 77 36                        	ja	0x67a0 <adjust_ringbuf_sz+0x60>
    676a: b9 01 00 00 00               	movl	$1, %ecx
    676f: 90                           	nop
; 	for (mul = 1; mul <= UINT_MAX / page_sz; mul <<= 1) {
    6770: 01 c9                        	addl	%ecx, %ecx
    6772: 89 c8                        	movl	%ecx, %eax
    6774: f7 e6                        	mull	%esi
    6776: 70 0a                        	jo	0x6782 <adjust_ringbuf_sz+0x42>
; 		if (mul * page_sz > sz)
    6778: 89 c0                        	movl	%eax, %eax
    677a: 4c 39 e0                     	cmpq	%r12, %rax
    677d: 76 f1                        	jbe	0x6770 <adjust_ringbuf_sz+0x30>
    677f: 49 89 c4                     	movq	%rax, %r12
; }
    6782: 4c 89 e0                     	movq	%r12, %rax
    6785: 41 5c                        	popq	%r12
    6787: c3                           	retq
    6788: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	return x && (x & (x - 1)) == 0;
    6790: 4c 39 e1                     	cmpq	%r12, %rcx
    6793: 77 0b                        	ja	0x67a0 <adjust_ringbuf_sz+0x60>
    6795: 48 8d 50 ff                  	leaq	-1(%rax), %rdx
    6799: 48 85 c2                     	testq	%rax, %rdx
    679c: 74 e4                        	je	0x6782 <adjust_ringbuf_sz+0x42>
    679e: eb ca                        	jmp	0x676a <adjust_ringbuf_sz+0x2a>
; 		if (mul * page_sz > sz)
    67a0: 49 89 cc                     	movq	%rcx, %r12
; }
    67a3: 4c 89 e0                     	movq	%r12, %rax
    67a6: 41 5c                        	popq	%r12
    67a8: c3                           	retq
    67a9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

00000000000067b0 <append_to_file>:
; {
    67b0: 41 54                        	pushq	%r12
    67b2: 49 89 f4                     	movq	%rsi, %r12
    67b5: 55                           	pushq	%rbp
    67b6: 48 81 ec d8 00 00 00         	subq	$216, %rsp
    67bd: 48 89 54 24 30               	movq	%rdx, 48(%rsp)
    67c2: 48 89 4c 24 38               	movq	%rcx, 56(%rsp)
    67c7: 4c 89 44 24 40               	movq	%r8, 64(%rsp)
    67cc: 4c 89 4c 24 48               	movq	%r9, 72(%rsp)
    67d1: 84 c0                        	testb	%al, %al
    67d3: 74 37                        	je	0x680c <append_to_file+0x5c>
    67d5: 0f 29 44 24 50               	movaps	%xmm0, 80(%rsp)
    67da: 0f 29 4c 24 60               	movaps	%xmm1, 96(%rsp)
    67df: 0f 29 54 24 70               	movaps	%xmm2, 112(%rsp)
    67e4: 0f 29 9c 24 80 00 00 00      	movaps	%xmm3, 128(%rsp)
    67ec: 0f 29 a4 24 90 00 00 00      	movaps	%xmm4, 144(%rsp)
    67f4: 0f 29 ac 24 a0 00 00 00      	movaps	%xmm5, 160(%rsp)
    67fc: 0f 29 b4 24 b0 00 00 00      	movaps	%xmm6, 176(%rsp)
    6804: 0f 29 bc 24 c0 00 00 00      	movaps	%xmm7, 192(%rsp)
    680c: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6815: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    681a: 31 c0                        	xorl	%eax, %eax
;       return __open_alias (__path, __oflag, __va_arg_pack ());
    681c: 31 d2                        	xorl	%edx, %edx
    681e: be 01 04 08 00               	movl	$525313, %esi           # imm = 0x80401
    6823: e8 38 f3 ff ff               	callq	0x5b60 <.plt.sec+0x4f0>
    6828: 89 c5                        	movl	%eax, %ebp
; 	if (fd < 0)
    682a: 85 c0                        	testl	%eax, %eax
    682c: 78 7a                        	js	0x68a8 <append_to_file+0xf8>
; 	va_start(ap, fmt);
    682e: 48 8d 84 24 f0 00 00 00      	leaq	240(%rsp), %rax
;   return __vdprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    6836: 4c 89 e2                     	movq	%r12, %rdx
    6839: 48 89 e1                     	movq	%rsp, %rcx
    683c: 89 ef                        	movl	%ebp, %edi
; 	va_start(ap, fmt);
    683e: 48 89 44 24 08               	movq	%rax, 8(%rsp)
;   return __vdprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    6843: be 01 00 00 00               	movl	$1, %esi
; 	va_start(ap, fmt);
    6848: 48 8d 44 24 20               	leaq	32(%rsp), %rax
; 	int fd, n, err = 0;
    684d: 45 31 e4                     	xorl	%r12d, %r12d
; 	va_start(ap, fmt);
    6850: c7 04 24 10 00 00 00         	movl	$16, (%rsp)
    6857: c7 44 24 04 30 00 00 00      	movl	$48, 4(%rsp)
    685f: 48 89 44 24 10               	movq	%rax, 16(%rsp)
;   return __vdprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    6864: e8 37 f1 ff ff               	callq	0x59a0 <.plt.sec+0x330>
; 	if (n < 0)
    6869: 85 c0                        	testl	%eax, %eax
    686b: 78 2b                        	js	0x6898 <append_to_file+0xe8>
; 	close(fd);
    686d: 89 ef                        	movl	%ebp, %edi
    686f: e8 8c f0 ff ff               	callq	0x5900 <.plt.sec+0x290>
; }
    6874: 48 8b 44 24 18               	movq	24(%rsp), %rax
    6879: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    6882: 75 31                        	jne	0x68b5 <append_to_file+0x105>
    6884: 48 81 c4 d8 00 00 00         	addq	$216, %rsp
    688b: 44 89 e0                     	movl	%r12d, %eax
    688e: 5d                           	popq	%rbp
    688f: 41 5c                        	popq	%r12
    6891: c3                           	retq
    6892: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		err = -errno;
    6898: e8 53 ee ff ff               	callq	0x56f0 <.plt.sec+0x80>
    689d: 44 8b 20                     	movl	(%rax), %r12d
    68a0: 41 f7 dc                     	negl	%r12d
    68a3: eb c8                        	jmp	0x686d <append_to_file+0xbd>
    68a5: 0f 1f 00                     	nopl	(%rax)
; 		return -errno;
    68a8: e8 43 ee ff ff               	callq	0x56f0 <.plt.sec+0x80>
    68ad: 44 8b 20                     	movl	(%rax), %r12d
    68b0: 41 f7 dc                     	negl	%r12d
    68b3: eb bf                        	jmp	0x6874 <append_to_file+0xc4>
; }
    68b5: e8 46 ef ff ff               	callq	0x5800 <.plt.sec+0x190>
    68ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

00000000000068c0 <probe_kern_btf_enum64>:
; {
    68c0: f3 0f 1e fa                  	endbr64
    68c4: 53                           	pushq	%rbx
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    68c5: b9 08 00 00 00               	movl	$8, %ecx
    68ca: be 0c 00 00 00               	movl	$12, %esi
    68cf: 48 8d 15 ba c5 02 00         	leaq	181690(%rip), %rdx      # 0x32e90 <strs.2>
; {
    68d6: 48 83 ec 20                  	subq	$32, %rsp
; 	__u32 types[] = {
    68da: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    68e3: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    68e8: 48 b8 01 00 00 00 00 00 00 13	movabsq	$1369094286720630785, %rax # imm = 0x1300000000000001
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    68f2: 48 8d 7c 24 0c               	leaq	12(%rsp), %rdi
; 	__u32 types[] = {
    68f7: c7 44 24 14 08 00 00 00      	movl	$8, 20(%rsp)
    68ff: 48 89 44 24 0c               	movq	%rax, 12(%rsp)
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6904: e8 57 74 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    6909: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    690b: 85 c0                        	testl	%eax, %eax
    690d: 78 07                        	js	0x6916 <probe_kern_btf_enum64+0x56>
; 		close(fd);
    690f: 89 c7                        	movl	%eax, %edi
    6911: e8 ea ef ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6916: f7 d3                        	notl	%ebx
    6918: 89 d8                        	movl	%ebx, %eax
    691a: c1 e8 1f                     	shrl	$31, %eax
; }
    691d: 48 8b 54 24 18               	movq	24(%rsp), %rdx
    6922: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    692b: 75 06                        	jne	0x6933 <probe_kern_btf_enum64+0x73>
    692d: 48 83 c4 20                  	addq	$32, %rsp
    6931: 5b                           	popq	%rbx
    6932: c3                           	retq
    6933: e8 c8 ee ff ff               	callq	0x5800 <.plt.sec+0x190>
    6938: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000006940 <probe_kern_btf_type_tag>:
; {
    6940: f3 0f 1e fa                  	endbr64
    6944: 53                           	pushq	%rbx
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6945: b9 05 00 00 00               	movl	$5, %ecx
    694a: be 28 00 00 00               	movl	$40, %esi
    694f: 48 8d 15 2f c5 02 00         	leaq	181551(%rip), %rdx      # 0x32e85 <strs.3>
; {
    6956: 48 83 ec 30                  	subq	$48, %rsp
; 	__u32 types[] = {
    695a: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6963: 48 89 44 24 28               	movq	%rax, 40(%rsp)
    6968: 48 b8 00 00 00 00 00 00 00 01	movabsq	$72057594037927936, %rax # imm = 0x100000000000000
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6972: 48 89 e7                     	movq	%rsp, %rdi
; 	__u32 types[] = {
    6975: 48 c7 44 24 18 01 00 00 00   	movq	$1, 24(%rsp)
    697e: 48 89 04 24                  	movq	%rax, (%rsp)
    6982: 48 b8 04 00 00 00 20 00 00 01	movabsq	$72057731476881412, %rax # imm = 0x100002000000004
    698c: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    6991: 48 b8 01 00 00 00 00 00 00 12	movabsq	$1297036692682702849, %rax # imm = 0x1200000000000001
    699b: 48 89 44 24 10               	movq	%rax, 16(%rsp)
    69a0: 48 b8 00 00 00 02 02 00 00 00	movabsq	$8623489024, %rax       # imm = 0x202000000
    69aa: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    69af: e8 ac 73 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    69b4: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    69b6: 85 c0                        	testl	%eax, %eax
    69b8: 78 07                        	js	0x69c1 <probe_kern_btf_type_tag+0x81>
; 		close(fd);
    69ba: 89 c7                        	movl	%eax, %edi
    69bc: e8 3f ef ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    69c1: f7 d3                        	notl	%ebx
    69c3: 89 d8                        	movl	%ebx, %eax
    69c5: c1 e8 1f                     	shrl	$31, %eax
; }
    69c8: 48 8b 54 24 28               	movq	40(%rsp), %rdx
    69cd: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    69d6: 75 06                        	jne	0x69de <probe_kern_btf_type_tag+0x9e>
    69d8: 48 83 c4 30                  	addq	$48, %rsp
    69dc: 5b                           	popq	%rbx
    69dd: c3                           	retq
    69de: e8 1d ee ff ff               	callq	0x5800 <.plt.sec+0x190>
    69e3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    69ee: 66 90                        	nop

00000000000069f0 <probe_kern_btf_decl_tag>:
; {
    69f0: f3 0f 1e fa                  	endbr64
    69f4: 53                           	pushq	%rbx
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    69f5: b9 05 00 00 00               	movl	$5, %ecx
    69fa: be 30 00 00 00               	movl	$48, %esi
    69ff: 48 8d 15 7a c4 02 00         	leaq	181370(%rip), %rdx      # 0x32e80 <strs.4>
; {
    6a06: 48 83 ec 40                  	subq	$64, %rsp
; 	__u32 types[] = {
    6a0a: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6a13: 48 89 44 24 38               	movq	%rax, 56(%rsp)
    6a18: 48 b8 00 00 00 00 00 00 00 01	movabsq	$72057594037927936, %rax # imm = 0x100000000000000
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6a22: 48 89 e7                     	movq	%rsp, %rdi
; 	__u32 types[] = {
    6a25: 48 c7 44 24 18 01 00 00 00   	movq	$1, 24(%rsp)
    6a2e: 48 89 04 24                  	movq	%rax, (%rsp)
    6a32: 48 b8 04 00 00 00 20 00 00 01	movabsq	$72057731476881412, %rax # imm = 0x100002000000004
    6a3c: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    6a41: 48 b8 01 00 00 00 00 00 00 0e	movabsq	$1008806316530991105, %rax # imm = 0xE00000000000001
    6a4b: 48 89 44 24 10               	movq	%rax, 16(%rsp)
    6a50: 48 b8 01 00 00 00 00 00 00 11	movabsq	$1224979098644774913, %rax # imm = 0x1100000000000001
    6a5a: 48 89 44 24 20               	movq	%rax, 32(%rsp)
    6a5f: 48 b8 02 00 00 00 ff ff ff ff	movabsq	$-4294967294, %rax      # imm = 0xFFFFFFFF00000002
    6a69: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6a6e: e8 ed 72 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    6a73: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    6a75: 85 c0                        	testl	%eax, %eax
    6a77: 78 07                        	js	0x6a80 <probe_kern_btf_decl_tag+0x90>
; 		close(fd);
    6a79: 89 c7                        	movl	%eax, %edi
    6a7b: e8 80 ee ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6a80: f7 d3                        	notl	%ebx
    6a82: 89 d8                        	movl	%ebx, %eax
    6a84: c1 e8 1f                     	shrl	$31, %eax
; }
    6a87: 48 8b 54 24 38               	movq	56(%rsp), %rdx
    6a8c: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6a95: 75 06                        	jne	0x6a9d <probe_kern_btf_decl_tag+0xad>
    6a97: 48 83 c4 40                  	addq	$64, %rsp
    6a9b: 5b                           	popq	%rbx
    6a9c: c3                           	retq
    6a9d: e8 5e ed ff ff               	callq	0x5800 <.plt.sec+0x190>
    6aa2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    6aad: 0f 1f 00                     	nopl	(%rax)

0000000000006ab0 <probe_kern_btf_float>:
; {
    6ab0: f3 0f 1e fa                  	endbr64
    6ab4: 53                           	pushq	%rbx
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6ab5: b9 07 00 00 00               	movl	$7, %ecx
    6aba: be 0c 00 00 00               	movl	$12, %esi
    6abf: 48 8d 15 b3 c3 02 00         	leaq	181171(%rip), %rdx      # 0x32e79 <strs.5>
; {
    6ac6: 48 83 ec 20                  	subq	$32, %rsp
; 	__u32 types[] = {
    6aca: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6ad3: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    6ad8: 48 b8 01 00 00 00 00 00 00 10	movabsq	$1152921504606846977, %rax # imm = 0x1000000000000001
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6ae2: 48 8d 7c 24 0c               	leaq	12(%rsp), %rdi
; 	__u32 types[] = {
    6ae7: c7 44 24 14 04 00 00 00      	movl	$4, 20(%rsp)
    6aef: 48 89 44 24 0c               	movq	%rax, 12(%rsp)
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6af4: e8 67 72 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    6af9: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    6afb: 85 c0                        	testl	%eax, %eax
    6afd: 78 07                        	js	0x6b06 <probe_kern_btf_float+0x56>
; 		close(fd);
    6aff: 89 c7                        	movl	%eax, %edi
    6b01: e8 fa ed ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6b06: f7 d3                        	notl	%ebx
    6b08: 89 d8                        	movl	%ebx, %eax
    6b0a: c1 e8 1f                     	shrl	$31, %eax
; }
    6b0d: 48 8b 54 24 18               	movq	24(%rsp), %rdx
    6b12: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6b1b: 75 06                        	jne	0x6b23 <probe_kern_btf_float+0x73>
    6b1d: 48 83 c4 20                  	addq	$32, %rsp
    6b21: 5b                           	popq	%rbx
    6b22: c3                           	retq
    6b23: e8 d8 ec ff ff               	callq	0x5800 <.plt.sec+0x190>
    6b28: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000006b30 <probe_kern_btf_func_global>:
; {
    6b30: f3 0f 1e fa                  	endbr64
    6b34: 53                           	pushq	%rbx
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6b35: b9 09 00 00 00               	movl	$9, %ecx
    6b3a: be 30 00 00 00               	movl	$48, %esi
    6b3f: 48 8d 15 0a c3 02 00         	leaq	181002(%rip), %rdx      # 0x32e50 <strs.8>
; {
    6b46: 48 83 ec 40                  	subq	$64, %rsp
; 	__u32 types[] = {
    6b4a: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6b53: 48 89 44 24 38               	movq	%rax, 56(%rsp)
    6b58: 48 b8 01 00 00 00 00 00 00 01	movabsq	$72057594037927937, %rax # imm = 0x100000000000001
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6b62: 48 89 e7                     	movq	%rsp, %rdi
; 	__u32 types[] = {
    6b65: 48 89 04 24                  	movq	%rax, (%rsp)
    6b69: 48 b8 04 00 00 00 20 00 00 01	movabsq	$72057731476881412, %rax # imm = 0x100002000000004
    6b73: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    6b78: 48 b8 00 00 00 00 01 00 00 0d	movabsq	$936748726788030464, %rax # imm = 0xD00000100000000
    6b82: 48 89 44 24 10               	movq	%rax, 16(%rsp)
    6b87: 48 b8 00 00 00 00 07 00 00 00	movabsq	$30064771072, %rax      # imm = 0x700000000
    6b91: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    6b96: 48 b8 01 00 00 00 05 00 00 00	movabsq	$21474836481, %rax      # imm = 0x500000001
    6ba0: 48 89 44 24 20               	movq	%rax, 32(%rsp)
    6ba5: 48 b8 01 00 00 0c 02 00 00 00	movabsq	$8791261185, %rax       # imm = 0x20C000001
    6baf: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6bb4: e8 a7 71 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    6bb9: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    6bbb: 85 c0                        	testl	%eax, %eax
    6bbd: 78 07                        	js	0x6bc6 <probe_kern_btf_func_global+0x96>
; 		close(fd);
    6bbf: 89 c7                        	movl	%eax, %edi
    6bc1: e8 3a ed ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6bc6: f7 d3                        	notl	%ebx
    6bc8: 89 d8                        	movl	%ebx, %eax
    6bca: c1 e8 1f                     	shrl	$31, %eax
; }
    6bcd: 48 8b 54 24 38               	movq	56(%rsp), %rdx
    6bd2: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6bdb: 75 06                        	jne	0x6be3 <probe_kern_btf_func_global+0xb3>
    6bdd: 48 83 c4 40                  	addq	$64, %rsp
    6be1: 5b                           	popq	%rbx
    6be2: c3                           	retq
    6be3: e8 18 ec ff ff               	callq	0x5800 <.plt.sec+0x190>
    6be8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000006bf0 <probe_kern_btf_datasec>:
; {
    6bf0: f3 0f 1e fa                  	endbr64
    6bf4: 53                           	pushq	%rbx
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6bf5: b9 09 00 00 00               	movl	$9, %ecx
    6bfa: be 38 00 00 00               	movl	$56, %esi
    6bff: 48 8d 15 3a c2 02 00         	leaq	180794(%rip), %rdx      # 0x32e40 <strs.9>
; {
    6c06: 48 83 ec 40                  	subq	$64, %rsp
; 	__u32 types[] = {
    6c0a: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6c13: 48 89 44 24 38               	movq	%rax, 56(%rsp)
    6c18: 48 b8 00 00 00 00 00 00 00 01	movabsq	$72057594037927936, %rax # imm = 0x100000000000000
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6c22: 48 89 e7                     	movq	%rsp, %rdi
; 	__u32 types[] = {
    6c25: 48 c7 44 24 18 01 00 00 00   	movq	$1, 24(%rsp)
    6c2e: 48 89 04 24                  	movq	%rax, (%rsp)
    6c32: 48 b8 04 00 00 00 20 00 00 01	movabsq	$72057731476881412, %rax # imm = 0x100002000000004
    6c3c: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    6c41: 48 b8 01 00 00 00 00 00 00 0e	movabsq	$1008806316530991105, %rax # imm = 0xE00000000000001
    6c4b: 48 89 44 24 10               	movq	%rax, 16(%rsp)
    6c50: 48 b8 03 00 00 00 01 00 00 0f	movabsq	$1080863914863886339, %rax # imm = 0xF00000100000003
    6c5a: 48 89 44 24 20               	movq	%rax, 32(%rsp)
    6c5f: 48 b8 04 00 00 00 02 00 00 00	movabsq	$8589934596, %rax       # imm = 0x200000004
    6c69: 48 89 44 24 28               	movq	%rax, 40(%rsp)
    6c6e: 48 b8 00 00 00 00 04 00 00 00	movabsq	$17179869184, %rax      # imm = 0x400000000
    6c78: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6c7d: e8 de 70 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    6c82: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    6c84: 85 c0                        	testl	%eax, %eax
    6c86: 78 07                        	js	0x6c8f <probe_kern_btf_datasec+0x9f>
; 		close(fd);
    6c88: 89 c7                        	movl	%eax, %edi
    6c8a: e8 71 ec ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6c8f: f7 d3                        	notl	%ebx
    6c91: 89 d8                        	movl	%ebx, %eax
    6c93: c1 e8 1f                     	shrl	$31, %eax
; }
    6c96: 48 8b 54 24 38               	movq	56(%rsp), %rdx
    6c9b: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6ca4: 75 06                        	jne	0x6cac <probe_kern_btf_datasec+0xbc>
    6ca6: 48 83 c4 40                  	addq	$64, %rsp
    6caa: 5b                           	popq	%rbx
    6cab: c3                           	retq
    6cac: e8 4f eb ff ff               	callq	0x5800 <.plt.sec+0x190>
    6cb1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    6cbc: 0f 1f 40 00                  	nopl	(%rax)

0000000000006cc0 <probe_kern_btf_func>:
; {
    6cc0: f3 0f 1e fa                  	endbr64
    6cc4: 53                           	pushq	%rbx
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6cc5: b9 09 00 00 00               	movl	$9, %ecx
    6cca: be 30 00 00 00               	movl	$48, %esi
    6ccf: 48 8d 15 5a c1 02 00         	leaq	180570(%rip), %rdx      # 0x32e30 <strs.10>
; {
    6cd6: 48 83 ec 40                  	subq	$64, %rsp
; 	__u32 types[] = {
    6cda: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6ce3: 48 89 44 24 38               	movq	%rax, 56(%rsp)
    6ce8: 48 b8 01 00 00 00 00 00 00 01	movabsq	$72057594037927937, %rax # imm = 0x100000000000001
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6cf2: 48 89 e7                     	movq	%rsp, %rdi
; 	__u32 types[] = {
    6cf5: 48 89 04 24                  	movq	%rax, (%rsp)
    6cf9: 48 b8 04 00 00 00 20 00 00 01	movabsq	$72057731476881412, %rax # imm = 0x100002000000004
    6d03: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    6d08: 48 b8 00 00 00 00 01 00 00 0d	movabsq	$936748726788030464, %rax # imm = 0xD00000100000000
    6d12: 48 89 44 24 10               	movq	%rax, 16(%rsp)
    6d17: 48 b8 00 00 00 00 07 00 00 00	movabsq	$30064771072, %rax      # imm = 0x700000000
    6d21: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    6d26: 48 b8 01 00 00 00 05 00 00 00	movabsq	$21474836481, %rax      # imm = 0x500000001
    6d30: 48 89 44 24 20               	movq	%rax, 32(%rsp)
    6d35: 48 b8 00 00 00 0c 02 00 00 00	movabsq	$8791261184, %rax       # imm = 0x20C000000
    6d3f: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6d44: e8 17 70 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    6d49: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    6d4b: 85 c0                        	testl	%eax, %eax
    6d4d: 78 07                        	js	0x6d56 <probe_kern_btf_func+0x96>
; 		close(fd);
    6d4f: 89 c7                        	movl	%eax, %edi
    6d51: e8 aa eb ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6d56: f7 d3                        	notl	%ebx
    6d58: 89 d8                        	movl	%ebx, %eax
    6d5a: c1 e8 1f                     	shrl	$31, %eax
; }
    6d5d: 48 8b 54 24 38               	movq	56(%rsp), %rdx
    6d62: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6d6b: 75 06                        	jne	0x6d73 <probe_kern_btf_func+0xb3>
    6d6d: 48 83 c4 40                  	addq	$64, %rsp
    6d71: 5b                           	popq	%rbx
    6d72: c3                           	retq
    6d73: e8 88 ea ff ff               	callq	0x5800 <.plt.sec+0x190>
    6d78: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000006d80 <probe_kern_btf>:
; {
    6d80: f3 0f 1e fa                  	endbr64
    6d84: 53                           	pushq	%rbx
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6d85: b9 05 00 00 00               	movl	$5, %ecx
    6d8a: be 10 00 00 00               	movl	$16, %esi
    6d8f: 48 8d 15 91 c0 02 00         	leaq	180369(%rip), %rdx      # 0x32e27 <strs.11>
; {
    6d96: 48 83 ec 20                  	subq	$32, %rsp
; 	__u32 types[] = {
    6d9a: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6da3: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    6da8: 48 b8 01 00 00 00 00 00 00 01	movabsq	$72057594037927937, %rax # imm = 0x100000000000001
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6db2: 48 89 e7                     	movq	%rsp, %rdi
; 	__u32 types[] = {
    6db5: 48 89 04 24                  	movq	%rax, (%rsp)
    6db9: 48 b8 04 00 00 00 20 00 00 01	movabsq	$72057731476881412, %rax # imm = 0x100002000000004
    6dc3: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	return probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),
    6dc8: e8 93 6f 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    6dcd: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    6dcf: 85 c0                        	testl	%eax, %eax
    6dd1: 78 07                        	js	0x6dda <probe_kern_btf+0x5a>
; 		close(fd);
    6dd3: 89 c7                        	movl	%eax, %edi
    6dd5: e8 26 eb ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6dda: f7 d3                        	notl	%ebx
    6ddc: 89 d8                        	movl	%ebx, %eax
    6dde: c1 e8 1f                     	shrl	$31, %eax
; }
    6de1: 48 8b 54 24 18               	movq	24(%rsp), %rdx
    6de6: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6def: 75 06                        	jne	0x6df7 <probe_kern_btf+0x77>
    6df1: 48 83 c4 20                  	addq	$32, %rsp
    6df5: 5b                           	popq	%rbx
    6df6: c3                           	retq
    6df7: e8 04 ea ff ff               	callq	0x5800 <.plt.sec+0x190>
    6dfc: 0f 1f 40 00                  	nopl	(%rax)

0000000000006e00 <probe_kern_bpf_cookie>:
; {
    6e00: f3 0f 1e fa                  	endbr64
    6e04: 53                           	pushq	%rbx
; 	ret = bpf_prog_load(BPF_PROG_TYPE_KPROBE, NULL, "GPL", insns, insn_cnt, NULL);
    6e05: 45 31 c9                     	xorl	%r9d, %r9d
    6e08: 41 b8 02 00 00 00            	movl	$2, %r8d
    6e0e: 31 f6                        	xorl	%esi, %esi
    6e10: 48 8d 15 23 ae 02 00         	leaq	175651(%rip), %rdx      # 0x31c3a <_IO_stdin_used+0x1c3a>
    6e17: bf 02 00 00 00               	movl	$2, %edi
; {
    6e1c: 48 83 ec 20                  	subq	$32, %rsp
; 	struct bpf_insn insns[] = {
    6e20: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6e29: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    6e2e: 48 b8 85 00 00 00 ae 00 00 00	movabsq	$747324309637, %rax     # imm = 0xAE00000085
; 	ret = bpf_prog_load(BPF_PROG_TYPE_KPROBE, NULL, "GPL", insns, insn_cnt, NULL);
    6e38: 48 89 e1                     	movq	%rsp, %rcx
; 	struct bpf_insn insns[] = {
    6e3b: 48 c7 44 24 08 95 00 00 00   	movq	$149, 8(%rsp)
    6e44: 48 89 04 24                  	movq	%rax, (%rsp)
; 	ret = bpf_prog_load(BPF_PROG_TYPE_KPROBE, NULL, "GPL", insns, insn_cnt, NULL);
    6e48: e8 03 ee 01 00               	callq	0x25c50 <bpf_prog_load>
    6e4d: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    6e4f: 85 c0                        	testl	%eax, %eax
    6e51: 78 07                        	js	0x6e5a <probe_kern_bpf_cookie+0x5a>
; 		close(fd);
    6e53: 89 c7                        	movl	%eax, %edi
    6e55: e8 a6 ea ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6e5a: f7 d3                        	notl	%ebx
    6e5c: 89 d8                        	movl	%ebx, %eax
    6e5e: c1 e8 1f                     	shrl	$31, %eax
; }
    6e61: 48 8b 54 24 18               	movq	24(%rsp), %rdx
    6e66: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6e6f: 75 06                        	jne	0x6e77 <probe_kern_bpf_cookie+0x77>
    6e71: 48 83 c4 20                  	addq	$32, %rsp
    6e75: 5b                           	popq	%rbx
    6e76: c3                           	retq
    6e77: e8 84 e9 ff ff               	callq	0x5800 <.plt.sec+0x190>
    6e7c: 0f 1f 40 00                  	nopl	(%rax)

0000000000006e80 <probe_kern_probe_read_kernel>:
; {
    6e80: f3 0f 1e fa                  	endbr64
    6e84: 53                           	pushq	%rbx
; 	fd = bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL", insns, insn_cnt, NULL);
    6e85: 45 31 c9                     	xorl	%r9d, %r9d
    6e88: 41 b8 06 00 00 00            	movl	$6, %r8d
    6e8e: 31 f6                        	xorl	%esi, %esi
    6e90: 48 8d 15 a3 ad 02 00         	leaq	175523(%rip), %rdx      # 0x31c3a <_IO_stdin_used+0x1c3a>
    6e97: bf 05 00 00 00               	movl	$5, %edi
; {
    6e9c: 48 83 ec 40                  	subq	$64, %rsp
    6ea0: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6ea9: 48 89 44 24 38               	movq	%rax, 56(%rsp)
    6eae: 31 c0                        	xorl	%eax, %eax
; 	fd = bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL", insns, insn_cnt, NULL);
    6eb0: 48 89 e1                     	movq	%rsp, %rcx
; 	struct bpf_insn insns[] = {
    6eb3: 48 c7 04 24 bf a1 00 00      	movq	$41407, (%rsp)          # imm = 0xA1BF
    6ebb: 48 b8 07 01 00 00 f8 ff ff ff	movabsq	$-34359738105, %rax     # imm = 0xFFFFFFF800000107
    6ec5: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    6eca: 48 b8 b7 02 00 00 08 00 00 00	movabsq	$34359739063, %rax      # imm = 0x8000002B7
    6ed4: 48 89 44 24 10               	movq	%rax, 16(%rsp)
    6ed9: 48 b8 85 00 00 00 71 00 00 00	movabsq	$485331304581, %rax     # imm = 0x7100000085
    6ee3: 48 c7 44 24 18 b7 03 00 00   	movq	$951, 24(%rsp)          # imm = 0x3B7
    6eec: 48 89 44 24 20               	movq	%rax, 32(%rsp)
    6ef1: 48 c7 44 24 28 95 00 00 00   	movq	$149, 40(%rsp)
; 	fd = bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL", insns, insn_cnt, NULL);
    6efa: e8 51 ed 01 00               	callq	0x25c50 <bpf_prog_load>
    6eff: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    6f01: 85 c0                        	testl	%eax, %eax
    6f03: 78 07                        	js	0x6f0c <probe_kern_probe_read_kernel+0x8c>
; 		close(fd);
    6f05: 89 c7                        	movl	%eax, %edi
    6f07: e8 f4 e9 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    6f0c: f7 d3                        	notl	%ebx
    6f0e: 89 d8                        	movl	%ebx, %eax
    6f10: c1 e8 1f                     	shrl	$31, %eax
; }
    6f13: 48 8b 54 24 38               	movq	56(%rsp), %rdx
    6f18: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6f21: 75 06                        	jne	0x6f29 <probe_kern_probe_read_kernel+0xa9>
    6f23: 48 83 c4 40                  	addq	$64, %rsp
    6f27: 5b                           	popq	%rbx
    6f28: c3                           	retq
    6f29: e8 d2 e8 ff ff               	callq	0x5800 <.plt.sec+0x190>
    6f2e: 66 90                        	nop

0000000000006f30 <probe_perf_link>:
; {
    6f30: f3 0f 1e fa                  	endbr64
    6f34: 41 54                        	pushq	%r12
; 	prog_fd = bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL",
    6f36: 45 31 c9                     	xorl	%r9d, %r9d
    6f39: 41 b8 02 00 00 00            	movl	$2, %r8d
    6f3f: 31 f6                        	xorl	%esi, %esi
; {
    6f41: 55                           	pushq	%rbp
; 	prog_fd = bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL",
    6f42: 48 8d 15 f1 ac 02 00         	leaq	175345(%rip), %rdx      # 0x31c3a <_IO_stdin_used+0x1c3a>
    6f49: bf 05 00 00 00               	movl	$5, %edi
; {
    6f4e: 53                           	pushq	%rbx
    6f4f: 48 83 ec 20                  	subq	$32, %rsp
    6f53: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    6f5c: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    6f61: 31 c0                        	xorl	%eax, %eax
; 	prog_fd = bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL",
    6f63: 48 89 e1                     	movq	%rsp, %rcx
; 	struct bpf_insn insns[] = {
    6f66: 48 c7 04 24 b7 00 00 00      	movq	$183, (%rsp)
    6f6e: 48 c7 44 24 08 95 00 00 00   	movq	$149, 8(%rsp)
; 	prog_fd = bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL",
    6f77: e8 d4 ec 01 00               	callq	0x25c50 <bpf_prog_load>
    6f7c: 89 c5                        	movl	%eax, %ebp
; 		return -errno;
    6f7e: e8 6d e7 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    6f83: 49 89 c4                     	movq	%rax, %r12
; 	if (prog_fd < 0)
    6f86: 85 ed                        	testl	%ebp, %ebp
    6f88: 78 5e                        	js	0x6fe8 <probe_perf_link+0xb8>
; 	link_fd = bpf_link_create(prog_fd, -1, BPF_PERF_EVENT, NULL);
    6f8a: 31 c9                        	xorl	%ecx, %ecx
    6f8c: ba 29 00 00 00               	movl	$41, %edx
    6f91: be ff ff ff ff               	movl	$4294967295, %esi       # imm = 0xFFFFFFFF
    6f96: 89 ef                        	movl	%ebp, %edi
    6f98: e8 b3 0d 02 00               	callq	0x27d50 <bpf_link_create>
; 	err = -errno; /* close() can clobber errno */
    6f9d: 45 8b 24 24                  	movl	(%r12), %r12d
; 	link_fd = bpf_link_create(prog_fd, -1, BPF_PERF_EVENT, NULL);
    6fa1: 89 c3                        	movl	%eax, %ebx
; 	if (link_fd >= 0)
    6fa3: 85 c0                        	testl	%eax, %eax
    6fa5: 79 31                        	jns	0x6fd8 <probe_perf_link+0xa8>
; 	close(prog_fd);
    6fa7: 89 ef                        	movl	%ebp, %edi
    6fa9: e8 52 e9 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return link_fd < 0 && err == -EBADF;
    6fae: 89 d8                        	movl	%ebx, %eax
    6fb0: c1 e8 1f                     	shrl	$31, %eax
    6fb3: 41 83 fc 09                  	cmpl	$9, %r12d
    6fb7: 0f 94 c2                     	sete	%dl
    6fba: 21 d0                        	andl	%edx, %eax
; }
    6fbc: 48 8b 54 24 18               	movq	24(%rsp), %rdx
    6fc1: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    6fca: 75 22                        	jne	0x6fee <probe_perf_link+0xbe>
    6fcc: 48 83 c4 20                  	addq	$32, %rsp
    6fd0: 5b                           	popq	%rbx
    6fd1: 5d                           	popq	%rbp
    6fd2: 41 5c                        	popq	%r12
    6fd4: c3                           	retq
    6fd5: 0f 1f 00                     	nopl	(%rax)
; 		close(link_fd);
    6fd8: 89 c7                        	movl	%eax, %edi
    6fda: e8 21 e9 ff ff               	callq	0x5900 <.plt.sec+0x290>
    6fdf: eb c6                        	jmp	0x6fa7 <probe_perf_link+0x77>
    6fe1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return -errno;
    6fe8: 8b 00                        	movl	(%rax), %eax
    6fea: f7 d8                        	negl	%eax
    6fec: eb ce                        	jmp	0x6fbc <probe_perf_link+0x8c>
; }
    6fee: e8 0d e8 ff ff               	callq	0x5800 <.plt.sec+0x190>
    6ff3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    6ffe: 66 90                        	nop

0000000000007000 <find_int_btf_id>:
; {
    7000: 41 54                        	pushq	%r12
    7002: 55                           	pushq	%rbp
    7003: 53                           	pushq	%rbx
    7004: 48 89 fb                     	movq	%rdi, %rbx
; 	n = btf__type_cnt(btf);
    7007: e8 34 2f 02 00               	callq	0x29f40 <btf__type_cnt>
; 	for (i = 1; i < n; i++) {
    700c: 83 f8 01                     	cmpl	$1, %eax
    700f: 7e 3f                        	jle	0x7050 <find_int_btf_id+0x50>
    7011: 89 c5                        	movl	%eax, %ebp
    7013: 41 bc 01 00 00 00            	movl	$1, %r12d
    7019: eb 0e                        	jmp	0x7029 <find_int_btf_id+0x29>
    701b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    7020: 41 83 c4 01                  	addl	$1, %r12d
    7024: 44 39 e5                     	cmpl	%r12d, %ebp
    7027: 74 27                        	je	0x7050 <find_int_btf_id+0x50>
; 		t = btf__type_by_id(btf, i);
    7029: 44 89 e6                     	movl	%r12d, %esi
    702c: 48 89 df                     	movq	%rbx, %rdi
    702f: e8 6c 2f 02 00               	callq	0x29fa0 <btf__type_by_id>
; 	return BTF_INFO_KIND(t->info);
    7034: 0f b6 50 07                  	movzbl	7(%rax), %edx
    7038: 83 e2 1f                     	andl	$31, %edx
; 		if (btf_is_int(t) && btf_int_bits(t) == 32)
    703b: 66 83 fa 01                  	cmpw	$1, %dx
    703f: 75 df                        	jne	0x7020 <find_int_btf_id+0x20>
    7041: 80 78 0c 20                  	cmpb	$32, 12(%rax)
    7045: 75 d9                        	jne	0x7020 <find_int_btf_id+0x20>
; }
    7047: 44 89 e0                     	movl	%r12d, %eax
    704a: 5b                           	popq	%rbx
    704b: 5d                           	popq	%rbp
    704c: 41 5c                        	popq	%r12
    704e: c3                           	retq
    704f: 90                           	nop
; 	return 0;
    7050: 45 31 e4                     	xorl	%r12d, %r12d
; }
    7053: 5b                           	popq	%rbx
    7054: 5d                           	popq	%rbp
    7055: 44 89 e0                     	movl	%r12d, %eax
    7058: 41 5c                        	popq	%r12
    705a: c3                           	retq
    705b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000007060 <patch_log>:
; {
    7060: 41 57                        	pushq	%r15
    7062: 4d 89 cf                     	movq	%r9, %r15
    7065: 41 56                        	pushq	%r14
    7067: 49 89 f6                     	movq	%rsi, %r14
    706a: 41 55                        	pushq	%r13
    706c: 49 89 fd                     	movq	%rdi, %r13
; 	size_t patch_sz = strlen(patch);
    706f: 4c 89 cf                     	movq	%r9, %rdi
; {
    7072: 41 54                        	pushq	%r12
    7074: 55                           	pushq	%rbp
    7075: 48 89 cd                     	movq	%rcx, %rbp
    7078: 53                           	pushq	%rbx
    7079: 4c 89 c3                     	movq	%r8, %rbx
    707c: 48 83 ec 18                  	subq	$24, %rsp
    7080: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
; 	size_t patch_sz = strlen(patch);
    7085: e8 56 e7 ff ff               	callq	0x57e0 <.plt.sec+0x170>
    708a: 49 89 c4                     	movq	%rax, %r12
; 	if (patch_sz != orig_sz) {
    708d: 48 39 c3                     	cmpq	%rax, %rbx
    7090: 74 21                        	je	0x70b3 <patch_log+0x53>
; 	size_t rem_sz = (buf + log_sz) - (orig + orig_sz);
    7092: 48 8b 44 24 08               	movq	8(%rsp), %rax
    7097: 48 8d 74 1d 00               	leaq	(%rbp,%rbx), %rsi
; 			if (orig + patch_sz >= buf + buf_sz) {
    709c: 4a 8d 7c 25 00               	leaq	(%rbp,%r12), %rdi
; 	size_t rem_sz = (buf + log_sz) - (orig + orig_sz);
    70a1: 49 8d 54 05 00               	leaq	(%r13,%rax), %rdx
    70a6: 48 29 f2                     	subq	%rsi, %rdx
; 		if (patch_sz > orig_sz) {
    70a9: 4c 39 e3                     	cmpq	%r12, %rbx
    70ac: 72 22                        	jb	0x70d0 <patch_log+0x70>
;   return __builtin___memmove_chk (__dest, __src, __len,
    70ae: e8 cd ea ff ff               	callq	0x5b80 <.plt.sec+0x510>
; }
    70b3: 48 83 c4 18                  	addq	$24, %rsp
;   return __builtin___memcpy_chk (__dest, __src, __len,
    70b7: 4c 89 e2                     	movq	%r12, %rdx
    70ba: 4c 89 fe                     	movq	%r15, %rsi
    70bd: 48 89 ef                     	movq	%rbp, %rdi
; }
    70c0: 5b                           	popq	%rbx
    70c1: 5d                           	popq	%rbp
    70c2: 41 5c                        	popq	%r12
    70c4: 41 5d                        	popq	%r13
    70c6: 41 5e                        	popq	%r14
    70c8: 41 5f                        	popq	%r15
;   return __builtin___memcpy_chk (__dest, __src, __len,
    70ca: e9 71 e9 ff ff               	jmp	0x5a40 <.plt.sec+0x3d0>
    70cf: 90                           	nop
; 			if (orig + patch_sz >= buf + buf_sz) {
    70d0: 4d 01 f5                     	addq	%r14, %r13
    70d3: 49 39 fd                     	cmpq	%rdi, %r13
    70d6: 76 20                        	jbe	0x70f8 <patch_log+0x98>
; 			} else if (patch_sz - orig_sz > buf_sz - log_sz) {
    70d8: 4c 89 e0                     	movq	%r12, %rax
    70db: 4c 2b 74 24 08               	subq	8(%rsp), %r14
    70e0: 48 29 d8                     	subq	%rbx, %rax
    70e3: 4c 39 f0                     	cmpq	%r14, %rax
    70e6: 76 c6                        	jbe	0x70ae <patch_log+0x4e>
; 				rem_sz -= (patch_sz - orig_sz) - (buf_sz - log_sz);
    70e8: 49 01 de                     	addq	%rbx, %r14
    70eb: 4c 01 f2                     	addq	%r14, %rdx
    70ee: 4c 29 e2                     	subq	%r12, %rdx
    70f1: eb bb                        	jmp	0x70ae <patch_log+0x4e>
    70f3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 				patch_sz -= (orig + patch_sz) - (buf + buf_sz) + 1;
    70f8: 4c 29 ef                     	subq	%r13, %rdi
    70fb: 49 83 ec 01                  	subq	$1, %r12
; 				rem_sz = 0;
    70ff: 31 d2                        	xorl	%edx, %edx
; 				patch_sz -= (orig + patch_sz) - (buf + buf_sz) + 1;
    7101: 49 29 fc                     	subq	%rdi, %r12
; 		memmove(orig + patch_sz, orig + orig_sz, rem_sz);
    7104: 4a 8d 7c 25 00               	leaq	(%rbp,%r12), %rdi
    7109: eb a3                        	jmp	0x70ae <patch_log+0x4e>
    710b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000007110 <libbpf_get_type_names>:
; {
    7110: 41 57                        	pushq	%r15
    7112: 41 56                        	pushq	%r14
    7114: 41 55                        	pushq	%r13
    7116: 41 54                        	pushq	%r12
    7118: 55                           	pushq	%rbp
    7119: 89 fd                        	movl	%edi, %ebp
; 	buf = malloc(len);
    711b: bf 20 0a 00 00               	movl	$2592, %edi             # imm = 0xA20
; {
    7120: 53                           	pushq	%rbx
    7121: 48 83 ec 08                  	subq	$8, %rsp
; 	buf = malloc(len);
    7125: e8 66 e9 ff ff               	callq	0x5a90 <.plt.sec+0x420>
    712a: 49 89 c4                     	movq	%rax, %r12
; 	if (!buf)
    712d: 48 85 c0                     	testq	%rax, %rax
    7130: 0f 84 a1 00 00 00            	je	0x71d7 <libbpf_get_type_names+0xc7>
; 	buf[0] = '\0';
    7136: c6 00 00                     	movb	$0, (%rax)
; 	for (i = 0; i < ARRAY_SIZE(section_defs); i++) {
    7139: 48 8d 1d c0 e0 03 00         	leaq	254144(%rip), %rbx      # 0x45200 <section_defs>
;   return __builtin___strcat_chk (__dest, __src, __glibc_objsize (__dest));
    7140: 4c 8d 35 35 31 03 00         	leaq	209205(%rip), %r14      # 0x3a27c <CSWTCH.126+0x97c>
    7147: eb 28                        	jmp	0x7171 <libbpf_get_type_names+0x61>
    7149: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			if (sec_def->prog_prepare_load_fn != libbpf_prepare_prog_load)
    7150: 48 8d 05 c9 6b 00 00         	leaq	27593(%rip), %rax       # 0xdd20 <libbpf_prepare_prog_load>
    7157: 48 39 43 28                  	cmpq	%rax, 40(%rbx)
    715b: 0f 84 8f 00 00 00            	je	0x71f0 <libbpf_get_type_names+0xe0>
; 	for (i = 0; i < ARRAY_SIZE(section_defs); i++) {
    7161: 48 83 c3 38                  	addq	$56, %rbx
    7165: 48 8d 05 4c f2 03 00         	leaq	258636(%rip), %rax      # 0x463b8 <section_defs+0x11b8>
    716c: 48 39 c3                     	cmpq	%rax, %rbx
    716f: 74 66                        	je	0x71d7 <libbpf_get_type_names+0xc7>
; 		if (attach_type) {
    7171: 40 84 ed                     	testb	%bpl, %bpl
    7174: 75 da                        	jne	0x7150 <libbpf_get_type_names+0x40>
; 		if (strlen(buf) + strlen(section_defs[i].sec) + 2 > len) {
    7176: 4c 89 e7                     	movq	%r12, %rdi
    7179: e8 62 e6 ff ff               	callq	0x57e0 <.plt.sec+0x170>
    717e: 4c 8b 3b                     	movq	(%rbx), %r15
    7181: 49 89 c5                     	movq	%rax, %r13
    7184: 4c 89 ff                     	movq	%r15, %rdi
    7187: e8 54 e6 ff ff               	callq	0x57e0 <.plt.sec+0x170>
    718c: 49 8d 44 05 02               	leaq	2(%r13,%rax), %rax
    7191: 48 3d 20 0a 00 00            	cmpq	$2592, %rax             # imm = 0xA20
    7197: 77 67                        	ja	0x7200 <libbpf_get_type_names+0xf0>
;   return __builtin___strcat_chk (__dest, __src, __glibc_objsize (__dest));
    7199: b9 20 0a 00 00               	movl	$2592, %ecx             # imm = 0xA20
    719e: 4b 8d 3c 2c                  	leaq	(%r12,%r13), %rdi
    71a2: 4c 89 f6                     	movq	%r14, %rsi
; 	for (i = 0; i < ARRAY_SIZE(section_defs); i++) {
    71a5: 48 83 c3 38                  	addq	$56, %rbx
;   return __builtin___strcat_chk (__dest, __src, __glibc_objsize (__dest));
    71a9: 4c 29 e9                     	subq	%r13, %rcx
    71ac: ba 01 00 00 00               	movl	$1, %edx
    71b1: e8 0a e8 ff ff               	callq	0x59c0 <.plt.sec+0x350>
    71b6: ba 1f 0a 00 00               	movl	$2591, %edx             # imm = 0xA1F
    71bb: 4b 8d 7c 2c 01               	leaq	1(%r12,%r13), %rdi
    71c0: 4c 89 fe                     	movq	%r15, %rsi
    71c3: 4c 29 ea                     	subq	%r13, %rdx
    71c6: e8 65 e9 ff ff               	callq	0x5b30 <.plt.sec+0x4c0>
; 	for (i = 0; i < ARRAY_SIZE(section_defs); i++) {
    71cb: 48 8d 05 e6 f1 03 00         	leaq	258534(%rip), %rax      # 0x463b8 <section_defs+0x11b8>
    71d2: 48 39 c3                     	cmpq	%rax, %rbx
    71d5: 75 9a                        	jne	0x7171 <libbpf_get_type_names+0x61>
; }
    71d7: 48 83 c4 08                  	addq	$8, %rsp
    71db: 4c 89 e0                     	movq	%r12, %rax
    71de: 5b                           	popq	%rbx
    71df: 5d                           	popq	%rbp
    71e0: 41 5c                        	popq	%r12
    71e2: 41 5d                        	popq	%r13
    71e4: 41 5e                        	popq	%r14
    71e6: 41 5f                        	popq	%r15
    71e8: c3                           	retq
    71e9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			if (!(sec_def->cookie & SEC_ATTACHABLE))
    71f0: f6 43 10 02                  	testb	$2, 16(%rbx)
    71f4: 75 80                        	jne	0x7176 <libbpf_get_type_names+0x66>
    71f6: e9 66 ff ff ff               	jmp	0x7161 <libbpf_get_type_names+0x51>
    71fb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			free(buf);
    7200: 4c 89 e7                     	movq	%r12, %rdi
; 			return NULL;
    7203: 45 31 e4                     	xorl	%r12d, %r12d
; 			free(buf);
    7206: e8 b5 e4 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 			return NULL;
    720b: eb ca                        	jmp	0x71d7 <libbpf_get_type_names+0xc7>
    720d: 0f 1f 00                     	nopl	(%rax)

0000000000007210 <__base_pr>:
; {
    7210: f3 0f 1e fa                  	endbr64
    7214: 48 89 d1                     	movq	%rdx, %rcx
; 	if (level == LIBBPF_DEBUG)
    7217: 83 ff 02                     	cmpl	$2, %edi
    721a: 74 14                        	je	0x7230 <__base_pr+0x20>
;   return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    721c: 48 8b 3d dd ff 03 00         	movq	262109(%rip), %rdi      # 0x47200 <stderr@GLIBC_2.2.5>
    7223: 48 89 f2                     	movq	%rsi, %rdx
    7226: be 01 00 00 00               	movl	$1, %esi
    722b: e9 a0 e4 ff ff               	jmp	0x56d0 <.plt.sec+0x60>
; }
    7230: 31 c0                        	xorl	%eax, %eax
    7232: c3                           	retq
    7233: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    723e: 66 90                        	nop

0000000000007240 <cmp_relocs>:
; {
    7240: f3 0f 1e fa                  	endbr64
; 	if (a->insn_idx != b->insn_idx)
    7244: 8b 46 04                     	movl	4(%rsi), %eax
    7247: 39 47 04                     	cmpl	%eax, 4(%rdi)
    724a: 74 14                        	je	0x7260 <cmp_relocs+0x20>
; 		return a->insn_idx < b->insn_idx ? -1 : 1;
    724c: 0f 9d c0                     	setge	%al
    724f: 0f b6 c0                     	movzbl	%al, %eax
    7252: 8d 44 00 ff                  	leal	-1(%rax,%rax), %eax
    7256: c3                           	retq
    7257: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	if (a->type != b->type)
    7260: 8b 16                        	movl	(%rsi), %edx
; 	return 0;
    7262: 31 c0                        	xorl	%eax, %eax
; 	if (a->type != b->type)
    7264: 39 17                        	cmpl	%edx, (%rdi)
    7266: 74 05                        	je	0x726d <cmp_relocs+0x2d>
; 		return a->insn_idx < b->insn_idx ? -1 : 1;
    7268: 19 c0                        	sbbl	%eax, %eax
    726a: 83 c8 01                     	orl	$1, %eax
; }
    726d: c3                           	retq
    726e: 66 90                        	nop

0000000000007270 <libbpf_err.part.0>:
; static inline int libbpf_err(int ret)
    7270: 53                           	pushq	%rbx
    7271: 89 fb                        	movl	%edi, %ebx
; 		errno = -ret;
    7273: f7 db                        	negl	%ebx
    7275: e8 76 e4 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    727a: 89 18                        	movl	%ebx, (%rax)
; }
    727c: 5b                           	popq	%rbx
    727d: c3                           	retq
    727e: 66 90                        	nop

0000000000007280 <probe_module_btf>:
; {
    7280: f3 0f 1e fa                  	endbr64
    7284: 55                           	pushq	%rbp
; 	fd = libbpf__load_raw_btf((char *)types, sizeof(types), strs, sizeof(strs));
    7285: b9 05 00 00 00               	movl	$5, %ecx
    728a: be 10 00 00 00               	movl	$16, %esi
    728f: 48 8d 15 de bb 02 00         	leaq	179166(%rip), %rdx      # 0x32e74 <strs.6>
; {
    7296: 53                           	pushq	%rbx
    7297: 48 83 ec 68                  	subq	$104, %rsp
; 	__u32 types[] = {
    729b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    72a4: 48 89 44 24 58               	movq	%rax, 88(%rsp)
    72a9: 48 b8 01 00 00 00 00 00 00 01	movabsq	$72057594037927937, %rax # imm = 0x100000000000001
; 	fd = libbpf__load_raw_btf((char *)types, sizeof(types), strs, sizeof(strs));
    72b3: 48 8d 7c 24 30               	leaq	48(%rsp), %rdi
; 	__u32 len = sizeof(info);
    72b8: c7 44 24 0c 20 00 00 00      	movl	$32, 12(%rsp)
; 	__u32 types[] = {
    72c0: 48 89 44 24 30               	movq	%rax, 48(%rsp)
    72c5: 48 b8 04 00 00 00 20 00 00 01	movabsq	$72057731476881412, %rax # imm = 0x100002000000004
    72cf: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 	fd = libbpf__load_raw_btf((char *)types, sizeof(types), strs, sizeof(strs));
    72d4: e8 87 6a 01 00               	callq	0x1dd60 <libbpf__load_raw_btf>
    72d9: 89 c5                        	movl	%eax, %ebp
; 	if (fd < 0)
    72db: 31 c0                        	xorl	%eax, %eax
    72dd: 85 ed                        	testl	%ebp, %ebp
    72df: 78 41                        	js	0x7322 <probe_module_btf+0xa2>
;   return __builtin___memset_chk (__dest, __ch, __len,
    72e1: 66 0f ef c0                  	pxor	%xmm0, %xmm0
    72e5: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
; 	return (__u64) (unsigned long) ptr;
    72ea: 48 8d 44 24 40               	leaq	64(%rsp), %rax
; 	err = bpf_obj_get_info_by_fd(fd, &info, &len);
    72ef: 89 ef                        	movl	%ebp, %edi
    72f1: 48 8d 54 24 0c               	leaq	12(%rsp), %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
    72f6: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
    72fb: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
; 	return (__u64) (unsigned long) ptr;
    7300: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	info.name_len = sizeof(name);
    7305: c7 44 24 28 10 00 00 00      	movl	$16, 40(%rsp)
; 	err = bpf_obj_get_info_by_fd(fd, &info, &len);
    730d: e8 ae 08 02 00               	callq	0x27bc0 <bpf_obj_get_info_by_fd>
; 	close(fd);
    7312: 89 ef                        	movl	%ebp, %edi
; 	err = bpf_obj_get_info_by_fd(fd, &info, &len);
    7314: 89 c3                        	movl	%eax, %ebx
; 	close(fd);
    7316: e8 e5 e5 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return !err;
    731b: 31 c0                        	xorl	%eax, %eax
    731d: 85 db                        	testl	%ebx, %ebx
    731f: 0f 94 c0                     	sete	%al
; }
    7322: 48 8b 54 24 58               	movq	88(%rsp), %rdx
    7327: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    7330: 75 07                        	jne	0x7339 <probe_module_btf+0xb9>
    7332: 48 83 c4 68                  	addq	$104, %rsp
    7336: 5b                           	popq	%rbx
    7337: 5d                           	popq	%rbp
    7338: c3                           	retq
    7339: e8 c2 e4 ff ff               	callq	0x5800 <.plt.sec+0x190>
    733e: 66 90                        	nop

0000000000007340 <probe_kern_exp_attach_type>:
; {
    7340: f3 0f 1e fa                  	endbr64
    7344: 53                           	pushq	%rbx
;   return __builtin___memset_chk (__dest, __ch, __len,
    7345: b9 0c 00 00 00               	movl	$12, %ecx
; 	fd = bpf_prog_load(BPF_PROG_TYPE_CGROUP_SOCK, NULL, "GPL", insns, insn_cnt, &opts);
    734a: 41 b8 02 00 00 00            	movl	$2, %r8d
    7350: 31 f6                        	xorl	%esi, %esi
; {
    7352: 48 81 ec 90 00 00 00         	subq	$144, %rsp
    7359: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    7362: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
    736a: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
    736c: 48 8d 54 24 08               	leaq	8(%rsp), %rdx
; 	fd = bpf_prog_load(BPF_PROG_TYPE_CGROUP_SOCK, NULL, "GPL", insns, insn_cnt, &opts);
    7371: 49 89 e1                     	movq	%rsp, %r9
; 	LIBBPF_OPTS(bpf_prog_load_opts, opts, .expected_attach_type = BPF_CGROUP_INET_SOCK_CREATE);
    7374: 48 c7 04 24 68 00 00 00      	movq	$104, (%rsp)
; 	struct bpf_insn insns[] = {
    737c: 48 c7 44 24 70 b7 00 00 00   	movq	$183, 112(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    7385: 48 89 d7                     	movq	%rdx, %rdi
; 	fd = bpf_prog_load(BPF_PROG_TYPE_CGROUP_SOCK, NULL, "GPL", insns, insn_cnt, &opts);
    7388: 48 8d 15 ab a8 02 00         	leaq	174251(%rip), %rdx      # 0x31c3a <_IO_stdin_used+0x1c3a>
; 	struct bpf_insn insns[] = {
    738f: 48 c7 44 24 78 95 00 00 00   	movq	$149, 120(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    7398: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	fd = bpf_prog_load(BPF_PROG_TYPE_CGROUP_SOCK, NULL, "GPL", insns, insn_cnt, &opts);
    739b: 48 8d 4c 24 70               	leaq	112(%rsp), %rcx
    73a0: bf 09 00 00 00               	movl	$9, %edi
; 	LIBBPF_OPTS(bpf_prog_load_opts, opts, .expected_attach_type = BPF_CGROUP_INET_SOCK_CREATE);
    73a5: c7 44 24 0c 02 00 00 00      	movl	$2, 12(%rsp)
; 	fd = bpf_prog_load(BPF_PROG_TYPE_CGROUP_SOCK, NULL, "GPL", insns, insn_cnt, &opts);
    73ad: e8 9e e8 01 00               	callq	0x25c50 <bpf_prog_load>
    73b2: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    73b4: 85 c0                        	testl	%eax, %eax
    73b6: 78 07                        	js	0x73bf <probe_kern_exp_attach_type+0x7f>
; 		close(fd);
    73b8: 89 c7                        	movl	%eax, %edi
    73ba: e8 41 e5 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    73bf: f7 d3                        	notl	%ebx
    73c1: 89 d8                        	movl	%ebx, %eax
    73c3: c1 e8 1f                     	shrl	$31, %eax
; }
    73c6: 48 8b 94 24 88 00 00 00      	movq	136(%rsp), %rdx
    73ce: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    73d7: 75 09                        	jne	0x73e2 <probe_kern_exp_attach_type+0xa2>
    73d9: 48 81 c4 90 00 00 00         	addq	$144, %rsp
    73e0: 5b                           	popq	%rbx
    73e1: c3                           	retq
    73e2: e8 19 e4 ff ff               	callq	0x5800 <.plt.sec+0x190>
    73e7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

00000000000073f0 <probe_kern_array_mmap>:
; {
    73f0: f3 0f 1e fa                  	endbr64
    73f4: 53                           	pushq	%rbx
;   return __builtin___memset_chk (__dest, __ch, __len,
    73f5: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_mmap", sizeof(int), sizeof(int), 1, &opts);
    73f9: 41 b8 01 00 00 00            	movl	$1, %r8d
    73ff: b9 04 00 00 00               	movl	$4, %ecx
    7404: ba 04 00 00 00               	movl	$4, %edx
    7409: 48 8d 35 2e a8 02 00         	leaq	174126(%rip), %rsi      # 0x31c3e <_IO_stdin_used+0x1c3e>
    7410: bf 02 00 00 00               	movl	$2, %edi
; {
    7415: 48 83 ec 40                  	subq	$64, %rsp
    7419: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    7422: 48 89 44 24 38               	movq	%rax, 56(%rsp)
    7427: 31 c0                        	xorl	%eax, %eax
; 	fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_mmap", sizeof(int), sizeof(int), 1, &opts);
    7429: 49 89 e1                     	movq	%rsp, %r9
;   return __builtin___memset_chk (__dest, __ch, __len,
    742c: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
    7431: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	LIBBPF_OPTS(bpf_map_create_opts, opts, .map_flags = BPF_F_MMAPABLE);
    743a: 48 c7 04 24 30 00 00 00      	movq	$48, (%rsp)
    7442: c7 44 24 1c 00 04 00 00      	movl	$1024, 28(%rsp)         # imm = 0x400
;   return __builtin___memset_chk (__dest, __ch, __len,
    744a: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
; 	fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_mmap", sizeof(int), sizeof(int), 1, &opts);
    744f: e8 4c e4 01 00               	callq	0x258a0 <bpf_map_create>
    7454: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    7456: 85 c0                        	testl	%eax, %eax
    7458: 78 07                        	js	0x7461 <probe_kern_array_mmap+0x71>
; 		close(fd);
    745a: 89 c7                        	movl	%eax, %edi
    745c: e8 9f e4 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    7461: f7 d3                        	notl	%ebx
    7463: 89 d8                        	movl	%ebx, %eax
    7465: c1 e8 1f                     	shrl	$31, %eax
; }
    7468: 48 8b 54 24 38               	movq	56(%rsp), %rdx
    746d: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    7476: 75 06                        	jne	0x747e <probe_kern_array_mmap+0x8e>
    7478: 48 83 c4 40                  	addq	$64, %rsp
    747c: 5b                           	popq	%rbx
    747d: c3                           	retq
    747e: e8 7d e3 ff ff               	callq	0x5800 <.plt.sec+0x190>
    7483: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    748e: 66 90                        	nop

0000000000007490 <bpf_object__add_map>:
; 	err = libbpf_ensure_mem((void **)&obj->maps, &obj->maps_cap,
    7490: 48 8b 47 70                  	movq	112(%rdi), %rax
; {
    7494: 53                           	pushq	%rbx
; 	err = libbpf_ensure_mem((void **)&obj->maps, &obj->maps_cap,
    7495: 48 8d 77 78                  	leaq	120(%rdi), %rsi
; {
    7499: 48 89 fb                     	movq	%rdi, %rbx
; 	err = libbpf_ensure_mem((void **)&obj->maps, &obj->maps_cap,
    749c: ba a0 00 00 00               	movl	$160, %edx
    74a1: 48 83 c7 68                  	addq	$104, %rdi
    74a5: 48 8d 48 01                  	leaq	1(%rax), %rcx
    74a9: e8 e2 29 02 00               	callq	0x29e90 <libbpf_ensure_mem>
; 	if (err)
    74ae: 85 c0                        	testl	%eax, %eax
    74b0: 75 36                        	jne	0x74e8 <bpf_object__add_map+0x58>
; 	map = &obj->maps[obj->nr_maps++];
    74b2: 48 8b 43 70                  	movq	112(%rbx), %rax
    74b6: 48 8d 50 01                  	leaq	1(%rax), %rdx
    74ba: 48 8d 04 80                  	leaq	(%rax,%rax,4), %rax
    74be: 48 c1 e0 05                  	shlq	$5, %rax
    74c2: 48 03 43 68                  	addq	104(%rbx), %rax
    74c6: 48 89 53 70                  	movq	%rdx, 112(%rbx)
; 	map->obj = obj;
    74ca: 48 89 18                     	movq	%rbx, (%rax)
; 	map->fd = -1;
    74cd: c7 40 18 ff ff ff ff         	movl	$4294967295, 24(%rax)   # imm = 0xFFFFFFFF
; 	map->inner_map_fd = -1;
    74d4: c7 40 2c ff ff ff ff         	movl	$4294967295, 44(%rax)   # imm = 0xFFFFFFFF
; 	map->autocreate = true;
    74db: c6 80 92 00 00 00 01         	movb	$1, 146(%rax)
; }
    74e2: 5b                           	popq	%rbx
    74e3: c3                           	retq
    74e4: 0f 1f 40 00                  	nopl	(%rax)
; 		return ERR_PTR(err);
    74e8: 48 98                        	cltq
; }
    74ea: 5b                           	popq	%rbx
    74eb: c3                           	retq
    74ec: 0f 1f 40 00                  	nopl	(%rax)

00000000000074f0 <resolve_kprobe_multi_cb>:
; {
    74f0: f3 0f 1e fa                  	endbr64
    74f4: 55                           	pushq	%rbp
    74f5: 48 89 fd                     	movq	%rdi, %rbp
    74f8: 48 89 d7                     	movq	%rdx, %rdi
    74fb: 53                           	pushq	%rbx
    74fc: 48 89 cb                     	movq	%rcx, %rbx
    74ff: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!glob_match(sym_name, res->pattern))
    7503: 48 8b 31                     	movq	(%rcx), %rsi
    7506: e8 d5 f0 ff ff               	callq	0x65e0 <glob_match>
    750b: 41 89 c0                     	movl	%eax, %r8d
; 		return 0;
    750e: 31 c0                        	xorl	%eax, %eax
; 	if (!glob_match(sym_name, res->pattern))
    7510: 45 84 c0                     	testb	%r8b, %r8b
    7513: 75 0b                        	jne	0x7520 <resolve_kprobe_multi_cb+0x30>
; }
    7515: 48 83 c4 08                  	addq	$8, %rsp
    7519: 5b                           	popq	%rbx
    751a: 5d                           	popq	%rbp
    751b: c3                           	retq
    751c: 0f 1f 40 00                  	nopl	(%rax)
; 	err = libbpf_ensure_mem((void **) &res->addrs, &res->cap, sizeof(unsigned long),
    7520: 48 8b 43 18                  	movq	24(%rbx), %rax
    7524: 48 8d 73 10                  	leaq	16(%rbx), %rsi
    7528: 48 8d 7b 08                  	leaq	8(%rbx), %rdi
    752c: ba 08 00 00 00               	movl	$8, %edx
    7531: 48 8d 48 01                  	leaq	1(%rax), %rcx
    7535: e8 56 29 02 00               	callq	0x29e90 <libbpf_ensure_mem>
; 	if (err)
    753a: 85 c0                        	testl	%eax, %eax
    753c: 75 d7                        	jne	0x7515 <resolve_kprobe_multi_cb+0x25>
; 	res->addrs[res->cnt++] = (unsigned long) sym_addr;
    753e: 48 8b 53 18                  	movq	24(%rbx), %rdx
    7542: 48 8b 4b 08                  	movq	8(%rbx), %rcx
    7546: 48 8d 72 01                  	leaq	1(%rdx), %rsi
    754a: 48 89 73 18                  	movq	%rsi, 24(%rbx)
    754e: 48 89 2c d1                  	movq	%rbp, (%rcx,%rdx,8)
; }
    7552: 48 83 c4 08                  	addq	$8, %rsp
    7556: 5b                           	popq	%rbx
    7557: 5d                           	popq	%rbp
    7558: c3                           	retq
    7559: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000007560 <bpf_link__detach_struct_ops>:
; {
    7560: f3 0f 1e fa                  	endbr64
    7564: 48 83 ec 18                  	subq	$24, %rsp
; 	if (bpf_map_delete_elem(link->fd, &zero))
    7568: 8b 7f 18                     	movl	24(%rdi), %edi
; {
    756b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    7574: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    7579: 31 c0                        	xorl	%eax, %eax
; 	if (bpf_map_delete_elem(link->fd, &zero))
    757b: 48 8d 74 24 04               	leaq	4(%rsp), %rsi
; 	__u32 zero = 0;
    7580: c7 44 24 04 00 00 00 00      	movl	$0, 4(%rsp)
; 	if (bpf_map_delete_elem(link->fd, &zero))
    7588: e8 33 f1 01 00               	callq	0x266c0 <bpf_map_delete_elem>
    758d: 85 c0                        	testl	%eax, %eax
    758f: 74 09                        	je	0x759a <bpf_link__detach_struct_ops+0x3a>
; 		return -errno;
    7591: e8 5a e1 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    7596: 8b 00                        	movl	(%rax), %eax
    7598: f7 d8                        	negl	%eax
; }
    759a: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    759f: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    75a8: 75 05                        	jne	0x75af <bpf_link__detach_struct_ops+0x4f>
    75aa: 48 83 c4 18                  	addq	$24, %rsp
    75ae: c3                           	retq
    75af: e8 4c e2 ff ff               	callq	0x5800 <.plt.sec+0x190>
    75b4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    75bf: 90                           	nop

00000000000075c0 <adjust_prog_btf_ext_info.constprop.0>:
; static int adjust_prog_btf_ext_info(const struct bpf_object *obj,
    75c0: 41 57                        	pushq	%r15
    75c2: 49 89 d7                     	movq	%rdx, %r15
    75c5: 41 56                        	pushq	%r14
    75c7: 41 55                        	pushq	%r13
    75c9: 41 54                        	pushq	%r12
    75cb: 55                           	pushq	%rbp
    75cc: 53                           	pushq	%rbx
    75cd: 48 83 ec 28                  	subq	$40, %rsp
; 	for_each_btf_ext_sec(ext_info, sec) {
    75d1: 48 8b 16                     	movq	(%rsi), %rdx
    75d4: 8b 46 0c                     	movl	12(%rsi), %eax
; static int adjust_prog_btf_ext_info(const struct bpf_object *obj,
    75d7: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
; 	for_each_btf_ext_sec(ext_info, sec) {
    75dc: 48 01 d0                     	addq	%rdx, %rax
    75df: 48 39 c2                     	cmpq	%rax, %rdx
    75e2: 73 30                        	jae	0x7614 <adjust_prog_btf_ext_info.constprop.0+0x54>
    75e4: 49 89 fd                     	movq	%rdi, %r13
    75e7: 49 89 ce                     	movq	%rcx, %r14
; 		if (prog->sec_idx != sec_idx)
    75ea: 48 8b 7f 10                  	movq	16(%rdi), %rdi
    75ee: 48 8b 4e 10                  	movq	16(%rsi), %rcx
    75f2: 48 89 f5                     	movq	%rsi, %rbp
    75f5: 48 63 31                     	movslq	(%rcx), %rsi
; 	for_each_btf_ext_sec(ext_info, sec) {
    75f8: 44 8b 4a 04                  	movl	4(%rdx), %r9d
; 		if (prog->sec_idx != sec_idx)
    75fc: 48 39 f7                     	cmpq	%rsi, %rdi
    75ff: 74 2f                        	je	0x7630 <adjust_prog_btf_ext_info.constprop.0+0x70>
; 	for_each_btf_ext_sec(ext_info, sec) {
    7601: 44 0f af 4d 08               	imull	8(%rbp), %r9d
    7606: 48 83 c1 04                  	addq	$4, %rcx
    760a: 4a 8d 54 0a 08               	leaq	8(%rdx,%r9), %rdx
    760f: 48 39 c2                     	cmpq	%rax, %rdx
    7612: 72 e1                        	jb	0x75f5 <adjust_prog_btf_ext_info.constprop.0+0x35>
; }
    7614: 48 83 c4 28                  	addq	$40, %rsp
; 	return -ENOENT;
    7618: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
; }
    761d: 5b                           	popq	%rbx
    761e: 5d                           	popq	%rbp
    761f: 41 5c                        	popq	%r12
    7621: 41 5d                        	popq	%r13
    7623: 41 5e                        	popq	%r14
    7625: 41 5f                        	popq	%r15
    7627: c3                           	retq
    7628: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		for_each_btf_ext_rec(ext_info, sec, i, rec) {
    7630: 48 83 c2 08                  	addq	$8, %rdx
    7634: 45 85 c9                     	testl	%r9d, %r9d
    7637: 74 db                        	je	0x7614 <adjust_prog_btf_ext_info.constprop.0+0x54>
; 			if (insn_off < prog->sec_insn_off)
    7639: 4d 8b 45 20                  	movq	32(%r13), %r8
; 	void *copy_start = NULL, *copy_end = NULL;
    763d: 31 f6                        	xorl	%esi, %esi
; 		for_each_btf_ext_rec(ext_info, sec, i, rec) {
    763f: 31 ff                        	xorl	%edi, %edi
; 	void *copy_start = NULL, *copy_end = NULL;
    7641: 45 31 e4                     	xorl	%r12d, %r12d
    7644: eb 2e                        	jmp	0x7674 <adjust_prog_btf_ext_info.constprop.0+0xb4>
    7646: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 			if (insn_off >= prog->sec_insn_off + prog->sec_insn_cnt)
    7650: 49 8b 4d 28                  	movq	40(%r13), %rcx
    7654: 4c 01 c1                     	addq	%r8, %rcx
    7657: 48 39 c8                     	cmpq	%rcx, %rax
    765a: 73 30                        	jae	0x768c <adjust_prog_btf_ext_info.constprop.0+0xcc>
; 			copy_end = rec + ext_info->rec_size;
    765c: 8b 75 08                     	movl	8(%rbp), %esi
; 			if (!copy_start)
    765f: 4d 85 e4                     	testq	%r12, %r12
    7662: 4c 0f 44 e2                  	cmoveq	%rdx, %r12
; 		for_each_btf_ext_rec(ext_info, sec, i, rec) {
    7666: 83 c7 01                     	addl	$1, %edi
; 			copy_end = rec + ext_info->rec_size;
    7669: 48 01 d6                     	addq	%rdx, %rsi
    766c: 48 89 f2                     	movq	%rsi, %rdx
; 		for_each_btf_ext_rec(ext_info, sec, i, rec) {
    766f: 44 39 cf                     	cmpl	%r9d, %edi
    7672: 74 18                        	je	0x768c <adjust_prog_btf_ext_info.constprop.0+0xcc>
; 			__u32 insn_off = *(__u32 *)rec / BPF_INSN_SZ;
    7674: 8b 02                        	movl	(%rdx), %eax
    7676: c1 e8 03                     	shrl	$3, %eax
; 			if (insn_off < prog->sec_insn_off)
    7679: 4c 39 c0                     	cmpq	%r8, %rax
    767c: 73 d2                        	jae	0x7650 <adjust_prog_btf_ext_info.constprop.0+0x90>
; 			copy_end = rec + ext_info->rec_size;
    767e: 8b 45 08                     	movl	8(%rbp), %eax
; 		for_each_btf_ext_rec(ext_info, sec, i, rec) {
    7681: 83 c7 01                     	addl	$1, %edi
; 			copy_end = rec + ext_info->rec_size;
    7684: 48 01 c2                     	addq	%rax, %rdx
; 		for_each_btf_ext_rec(ext_info, sec, i, rec) {
    7687: 44 39 cf                     	cmpl	%r9d, %edi
    768a: 75 e8                        	jne	0x7674 <adjust_prog_btf_ext_info.constprop.0+0xb4>
; 		if (!copy_start)
    768c: 4d 85 e4                     	testq	%r12, %r12
    768f: 74 83                        	je	0x7614 <adjust_prog_btf_ext_info.constprop.0+0x54>
; 		old_sz = (size_t)(*prog_rec_cnt) * ext_info->rec_size;
    7691: 41 8b 0e                     	movl	(%r14), %ecx
    7694: 8b 45 08                     	movl	8(%rbp), %eax
; 		new_sz = old_sz + (copy_end - copy_start);
    7697: 4c 29 e6                     	subq	%r12, %rsi
; 		new_prog_info = realloc(*prog_info, new_sz);
    769a: 49 8b 3f                     	movq	(%r15), %rdi
; 		new_sz = old_sz + (copy_end - copy_start);
    769d: 48 89 74 24 18               	movq	%rsi, 24(%rsp)
; 		old_sz = (size_t)(*prog_rec_cnt) * ext_info->rec_size;
    76a2: 48 0f af c8                  	imulq	%rax, %rcx
; 		new_sz = old_sz + (copy_end - copy_start);
    76a6: 48 8d 1c 31                  	leaq	(%rcx,%rsi), %rbx
    76aa: 48 89 4c 24 10               	movq	%rcx, 16(%rsp)
; 		new_prog_info = realloc(*prog_info, new_sz);
    76af: 48 89 de                     	movq	%rbx, %rsi
    76b2: e8 69 e4 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
    76b7: 49 89 c0                     	movq	%rax, %r8
; 		if (!new_prog_info)
    76ba: 48 85 c0                     	testq	%rax, %rax
    76bd: 0f 84 81 00 00 00            	je	0x7744 <adjust_prog_btf_ext_info.constprop.0+0x184>
; 		*prog_rec_cnt = new_sz / ext_info->rec_size;
    76c3: 8b 75 08                     	movl	8(%rbp), %esi
    76c6: 31 d2                        	xorl	%edx, %edx
; 		memcpy(new_prog_info + old_sz, copy_start, copy_end - copy_start);
    76c8: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
; 		*prog_info = new_prog_info;
    76cd: 49 89 07                     	movq	%rax, (%r15)
; 		*prog_rec_cnt = new_sz / ext_info->rec_size;
    76d0: 48 89 d8                     	movq	%rbx, %rax
; 		memcpy(new_prog_info + old_sz, copy_start, copy_end - copy_start);
    76d3: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
; 		*prog_rec_cnt = new_sz / ext_info->rec_size;
    76d8: 48 f7 f6                     	divq	%rsi
;   return __builtin___memcpy_chk (__dest, __src, __len,
    76db: 48 8b 54 24 18               	movq	24(%rsp), %rdx
; 		memcpy(new_prog_info + old_sz, copy_start, copy_end - copy_start);
    76e0: 4c 01 c1                     	addq	%r8, %rcx
;   return __builtin___memcpy_chk (__dest, __src, __len,
    76e3: 4c 89 e6                     	movq	%r12, %rsi
    76e6: 48 89 cf                     	movq	%rcx, %rdi
; 		*prog_rec_cnt = new_sz / ext_info->rec_size;
    76e9: 41 89 06                     	movl	%eax, (%r14)
;   return __builtin___memcpy_chk (__dest, __src, __len,
    76ec: e8 4f e3 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 		rec_end = new_prog_info + new_sz;
    76f1: 4c 8b 44 24 10               	movq	16(%rsp), %r8
; 		off_adj = prog->sub_insn_off - prog->sec_insn_off;
    76f6: 49 8b 7d 30                  	movq	48(%r13), %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
    76fa: 48 89 c1                     	movq	%rax, %rcx
; 		off_adj = prog->sub_insn_off - prog->sec_insn_off;
    76fd: 41 2b 7d 20                  	subl	32(%r13), %edi
; 		rec_end = new_prog_info + new_sz;
    7701: 49 8d 04 18                  	leaq	(%r8,%rbx), %rax
; 		for (; rec < rec_end; rec += ext_info->rec_size) {
    7705: 48 39 c1                     	cmpq	%rax, %rcx
    7708: 73 35                        	jae	0x773f <adjust_prog_btf_ext_info.constprop.0+0x17f>
    770a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			*insn_off = *insn_off / BPF_INSN_SZ + off_adj;
    7710: 8b 11                        	movl	(%rcx), %edx
    7712: c1 ea 03                     	shrl	$3, %edx
    7715: 01 fa                        	addl	%edi, %edx
    7717: 89 11                        	movl	%edx, (%rcx)
; 		for (; rec < rec_end; rec += ext_info->rec_size) {
    7719: 8b 75 08                     	movl	8(%rbp), %esi
    771c: 48 01 f1                     	addq	%rsi, %rcx
    771f: 48 89 f2                     	movq	%rsi, %rdx
    7722: 48 39 c8                     	cmpq	%rcx, %rax
    7725: 77 e9                        	ja	0x7710 <adjust_prog_btf_ext_info.constprop.0+0x150>
; 		*prog_rec_sz = ext_info->rec_size;
    7727: 48 8b 44 24 08               	movq	8(%rsp), %rax
    772c: 89 10                        	movl	%edx, (%rax)
; 		return 0;
    772e: 31 c0                        	xorl	%eax, %eax
; }
    7730: 48 83 c4 28                  	addq	$40, %rsp
    7734: 5b                           	popq	%rbx
    7735: 5d                           	popq	%rbp
    7736: 41 5c                        	popq	%r12
    7738: 41 5d                        	popq	%r13
    773a: 41 5e                        	popq	%r14
    773c: 41 5f                        	popq	%r15
    773e: c3                           	retq
; 		*prog_rec_sz = ext_info->rec_size;
    773f: 8b 55 08                     	movl	8(%rbp), %edx
    7742: eb e3                        	jmp	0x7727 <adjust_prog_btf_ext_info.constprop.0+0x167>
; 			return -ENOMEM;
    7744: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
    7749: eb e5                        	jmp	0x7730 <adjust_prog_btf_ext_info.constprop.0+0x170>
    774b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000007750 <sec_def_matches.isra.0>:
; static bool sec_def_matches(const struct bpf_sec_def *sec_def, const char *sec_name)
    7750: 41 55                        	pushq	%r13
    7752: 49 89 f5                     	movq	%rsi, %r13
    7755: 41 54                        	pushq	%r12
    7757: 55                           	pushq	%rbp
    7758: 48 89 fd                     	movq	%rdi, %rbp
; 	size_t len = strlen(sec_def->sec);
    775b: e8 80 e0 ff ff               	callq	0x57e0 <.plt.sec+0x170>
    7760: 49 89 c4                     	movq	%rax, %r12
; 	if (sec_def->sec[len - 1] == '/') {
    7763: 48 8d 50 ff                  	leaq	-1(%rax), %rdx
    7767: 0f b6 44 05 ff               	movzbl	-1(%rbp,%rax), %eax
    776c: 3c 2f                        	cmpb	$47, %al
    776e: 74 50                        	je	0x77c0 <sec_def_matches.isra.0+0x70>
; 		if (strncmp(sec_name, sec_def->sec, len) != 0)
    7770: 48 89 ee                     	movq	%rbp, %rsi
    7773: 4c 89 ef                     	movq	%r13, %rdi
; 	if (sec_def->sec[len - 1] == '+') {
    7776: 3c 2b                        	cmpb	$43, %al
    7778: 74 16                        	je	0x7790 <sec_def_matches.isra.0+0x40>
; 	return strcmp(sec_name, sec_def->sec) == 0;
    777a: e8 31 e2 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    777f: 85 c0                        	testl	%eax, %eax
    7781: 0f 94 c0                     	sete	%al
; }
    7784: 5d                           	popq	%rbp
    7785: 41 5c                        	popq	%r12
    7787: 41 5d                        	popq	%r13
    7789: c3                           	retq
    778a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		if (strncmp(sec_name, sec_def->sec, len) != 0)
    7790: e8 8b df ff ff               	callq	0x5720 <.plt.sec+0xb0>
    7795: 41 89 c0                     	movl	%eax, %r8d
; 			return false;
    7798: 31 c0                        	xorl	%eax, %eax
; 		if (strncmp(sec_name, sec_def->sec, len) != 0)
    779a: 45 85 c0                     	testl	%r8d, %r8d
    779d: 75 e5                        	jne	0x7784 <sec_def_matches.isra.0+0x34>
; 		if (sec_name[len] == '\0' || sec_name[len] == '/')
    779f: 43 0f b6 54 25 ff            	movzbl	-1(%r13,%r12), %edx
; }
    77a5: 5d                           	popq	%rbp
    77a6: 41 5c                        	popq	%r12
    77a8: 41 5d                        	popq	%r13
; 		if (sec_name[len] == '\0' || sec_name[len] == '/')
    77aa: 84 d2                        	testb	%dl, %dl
    77ac: 0f 94 c0                     	sete	%al
    77af: 80 fa 2f                     	cmpb	$47, %dl
    77b2: 0f 94 c2                     	sete	%dl
    77b5: 09 d0                        	orl	%edx, %eax
; }
    77b7: c3                           	retq
    77b8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		if (str_has_pfx(sec_name, sec_def->sec))
    77c0: 4c 89 e2                     	movq	%r12, %rdx
    77c3: 48 89 ee                     	movq	%rbp, %rsi
    77c6: 4c 89 ef                     	movq	%r13, %rdi
    77c9: e8 52 df ff ff               	callq	0x5720 <.plt.sec+0xb0>
; }
    77ce: 5d                           	popq	%rbp
    77cf: 41 5c                        	popq	%r12
; 		if (str_has_pfx(sec_name, sec_def->sec))
    77d1: 85 c0                        	testl	%eax, %eax
; }
    77d3: 41 5d                        	popq	%r13
; 		if (str_has_pfx(sec_name, sec_def->sec))
    77d5: 0f 94 c0                     	sete	%al
; }
    77d8: c3                           	retq
    77d9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

00000000000077e0 <find_sec_def>:
; {
    77e0: 41 55                        	pushq	%r13
    77e2: 41 54                        	pushq	%r12
    77e4: 49 89 fc                     	movq	%rdi, %r12
    77e7: 55                           	pushq	%rbp
    77e8: 53                           	pushq	%rbx
    77e9: 48 83 ec 08                  	subq	$8, %rsp
; 	n = custom_sec_def_cnt;
    77ed: 48 8b 05 8c fa 03 00         	movq	260748(%rip), %rax      # 0x47280 <custom_sec_def_cnt>
; 	for (i = 0; i < n; i++) {
    77f4: 85 c0                        	testl	%eax, %eax
    77f6: 7e 50                        	jle	0x7848 <find_sec_def+0x68>
    77f8: 8d 50 ff                     	leal	-1(%rax), %edx
    77fb: 48 8b 1d 76 fa 03 00         	movq	260726(%rip), %rbx      # 0x47278 <custom_sec_defs>
    7802: 48 8d 04 d5 00 00 00 00      	leaq	(,%rdx,8), %rax
    780a: 48 29 d0                     	subq	%rdx, %rax
    780d: 48 8d 6c c3 38               	leaq	56(%rbx,%rax,8), %rbp
    7812: eb 0d                        	jmp	0x7821 <find_sec_def+0x41>
    7814: 0f 1f 40 00                  	nopl	(%rax)
    7818: 48 83 c3 38                  	addq	$56, %rbx
    781c: 48 39 eb                     	cmpq	%rbp, %rbx
    781f: 74 27                        	je	0x7848 <find_sec_def+0x68>
; 		if (sec_def_matches(sec_def, sec_name))
    7821: 48 8b 3b                     	movq	(%rbx), %rdi
    7824: 4c 89 e6                     	movq	%r12, %rsi
; 		sec_def = &custom_sec_defs[i];
    7827: 49 89 dd                     	movq	%rbx, %r13
; 		if (sec_def_matches(sec_def, sec_name))
    782a: e8 21 ff ff ff               	callq	0x7750 <sec_def_matches.isra.0>
    782f: 84 c0                        	testb	%al, %al
    7831: 74 e5                        	je	0x7818 <find_sec_def+0x38>
; }
    7833: 48 83 c4 08                  	addq	$8, %rsp
    7837: 4c 89 e8                     	movq	%r13, %rax
    783a: 5b                           	popq	%rbx
    783b: 5d                           	popq	%rbp
    783c: 41 5c                        	popq	%r12
    783e: 41 5d                        	popq	%r13
    7840: c3                           	retq
    7841: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    7848: 48 8d 2d e9 d9 03 00         	leaq	252393(%rip), %rbp      # 0x45238 <section_defs+0x38>
; {
    784f: 48 8d 3d f4 a3 02 00         	leaq	173044(%rip), %rdi      # 0x31c4a <_IO_stdin_used+0x1c4a>
    7856: 31 db                        	xorl	%ebx, %ebx
    7858: eb 16                        	jmp	0x7870 <find_sec_def+0x90>
    785a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	for (i = 0; i < n; i++) {
    7860: 83 c3 01                     	addl	$1, %ebx
    7863: 83 fb 51                     	cmpl	$81, %ebx
    7866: 74 40                        	je	0x78a8 <find_sec_def+0xc8>
    7868: 48 8b 7d 00                  	movq	(%rbp), %rdi
    786c: 48 83 c5 38                  	addq	$56, %rbp
; 		if (sec_def_matches(sec_def, sec_name))
    7870: 4c 89 e6                     	movq	%r12, %rsi
    7873: e8 d8 fe ff ff               	callq	0x7750 <sec_def_matches.isra.0>
    7878: 84 c0                        	testb	%al, %al
    787a: 74 e4                        	je	0x7860 <find_sec_def+0x80>
; 		sec_def = &section_defs[i];
    787c: 48 63 db                     	movslq	%ebx, %rbx
    787f: 48 8d 15 7a d9 03 00         	leaq	252282(%rip), %rdx      # 0x45200 <section_defs>
; }
    7886: 48 83 c4 08                  	addq	$8, %rsp
; 		sec_def = &section_defs[i];
    788a: 48 8d 04 dd 00 00 00 00      	leaq	(,%rbx,8), %rax
    7892: 48 29 d8                     	subq	%rbx, %rax
; }
    7895: 5b                           	popq	%rbx
    7896: 5d                           	popq	%rbp
; 		sec_def = &section_defs[i];
    7897: 4c 8d 2c c2                  	leaq	(%rdx,%rax,8), %r13
; }
    789b: 41 5c                        	popq	%r12
    789d: 4c 89 e8                     	movq	%r13, %rax
    78a0: 41 5d                        	popq	%r13
    78a2: c3                           	retq
    78a3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		return &custom_fallback_def;
    78a8: 80 3d 7d f9 03 00 00         	cmpb	$0, 260477(%rip)        # 0x4722c <has_custom_fallback_def>
    78af: 4c 8d 2d 8a f9 03 00         	leaq	260490(%rip), %r13      # 0x47240 <custom_fallback_def>
    78b6: b8 00 00 00 00               	movl	$0, %eax
    78bb: 4c 0f 44 e8                  	cmoveq	%rax, %r13
    78bf: e9 6f ff ff ff               	jmp	0x7833 <find_sec_def+0x53>
    78c4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    78cf: 90                           	nop

00000000000078d0 <bpf_link__detach_fd>:
; {
    78d0: f3 0f 1e fa                  	endbr64
    78d4: 48 83 ec 08                  	subq	$8, %rsp
; 	return libbpf_err_errno(close(link->fd));
    78d8: 8b 7f 18                     	movl	24(%rdi), %edi
    78db: e8 20 e0 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return ret < 0 ? -errno : ret;
    78e0: 85 c0                        	testl	%eax, %eax
    78e2: 79 09                        	jns	0x78ed <bpf_link__detach_fd+0x1d>
    78e4: e8 07 de ff ff               	callq	0x56f0 <.plt.sec+0x80>
    78e9: 8b 00                        	movl	(%rax), %eax
    78eb: f7 d8                        	negl	%eax
; }
    78ed: 48 83 c4 08                  	addq	$8, %rsp
    78f1: c3                           	retq
    78f2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    78fd: 0f 1f 00                     	nopl	(%rax)

0000000000007900 <probe_kern_prog_name>:
; {
    7900: f3 0f 1e fa                  	endbr64
    7904: 53                           	pushq	%rbx
;   return __builtin___memset_chk (__dest, __ch, __len,
    7905: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	for (i = 0; i < sz && src[i]; i++)
    7909: ba 6c 00 00 00               	movl	$108, %edx
    790e: 48 8d 35 3c a3 02 00         	leaq	172860(%rip), %rsi      # 0x31c51 <_IO_stdin_used+0x1c51>
; {
    7915: 48 81 ec b0 00 00 00         	subq	$176, %rsp
    791c: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    7925: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
    792d: 31 c0                        	xorl	%eax, %eax
; 	attr.license = ptr_to_u64("GPL");
    792f: 48 8d 05 04 a3 02 00         	leaq	172804(%rip), %rax      # 0x31c3a <_IO_stdin_used+0x1c3a>
; 	struct bpf_insn insns[] = {
    7936: 48 c7 04 24 b7 00 00 00      	movq	$183, (%rsp)
    793e: 48 8d 4c 24 40               	leaq	64(%rsp), %rcx
; 	attr.license = ptr_to_u64("GPL");
    7943: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	return (__u64) (unsigned long) ptr;
    7948: 48 89 e0                     	movq	%rsp, %rax
    794b: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	attr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;
    7950: 48 b8 01 00 00 00 02 00 00 00	movabsq	$8589934593, %rax       # imm = 0x200000001
    795a: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	for (i = 0; i < sz && src[i]; i++)
    795f: 31 c0                        	xorl	%eax, %eax
; 	struct bpf_insn insns[] = {
    7961: 48 c7 44 24 08 95 00 00 00   	movq	$149, 8(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    796a: 48 c7 44 24 48 00 00 00 00   	movq	$0, 72(%rsp)
    7973: 0f 11 44 24 28               	movups	%xmm0, 40(%rsp)
    7978: 0f 11 44 24 38               	movups	%xmm0, 56(%rsp)
    797d: eb 09                        	jmp	0x7988 <probe_kern_prog_name+0x88>
    797f: 90                           	nop
; 	for (i = 0; i < sz && src[i]; i++)
    7980: 0f b6 14 06                  	movzbl	(%rsi,%rax), %edx
    7984: 84 d2                        	testb	%dl, %dl
    7986: 74 0d                        	je	0x7995 <probe_kern_prog_name+0x95>
; 		dst[i] = src[i];
    7988: 88 14 01                     	movb	%dl, (%rcx,%rax)
; 	for (i = 0; i < sz && src[i]; i++)
    798b: 48 83 c0 01                  	addq	$1, %rax
    798f: 48 83 f8 0f                  	cmpq	$15, %rax
    7993: 75 eb                        	jne	0x7980 <probe_kern_prog_name+0x80>
; 	ret = sys_bpf_prog_load(&attr, attr_sz, PROG_LOAD_ATTEMPTS);
    7995: 48 8d 7c 24 10               	leaq	16(%rsp), %rdi
    799a: ba 05 00 00 00               	movl	$5, %edx
    799f: be 40 00 00 00               	movl	$64, %esi
; 	dst[i] = '\0';
    79a4: c6 44 04 40 00               	movb	$0, 64(%rsp,%rax)
; 	ret = sys_bpf_prog_load(&attr, attr_sz, PROG_LOAD_ATTEMPTS);
    79a9: e8 12 dc 01 00               	callq	0x255c0 <sys_bpf_prog_load>
    79ae: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
    79b0: 85 c0                        	testl	%eax, %eax
    79b2: 78 07                        	js	0x79bb <probe_kern_prog_name+0xbb>
; 		close(fd);
    79b4: 89 c7                        	movl	%eax, %edi
    79b6: e8 45 df ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return fd >= 0;
    79bb: f7 d3                        	notl	%ebx
    79bd: 89 d8                        	movl	%ebx, %eax
    79bf: c1 e8 1f                     	shrl	$31, %eax
; }
    79c2: 48 8b 94 24 a8 00 00 00      	movq	168(%rsp), %rdx
    79ca: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    79d3: 75 09                        	jne	0x79de <probe_kern_prog_name+0xde>
    79d5: 48 81 c4 b0 00 00 00         	addq	$176, %rsp
    79dc: 5b                           	popq	%rbx
    79dd: c3                           	retq
    79de: e8 1d de ff ff               	callq	0x5800 <.plt.sec+0x190>
    79e3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    79ee: 66 90                        	nop

00000000000079f0 <bpf_object_unload.part.0.isra.0>:
; static int bpf_object_unload(struct bpf_object *obj)
    79f0: 41 54                        	pushq	%r12
    79f2: 55                           	pushq	%rbp
    79f3: 48 89 fd                     	movq	%rdi, %rbp
    79f6: 53                           	pushq	%rbx
; 	for (i = 0; i < obj->nr_maps; i++) {
    79f7: 48 83 7f 70 00               	cmpq	$0, 112(%rdi)
    79fc: 74 5e                        	je	0x7a5c <bpf_object_unload.part.0.isra.0+0x6c>
    79fe: 48 8b 57 68                  	movq	104(%rdi), %rdx
    7a02: 31 db                        	xorl	%ebx, %ebx
    7a04: 0f 1f 40 00                  	nopl	(%rax)
; 		zclose(obj->maps[i].fd);
    7a08: 4c 8d 24 9b                  	leaq	(%rbx,%rbx,4), %r12
    7a0c: 49 c1 e4 05                  	shlq	$5, %r12
    7a10: 4a 8d 04 22                  	leaq	(%rdx,%r12), %rax
    7a14: 8b 78 18                     	movl	24(%rax), %edi
    7a17: 85 ff                        	testl	%edi, %edi
    7a19: 78 0d                        	js	0x7a28 <bpf_object_unload.part.0.isra.0+0x38>
    7a1b: e8 e0 de ff ff               	callq	0x5900 <.plt.sec+0x290>
    7a20: 48 8b 55 68                  	movq	104(%rbp), %rdx
    7a24: 4a 8d 04 22                  	leaq	(%rdx,%r12), %rax
    7a28: c7 40 18 ff ff ff ff         	movl	$4294967295, 24(%rax)   # imm = 0xFFFFFFFF
; 		if (obj->maps[i].st_ops)
    7a2f: 48 8b 40 68                  	movq	104(%rax), %rax
    7a33: 48 85 c0                     	testq	%rax, %rax
    7a36: 74 1a                        	je	0x7a52 <bpf_object_unload.part.0.isra.0+0x62>
; 			zfree(&obj->maps[i].st_ops->kern_vdata);
    7a38: 48 8b 78 28                  	movq	40(%rax), %rdi
    7a3c: e8 7f dc ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7a41: 48 8b 55 68                  	movq	104(%rbp), %rdx
    7a45: 4a 8b 44 22 68               	movq	104(%rdx,%r12), %rax
    7a4a: 48 c7 40 28 00 00 00 00      	movq	$0, 40(%rax)
; 	for (i = 0; i < obj->nr_maps; i++) {
    7a52: 48 83 c3 01                  	addq	$1, %rbx
    7a56: 48 3b 5d 70                  	cmpq	112(%rbp), %rbx
    7a5a: 72 ac                        	jb	0x7a08 <bpf_object_unload.part.0.isra.0+0x18>
; 	for (i = 0; i < obj->nr_programs; i++)
    7a5c: 45 31 e4                     	xorl	%r12d, %r12d
    7a5f: 48 83 7d 60 00               	cmpq	$0, 96(%rbp)
    7a64: 74 63                        	je	0x7ac9 <bpf_object_unload.part.0.isra.0+0xd9>
    7a66: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		bpf_program__unload(&obj->programs[i]);
    7a70: 4b 8d 1c 64                  	leaq	(%r12,%r12,2), %rbx
    7a74: 48 c1 e3 06                  	shlq	$6, %rbx
; 	if (!prog)
    7a78: 48 03 5d 58                  	addq	88(%rbp), %rbx
    7a7c: 74 41                        	je	0x7abf <bpf_object_unload.part.0.isra.0+0xcf>
; 	zclose(prog->fd);
    7a7e: 8b 7b 78                     	movl	120(%rbx), %edi
    7a81: 85 ff                        	testl	%edi, %edi
    7a83: 78 05                        	js	0x7a8a <bpf_object_unload.part.0.isra.0+0x9a>
    7a85: e8 76 de ff ff               	callq	0x5900 <.plt.sec+0x290>
    7a8a: c7 43 78 ff ff ff ff         	movl	$4294967295, 120(%rbx)  # imm = 0xFFFFFFFF
; 	zfree(&prog->func_info);
    7a91: 48 8b bb 98 00 00 00         	movq	152(%rbx), %rdi
    7a98: e8 23 dc ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zfree(&prog->line_info);
    7a9d: 48 8b bb a8 00 00 00         	movq	168(%rbx), %rdi
; 	zfree(&prog->func_info);
    7aa4: 48 c7 83 98 00 00 00 00 00 00 00     	movq	$0, 152(%rbx)
; 	zfree(&prog->line_info);
    7aaf: e8 0c dc ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7ab4: 48 c7 83 a8 00 00 00 00 00 00 00     	movq	$0, 168(%rbx)
; 	for (i = 0; i < obj->nr_programs; i++)
    7abf: 49 83 c4 01                  	addq	$1, %r12
    7ac3: 4c 3b 65 60                  	cmpq	96(%rbp), %r12
    7ac7: 72 a7                        	jb	0x7a70 <bpf_object_unload.part.0.isra.0+0x80>
; }
    7ac9: 5b                           	popq	%rbx
    7aca: 5d                           	popq	%rbp
    7acb: 41 5c                        	popq	%r12
    7acd: c3                           	retq
    7ace: 66 90                        	nop

0000000000007ad0 <bpf_map__destroy>:
; {
    7ad0: 53                           	pushq	%rbx
    7ad1: 48 89 fb                     	movq	%rdi, %rbx
; 	if (map->inner_map) {
    7ad4: 48 8b 7f 70                  	movq	112(%rdi), %rdi
    7ad8: 48 85 ff                     	testq	%rdi, %rdi
    7adb: 74 16                        	je	0x7af3 <bpf_map__destroy+0x23>
; 		bpf_map__destroy(map->inner_map);
    7add: e8 ee ff ff ff               	callq	0x7ad0 <bpf_map__destroy>
; 		zfree(&map->inner_map);
    7ae2: 48 8b 7b 70                  	movq	112(%rbx), %rdi
    7ae6: e8 d5 db ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7aeb: 48 c7 43 70 00 00 00 00      	movq	$0, 112(%rbx)
; 	zfree(&map->init_slots);
    7af3: 48 8b 7b 78                  	movq	120(%rbx), %rdi
    7af7: e8 c4 db ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (map->mmaped) {
    7afc: 48 83 7b 60 00               	cmpq	$0, 96(%rbx)
; 	zfree(&map->init_slots);
    7b01: 48 c7 43 78 00 00 00 00      	movq	$0, 120(%rbx)
; 	map->init_slots_sz = 0;
    7b09: c7 83 80 00 00 00 00 00 00 00	movl	$0, 128(%rbx)
; 	if (map->mmaped) {
    7b13: 74 3f                        	je	0x7b54 <bpf_map__destroy+0x84>
; 	long page_sz = sysconf(_SC_PAGE_SIZE);
    7b15: bf 1e 00 00 00               	movl	$30, %edi
    7b1a: e8 91 e0 ff ff               	callq	0x5bb0 <.plt.sec+0x540>
; 		munmap(map->mmaped, bpf_map_mmap_sz(map));
    7b1f: 48 8b 7b 60                  	movq	96(%rbx), %rdi
; 	long page_sz = sysconf(_SC_PAGE_SIZE);
    7b23: 48 89 c1                     	movq	%rax, %rcx
; 	map_sz = (size_t)roundup(map->def.value_size, 8) * map->def.max_entries;
    7b26: 8b 43 38                     	movl	56(%rbx), %eax
    7b29: 8d 50 07                     	leal	7(%rax), %edx
    7b2c: 8b 43 3c                     	movl	60(%rbx), %eax
    7b2f: 83 e2 f8                     	andl	$-8, %edx
    7b32: 48 0f af d0                  	imulq	%rax, %rdx
; 	map_sz = roundup(map_sz, page_sz);
    7b36: 48 8d 44 11 ff               	leaq	-1(%rcx,%rdx), %rax
    7b3b: 31 d2                        	xorl	%edx, %edx
    7b3d: 48 f7 f1                     	divq	%rcx
    7b40: 48 0f af c1                  	imulq	%rcx, %rax
    7b44: 48 89 c6                     	movq	%rax, %rsi
; 		munmap(map->mmaped, bpf_map_mmap_sz(map));
    7b47: e8 f4 df ff ff               	callq	0x5b40 <.plt.sec+0x4d0>
; 		map->mmaped = NULL;
    7b4c: 48 c7 43 60 00 00 00 00      	movq	$0, 96(%rbx)
; 	if (map->st_ops) {
    7b54: 48 8b 43 68                  	movq	104(%rbx), %rax
    7b58: 48 85 c0                     	testq	%rax, %rax
    7b5b: 74 44                        	je	0x7ba1 <bpf_map__destroy+0xd1>
; 		zfree(&map->st_ops->data);
    7b5d: 48 8b 78 20                  	movq	32(%rax), %rdi
    7b61: e8 5a db ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7b66: 48 8b 43 68                  	movq	104(%rbx), %rax
    7b6a: 48 c7 40 20 00 00 00 00      	movq	$0, 32(%rax)
; 		zfree(&map->st_ops->progs);
    7b72: 48 8b 78 10                  	movq	16(%rax), %rdi
    7b76: e8 45 db ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7b7b: 48 8b 43 68                  	movq	104(%rbx), %rax
    7b7f: 48 c7 40 10 00 00 00 00      	movq	$0, 16(%rax)
; 		zfree(&map->st_ops->kern_func_off);
    7b87: 48 8b 78 18                  	movq	24(%rax), %rdi
    7b8b: e8 30 db ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 		zfree(&map->st_ops);
    7b90: 48 8b 7b 68                  	movq	104(%rbx), %rdi
    7b94: e8 27 db ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7b99: 48 c7 43 68 00 00 00 00      	movq	$0, 104(%rbx)
; 	zfree(&map->name);
    7ba1: 48 8b 7b 08                  	movq	8(%rbx), %rdi
    7ba5: e8 16 db ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7baa: 48 c7 43 08 00 00 00 00      	movq	$0, 8(%rbx)
; 	zfree(&map->real_name);
    7bb2: 48 8b 7b 10                  	movq	16(%rbx), %rdi
    7bb6: e8 05 db ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7bbb: 48 c7 43 10 00 00 00 00      	movq	$0, 16(%rbx)
; 	zfree(&map->pin_path);
    7bc3: 48 8b bb 88 00 00 00         	movq	136(%rbx), %rdi
    7bca: e8 f1 da ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (map->fd >= 0)
    7bcf: 8b 7b 18                     	movl	24(%rbx), %edi
; 	zfree(&map->pin_path);
    7bd2: 48 c7 83 88 00 00 00 00 00 00 00     	movq	$0, 136(%rbx)
; 	if (map->fd >= 0)
    7bdd: 85 ff                        	testl	%edi, %edi
    7bdf: 79 07                        	jns	0x7be8 <bpf_map__destroy+0x118>
; }
    7be1: 5b                           	popq	%rbx
    7be2: c3                           	retq
    7be3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		zclose(map->fd);
    7be8: e8 13 dd ff ff               	callq	0x5900 <.plt.sec+0x290>
    7bed: c7 43 18 ff ff ff ff         	movl	$4294967295, 24(%rbx)   # imm = 0xFFFFFFFF
; }
    7bf4: 5b                           	popq	%rbx
    7bf5: c3                           	retq
    7bf6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000007c00 <bpf_map__set_pin_path.part.0>:
; int bpf_map__set_pin_path(struct bpf_map *map, const char *path)
    7c00: 48 83 ec 08                  	subq	$8, %rsp
; 			return libbpf_err(-errno);
    7c04: e8 e7 da ff ff               	callq	0x56f0 <.plt.sec+0x80>
    7c09: 8b 00                        	movl	(%rax), %eax
; }
    7c0b: 48 83 c4 08                  	addq	$8, %rsp
; 			return libbpf_err(-errno);
    7c0f: f7 d8                        	negl	%eax
; }
    7c11: c3                           	retq
    7c12: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    7c1d: 0f 1f 00                     	nopl	(%rax)

0000000000007c20 <remove_kprobe_event_legacy>:
; {
    7c20: 41 55                        	pushq	%r13
; 	return append_to_file(tracefs_kprobe_events(), "-:%s/%s",
    7c22: 48 8d 05 43 a0 02 00         	leaq	172099(%rip), %rax      # 0x31c6c <_IO_stdin_used+0x1c6c>
; {
    7c29: 49 89 fd                     	movq	%rdi, %r13
    7c2c: 41 54                        	pushq	%r12
; 	return append_to_file(tracefs_kprobe_events(), "-:%s/%s",
    7c2e: 4c 8d 25 2c a0 02 00         	leaq	172076(%rip), %r12      # 0x31c61 <_IO_stdin_used+0x1c61>
; {
    7c35: 48 83 ec 08                  	subq	$8, %rsp
; 	return append_to_file(tracefs_kprobe_events(), "-:%s/%s",
    7c39: 40 84 f6                     	testb	%sil, %sil
    7c3c: 4c 0f 44 e0                  	cmoveq	%rax, %r12
; 	if (has_debugfs < 0)
    7c40: 8b 05 ca f3 03 00            	movl	259018(%rip), %eax      # 0x47010 <has_debugfs.1>
    7c46: 85 c0                        	testl	%eax, %eax
    7c48: 78 36                        	js	0x7c80 <remove_kprobe_event_legacy+0x60>
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
    7c4a: 83 f8 01                     	cmpl	$1, %eax
    7c4d: 48 8d 3d 44 b2 02 00         	leaq	176708(%rip), %rdi      # 0x32e98 <strs.2+0x8>
; 	return append_to_file(tracefs_kprobe_events(), "-:%s/%s",
    7c54: 4c 89 e9                     	movq	%r13, %rcx
    7c57: 4c 89 e2                     	movq	%r12, %rdx
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
    7c5a: 48 8d 05 5f b2 02 00         	leaq	176735(%rip), %rax      # 0x32ec0 <strs.2+0x30>
; 	return append_to_file(tracefs_kprobe_events(), "-:%s/%s",
    7c61: 48 8d 35 26 a0 02 00         	leaq	172070(%rip), %rsi      # 0x31c8e <_IO_stdin_used+0x1c8e>
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
    7c68: 48 0f 45 f8                  	cmovneq	%rax, %rdi
; }
    7c6c: 48 83 c4 08                  	addq	$8, %rsp
; 	return append_to_file(tracefs_kprobe_events(), "-:%s/%s",
    7c70: 31 c0                        	xorl	%eax, %eax
; }
    7c72: 41 5c                        	popq	%r12
    7c74: 41 5d                        	popq	%r13
; 	return append_to_file(tracefs_kprobe_events(), "-:%s/%s",
    7c76: e9 35 eb ff ff               	jmp	0x67b0 <append_to_file>
    7c7b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
    7c80: 31 f6                        	xorl	%esi, %esi
    7c82: 48 8d 3d eb 9f 02 00         	leaq	172011(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
    7c89: e8 12 df ff ff               	callq	0x5ba0 <.plt.sec+0x530>
    7c8e: 85 c0                        	testl	%eax, %eax
    7c90: 0f 94 c0                     	sete	%al
    7c93: 0f b6 c0                     	movzbl	%al, %eax
    7c96: 89 05 74 f3 03 00            	movl	%eax, 258932(%rip)      # 0x47010 <has_debugfs.1>
    7c9c: eb ac                        	jmp	0x7c4a <remove_kprobe_event_legacy+0x2a>
    7c9e: 66 90                        	nop

0000000000007ca0 <bpf_link__destroy.part.0>:
; int bpf_link__destroy(struct bpf_link *link)
    7ca0: 41 54                        	pushq	%r12
; 	int err = 0;
    7ca2: 45 31 e4                     	xorl	%r12d, %r12d
; int bpf_link__destroy(struct bpf_link *link)
    7ca5: 55                           	pushq	%rbp
    7ca6: 48 89 fd                     	movq	%rdi, %rbp
    7ca9: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!link->disconnected && link->detach)
    7cad: 80 7f 1c 00                  	cmpb	$0, 28(%rdi)
    7cb1: 75 0d                        	jne	0x7cc0 <bpf_link__destroy.part.0+0x20>
    7cb3: 48 8b 07                     	movq	(%rdi), %rax
    7cb6: 48 85 c0                     	testq	%rax, %rax
    7cb9: 74 05                        	je	0x7cc0 <bpf_link__destroy.part.0+0x20>
; 		err = link->detach(link);
    7cbb: ff d0                        	callq	*%rax
    7cbd: 41 89 c4                     	movl	%eax, %r12d
; 	if (link->pin_path)
    7cc0: 48 8b 7d 10                  	movq	16(%rbp), %rdi
    7cc4: 48 85 ff                     	testq	%rdi, %rdi
    7cc7: 74 05                        	je	0x7cce <bpf_link__destroy.part.0+0x2e>
; 		free(link->pin_path);
    7cc9: e8 f2 d9 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (link->dealloc)
    7cce: 48 8b 45 08                  	movq	8(%rbp), %rax
; 		link->dealloc(link);
    7cd2: 48 89 ef                     	movq	%rbp, %rdi
; 	if (link->dealloc)
    7cd5: 48 85 c0                     	testq	%rax, %rax
    7cd8: 74 26                        	je	0x7d00 <bpf_link__destroy.part.0+0x60>
; 		link->dealloc(link);
    7cda: ff d0                        	callq	*%rax
; 	if (ret < 0)
    7cdc: 45 85 e4                     	testl	%r12d, %r12d
    7cdf: 79 0c                        	jns	0x7ced <bpf_link__destroy.part.0+0x4d>
; 		errno = -ret;
    7ce1: e8 0a da ff ff               	callq	0x56f0 <.plt.sec+0x80>
    7ce6: 44 89 e2                     	movl	%r12d, %edx
    7ce9: f7 da                        	negl	%edx
    7ceb: 89 10                        	movl	%edx, (%rax)
; }
    7ced: 48 83 c4 08                  	addq	$8, %rsp
    7cf1: 44 89 e0                     	movl	%r12d, %eax
    7cf4: 5d                           	popq	%rbp
    7cf5: 41 5c                        	popq	%r12
    7cf7: c3                           	retq
    7cf8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		free(link);
    7d00: e8 bb d9 ff ff               	callq	0x56c0 <.plt.sec+0x50>
    7d05: eb d5                        	jmp	0x7cdc <bpf_link__destroy.part.0+0x3c>
    7d07: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000007d10 <bpf_link_perf_detach>:
; {
    7d10: f3 0f 1e fa                  	endbr64
    7d14: 41 55                        	pushq	%r13
; 	if (ioctl(perf_link->perf_event_fd, PERF_EVENT_IOC_DISABLE, 0) < 0)
    7d16: 31 d2                        	xorl	%edx, %edx
    7d18: be 01 24 00 00               	movl	$9217, %esi             # imm = 0x2401
    7d1d: 31 c0                        	xorl	%eax, %eax
; {
    7d1f: 41 54                        	pushq	%r12
    7d21: 45 31 ed                     	xorl	%r13d, %r13d
    7d24: 53                           	pushq	%rbx
    7d25: 48 89 fb                     	movq	%rdi, %rbx
; 	if (ioctl(perf_link->perf_event_fd, PERF_EVENT_IOC_DISABLE, 0) < 0)
    7d28: 8b 7f 20                     	movl	32(%rdi), %edi
    7d2b: e8 c0 db ff ff               	callq	0x58f0 <.plt.sec+0x280>
    7d30: 85 c0                        	testl	%eax, %eax
    7d32: 79 0b                        	jns	0x7d3f <bpf_link_perf_detach+0x2f>
; 		err = -errno;
    7d34: e8 b7 d9 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    7d39: 44 8b 28                     	movl	(%rax), %r13d
    7d3c: 41 f7 dd                     	negl	%r13d
; 	if (perf_link->perf_event_fd != link->fd)
    7d3f: 44 8b 43 20                  	movl	32(%rbx), %r8d
    7d43: 8b 7b 18                     	movl	24(%rbx), %edi
    7d46: 41 39 f8                     	cmpl	%edi, %r8d
    7d49: 74 0b                        	je	0x7d56 <bpf_link_perf_detach+0x46>
; 		close(perf_link->perf_event_fd);
    7d4b: 44 89 c7                     	movl	%r8d, %edi
    7d4e: e8 ad db ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	close(link->fd);
    7d53: 8b 7b 18                     	movl	24(%rbx), %edi
    7d56: e8 a5 db ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (perf_link->legacy_probe_name) {
    7d5b: 4c 8b 63 28                  	movq	40(%rbx), %r12
    7d5f: 4d 85 e4                     	testq	%r12, %r12
    7d62: 0f 84 90 00 00 00            	je	0x7df8 <bpf_link_perf_detach+0xe8>
; 		if (perf_link->legacy_is_kprobe) {
    7d68: 80 7b 30 00                  	cmpb	$0, 48(%rbx)
; 							 perf_link->legacy_is_retprobe);
    7d6c: 0f b6 43 31                  	movzbl	49(%rbx), %eax
; 		if (perf_link->legacy_is_kprobe) {
    7d70: 75 4e                        	jne	0x7dc0 <bpf_link_perf_detach+0xb0>
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
    7d72: 84 c0                        	testb	%al, %al
    7d74: 4c 8d 2d 1b 9f 02 00         	leaq	171803(%rip), %r13      # 0x31c96 <_IO_stdin_used+0x1c96>
    7d7b: 48 8d 05 1f 9f 02 00         	leaq	171807(%rip), %rax      # 0x31ca1 <_IO_stdin_used+0x1ca1>
    7d82: 4c 0f 44 e8                  	cmoveq	%rax, %r13
; 	if (has_debugfs < 0)
    7d86: 8b 05 84 f2 03 00            	movl	258692(%rip), %eax      # 0x47010 <has_debugfs.1>
    7d8c: 85 c0                        	testl	%eax, %eax
    7d8e: 78 78                        	js	0x7e08 <bpf_link_perf_detach+0xf8>
; 	return use_debugfs() ? DEBUGFS"/uprobe_events" : TRACEFS"/uprobe_events";
    7d90: 83 f8 01                     	cmpl	$1, %eax
    7d93: 48 8d 3d 4e b1 02 00         	leaq	176462(%rip), %rdi      # 0x32ee8 <strs.2+0x58>
    7d9a: 48 8d 05 6f b1 02 00         	leaq	176495(%rip), %rax      # 0x32f10 <strs.2+0x80>
    7da1: 48 0f 45 f8                  	cmovneq	%rax, %rdi
; }
    7da5: 5b                           	popq	%rbx
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
    7da6: 4c 89 e1                     	movq	%r12, %rcx
    7da9: 4c 89 ea                     	movq	%r13, %rdx
; }
    7dac: 41 5c                        	popq	%r12
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
    7dae: 48 8d 35 d9 9e 02 00         	leaq	171737(%rip), %rsi      # 0x31c8e <_IO_stdin_used+0x1c8e>
    7db5: 31 c0                        	xorl	%eax, %eax
; }
    7db7: 41 5d                        	popq	%r13
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
    7db9: e9 f2 e9 ff ff               	jmp	0x67b0 <append_to_file>
    7dbe: 66 90                        	nop
; 	return append_to_file(tracefs_kprobe_events(), "-:%s/%s",
    7dc0: 84 c0                        	testb	%al, %al
    7dc2: 4c 8d 2d 98 9e 02 00         	leaq	171672(%rip), %r13      # 0x31c61 <_IO_stdin_used+0x1c61>
    7dc9: 48 8d 05 9c 9e 02 00         	leaq	171676(%rip), %rax      # 0x31c6c <_IO_stdin_used+0x1c6c>
    7dd0: 4c 0f 44 e8                  	cmoveq	%rax, %r13
; 	if (has_debugfs < 0)
    7dd4: 8b 05 36 f2 03 00            	movl	258614(%rip), %eax      # 0x47010 <has_debugfs.1>
    7dda: 85 c0                        	testl	%eax, %eax
    7ddc: 78 52                        	js	0x7e30 <bpf_link_perf_detach+0x120>
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
    7dde: 83 f8 01                     	cmpl	$1, %eax
    7de1: 48 8d 3d b0 b0 02 00         	leaq	176304(%rip), %rdi      # 0x32e98 <strs.2+0x8>
    7de8: 48 8d 05 d1 b0 02 00         	leaq	176337(%rip), %rax      # 0x32ec0 <strs.2+0x30>
    7def: eb b0                        	jmp	0x7da1 <bpf_link_perf_detach+0x91>
    7df1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; }
    7df8: 44 89 e8                     	movl	%r13d, %eax
    7dfb: 5b                           	popq	%rbx
    7dfc: 41 5c                        	popq	%r12
    7dfe: 41 5d                        	popq	%r13
    7e00: c3                           	retq
    7e01: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
    7e08: 31 f6                        	xorl	%esi, %esi
    7e0a: 48 8d 3d 63 9e 02 00         	leaq	171619(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
    7e11: e8 8a dd ff ff               	callq	0x5ba0 <.plt.sec+0x530>
    7e16: 85 c0                        	testl	%eax, %eax
    7e18: 0f 94 c0                     	sete	%al
    7e1b: 0f b6 c0                     	movzbl	%al, %eax
    7e1e: 89 05 ec f1 03 00            	movl	%eax, 258540(%rip)      # 0x47010 <has_debugfs.1>
    7e24: e9 67 ff ff ff               	jmp	0x7d90 <bpf_link_perf_detach+0x80>
    7e29: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    7e30: 31 f6                        	xorl	%esi, %esi
    7e32: 48 8d 3d 3b 9e 02 00         	leaq	171579(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
    7e39: e8 62 dd ff ff               	callq	0x5ba0 <.plt.sec+0x530>
    7e3e: 85 c0                        	testl	%eax, %eax
    7e40: 0f 94 c0                     	sete	%al
    7e43: 0f b6 c0                     	movzbl	%al, %eax
    7e46: 89 05 c4 f1 03 00            	movl	%eax, 258500(%rip)      # 0x47010 <has_debugfs.1>
    7e4c: eb 90                        	jmp	0x7dde <bpf_link_perf_detach+0xce>
    7e4e: 66 90                        	nop

0000000000007e50 <bpf_object__close.part.0>:
; void bpf_object__close(struct bpf_object *obj)
    7e50: 41 54                        	pushq	%r12
    7e52: 55                           	pushq	%rbp
    7e53: 48 89 fd                     	movq	%rdi, %rbp
    7e56: 53                           	pushq	%rbx
; 	usdt_manager_free(obj->usdt_man);
    7e57: 48 8b bf 88 01 00 00         	movq	392(%rdi), %rdi
    7e5e: e8 4d bf 01 00               	callq	0x23db0 <usdt_manager_free>
; 	bpf_gen__free(obj->gen_loader);
    7e63: 48 8b bd a0 00 00 00         	movq	160(%rbp), %rdi
; 	obj->usdt_man = NULL;
    7e6a: 48 c7 85 88 01 00 00 00 00 00 00     	movq	$0, 392(%rbp)
; 	bpf_gen__free(obj->gen_loader);
    7e75: e8 d6 78 01 00               	callq	0x1f750 <bpf_gen__free>
; 	if (!obj->efile.elf)
    7e7a: 48 8b bd c0 00 00 00         	movq	192(%rbp), %rdi
    7e81: 48 85 ff                     	testq	%rdi, %rdi
    7e84: 74 75                        	je	0x7efb <bpf_object__close.part.0+0xab>
; 	elf_end(obj->efile.elf);
    7e86: e8 a5 db ff ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	zfree(&obj->efile.secs);
    7e8b: 48 8b bd f0 00 00 00         	movq	240(%rbp), %rdi
; 	obj->efile.elf = NULL;
    7e92: 48 c7 85 c0 00 00 00 00 00 00 00     	movq	$0, 192(%rbp)
; 	obj->efile.symbols = NULL;
    7e9d: 48 c7 85 d0 00 00 00 00 00 00 00     	movq	$0, 208(%rbp)
; 	obj->efile.st_ops_data = NULL;
    7ea8: 48 c7 85 d8 00 00 00 00 00 00 00     	movq	$0, 216(%rbp)
; 	zfree(&obj->efile.secs);
    7eb3: e8 08 d8 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zclose(obj->efile.fd);
    7eb8: 8b bd a8 00 00 00            	movl	168(%rbp), %edi
; 	zfree(&obj->efile.secs);
    7ebe: 48 c7 85 f0 00 00 00 00 00 00 00     	movq	$0, 240(%rbp)
; 	obj->efile.sec_cnt = 0;
    7ec9: c7 85 f8 00 00 00 00 00 00 00	movl	$0, 248(%rbp)
; 	zclose(obj->efile.fd);
    7ed3: 85 ff                        	testl	%edi, %edi
    7ed5: 0f 89 c5 01 00 00            	jns	0x80a0 <bpf_object__close.part.0+0x250>
    7edb: c7 85 a8 00 00 00 ff ff ff ff	movl	$4294967295, 168(%rbp)  # imm = 0xFFFFFFFF
; 	obj->efile.obj_buf = NULL;
    7ee5: 48 c7 85 b0 00 00 00 00 00 00 00     	movq	$0, 176(%rbp)
; 	obj->efile.obj_buf_sz = 0;
    7ef0: 48 c7 85 b8 00 00 00 00 00 00 00     	movq	$0, 184(%rbp)
; 	if (!obj)
    7efb: 48 89 ef                     	movq	%rbp, %rdi
; 	for (i = 0; i < obj->nr_maps; i++)
    7efe: 31 db                        	xorl	%ebx, %ebx
    7f00: e8 eb fa ff ff               	callq	0x79f0 <bpf_object_unload.part.0.isra.0>
; 	btf__free(obj->btf);
    7f05: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
    7f0c: e8 df 28 02 00               	callq	0x2a7f0 <btf__free>
; 	btf_ext__free(obj->btf_ext);
    7f11: 48 8b bd 18 01 00 00         	movq	280(%rbp), %rdi
    7f18: e8 83 53 02 00               	callq	0x2d2a0 <btf_ext__free>
; 	for (i = 0; i < obj->nr_maps; i++)
    7f1d: 48 83 7d 70 00               	cmpq	$0, 112(%rbp)
    7f22: 74 1f                        	je	0x7f43 <bpf_object__close.part.0+0xf3>
    7f24: 0f 1f 40 00                  	nopl	(%rax)
; 		bpf_map__destroy(&obj->maps[i]);
    7f28: 48 8d 3c 9b                  	leaq	(%rbx,%rbx,4), %rdi
; 	for (i = 0; i < obj->nr_maps; i++)
    7f2c: 48 83 c3 01                  	addq	$1, %rbx
; 		bpf_map__destroy(&obj->maps[i]);
    7f30: 48 c1 e7 05                  	shlq	$5, %rdi
    7f34: 48 03 7d 68                  	addq	104(%rbp), %rdi
    7f38: e8 93 fb ff ff               	callq	0x7ad0 <bpf_map__destroy>
; 	for (i = 0; i < obj->nr_maps; i++)
    7f3d: 48 3b 5d 70                  	cmpq	112(%rbp), %rbx
    7f41: 72 e5                        	jb	0x7f28 <bpf_object__close.part.0+0xd8>
; 	zfree(&obj->btf_custom_path);
    7f43: 48 8b bd 28 01 00 00         	movq	296(%rbp), %rdi
    7f4a: e8 71 d7 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zfree(&obj->kconfig);
    7f4f: 48 8b bd 80 00 00 00         	movq	128(%rbp), %rdi
; 	zfree(&obj->btf_custom_path);
    7f56: 48 c7 85 28 01 00 00 00 00 00 00     	movq	$0, 296(%rbp)
; 	zfree(&obj->kconfig);
    7f61: e8 5a d7 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zfree(&obj->externs);
    7f66: 48 8b bd 88 00 00 00         	movq	136(%rbp), %rdi
; 	zfree(&obj->kconfig);
    7f6d: 48 c7 85 80 00 00 00 00 00 00 00     	movq	$0, 128(%rbp)
; 	zfree(&obj->externs);
    7f78: e8 43 d7 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zfree(&obj->maps);
    7f7d: 48 8b 7d 68                  	movq	104(%rbp), %rdi
; 	zfree(&obj->externs);
    7f81: 48 c7 85 88 00 00 00 00 00 00 00     	movq	$0, 136(%rbp)
; 	obj->nr_extern = 0;
    7f8c: c7 85 90 00 00 00 00 00 00 00	movl	$0, 144(%rbp)
; 	zfree(&obj->maps);
    7f96: e8 25 d7 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (obj->programs && obj->nr_programs) {
    7f9b: 48 8b 7d 58                  	movq	88(%rbp), %rdi
; 	zfree(&obj->maps);
    7f9f: 48 c7 45 68 00 00 00 00      	movq	$0, 104(%rbp)
; 	obj->nr_maps = 0;
    7fa7: 48 c7 45 70 00 00 00 00      	movq	$0, 112(%rbp)
; 	if (obj->programs && obj->nr_programs) {
    7faf: 48 85 ff                     	testq	%rdi, %rdi
    7fb2: 0f 84 d5 00 00 00            	je	0x808d <bpf_object__close.part.0+0x23d>
    7fb8: 48 83 7d 60 00               	cmpq	$0, 96(%rbp)
    7fbd: 0f 84 ca 00 00 00            	je	0x808d <bpf_object__close.part.0+0x23d>
; 		for (i = 0; i < obj->nr_programs; i++)
    7fc3: 45 31 e4                     	xorl	%r12d, %r12d
    7fc6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 			bpf_program__exit(&obj->programs[i]);
    7fd0: 4b 8d 1c 64                  	leaq	(%r12,%r12,2), %rbx
    7fd4: 48 c1 e3 06                  	shlq	$6, %rbx
; 	if (!prog)
    7fd8: 48 01 fb                     	addq	%rdi, %rbx
    7fdb: 0f 84 9e 00 00 00            	je	0x807f <bpf_object__close.part.0+0x22f>
; 	zclose(prog->fd);
    7fe1: 8b 7b 78                     	movl	120(%rbx), %edi
    7fe4: 85 ff                        	testl	%edi, %edi
    7fe6: 78 05                        	js	0x7fed <bpf_object__close.part.0+0x19d>
    7fe8: e8 13 d9 ff ff               	callq	0x5900 <.plt.sec+0x290>
    7fed: c7 43 78 ff ff ff ff         	movl	$4294967295, 120(%rbx)  # imm = 0xFFFFFFFF
; 	zfree(&prog->func_info);
    7ff4: 48 8b bb 98 00 00 00         	movq	152(%rbx), %rdi
    7ffb: e8 c0 d6 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zfree(&prog->line_info);
    8000: 48 8b bb a8 00 00 00         	movq	168(%rbx), %rdi
; 	zfree(&prog->func_info);
    8007: 48 c7 83 98 00 00 00 00 00 00 00     	movq	$0, 152(%rbx)
; 	zfree(&prog->line_info);
    8012: e8 a9 d6 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zfree(&prog->name);
    8017: 48 8b 3b                     	movq	(%rbx), %rdi
; 	zfree(&prog->line_info);
    801a: 48 c7 83 a8 00 00 00 00 00 00 00     	movq	$0, 168(%rbx)
; 	zfree(&prog->name);
    8025: e8 96 d6 ff ff               	callq	0x56c0 <.plt.sec+0x50>
    802a: 48 c7 03 00 00 00 00         	movq	$0, (%rbx)
; 	zfree(&prog->sec_name);
    8031: 48 8b 7b 08                  	movq	8(%rbx), %rdi
    8035: e8 86 d6 ff ff               	callq	0x56c0 <.plt.sec+0x50>
    803a: 48 c7 43 08 00 00 00 00      	movq	$0, 8(%rbx)
; 	zfree(&prog->insns);
    8042: 48 8b 7b 38                  	movq	56(%rbx), %rdi
    8046: e8 75 d6 ff ff               	callq	0x56c0 <.plt.sec+0x50>
    804b: 48 c7 43 38 00 00 00 00      	movq	$0, 56(%rbx)
; 	zfree(&prog->reloc_desc);
    8053: 48 8b 7b 48                  	movq	72(%rbx), %rdi
    8057: e8 64 d6 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	prog->nr_reloc = 0;
    805c: c7 43 50 00 00 00 00         	movl	$0, 80(%rbx)
; 	zfree(&obj->programs);
    8063: 48 8b 7d 58                  	movq	88(%rbp), %rdi
; 	zfree(&prog->reloc_desc);
    8067: 48 c7 43 48 00 00 00 00      	movq	$0, 72(%rbx)
; 	prog->insns_cnt = 0;
    806f: 48 c7 43 40 00 00 00 00      	movq	$0, 64(%rbx)
; 	prog->sec_idx = -1;
    8077: 48 c7 43 10 ff ff ff ff      	movq	$-1, 16(%rbx)
; 		for (i = 0; i < obj->nr_programs; i++)
    807f: 49 83 c4 01                  	addq	$1, %r12
    8083: 4c 3b 65 60                  	cmpq	96(%rbp), %r12
    8087: 0f 82 43 ff ff ff            	jb	0x7fd0 <bpf_object__close.part.0+0x180>
; 	zfree(&obj->programs);
    808d: e8 2e d6 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; }
    8092: 5b                           	popq	%rbx
; 	free(obj);
    8093: 48 89 ef                     	movq	%rbp, %rdi
; }
    8096: 5d                           	popq	%rbp
    8097: 41 5c                        	popq	%r12
; 	free(obj);
    8099: e9 22 d6 ff ff               	jmp	0x56c0 <.plt.sec+0x50>
    809e: 66 90                        	nop
; 	zclose(obj->efile.fd);
    80a0: e8 5b d8 ff ff               	callq	0x5900 <.plt.sec+0x290>
    80a5: e9 31 fe ff ff               	jmp	0x7edb <bpf_object__close.part.0+0x8b>
    80aa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

00000000000080b0 <libbpf_set_print>:
; {
    80b0: f3 0f 1e fa                  	endbr64
; 	libbpf_print_fn_t old_print_fn = __libbpf_pr;
    80b4: 48 8b 05 2d f1 03 00         	movq	258349(%rip), %rax      # 0x471e8 <__libbpf_pr>
; 	__libbpf_pr = fn;
    80bb: 48 89 3d 26 f1 03 00         	movq	%rdi, 258342(%rip)      # 0x471e8 <__libbpf_pr>
; }
    80c2: c3                           	retq
    80c3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    80ce: 66 90                        	nop

00000000000080d0 <libbpf_print>:
; {
    80d0: f3 0f 1e fa                  	endbr64
    80d4: 41 56                        	pushq	%r14
    80d6: 41 55                        	pushq	%r13
    80d8: 41 54                        	pushq	%r12
    80da: 49 89 f4                     	movq	%rsi, %r12
    80dd: 55                           	pushq	%rbp
    80de: 89 fd                        	movl	%edi, %ebp
    80e0: 53                           	pushq	%rbx
    80e1: 48 81 ec d0 00 00 00         	subq	$208, %rsp
    80e8: 48 89 54 24 30               	movq	%rdx, 48(%rsp)
    80ed: 48 89 4c 24 38               	movq	%rcx, 56(%rsp)
    80f2: 4c 89 44 24 40               	movq	%r8, 64(%rsp)
    80f7: 4c 89 4c 24 48               	movq	%r9, 72(%rsp)
    80fc: 84 c0                        	testb	%al, %al
    80fe: 74 37                        	je	0x8137 <libbpf_print+0x67>
    8100: 0f 29 44 24 50               	movaps	%xmm0, 80(%rsp)
    8105: 0f 29 4c 24 60               	movaps	%xmm1, 96(%rsp)
    810a: 0f 29 54 24 70               	movaps	%xmm2, 112(%rsp)
    810f: 0f 29 9c 24 80 00 00 00      	movaps	%xmm3, 128(%rsp)
    8117: 0f 29 a4 24 90 00 00 00      	movaps	%xmm4, 144(%rsp)
    811f: 0f 29 ac 24 a0 00 00 00      	movaps	%xmm5, 160(%rsp)
    8127: 0f 29 b4 24 b0 00 00 00      	movaps	%xmm6, 176(%rsp)
    812f: 0f 29 bc 24 c0 00 00 00      	movaps	%xmm7, 192(%rsp)
    8137: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    8140: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    8145: 31 c0                        	xorl	%eax, %eax
; 	if (!__libbpf_pr)
    8147: 4c 8b 2d 9a f0 03 00         	movq	258202(%rip), %r13      # 0x471e8 <__libbpf_pr>
    814e: 4d 85 ed                     	testq	%r13, %r13
    8151: 74 3f                        	je	0x8192 <libbpf_print+0xc2>
; 	old_errno = errno;
    8153: e8 98 d5 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	__libbpf_pr(level, format, args);
    8158: 48 89 e2                     	movq	%rsp, %rdx
    815b: 4c 89 e6                     	movq	%r12, %rsi
    815e: 89 ef                        	movl	%ebp, %edi
; 	old_errno = errno;
    8160: 44 8b 30                     	movl	(%rax), %r14d
    8163: 48 89 c3                     	movq	%rax, %rbx
; 	va_start(args, format);
    8166: 48 8d 84 24 00 01 00 00      	leaq	256(%rsp), %rax
    816e: c7 04 24 10 00 00 00         	movl	$16, (%rsp)
    8175: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    817a: 48 8d 44 24 20               	leaq	32(%rsp), %rax
    817f: c7 44 24 04 30 00 00 00      	movl	$48, 4(%rsp)
    8187: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	__libbpf_pr(level, format, args);
    818c: 41 ff d5                     	callq	*%r13
; 	errno = old_errno;
    818f: 44 89 33                     	movl	%r14d, (%rbx)
; }
    8192: 48 8b 44 24 18               	movq	24(%rsp), %rax
    8197: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    81a0: 75 10                        	jne	0x81b2 <libbpf_print+0xe2>
    81a2: 48 81 c4 d0 00 00 00         	addq	$208, %rsp
    81a9: 5b                           	popq	%rbx
    81aa: 5d                           	popq	%rbp
    81ab: 41 5c                        	popq	%r12
    81ad: 41 5d                        	popq	%r13
    81af: 41 5e                        	popq	%r14
    81b1: c3                           	retq
    81b2: e8 49 d6 ff ff               	callq	0x5800 <.plt.sec+0x190>
    81b7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

00000000000081c0 <bpf_get_map_info_from_fdinfo>:
; {
    81c0: 41 57                        	pushq	%r15
    81c2: 41 56                        	pushq	%r14
    81c4: 41 55                        	pushq	%r13
    81c6: 41 54                        	pushq	%r12
    81c8: 55                           	pushq	%rbp
    81c9: 53                           	pushq	%rbx
    81ca: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
    81d1: 48 83 0c 24 00               	orq	$0, (%rsp)
    81d6: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
    81dd: 48 83 0c 24 00               	orq	$0, (%rsp)
    81e2: 48 83 ec 28                  	subq	$40, %rsp
    81e6: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    81ef: 48 89 84 24 18 20 00 00      	movq	%rax, 8216(%rsp)
    81f7: 31 c0                        	xorl	%eax, %eax
    81f9: 89 fb                        	movl	%edi, %ebx
    81fb: 49 89 f4                     	movq	%rsi, %r12
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    81fe: 4c 8d 6c 24 10               	leaq	16(%rsp), %r13
; 	snprintf(file, sizeof(file), "/proc/%d/fdinfo/%d", getpid(), fd);
    8203: e8 98 d5 ff ff               	callq	0x57a0 <.plt.sec+0x130>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    8208: 48 83 ec 08                  	subq	$8, %rsp
    820c: ba 01 00 00 00               	movl	$1, %edx
    8211: 4c 89 ef                     	movq	%r13, %rdi
    8214: 53                           	pushq	%rbx
; 	snprintf(file, sizeof(file), "/proc/%d/fdinfo/%d", getpid(), fd);
    8215: 41 89 c1                     	movl	%eax, %r9d
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    8218: 4c 8d 05 8a 9a 02 00         	leaq	170634(%rip), %r8       # 0x31ca9 <_IO_stdin_used+0x1ca9>
    821f: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
    8224: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
    8229: 31 c0                        	xorl	%eax, %eax
    822b: e8 80 d4 ff ff               	callq	0x56b0 <.plt.sec+0x40>
;   return __builtin___memset_chk (__dest, __ch, __len,
    8230: 31 c0                        	xorl	%eax, %eax
    8232: b9 0b 00 00 00               	movl	$11, %ecx
    8237: 4c 89 e7                     	movq	%r12, %rdi
    823a: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	fp = fopen(file, "r");
    823d: 48 8d 35 c5 99 02 00         	leaq	170437(%rip), %rsi      # 0x31c09 <_IO_stdin_used+0x1c09>
    8244: 4c 89 ef                     	movq	%r13, %rdi
    8247: e8 c4 d7 ff ff               	callq	0x5a10 <.plt.sec+0x3a0>
; 	if (!fp) {
    824c: 5a                           	popq	%rdx
    824d: 59                           	popq	%rcx
    824e: 48 85 c0                     	testq	%rax, %rax
    8251: 0f 84 44 01 00 00            	je	0x839b <bpf_get_map_info_from_fdinfo+0x1db>
    8257: 48 89 c5                     	movq	%rax, %rbp
    825a: 48 8d 9c 24 10 10 00 00      	leaq	4112(%rsp), %rbx
; 		if (sscanf(buff, "map_type:\t%u", &val) == 1)
    8262: 4c 8d 2d 53 9a 02 00         	leaq	170579(%rip), %r13      # 0x31cbc <_IO_stdin_used+0x1cbc>
; 		else if (sscanf(buff, "key_size:\t%u", &val) == 1)
    8269: 4c 8d 35 59 9a 02 00         	leaq	170585(%rip), %r14      # 0x31cc9 <_IO_stdin_used+0x1cc9>
;     return __fgets_alias (__s, __n, __stream);
    8270: 48 89 ea                     	movq	%rbp, %rdx
    8273: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
    8278: 48 89 df                     	movq	%rbx, %rdi
    827b: e8 f0 d6 ff ff               	callq	0x5970 <.plt.sec+0x300>
; 	while (fgets(buff, sizeof(buff), fp)) {
    8280: 48 85 c0                     	testq	%rax, %rax
    8283: 74 7b                        	je	0x8300 <bpf_get_map_info_from_fdinfo+0x140>
; 		if (sscanf(buff, "map_type:\t%u", &val) == 1)
    8285: 4c 8d 7c 24 0c               	leaq	12(%rsp), %r15
    828a: 31 c0                        	xorl	%eax, %eax
    828c: 4c 89 ee                     	movq	%r13, %rsi
    828f: 48 89 df                     	movq	%rbx, %rdi
    8292: 4c 89 fa                     	movq	%r15, %rdx
    8295: e8 26 d8 ff ff               	callq	0x5ac0 <.plt.sec+0x450>
    829a: 83 f8 01                     	cmpl	$1, %eax
    829d: 75 11                        	jne	0x82b0 <bpf_get_map_info_from_fdinfo+0xf0>
; 			info->type = val;
    829f: 8b 44 24 0c                  	movl	12(%rsp), %eax
    82a3: 41 89 04 24                  	movl	%eax, (%r12)
    82a7: eb c7                        	jmp	0x8270 <bpf_get_map_info_from_fdinfo+0xb0>
    82a9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		else if (sscanf(buff, "key_size:\t%u", &val) == 1)
    82b0: 31 c0                        	xorl	%eax, %eax
    82b2: 4c 89 fa                     	movq	%r15, %rdx
    82b5: 4c 89 f6                     	movq	%r14, %rsi
    82b8: 48 89 df                     	movq	%rbx, %rdi
    82bb: e8 00 d8 ff ff               	callq	0x5ac0 <.plt.sec+0x450>
    82c0: 83 f8 01                     	cmpl	$1, %eax
    82c3: 75 0b                        	jne	0x82d0 <bpf_get_map_info_from_fdinfo+0x110>
; 			info->key_size = val;
    82c5: 8b 44 24 0c                  	movl	12(%rsp), %eax
    82c9: 41 89 44 24 08               	movl	%eax, 8(%r12)
    82ce: eb a0                        	jmp	0x8270 <bpf_get_map_info_from_fdinfo+0xb0>
; 		else if (sscanf(buff, "value_size:\t%u", &val) == 1)
    82d0: 31 c0                        	xorl	%eax, %eax
    82d2: 4c 89 fa                     	movq	%r15, %rdx
    82d5: 48 8d 35 fa 99 02 00         	leaq	170490(%rip), %rsi      # 0x31cd6 <_IO_stdin_used+0x1cd6>
    82dc: 48 89 df                     	movq	%rbx, %rdi
    82df: e8 dc d7 ff ff               	callq	0x5ac0 <.plt.sec+0x450>
    82e4: 83 f8 01                     	cmpl	$1, %eax
    82e7: 75 57                        	jne	0x8340 <bpf_get_map_info_from_fdinfo+0x180>
; 			info->value_size = val;
    82e9: 8b 44 24 0c                  	movl	12(%rsp), %eax
    82ed: 41 89 44 24 0c               	movl	%eax, 12(%r12)
    82f2: e9 79 ff ff ff               	jmp	0x8270 <bpf_get_map_info_from_fdinfo+0xb0>
    82f7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	fclose(fp);
    8300: 48 89 ef                     	movq	%rbp, %rdi
; 	return 0;
    8303: 45 31 e4                     	xorl	%r12d, %r12d
; 	fclose(fp);
    8306: e8 b5 d4 ff ff               	callq	0x57c0 <.plt.sec+0x150>
; }
    830b: 48 8b 84 24 18 20 00 00      	movq	8216(%rsp), %rax
    8313: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    831c: 0f 85 9f 00 00 00            	jne	0x83c1 <bpf_get_map_info_from_fdinfo+0x201>
    8322: 48 81 c4 28 20 00 00         	addq	$8232, %rsp             # imm = 0x2028
    8329: 44 89 e0                     	movl	%r12d, %eax
    832c: 5b                           	popq	%rbx
    832d: 5d                           	popq	%rbp
    832e: 41 5c                        	popq	%r12
    8330: 41 5d                        	popq	%r13
    8332: 41 5e                        	popq	%r14
    8334: 41 5f                        	popq	%r15
    8336: c3                           	retq
    8337: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		else if (sscanf(buff, "max_entries:\t%u", &val) == 1)
    8340: 31 c0                        	xorl	%eax, %eax
    8342: 4c 89 fa                     	movq	%r15, %rdx
    8345: 48 8d 35 99 99 02 00         	leaq	170393(%rip), %rsi      # 0x31ce5 <_IO_stdin_used+0x1ce5>
    834c: 48 89 df                     	movq	%rbx, %rdi
    834f: e8 6c d7 ff ff               	callq	0x5ac0 <.plt.sec+0x450>
    8354: 83 f8 01                     	cmpl	$1, %eax
    8357: 75 17                        	jne	0x8370 <bpf_get_map_info_from_fdinfo+0x1b0>
; 			info->max_entries = val;
    8359: 8b 44 24 0c                  	movl	12(%rsp), %eax
    835d: 41 89 44 24 10               	movl	%eax, 16(%r12)
    8362: e9 09 ff ff ff               	jmp	0x8270 <bpf_get_map_info_from_fdinfo+0xb0>
    8367: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		else if (sscanf(buff, "map_flags:\t%i", &val) == 1)
    8370: 31 c0                        	xorl	%eax, %eax
    8372: 4c 89 fa                     	movq	%r15, %rdx
    8375: 48 8d 35 79 99 02 00         	leaq	170361(%rip), %rsi      # 0x31cf5 <_IO_stdin_used+0x1cf5>
    837c: 48 89 df                     	movq	%rbx, %rdi
    837f: e8 3c d7 ff ff               	callq	0x5ac0 <.plt.sec+0x450>
    8384: 83 f8 01                     	cmpl	$1, %eax
    8387: 0f 85 e3 fe ff ff            	jne	0x8270 <bpf_get_map_info_from_fdinfo+0xb0>
; 			info->map_flags = val;
    838d: 8b 44 24 0c                  	movl	12(%rsp), %eax
    8391: 41 89 44 24 14               	movl	%eax, 20(%r12)
    8396: e9 d5 fe ff ff               	jmp	0x8270 <bpf_get_map_info_from_fdinfo+0xb0>
; 		err = -errno;
    839b: e8 50 d3 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to open %s: %d. No procfs support?\n", file,
    83a0: 4c 89 ea                     	movq	%r13, %rdx
    83a3: 48 8d 35 8e ab 02 00         	leaq	174990(%rip), %rsi      # 0x32f38 <strs.2+0xa8>
    83aa: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
    83ac: 44 8b 20                     	movl	(%rax), %r12d
; 		pr_warn("failed to open %s: %d. No procfs support?\n", file,
    83af: 31 c0                        	xorl	%eax, %eax
; 		err = -errno;
    83b1: 41 f7 dc                     	negl	%r12d
; 		pr_warn("failed to open %s: %d. No procfs support?\n", file,
    83b4: 44 89 e1                     	movl	%r12d, %ecx
    83b7: e8 14 fd ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
    83bc: e9 4a ff ff ff               	jmp	0x830b <bpf_get_map_info_from_fdinfo+0x14b>
; }
    83c1: e8 3a d4 ff ff               	callq	0x5800 <.plt.sec+0x190>
    83c6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

00000000000083d0 <parse_uint_from_file>:
; {
    83d0: 41 55                        	pushq	%r13
    83d2: 49 89 f5                     	movq	%rsi, %r13
; 	f = fopen(file, "r");
    83d5: 48 8d 35 2d 98 02 00         	leaq	170029(%rip), %rsi      # 0x31c09 <_IO_stdin_used+0x1c09>
; {
    83dc: 41 54                        	pushq	%r12
    83de: 49 89 fc                     	movq	%rdi, %r12
    83e1: 55                           	pushq	%rbp
    83e2: 48 81 ec a0 00 00 00         	subq	$160, %rsp
    83e9: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    83f2: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
    83fa: 31 c0                        	xorl	%eax, %eax
; 	f = fopen(file, "r");
    83fc: e8 0f d6 ff ff               	callq	0x5a10 <.plt.sec+0x3a0>
; 	if (!f) {
    8401: 48 85 c0                     	testq	%rax, %rax
    8404: 0f 84 95 00 00 00            	je	0x849f <parse_uint_from_file+0xcf>
    840a: 48 89 c5                     	movq	%rax, %rbp
; 	err = fscanf(f, fmt, &ret);
    840d: 48 89 c7                     	movq	%rax, %rdi
    8410: 48 8d 54 24 0c               	leaq	12(%rsp), %rdx
    8415: 31 c0                        	xorl	%eax, %eax
    8417: 4c 89 ee                     	movq	%r13, %rsi
    841a: e8 c1 d4 ff ff               	callq	0x58e0 <.plt.sec+0x270>
; 	if (err != 1) {
    841f: 83 f8 01                     	cmpl	$1, %eax
    8422: 74 6c                        	je	0x8490 <parse_uint_from_file+0xc0>
; 		err = err == EOF ? -EIO : -errno;
    8424: 41 bd fb ff ff ff            	movl	$4294967291, %r13d      # imm = 0xFFFFFFFB
    842a: 83 f8 ff                     	cmpl	$-1, %eax
    842d: 74 0b                        	je	0x843a <parse_uint_from_file+0x6a>
    842f: e8 bc d2 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    8434: 44 8b 28                     	movl	(%rax), %r13d
    8437: 41 f7 dd                     	negl	%r13d
; 		pr_debug("failed to parse '%s': %s\n", file,
    843a: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
    843f: ba 80 00 00 00               	movl	$128, %edx
    8444: 44 89 ef                     	movl	%r13d, %edi
    8447: e8 84 55 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
    844c: bf 02 00 00 00               	movl	$2, %edi
    8451: 4c 89 e2                     	movq	%r12, %rdx
    8454: 48 8d 35 3d ab 02 00         	leaq	174909(%rip), %rsi      # 0x32f98 <strs.2+0x108>
    845b: 48 89 c1                     	movq	%rax, %rcx
    845e: 31 c0                        	xorl	%eax, %eax
    8460: e8 6b fc ff ff               	callq	0x80d0 <libbpf_print>
; 		fclose(f);
    8465: 48 89 ef                     	movq	%rbp, %rdi
    8468: e8 53 d3 ff ff               	callq	0x57c0 <.plt.sec+0x150>
; }
    846d: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
    8475: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    847e: 75 57                        	jne	0x84d7 <parse_uint_from_file+0x107>
    8480: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
    8487: 44 89 e8                     	movl	%r13d, %eax
    848a: 5d                           	popq	%rbp
    848b: 41 5c                        	popq	%r12
    848d: 41 5d                        	popq	%r13
    848f: c3                           	retq
; 	fclose(f);
    8490: 48 89 ef                     	movq	%rbp, %rdi
    8493: e8 28 d3 ff ff               	callq	0x57c0 <.plt.sec+0x150>
; 	return ret;
    8498: 44 8b 6c 24 0c               	movl	12(%rsp), %r13d
    849d: eb ce                        	jmp	0x846d <parse_uint_from_file+0x9d>
; 		err = -errno;
    849f: e8 4c d2 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_debug("failed to open '%s': %s\n", file,
    84a4: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
    84a9: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
    84ae: 44 8b 28                     	movl	(%rax), %r13d
    84b1: 41 f7 dd                     	negl	%r13d
; 		pr_debug("failed to open '%s': %s\n", file,
    84b4: 44 89 ef                     	movl	%r13d, %edi
    84b7: e8 14 55 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
    84bc: 4c 89 e2                     	movq	%r12, %rdx
    84bf: bf 02 00 00 00               	movl	$2, %edi
    84c4: 48 8d 35 a5 aa 02 00         	leaq	174757(%rip), %rsi      # 0x32f70 <strs.2+0xe0>
    84cb: 48 89 c1                     	movq	%rax, %rcx
    84ce: 31 c0                        	xorl	%eax, %eax
    84d0: e8 fb fb ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
    84d5: eb 96                        	jmp	0x846d <parse_uint_from_file+0x9d>
; }
    84d7: e8 24 d3 ff ff               	callq	0x5800 <.plt.sec+0x190>
    84dc: 0f 1f 40 00                  	nopl	(%rax)

00000000000084e0 <perf_event_open_probe>:
; {
    84e0: 41 57                        	pushq	%r15
    84e2: 41 56                        	pushq	%r14
    84e4: 41 55                        	pushq	%r13
    84e6: 41 54                        	pushq	%r12
    84e8: 55                           	pushq	%rbp
    84e9: 53                           	pushq	%rbx
    84ea: 48 81 ec 28 01 00 00         	subq	$296, %rsp              # imm = 0x128
    84f1: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
; 	if (ref_ctr_off >= (1ULL << PERF_UPROBE_REF_CTR_OFFSET_BITS))
    84f6: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    84ff: 48 89 84 24 18 01 00 00      	movq	%rax, 280(%rsp)
    8507: 4c 89 c8                     	movq	%r9, %rax
    850a: 48 c1 e8 20                  	shrq	$32, %rax
    850e: 0f 85 2c 02 00 00            	jne	0x8740 <perf_event_open_probe+0x260>
;   return __builtin___memset_chk (__dest, __ch, __len,
    8514: 4c 8d 74 24 10               	leaq	16(%rsp), %r14
    8519: 41 89 fa                     	movl	%edi, %r10d
    851c: 49 89 cf                     	movq	%rcx, %r15
    851f: 31 c0                        	xorl	%eax, %eax
    8521: b9 10 00 00 00               	movl	$16, %ecx
    8526: 4c 89 f7                     	movq	%r14, %rdi
    8529: 41 89 f5                     	movl	%esi, %r13d
    852c: 44 89 c5                     	movl	%r8d, %ebp
    852f: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
    8532: 4c 89 cb                     	movq	%r9, %rbx
; 	return parse_uint_from_file(file, "%d\n");
    8535: 48 8d 35 08 0d 03 00         	leaq	199944(%rip), %rsi      # 0x39244 <strs.2+0x63b4>
; 		      : determine_kprobe_perf_type();
    853c: 45 84 d2                     	testb	%r10b, %r10b
    853f: 0f 84 eb 00 00 00            	je	0x8630 <perf_event_open_probe+0x150>
; 	return parse_uint_from_file(file, "%d\n");
    8545: 48 8d 3d 74 aa 02 00         	leaq	174708(%rip), %rdi      # 0x32fc0 <strs.2+0x130>
    854c: e8 7f fe ff ff               	callq	0x83d0 <parse_uint_from_file>
    8551: 41 89 c4                     	movl	%eax, %r12d
; 	if (type < 0) {
    8554: 85 c0                        	testl	%eax, %eax
    8556: 0f 88 44 01 00 00            	js	0x86a0 <perf_event_open_probe+0x1c0>
; 	if (retprobe) {
    855c: 45 84 ed                     	testb	%r13b, %r13b
    855f: 0f 84 2b 01 00 00            	je	0x8690 <perf_event_open_probe+0x1b0>
; 	return parse_uint_from_file(file, "config:%d\n");
    8565: 48 8d 35 a5 97 02 00         	leaq	169893(%rip), %rsi      # 0x31d11 <_IO_stdin_used+0x1d11>
    856c: 48 8d 3d dd aa 02 00         	leaq	174813(%rip), %rdi      # 0x33050 <strs.2+0x1c0>
    8573: e8 58 fe ff ff               	callq	0x83d0 <parse_uint_from_file>
    8578: 41 89 c5                     	movl	%eax, %r13d
; 		if (bit < 0) {
    857b: 85 c0                        	testl	%eax, %eax
    857d: 0f 88 7d 01 00 00            	js	0x8700 <perf_event_open_probe+0x220>
; 		attr.config |= 1 << bit;
    8583: b8 01 00 00 00               	movl	$1, %eax
    8588: 44 89 e9                     	movl	%r13d, %ecx
    858b: d3 e0                        	shll	%cl, %eax
    858d: 48 98                        	cltq
    858f: 48 0b 44 24 18               	orq	24(%rsp), %rax
; 	attr.config |= (__u64)ref_ctr_off << PERF_UPROBE_REF_CTR_OFFSET_SHIFT;
    8594: 48 c1 e3 20                  	shlq	$32, %rbx
; 	pfd = syscall(__NR_perf_event_open, &attr,
    8598: 31 c9                        	xorl	%ecx, %ecx
    859a: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
    859f: 4c 89 f6                     	movq	%r14, %rsi
; 	attr.config |= (__u64)ref_ctr_off << PERF_UPROBE_REF_CTR_OFFSET_SHIFT;
    85a2: 48 09 c3                     	orq	%rax, %rbx
; 	pfd = syscall(__NR_perf_event_open, &attr,
    85a5: 83 fd ff                     	cmpl	$-1, %ebp
; 	attr.config1 = ptr_to_u64(name); /* kprobe_func or uprobe_path */
    85a8: 48 8b 44 24 08               	movq	8(%rsp), %rax
; 	pfd = syscall(__NR_perf_event_open, &attr,
    85ad: 41 b9 08 00 00 00            	movl	$8, %r9d
    85b3: 0f 95 c1                     	setne	%cl
    85b6: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
    85bc: bf 2a 01 00 00               	movl	$298, %edi              # imm = 0x12A
; 	attr.type = type;
    85c1: 44 89 64 24 10               	movl	%r12d, 16(%rsp)
; 	pfd = syscall(__NR_perf_event_open, &attr,
    85c6: f7 d9                        	negl	%ecx
    85c8: 85 ed                        	testl	%ebp, %ebp
; 	attr.config1 = ptr_to_u64(name); /* kprobe_func or uprobe_path */
    85ca: 48 89 44 24 48               	movq	%rax, 72(%rsp)
; 	pfd = syscall(__NR_perf_event_open, &attr,
    85cf: 0f 49 d5                     	cmovnsl	%ebp, %edx
    85d2: 31 c0                        	xorl	%eax, %eax
; 	attr.config |= (__u64)ref_ctr_off << PERF_UPROBE_REF_CTR_OFFSET_SHIFT;
    85d4: 48 89 5c 24 18               	movq	%rbx, 24(%rsp)
; 	attr.size = attr_sz;
    85d9: c7 44 24 14 80 00 00 00      	movl	$128, 20(%rsp)
; 	attr.config2 = offset;		 /* kprobe_addr or probe_offset */
    85e1: 4c 89 7c 24 50               	movq	%r15, 80(%rsp)
; 	pfd = syscall(__NR_perf_event_open, &attr,
    85e6: e8 f5 d3 ff ff               	callq	0x59e0 <.plt.sec+0x370>
    85eb: 41 89 c4                     	movl	%eax, %r12d
; 	return pfd >= 0 ? pfd : -errno;
    85ee: 85 c0                        	testl	%eax, %eax
    85f0: 79 0b                        	jns	0x85fd <perf_event_open_probe+0x11d>
    85f2: e8 f9 d0 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    85f7: 44 8b 20                     	movl	(%rax), %r12d
    85fa: 41 f7 dc                     	negl	%r12d
; }
    85fd: 48 8b 84 24 18 01 00 00      	movq	280(%rsp), %rax
    8605: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    860e: 0f 85 37 01 00 00            	jne	0x874b <perf_event_open_probe+0x26b>
    8614: 48 81 c4 28 01 00 00         	addq	$296, %rsp              # imm = 0x128
    861b: 44 89 e0                     	movl	%r12d, %eax
    861e: 5b                           	popq	%rbx
    861f: 5d                           	popq	%rbp
    8620: 41 5c                        	popq	%r12
    8622: 41 5d                        	popq	%r13
    8624: 41 5e                        	popq	%r14
    8626: 41 5f                        	popq	%r15
    8628: c3                           	retq
    8629: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return parse_uint_from_file(file, "%d\n");
    8630: 48 8d 3d b9 a9 02 00         	leaq	174521(%rip), %rdi      # 0x32ff0 <strs.2+0x160>
    8637: e8 94 fd ff ff               	callq	0x83d0 <parse_uint_from_file>
    863c: 41 89 c4                     	movl	%eax, %r12d
; 	if (type < 0) {
    863f: 85 c0                        	testl	%eax, %eax
    8641: 0f 88 91 00 00 00            	js	0x86d8 <perf_event_open_probe+0x1f8>
; 	if (retprobe) {
    8647: 45 84 ed                     	testb	%r13b, %r13b
    864a: 74 44                        	je	0x8690 <perf_event_open_probe+0x1b0>
; 	return parse_uint_from_file(file, "config:%d\n");
    864c: 48 8d 35 be 96 02 00         	leaq	169662(%rip), %rsi      # 0x31d11 <_IO_stdin_used+0x1d11>
    8653: 48 8d 3d 2e aa 02 00         	leaq	174638(%rip), %rdi      # 0x33088 <strs.2+0x1f8>
    865a: e8 71 fd ff ff               	callq	0x83d0 <parse_uint_from_file>
    865f: 41 89 c5                     	movl	%eax, %r13d
; 		if (bit < 0) {
    8662: 85 c0                        	testl	%eax, %eax
    8664: 0f 89 19 ff ff ff            	jns	0x8583 <perf_event_open_probe+0xa3>
; 			pr_warn("failed to determine %s retprobe bit: %s\n",
    866a: ba 80 00 00 00               	movl	$128, %edx
    866f: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
    8677: 89 c7                        	movl	%eax, %edi
    8679: 45 89 ec                     	movl	%r13d, %r12d
    867c: e8 4f 53 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
    8681: 48 8d 15 7b 96 02 00         	leaq	169595(%rip), %rdx      # 0x31d03 <_IO_stdin_used+0x1d03>
    8688: 48 89 c1                     	movq	%rax, %rcx
    868b: e9 91 00 00 00               	jmp	0x8721 <perf_event_open_probe+0x241>
; 	attr.config |= (__u64)ref_ctr_off << PERF_UPROBE_REF_CTR_OFFSET_SHIFT;
    8690: 48 8b 44 24 18               	movq	24(%rsp), %rax
    8695: e9 fa fe ff ff               	jmp	0x8594 <perf_event_open_probe+0xb4>
    869a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("failed to determine %s perf type: %s\n",
    86a0: ba 80 00 00 00               	movl	$128, %edx
    86a5: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
    86ad: 89 c7                        	movl	%eax, %edi
    86af: e8 1c 53 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
    86b4: 48 8d 15 4f 96 02 00         	leaq	169551(%rip), %rdx      # 0x31d0a <_IO_stdin_used+0x1d0a>
    86bb: 48 89 c1                     	movq	%rax, %rcx
    86be: 48 8d 35 5b a9 02 00         	leaq	174427(%rip), %rsi      # 0x33020 <strs.2+0x190>
    86c5: 31 ff                        	xorl	%edi, %edi
    86c7: 31 c0                        	xorl	%eax, %eax
    86c9: e8 02 fa ff ff               	callq	0x80d0 <libbpf_print>
; 		return type;
    86ce: e9 2a ff ff ff               	jmp	0x85fd <perf_event_open_probe+0x11d>
    86d3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("failed to determine %s perf type: %s\n",
    86d8: ba 80 00 00 00               	movl	$128, %edx
    86dd: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
    86e5: 89 c7                        	movl	%eax, %edi
    86e7: e8 e4 52 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
    86ec: 48 8d 15 10 96 02 00         	leaq	169488(%rip), %rdx      # 0x31d03 <_IO_stdin_used+0x1d03>
    86f3: 48 89 c1                     	movq	%rax, %rcx
    86f6: eb c6                        	jmp	0x86be <perf_event_open_probe+0x1de>
    86f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 			pr_warn("failed to determine %s retprobe bit: %s\n",
    8700: ba 80 00 00 00               	movl	$128, %edx
    8705: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
    870d: 89 c7                        	movl	%eax, %edi
    870f: 45 89 ec                     	movl	%r13d, %r12d
    8712: e8 b9 52 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
    8717: 48 8d 15 ec 95 02 00         	leaq	169452(%rip), %rdx      # 0x31d0a <_IO_stdin_used+0x1d0a>
    871e: 48 89 c1                     	movq	%rax, %rcx
    8721: 48 8d 35 98 a9 02 00         	leaq	174488(%rip), %rsi      # 0x330c0 <strs.2+0x230>
    8728: 31 ff                        	xorl	%edi, %edi
    872a: 31 c0                        	xorl	%eax, %eax
    872c: e8 9f f9 ff ff               	callq	0x80d0 <libbpf_print>
; 			return bit;
    8731: e9 c7 fe ff ff               	jmp	0x85fd <perf_event_open_probe+0x11d>
    8736: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		return -EINVAL;
    8740: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
    8746: e9 b2 fe ff ff               	jmp	0x85fd <perf_event_open_probe+0x11d>
; }
    874b: e8 b0 d0 ff ff               	callq	0x5800 <.plt.sec+0x190>

0000000000008750 <probe_kern_syscall_wrapper>:
; {
    8750: f3 0f 1e fa                  	endbr64
    8754: 41 54                        	pushq	%r12
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    8756: be 40 00 00 00               	movl	$64, %esi
    875b: 4c 8d 0d ba 95 02 00         	leaq	169402(%rip), %r9       # 0x31d1c <_IO_stdin_used+0x1d1c>
    8762: 4c 8d 05 b7 95 02 00         	leaq	169399(%rip), %r8       # 0x31d20 <_IO_stdin_used+0x1d20>
; {
    8769: 55                           	pushq	%rbp
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    876a: b9 40 00 00 00               	movl	$64, %ecx
    876f: ba 01 00 00 00               	movl	$1, %edx
; {
    8774: 53                           	pushq	%rbx
    8775: 48 81 ec d0 00 00 00         	subq	$208, %rsp
    877c: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    8785: 48 89 84 24 c8 00 00 00      	movq	%rax, 200(%rsp)
    878d: 31 c0                        	xorl	%eax, %eax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    878f: 49 89 e4                     	movq	%rsp, %r12
    8792: 4c 89 e7                     	movq	%r12, %rdi
    8795: e8 16 cf ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	return parse_uint_from_file(file, "%d\n");
    879a: 48 8d 35 a3 0a 03 00         	leaq	199331(%rip), %rsi      # 0x39244 <strs.2+0x63b4>
    87a1: 48 8d 3d 48 a8 02 00         	leaq	174152(%rip), %rdi      # 0x32ff0 <strs.2+0x160>
    87a8: e8 23 fc ff ff               	callq	0x83d0 <parse_uint_from_file>
; 	if (determine_kprobe_perf_type() >= 0) {
    87ad: 85 c0                        	testl	%eax, %eax
    87af: 0f 89 d3 00 00 00            	jns	0x8888 <probe_kern_syscall_wrapper+0x138>
; 		 __sync_fetch_and_add(&index, 1));
    87b5: bb 01 00 00 00               	movl	$1, %ebx
    87ba: f0                           	lock
    87bb: 0f c1 1d 62 ea 03 00         	xaddl	%ebx, 256610(%rip)      # 0x47224 <index.0>
; 	snprintf(buf, buf_sz, "libbpf_%u_%s_0x%zx_%d", getpid(), kfunc_name, offset,
    87c2: e8 d9 cf ff ff               	callq	0x57a0 <.plt.sec+0x130>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    87c7: 48 8d 6c 24 40               	leaq	64(%rsp), %rbp
    87cc: 48 83 ec 08                  	subq	$8, %rsp
    87d0: 4c 8d 05 56 95 02 00         	leaq	169302(%rip), %r8       # 0x31d2d <_IO_stdin_used+0x1d2d>
    87d7: 53                           	pushq	%rbx
; 	snprintf(buf, buf_sz, "libbpf_%u_%s_0x%zx_%d", getpid(), kfunc_name, offset,
    87d8: 41 89 c1                     	movl	%eax, %r9d
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    87db: b9 80 00 00 00               	movl	$128, %ecx
    87e0: ba 01 00 00 00               	movl	$1, %edx
    87e5: 6a 00                        	pushq	$0
    87e7: be 80 00 00 00               	movl	$128, %esi
    87ec: 48 89 ef                     	movq	%rbp, %rdi
    87ef: 31 c0                        	xorl	%eax, %eax
    87f1: 41 54                        	pushq	%r12
    87f3: e8 b8 ce ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (has_debugfs < 0)
    87f8: 8b 05 12 e8 03 00            	movl	256018(%rip), %eax      # 0x47010 <has_debugfs.1>
    87fe: 48 83 c4 20                  	addq	$32, %rsp
    8802: 85 c0                        	testl	%eax, %eax
    8804: 0f 88 b6 00 00 00            	js	0x88c0 <probe_kern_syscall_wrapper+0x170>
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
    880a: 83 f8 01                     	cmpl	$1, %eax
    880d: 48 8d 3d 84 a6 02 00         	leaq	173700(%rip), %rdi      # 0x32e98 <strs.2+0x8>
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
    8814: 49 89 e8                     	movq	%rbp, %r8
    8817: 4d 89 e1                     	movq	%r12, %r9
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
    881a: 48 8d 05 9f a6 02 00         	leaq	173727(%rip), %rax      # 0x32ec0 <strs.2+0x30>
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
    8821: ba 70 00 00 00               	movl	$112, %edx
    8826: 48 8d 0d 3f 94 02 00         	leaq	169023(%rip), %rcx      # 0x31c6c <_IO_stdin_used+0x1c6c>
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
    882d: 48 0f 45 f8                  	cmovneq	%rax, %rdi
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
    8831: 48 83 ec 08                  	subq	$8, %rsp
    8835: 48 8d 35 07 95 02 00         	leaq	169223(%rip), %rsi      # 0x31d43 <_IO_stdin_used+0x1d43>
    883c: 31 c0                        	xorl	%eax, %eax
    883e: 6a 00                        	pushq	$0
    8840: e8 6b df ff ff               	callq	0x67b0 <append_to_file>
    8845: 41 89 c0                     	movl	%eax, %r8d
; 		if (add_kprobe_event_legacy(probe_name, false, syscall_name, 0) < 0)
    8848: 58                           	popq	%rax
; 			return 0;
    8849: 31 c0                        	xorl	%eax, %eax
; 		if (add_kprobe_event_legacy(probe_name, false, syscall_name, 0) < 0)
    884b: 5a                           	popq	%rdx
    884c: 45 85 c0                     	testl	%r8d, %r8d
    884f: 79 1f                        	jns	0x8870 <probe_kern_syscall_wrapper+0x120>
; }
    8851: 48 8b 94 24 c8 00 00 00      	movq	200(%rsp), %rdx
    8859: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    8862: 75 7d                        	jne	0x88e1 <probe_kern_syscall_wrapper+0x191>
    8864: 48 81 c4 d0 00 00 00         	addq	$208, %rsp
    886b: 5b                           	popq	%rbx
    886c: 5d                           	popq	%rbp
    886d: 41 5c                        	popq	%r12
    886f: c3                           	retq
; 		(void)remove_kprobe_event_legacy(probe_name, false);
    8870: 31 f6                        	xorl	%esi, %esi
    8872: 48 89 ef                     	movq	%rbp, %rdi
    8875: e8 a6 f3 ff ff               	callq	0x7c20 <remove_kprobe_event_legacy>
; 		return 1;
    887a: b8 01 00 00 00               	movl	$1, %eax
    887f: eb d0                        	jmp	0x8851 <probe_kern_syscall_wrapper+0x101>
    8881: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pfd = perf_event_open_probe(false, false, syscall_name, 0, getpid(), 0);
    8888: e8 13 cf ff ff               	callq	0x57a0 <.plt.sec+0x130>
    888d: 45 31 c9                     	xorl	%r9d, %r9d
    8890: 31 c9                        	xorl	%ecx, %ecx
    8892: 4c 89 e2                     	movq	%r12, %rdx
    8895: 41 89 c0                     	movl	%eax, %r8d
    8898: 31 f6                        	xorl	%esi, %esi
    889a: 31 ff                        	xorl	%edi, %edi
    889c: e8 3f fc ff ff               	callq	0x84e0 <perf_event_open_probe>
    88a1: 89 c3                        	movl	%eax, %ebx
; 		if (pfd >= 0)
    88a3: 85 c0                        	testl	%eax, %eax
    88a5: 78 07                        	js	0x88ae <probe_kern_syscall_wrapper+0x15e>
; 			close(pfd);
    88a7: 89 c7                        	movl	%eax, %edi
    88a9: e8 52 d0 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 		return pfd >= 0 ? 1 : 0;
    88ae: 89 d8                        	movl	%ebx, %eax
    88b0: f7 d0                        	notl	%eax
    88b2: c1 e8 1f                     	shrl	$31, %eax
    88b5: eb 9a                        	jmp	0x8851 <probe_kern_syscall_wrapper+0x101>
    88b7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
    88c0: 31 f6                        	xorl	%esi, %esi
    88c2: 48 8d 3d ab 93 02 00         	leaq	168875(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
    88c9: e8 d2 d2 ff ff               	callq	0x5ba0 <.plt.sec+0x530>
    88ce: 85 c0                        	testl	%eax, %eax
    88d0: 0f 94 c0                     	sete	%al
    88d3: 0f b6 c0                     	movzbl	%al, %eax
    88d6: 89 05 34 e7 03 00            	movl	%eax, 255796(%rip)      # 0x47010 <has_debugfs.1>
    88dc: e9 29 ff ff ff               	jmp	0x880a <probe_kern_syscall_wrapper+0xba>
; }
    88e1: e8 1a cf ff ff               	callq	0x5800 <.plt.sec+0x190>
    88e6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

00000000000088f0 <probe_prog_bind_map>:
; {
    88f0: f3 0f 1e fa                  	endbr64
    88f4: 41 55                        	pushq	%r13
; 	map = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_det_bind", sizeof(int), 32, 1, NULL);
    88f6: 45 31 c9                     	xorl	%r9d, %r9d
    88f9: 41 b8 01 00 00 00            	movl	$1, %r8d
    88ff: b9 20 00 00 00               	movl	$32, %ecx
; {
    8904: 41 54                        	pushq	%r12
; 	map = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_det_bind", sizeof(int), 32, 1, NULL);
    8906: ba 04 00 00 00               	movl	$4, %edx
    890b: bf 02 00 00 00               	movl	$2, %edi
    8910: 48 8d 35 3e 94 02 00         	leaq	169022(%rip), %rsi      # 0x31d55 <_IO_stdin_used+0x1d55>
; {
    8917: 55                           	pushq	%rbp
    8918: 48 81 ec a0 00 00 00         	subq	$160, %rsp
    891f: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    8928: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
    8930: 31 c0                        	xorl	%eax, %eax
; 	struct bpf_insn insns[] = {
    8932: 48 c7 04 24 b7 00 00 00      	movq	$183, (%rsp)
    893a: 48 c7 44 24 08 95 00 00 00   	movq	$149, 8(%rsp)
; 	map = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_det_bind", sizeof(int), 32, 1, NULL);
    8943: e8 58 cf 01 00               	callq	0x258a0 <bpf_map_create>
; 	if (map < 0) {
    8948: 85 c0                        	testl	%eax, %eax
    894a: 78 74                        	js	0x89c0 <probe_prog_bind_map+0xd0>
; 	prog = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, "GPL", insns, insn_cnt, NULL);
    894c: 48 89 e1                     	movq	%rsp, %rcx
    894f: 45 31 c9                     	xorl	%r9d, %r9d
    8952: 41 b8 02 00 00 00            	movl	$2, %r8d
    8958: 31 f6                        	xorl	%esi, %esi
    895a: 48 8d 15 d9 92 02 00         	leaq	168665(%rip), %rdx      # 0x31c3a <_IO_stdin_used+0x1c3a>
    8961: bf 01 00 00 00               	movl	$1, %edi
    8966: 89 c5                        	movl	%eax, %ebp
    8968: e8 e3 d2 01 00               	callq	0x25c50 <bpf_prog_load>
    896d: 41 89 c5                     	movl	%eax, %r13d
; 	if (prog < 0) {
    8970: 85 c0                        	testl	%eax, %eax
    8972: 0f 88 88 00 00 00            	js	0x8a00 <probe_prog_bind_map+0x110>
; 	ret = bpf_prog_bind_map(prog, map, NULL);
    8978: 31 d2                        	xorl	%edx, %edx
    897a: 89 ee                        	movl	%ebp, %esi
    897c: 89 c7                        	movl	%eax, %edi
    897e: e8 bd fe 01 00               	callq	0x28840 <bpf_prog_bind_map>
; 	close(map);
    8983: 89 ef                        	movl	%ebp, %edi
; 	ret = bpf_prog_bind_map(prog, map, NULL);
    8985: 41 89 c4                     	movl	%eax, %r12d
; 	close(map);
    8988: e8 73 cf ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return ret >= 0;
    898d: 41 f7 d4                     	notl	%r12d
; 	close(prog);
    8990: 44 89 ef                     	movl	%r13d, %edi
    8993: e8 68 cf ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	return ret >= 0;
    8998: 41 c1 ec 1f                  	shrl	$31, %r12d
; }
    899c: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
    89a4: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    89ad: 75 5d                        	jne	0x8a0c <probe_prog_bind_map+0x11c>
    89af: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
    89b6: 44 89 e0                     	movl	%r12d, %eax
    89b9: 5d                           	popq	%rbp
    89ba: 41 5c                        	popq	%r12
    89bc: 41 5d                        	popq	%r13
    89be: c3                           	retq
    89bf: 90                           	nop
; 		ret = -errno;
    89c0: e8 2b cd ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
    89c5: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
    89ca: ba 80 00 00 00               	movl	$128, %edx
; 		ret = -errno;
    89cf: 8b 28                        	movl	(%rax), %ebp
    89d1: 41 89 ec                     	movl	%ebp, %r12d
    89d4: 41 f7 dc                     	negl	%r12d
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
    89d7: 44 89 e7                     	movl	%r12d, %edi
    89da: e8 f1 4f 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("Error in %s():%s(%d). Couldn't create simple array map.\n",
    89df: 41 89 e8                     	movl	%ebp, %r8d
    89e2: 48 8d 15 77 a4 02 00         	leaq	173175(%rip), %rdx      # 0x32e60 <__func__.7>
    89e9: 31 ff                        	xorl	%edi, %edi
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
    89eb: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("Error in %s():%s(%d). Couldn't create simple array map.\n",
    89ee: 48 8d 35 03 a7 02 00         	leaq	173827(%rip), %rsi      # 0x330f8 <strs.2+0x268>
    89f5: 31 c0                        	xorl	%eax, %eax
    89f7: e8 d4 f6 ff ff               	callq	0x80d0 <libbpf_print>
; 		return ret;
    89fc: eb 9e                        	jmp	0x899c <probe_prog_bind_map+0xac>
    89fe: 66 90                        	nop
; 		close(map);
    8a00: 89 ef                        	movl	%ebp, %edi
; 		return 0;
    8a02: 45 31 e4                     	xorl	%r12d, %r12d
; 		close(map);
    8a05: e8 f6 ce ff ff               	callq	0x5900 <.plt.sec+0x290>
; 		return 0;
    8a0a: eb 90                        	jmp	0x899c <probe_prog_bind_map+0xac>
; }
    8a0c: e8 ef cd ff ff               	callq	0x5800 <.plt.sec+0x190>
    8a11: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    8a1c: 0f 1f 40 00                  	nopl	(%rax)

0000000000008a20 <probe_kern_global_data>:
; {
    8a20: f3 0f 1e fa                  	endbr64
    8a24: 41 54                        	pushq	%r12
; 	map = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_global", sizeof(int), 32, 1, NULL);
    8a26: 45 31 c9                     	xorl	%r9d, %r9d
    8a29: 41 b8 01 00 00 00            	movl	$1, %r8d
    8a2f: b9 20 00 00 00               	movl	$32, %ecx
; {
    8a34: 53                           	pushq	%rbx
; 	map = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_global", sizeof(int), 32, 1, NULL);
    8a35: ba 04 00 00 00               	movl	$4, %edx
    8a3a: bf 02 00 00 00               	movl	$2, %edi
    8a3f: 48 8d 35 1f 93 02 00         	leaq	168735(%rip), %rsi      # 0x31d65 <_IO_stdin_used+0x1d65>
; {
    8a46: 48 81 ec c8 00 00 00         	subq	$200, %rsp
    8a4d: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    8a56: 48 89 84 24 b8 00 00 00      	movq	%rax, 184(%rsp)
    8a5e: 31 c0                        	xorl	%eax, %eax
; 	struct bpf_insn insns[] = {
    8a60: 48 c7 04 24 18 21 00 00      	movq	$8472, (%rsp)           # imm = 0x2118
    8a68: 48 b8 00 00 00 00 10 00 00 00	movabsq	$68719476736, %rax      # imm = 0x1000000000
    8a72: 48 89 44 24 08               	movq	%rax, 8(%rsp)
    8a77: 48 b8 7a 01 00 00 2a 00 00 00	movabsq	$180388626810, %rax     # imm = 0x2A0000017A
    8a81: 48 89 44 24 10               	movq	%rax, 16(%rsp)
    8a86: 48 c7 44 24 18 b7 00 00 00   	movq	$183, 24(%rsp)
    8a8f: 48 c7 44 24 20 95 00 00 00   	movq	$149, 32(%rsp)
; 	map = bpf_map_create(BPF_MAP_TYPE_ARRAY, "libbpf_global", sizeof(int), 32, 1, NULL);
    8a98: e8 03 ce 01 00               	callq	0x258a0 <bpf_map_create>
; 	if (map < 0) {
    8a9d: 85 c0                        	testl	%eax, %eax
    8a9f: 78 6f                        	js	0x8b10 <probe_kern_global_data+0xf0>
; 	ret = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, "GPL", insns, insn_cnt, NULL);
    8aa1: 45 31 c9                     	xorl	%r9d, %r9d
    8aa4: 31 f6                        	xorl	%esi, %esi
    8aa6: bf 01 00 00 00               	movl	$1, %edi
    8aab: 48 89 e1                     	movq	%rsp, %rcx
    8aae: 41 b8 05 00 00 00            	movl	$5, %r8d
    8ab4: 48 8d 15 7f 91 02 00         	leaq	168319(%rip), %rdx      # 0x31c3a <_IO_stdin_used+0x1c3a>
    8abb: 41 89 c4                     	movl	%eax, %r12d
; 	insns[0].imm = map;
    8abe: 89 44 24 04                  	movl	%eax, 4(%rsp)
; 	ret = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, "GPL", insns, insn_cnt, NULL);
    8ac2: e8 89 d1 01 00               	callq	0x25c50 <bpf_prog_load>
; 	close(map);
    8ac7: 44 89 e7                     	movl	%r12d, %edi
; 	ret = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, "GPL", insns, insn_cnt, NULL);
    8aca: 89 c3                        	movl	%eax, %ebx
; 	close(map);
    8acc: e8 2f ce ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (fd >= 0)
    8ad1: 85 db                        	testl	%ebx, %ebx
    8ad3: 79 2b                        	jns	0x8b00 <probe_kern_global_data+0xe0>
; 	return fd >= 0;
    8ad5: f7 d3                        	notl	%ebx
    8ad7: c1 eb 1f                     	shrl	$31, %ebx
    8ada: 41 89 dc                     	movl	%ebx, %r12d
; }
    8add: 48 8b 84 24 b8 00 00 00      	movq	184(%rsp), %rax
    8ae5: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    8aee: 75 5e                        	jne	0x8b4e <probe_kern_global_data+0x12e>
    8af0: 48 81 c4 c8 00 00 00         	addq	$200, %rsp
    8af7: 44 89 e0                     	movl	%r12d, %eax
    8afa: 5b                           	popq	%rbx
    8afb: 41 5c                        	popq	%r12
    8afd: c3                           	retq
    8afe: 66 90                        	nop
; 		close(fd);
    8b00: 89 df                        	movl	%ebx, %edi
    8b02: e8 f9 cd ff ff               	callq	0x5900 <.plt.sec+0x290>
    8b07: eb cc                        	jmp	0x8ad5 <probe_kern_global_data+0xb5>
    8b09: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		ret = -errno;
    8b10: e8 db cb ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
    8b15: 48 8d 74 24 30               	leaq	48(%rsp), %rsi
    8b1a: ba 80 00 00 00               	movl	$128, %edx
; 		ret = -errno;
    8b1f: 8b 18                        	movl	(%rax), %ebx
    8b21: 41 89 dc                     	movl	%ebx, %r12d
    8b24: 41 f7 dc                     	negl	%r12d
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
    8b27: 44 89 e7                     	movl	%r12d, %edi
    8b2a: e8 a1 4e 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("Error in %s():%s(%d). Couldn't create simple array map.\n",
    8b2f: 41 89 d8                     	movl	%ebx, %r8d
    8b32: 48 8d 15 d7 a2 02 00         	leaq	172759(%rip), %rdx      # 0x32e10 <__func__.12>
    8b39: 31 ff                        	xorl	%edi, %edi
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
    8b3b: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("Error in %s():%s(%d). Couldn't create simple array map.\n",
    8b3e: 48 8d 35 b3 a5 02 00         	leaq	173491(%rip), %rsi      # 0x330f8 <strs.2+0x268>
    8b45: 31 c0                        	xorl	%eax, %eax
    8b47: e8 84 f5 ff ff               	callq	0x80d0 <libbpf_print>
; 		return ret;
    8b4c: eb 8f                        	jmp	0x8add <probe_kern_global_data+0xbd>
; }
    8b4e: e8 ad cc ff ff               	callq	0x5800 <.plt.sec+0x190>
    8b53: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    8b5e: 66 90                        	nop

0000000000008b60 <bpf_object__elf_init>:
; {
    8b60: 41 55                        	pushq	%r13
    8b62: 41 54                        	pushq	%r12
    8b64: 55                           	pushq	%rbp
    8b65: 53                           	pushq	%rbx
    8b66: 48 81 ec 98 00 00 00         	subq	$152, %rsp
    8b6d: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    8b76: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
    8b7e: 31 c0                        	xorl	%eax, %eax
; 	if (obj->efile.elf) {
    8b80: 48 83 bf c0 00 00 00 00      	cmpq	$0, 192(%rdi)
    8b88: 0f 85 f2 02 00 00            	jne	0x8e80 <bpf_object__elf_init+0x320>
; 	if (obj->efile.obj_buf_sz > 0) {
    8b8e: 48 8b b7 b8 00 00 00         	movq	184(%rdi), %rsi
    8b95: 48 89 fb                     	movq	%rdi, %rbx
    8b98: 48 85 f6                     	testq	%rsi, %rsi
    8b9b: 0f 85 1f 01 00 00            	jne	0x8cc0 <bpf_object__elf_init+0x160>
; 		obj->efile.fd = open(obj->path, O_RDONLY | O_CLOEXEC);
    8ba1: 4c 8d af 90 01 00 00         	leaq	400(%rdi), %r13
;       return __open_alias (__path, __oflag, __va_arg_pack ());
    8ba8: be 00 00 08 00               	movl	$524288, %esi           # imm = 0x80000
    8bad: 31 c0                        	xorl	%eax, %eax
    8baf: 4c 89 ef                     	movq	%r13, %rdi
    8bb2: e8 a9 cf ff ff               	callq	0x5b60 <.plt.sec+0x4f0>
; 		obj->efile.fd = open(obj->path, O_RDONLY | O_CLOEXEC);
    8bb7: 89 83 a8 00 00 00            	movl	%eax, 168(%rbx)
;       return __open_alias (__path, __oflag, __va_arg_pack ());
    8bbd: 89 c7                        	movl	%eax, %edi
; 		if (obj->efile.fd < 0) {
    8bbf: 85 c0                        	testl	%eax, %eax
    8bc1: 0f 88 e9 01 00 00            	js	0x8db0 <bpf_object__elf_init+0x250>
; 		elf = elf_begin(obj->efile.fd, ELF_C_READ_MMAP, NULL);
    8bc7: 31 d2                        	xorl	%edx, %edx
    8bc9: be 01 00 00 00               	movl	$1, %esi
    8bce: e8 2d cf ff ff               	callq	0x5b00 <.plt.sec+0x490>
    8bd3: 48 89 c5                     	movq	%rax, %rbp
; 	if (!elf) {
    8bd6: 48 85 ed                     	testq	%rbp, %rbp
    8bd9: 0f 84 11 02 00 00            	je	0x8df0 <bpf_object__elf_init+0x290>
; 	obj->efile.elf = elf;
    8bdf: 48 89 ab c0 00 00 00         	movq	%rbp, 192(%rbx)
; 	if (elf_kind(elf) != ELF_K_ELF) {
    8be6: 48 89 ef                     	movq	%rbp, %rdi
    8be9: e8 82 d0 ff ff               	callq	0x5c70 <.plt.sec+0x600>
    8bee: 83 f8 03                     	cmpl	$3, %eax
    8bf1: 0f 84 e1 00 00 00            	je	0x8cd8 <bpf_object__elf_init+0x178>
; 		pr_warn("elf: '%s' is not a proper ELF object\n", obj->path);
    8bf7: 48 8d 93 90 01 00 00         	leaq	400(%rbx), %rdx
    8bfe: 48 8d 35 bb a5 02 00         	leaq	173499(%rip), %rsi      # 0x331c0 <strs.2+0x330>
    8c05: 31 ff                        	xorl	%edi, %edi
    8c07: 31 c0                        	xorl	%eax, %eax
    8c09: e8 c2 f4 ff ff               	callq	0x80d0 <libbpf_print>
; 		err = -LIBBPF_ERRNO__FORMAT;
    8c0e: 41 bc 5f f0 ff ff            	movl	$4294963295, %r12d      # imm = 0xFFFFF05F
; 	if (!obj->efile.elf)
    8c14: 48 8b bb c0 00 00 00         	movq	192(%rbx), %rdi
    8c1b: 48 85 ff                     	testq	%rdi, %rdi
    8c1e: 74 76                        	je	0x8c96 <bpf_object__elf_init+0x136>
; 	elf_end(obj->efile.elf);
    8c20: e8 0b ce ff ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	zfree(&obj->efile.secs);
    8c25: 48 8b bb f0 00 00 00         	movq	240(%rbx), %rdi
; 	obj->efile.elf = NULL;
    8c2c: 48 c7 83 c0 00 00 00 00 00 00 00     	movq	$0, 192(%rbx)
; 	obj->efile.symbols = NULL;
    8c37: 48 c7 83 d0 00 00 00 00 00 00 00     	movq	$0, 208(%rbx)
; 	obj->efile.st_ops_data = NULL;
    8c42: 48 c7 83 d8 00 00 00 00 00 00 00     	movq	$0, 216(%rbx)
; 	zfree(&obj->efile.secs);
    8c4d: e8 6e ca ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zclose(obj->efile.fd);
    8c52: 8b bb a8 00 00 00            	movl	168(%rbx), %edi
; 	zfree(&obj->efile.secs);
    8c58: 48 c7 83 f0 00 00 00 00 00 00 00     	movq	$0, 240(%rbx)
; 	obj->efile.sec_cnt = 0;
    8c63: c7 83 f8 00 00 00 00 00 00 00	movl	$0, 248(%rbx)
; 	zclose(obj->efile.fd);
    8c6d: 85 ff                        	testl	%edi, %edi
    8c6f: 78 05                        	js	0x8c76 <bpf_object__elf_init+0x116>
    8c71: e8 8a cc ff ff               	callq	0x5900 <.plt.sec+0x290>
    8c76: c7 83 a8 00 00 00 ff ff ff ff	movl	$4294967295, 168(%rbx)  # imm = 0xFFFFFFFF
; 	obj->efile.obj_buf = NULL;
    8c80: 48 c7 83 b0 00 00 00 00 00 00 00     	movq	$0, 176(%rbx)
; 	obj->efile.obj_buf_sz = 0;
    8c8b: 48 c7 83 b8 00 00 00 00 00 00 00     	movq	$0, 184(%rbx)
; }
    8c96: 48 8b 84 24 88 00 00 00      	movq	136(%rsp), %rax
    8c9e: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    8ca7: 0f 85 22 02 00 00            	jne	0x8ecf <bpf_object__elf_init+0x36f>
    8cad: 48 81 c4 98 00 00 00         	addq	$152, %rsp
    8cb4: 44 89 e0                     	movl	%r12d, %eax
    8cb7: 5b                           	popq	%rbx
    8cb8: 5d                           	popq	%rbp
    8cb9: 41 5c                        	popq	%r12
    8cbb: 41 5d                        	popq	%r13
    8cbd: c3                           	retq
    8cbe: 66 90                        	nop
; 		elf = elf_memory((char *)obj->efile.obj_buf, obj->efile.obj_buf_sz);
    8cc0: 48 8b bf b0 00 00 00         	movq	176(%rdi), %rdi
    8cc7: e8 44 ce ff ff               	callq	0x5b10 <.plt.sec+0x4a0>
    8ccc: 48 89 c5                     	movq	%rax, %rbp
    8ccf: e9 02 ff ff ff               	jmp	0x8bd6 <bpf_object__elf_init+0x76>
    8cd4: 0f 1f 40 00                  	nopl	(%rax)
; 	if (gelf_getclass(elf) != ELFCLASS64) {
    8cd8: 48 89 ef                     	movq	%rbp, %rdi
    8cdb: e8 80 cb ff ff               	callq	0x5860 <.plt.sec+0x1f0>
    8ce0: 83 f8 02                     	cmpl	$2, %eax
    8ce3: 0f 85 9f 00 00 00            	jne	0x8d88 <bpf_object__elf_init+0x228>
; 	obj->efile.ehdr = ehdr = elf64_getehdr(elf);
    8ce9: 48 89 ef                     	movq	%rbp, %rdi
    8cec: e8 df ca ff ff               	callq	0x57d0 <.plt.sec+0x160>
    8cf1: 48 89 83 c8 00 00 00         	movq	%rax, 200(%rbx)
    8cf8: 49 89 c5                     	movq	%rax, %r13
; 	if (!obj->efile.ehdr) {
    8cfb: 48 85 c0                     	testq	%rax, %rax
    8cfe: 0f 84 4c 01 00 00            	je	0x8e50 <bpf_object__elf_init+0x2f0>
; 	if (elf_getshdrstrndx(elf, &obj->efile.shstrndx)) {
    8d04: 48 8d b3 e0 00 00 00         	leaq	224(%rbx), %rsi
    8d0b: 48 89 ef                     	movq	%rbp, %rdi
    8d0e: e8 3d cf ff ff               	callq	0x5c50 <.plt.sec+0x5e0>
    8d13: 41 89 c4                     	movl	%eax, %r12d
    8d16: 85 c0                        	testl	%eax, %eax
    8d18: 0f 85 02 01 00 00            	jne	0x8e20 <bpf_object__elf_init+0x2c0>
; 	if (!elf_rawdata(elf_getscn(elf, obj->efile.shstrndx), NULL)) {
    8d1e: 48 8b b3 e0 00 00 00         	movq	224(%rbx), %rsi
    8d25: 48 89 ef                     	movq	%rbp, %rdi
    8d28: e8 d3 ce ff ff               	callq	0x5c00 <.plt.sec+0x590>
    8d2d: 31 f6                        	xorl	%esi, %esi
    8d2f: 48 89 c7                     	movq	%rax, %rdi
    8d32: e8 99 cd ff ff               	callq	0x5ad0 <.plt.sec+0x460>
    8d37: 48 85 c0                     	testq	%rax, %rax
    8d3a: 0f 84 60 01 00 00            	je	0x8ea0 <bpf_object__elf_init+0x340>
; 	if (ehdr->e_type != ET_REL || (ehdr->e_machine && ehdr->e_machine != EM_BPF)) {
    8d40: 66 41 83 7d 10 01            	cmpw	$1, 16(%r13)
    8d46: 75 18                        	jne	0x8d60 <bpf_object__elf_init+0x200>
    8d48: 41 0f b7 45 12               	movzwl	18(%r13), %eax
    8d4d: 66 85 c0                     	testw	%ax, %ax
    8d50: 0f 84 40 ff ff ff            	je	0x8c96 <bpf_object__elf_init+0x136>
    8d56: 66 3d f7 00                  	cmpw	$247, %ax
    8d5a: 0f 84 36 ff ff ff            	je	0x8c96 <bpf_object__elf_init+0x136>
; 		pr_warn("elf: %s is not a valid eBPF object file\n", obj->path);
    8d60: 48 8d 93 90 01 00 00         	leaq	400(%rbx), %rdx
    8d67: 48 8d 35 72 a5 02 00         	leaq	173426(%rip), %rsi      # 0x332e0 <strs.2+0x450>
    8d6e: 31 ff                        	xorl	%edi, %edi
    8d70: 31 c0                        	xorl	%eax, %eax
    8d72: e8 59 f3 ff ff               	callq	0x80d0 <libbpf_print>
; 		err = -LIBBPF_ERRNO__FORMAT;
    8d77: 41 bc 5f f0 ff ff            	movl	$4294963295, %r12d      # imm = 0xFFFFF05F
; 		goto errout;
    8d7d: e9 92 fe ff ff               	jmp	0x8c14 <bpf_object__elf_init+0xb4>
    8d82: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("elf: '%s' is not a 64-bit ELF object\n", obj->path);
    8d88: 48 8d 93 90 01 00 00         	leaq	400(%rbx), %rdx
    8d8f: 48 8d 35 5a a4 02 00         	leaq	173146(%rip), %rsi      # 0x331f0 <strs.2+0x360>
    8d96: 31 ff                        	xorl	%edi, %edi
    8d98: 31 c0                        	xorl	%eax, %eax
    8d9a: e8 31 f3 ff ff               	callq	0x80d0 <libbpf_print>
; 		err = -LIBBPF_ERRNO__FORMAT;
    8d9f: 41 bc 5f f0 ff ff            	movl	$4294963295, %r12d      # imm = 0xFFFFF05F
; 		goto errout;
    8da5: e9 6a fe ff ff               	jmp	0x8c14 <bpf_object__elf_init+0xb4>
    8daa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			err = -errno;
    8db0: e8 3b c9 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 			cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
    8db5: 48 89 e6                     	movq	%rsp, %rsi
    8db8: ba 80 00 00 00               	movl	$128, %edx
; 			err = -errno;
    8dbd: 44 8b 20                     	movl	(%rax), %r12d
    8dc0: 41 f7 dc                     	negl	%r12d
; 			cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
    8dc3: 44 89 e7                     	movl	%r12d, %edi
    8dc6: e8 05 4c 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 			pr_warn("elf: failed to open %s: %s\n", obj->path, cp);
    8dcb: 4c 89 ea                     	movq	%r13, %rdx
    8dce: 48 8d 35 93 a3 02 00         	leaq	172947(%rip), %rsi      # 0x33168 <strs.2+0x2d8>
    8dd5: 31 ff                        	xorl	%edi, %edi
; 			cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
    8dd7: 48 89 c1                     	movq	%rax, %rcx
; 			pr_warn("elf: failed to open %s: %s\n", obj->path, cp);
    8dda: 31 c0                        	xorl	%eax, %eax
    8ddc: e8 ef f2 ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
    8de1: e9 b0 fe ff ff               	jmp	0x8c96 <bpf_object__elf_init+0x136>
    8de6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("elf: failed to open %s as ELF file: %s\n", obj->path, elf_errmsg(-1));
    8df0: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
; 		err = -LIBBPF_ERRNO__LIBELF;
    8df5: 41 bc 60 f0 ff ff            	movl	$4294963296, %r12d      # imm = 0xFFFFF060
; 		pr_warn("elf: failed to open %s as ELF file: %s\n", obj->path, elf_errmsg(-1));
    8dfb: e8 60 cc ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    8e00: 48 8d 93 90 01 00 00         	leaq	400(%rbx), %rdx
    8e07: 48 8d 35 82 a3 02 00         	leaq	172930(%rip), %rsi      # 0x33190 <strs.2+0x300>
    8e0e: 31 ff                        	xorl	%edi, %edi
    8e10: 48 89 c1                     	movq	%rax, %rcx
    8e13: 31 c0                        	xorl	%eax, %eax
    8e15: e8 b6 f2 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto errout;
    8e1a: e9 f5 fd ff ff               	jmp	0x8c14 <bpf_object__elf_init+0xb4>
    8e1f: 90                           	nop
; 		pr_warn("elf: failed to get section names section index for %s: %s\n",
    8e20: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
; 		err = -LIBBPF_ERRNO__FORMAT;
    8e25: 41 bc 5f f0 ff ff            	movl	$4294963295, %r12d      # imm = 0xFFFFF05F
; 		pr_warn("elf: failed to get section names section index for %s: %s\n",
    8e2b: e8 30 cc ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    8e30: 48 8d 93 90 01 00 00         	leaq	400(%rbx), %rdx
    8e37: 48 8d 35 1a a4 02 00         	leaq	173082(%rip), %rsi      # 0x33258 <strs.2+0x3c8>
    8e3e: 31 ff                        	xorl	%edi, %edi
    8e40: 48 89 c1                     	movq	%rax, %rcx
    8e43: 31 c0                        	xorl	%eax, %eax
    8e45: e8 86 f2 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto errout;
    8e4a: e9 c5 fd ff ff               	jmp	0x8c14 <bpf_object__elf_init+0xb4>
    8e4f: 90                           	nop
; 		pr_warn("elf: failed to get ELF header from %s: %s\n", obj->path, elf_errmsg(-1));
    8e50: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
; 		err = -LIBBPF_ERRNO__FORMAT;
    8e55: 41 bc 5f f0 ff ff            	movl	$4294963295, %r12d      # imm = 0xFFFFF05F
; 		pr_warn("elf: failed to get ELF header from %s: %s\n", obj->path, elf_errmsg(-1));
    8e5b: e8 00 cc ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    8e60: 48 8d 93 90 01 00 00         	leaq	400(%rbx), %rdx
    8e67: 48 8d 35 b2 a3 02 00         	leaq	172978(%rip), %rsi      # 0x33220 <strs.2+0x390>
    8e6e: 31 ff                        	xorl	%edi, %edi
    8e70: 48 89 c1                     	movq	%rax, %rcx
    8e73: 31 c0                        	xorl	%eax, %eax
    8e75: e8 56 f2 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto errout;
    8e7a: e9 95 fd ff ff               	jmp	0x8c14 <bpf_object__elf_init+0xb4>
    8e7f: 90                           	nop
; 		pr_warn("elf: init internal error\n");
    8e80: 48 8d 35 b9 a2 02 00         	leaq	172729(%rip), %rsi      # 0x33140 <strs.2+0x2b0>
    8e87: 31 ff                        	xorl	%edi, %edi
; 		return -LIBBPF_ERRNO__LIBELF;
    8e89: 41 bc 60 f0 ff ff            	movl	$4294963296, %r12d      # imm = 0xFFFFF060
; 		pr_warn("elf: init internal error\n");
    8e8f: e8 3c f2 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -LIBBPF_ERRNO__LIBELF;
    8e94: e9 fd fd ff ff               	jmp	0x8c96 <bpf_object__elf_init+0x136>
    8e99: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("elf: failed to get section names strings from %s: %s\n",
    8ea0: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
; 		err = -LIBBPF_ERRNO__FORMAT;
    8ea5: 41 bc 5f f0 ff ff            	movl	$4294963295, %r12d      # imm = 0xFFFFF05F
; 		pr_warn("elf: failed to get section names strings from %s: %s\n",
    8eab: e8 b0 cb ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    8eb0: 48 8d 93 90 01 00 00         	leaq	400(%rbx), %rdx
    8eb7: 48 8d 35 e2 a3 02 00         	leaq	173026(%rip), %rsi      # 0x332a0 <strs.2+0x410>
    8ebe: 31 ff                        	xorl	%edi, %edi
    8ec0: 48 89 c1                     	movq	%rax, %rcx
    8ec3: 31 c0                        	xorl	%eax, %eax
    8ec5: e8 06 f2 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto errout;
    8eca: e9 45 fd ff ff               	jmp	0x8c14 <bpf_object__elf_init+0xb4>
; }
    8ecf: e8 2c c9 ff ff               	callq	0x5800 <.plt.sec+0x190>
    8ed4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    8edf: 90                           	nop

0000000000008ee0 <elf_sec_hdr>:
; {
    8ee0: 41 55                        	pushq	%r13
    8ee2: 41 54                        	pushq	%r12
    8ee4: 55                           	pushq	%rbp
    8ee5: 53                           	pushq	%rbx
    8ee6: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!scn)
    8eea: 48 85 f6                     	testq	%rsi, %rsi
    8eed: 74 29                        	je	0x8f18 <elf_sec_hdr+0x38>
    8eef: 48 89 fb                     	movq	%rdi, %rbx
; 	shdr = elf64_getshdr(scn);
    8ef2: 48 89 f7                     	movq	%rsi, %rdi
    8ef5: 48 89 f5                     	movq	%rsi, %rbp
    8ef8: e8 23 ca ff ff               	callq	0x5920 <.plt.sec+0x2b0>
    8efd: 49 89 c4                     	movq	%rax, %r12
; 	if (!shdr) {
    8f00: 48 85 c0                     	testq	%rax, %rax
    8f03: 74 2b                        	je	0x8f30 <elf_sec_hdr+0x50>
; }
    8f05: 48 83 c4 08                  	addq	$8, %rsp
    8f09: 4c 89 e0                     	movq	%r12, %rax
    8f0c: 5b                           	popq	%rbx
    8f0d: 5d                           	popq	%rbp
    8f0e: 41 5c                        	popq	%r12
    8f10: 41 5d                        	popq	%r13
    8f12: c3                           	retq
    8f13: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    8f18: 48 83 c4 08                  	addq	$8, %rsp
; 		return NULL;
    8f1c: 45 31 e4                     	xorl	%r12d, %r12d
; }
    8f1f: 5b                           	popq	%rbx
    8f20: 4c 89 e0                     	movq	%r12, %rax
    8f23: 5d                           	popq	%rbp
    8f24: 41 5c                        	popq	%r12
    8f26: 41 5d                        	popq	%r13
    8f28: c3                           	retq
    8f29: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("elf: failed to get section(%zu) header from %s: %s\n",
    8f30: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
    8f35: e8 26 cb ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    8f3a: 48 89 ef                     	movq	%rbp, %rdi
    8f3d: 49 89 c5                     	movq	%rax, %r13
    8f40: e8 9b cc ff ff               	callq	0x5be0 <.plt.sec+0x570>
    8f45: 48 8d 8b 90 01 00 00         	leaq	400(%rbx), %rcx
    8f4c: 4d 89 e8                     	movq	%r13, %r8
    8f4f: 31 ff                        	xorl	%edi, %edi
    8f51: 48 89 c2                     	movq	%rax, %rdx
    8f54: 48 8d 35 bd a3 02 00         	leaq	172989(%rip), %rsi      # 0x33318 <strs.2+0x488>
    8f5b: 31 c0                        	xorl	%eax, %eax
    8f5d: e8 6e f1 ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
    8f62: eb a1                        	jmp	0x8f05 <elf_sec_hdr+0x25>
    8f64: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    8f6f: 90                           	nop

0000000000008f70 <fill_map_from_def>:
; {
    8f70: 55                           	pushq	%rbp
    8f71: 48 89 fd                     	movq	%rdi, %rbp
    8f74: 53                           	pushq	%rbx
    8f75: 48 89 f3                     	movq	%rsi, %rbx
    8f78: 48 83 ec 08                  	subq	$8, %rsp
; 	map->def.key_size = def->key_size;
    8f7c: 8b 56 0c                     	movl	12(%rsi), %edx
; 	map->def.type = def->map_type;
    8f7f: 8b 46 04                     	movl	4(%rsi), %eax
; 	map->def.key_size = def->key_size;
    8f82: 89 57 34                     	movl	%edx, 52(%rdi)
; 	map->def.value_size = def->value_size;
    8f85: 8b 56 14                     	movl	20(%rsi), %edx
; 	map->def.type = def->map_type;
    8f88: 89 47 30                     	movl	%eax, 48(%rdi)
; 	map->def.value_size = def->value_size;
    8f8b: 89 57 38                     	movl	%edx, 56(%rdi)
; 	map->def.map_flags = def->map_flags;
    8f8e: 8b 56 1c                     	movl	28(%rsi), %edx
; 	map->def.max_entries = def->max_entries;
    8f91: 8b 7e 18                     	movl	24(%rsi), %edi
; 	map->def.map_flags = def->map_flags;
    8f94: 89 55 40                     	movl	%edx, 64(%rbp)
; 	map->map_extra = def->map_extra;
    8f97: 48 8b 56 28                  	movq	40(%rsi), %rdx
; 	map->def.max_entries = def->max_entries;
    8f9b: 89 7d 3c                     	movl	%edi, 60(%rbp)
; 	map->map_extra = def->map_extra;
    8f9e: 48 89 95 98 00 00 00         	movq	%rdx, 152(%rbp)
; 	map->numa_node = def->numa_node;
    8fa5: 8b 56 20                     	movl	32(%rsi), %edx
    8fa8: 89 55 44                     	movl	%edx, 68(%rbp)
; 	map->btf_key_type_id = def->key_type_id;
    8fab: 8b 56 08                     	movl	8(%rsi), %edx
    8fae: 89 55 4c                     	movl	%edx, 76(%rbp)
; 	map->btf_value_type_id = def->value_type_id;
    8fb1: 8b 56 10                     	movl	16(%rsi), %edx
    8fb4: 89 55 50                     	movl	%edx, 80(%rbp)
; 	if (map->def.type == BPF_MAP_TYPE_RINGBUF)
    8fb7: 83 f8 1b                     	cmpl	$27, %eax
    8fba: 0f 84 f8 01 00 00            	je	0x91b8 <fill_map_from_def+0x248>
; 	if (def->parts & MAP_DEF_MAP_TYPE)
    8fc0: 8b 03                        	movl	(%rbx), %eax
    8fc2: a8 01                        	testb	$1, %al
    8fc4: 0f 85 c6 01 00 00            	jne	0x9190 <fill_map_from_def+0x220>
; 	if (def->parts & MAP_DEF_KEY_TYPE)
    8fca: a8 02                        	testb	$2, %al
    8fcc: 0f 85 96 01 00 00            	jne	0x9168 <fill_map_from_def+0x1f8>
; 	else if (def->parts & MAP_DEF_KEY_SIZE)
    8fd2: a8 04                        	testb	$4, %al
    8fd4: 0f 85 3e 01 00 00            	jne	0x9118 <fill_map_from_def+0x1a8>
; 	if (def->parts & MAP_DEF_VALUE_TYPE)
    8fda: a8 08                        	testb	$8, %al
    8fdc: 0f 85 5a 01 00 00            	jne	0x913c <fill_map_from_def+0x1cc>
; 	else if (def->parts & MAP_DEF_VALUE_SIZE)
    8fe2: a8 10                        	testb	$16, %al
    8fe4: 75 3a                        	jne	0x9020 <fill_map_from_def+0xb0>
; 	if (def->parts & MAP_DEF_MAX_ENTRIES)
    8fe6: a8 20                        	testb	$32, %al
    8fe8: 75 56                        	jne	0x9040 <fill_map_from_def+0xd0>
; 	if (def->parts & MAP_DEF_MAP_FLAGS)
    8fea: a8 40                        	testb	$64, %al
    8fec: 75 72                        	jne	0x9060 <fill_map_from_def+0xf0>
; 	if (def->parts & MAP_DEF_MAP_EXTRA)
    8fee: f6 c4 04                     	testb	$4, %ah
    8ff1: 0f 85 8e 00 00 00            	jne	0x9085 <fill_map_from_def+0x115>
; 	if (def->parts & MAP_DEF_PINNING)
    8ff7: f6 c4 01                     	testb	$1, %ah
    8ffa: 0f 85 ab 00 00 00            	jne	0x90ab <fill_map_from_def+0x13b>
; 	if (def->parts & MAP_DEF_NUMA_NODE)
    9000: a8 80                        	testb	$-128, %al
    9002: 0f 85 c7 00 00 00            	jne	0x90cf <fill_map_from_def+0x15f>
; 	if (def->parts & MAP_DEF_INNER_MAP)
    9008: f6 c4 02                     	testb	$2, %ah
    900b: 0f 85 e3 00 00 00            	jne	0x90f4 <fill_map_from_def+0x184>
; }
    9011: 48 83 c4 08                  	addq	$8, %rsp
    9015: 5b                           	popq	%rbx
    9016: 5d                           	popq	%rbp
    9017: c3                           	retq
    9018: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		pr_debug("map '%s': found value_size = %u.\n", map->name, def->value_size);
    9020: 8b 4b 14                     	movl	20(%rbx), %ecx
    9023: 48 8b 55 08                  	movq	8(%rbp), %rdx
    9027: 31 c0                        	xorl	%eax, %eax
    9029: 48 8d 35 d8 a3 02 00         	leaq	173016(%rip), %rsi      # 0x33408 <strs.2+0x578>
    9030: bf 02 00 00 00               	movl	$2, %edi
    9035: e8 96 f0 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_MAX_ENTRIES)
    903a: 8b 03                        	movl	(%rbx), %eax
    903c: a8 20                        	testb	$32, %al
    903e: 74 aa                        	je	0x8fea <fill_map_from_def+0x7a>
; 		pr_debug("map '%s': found max_entries = %u.\n", map->name, def->max_entries);
    9040: 8b 4b 18                     	movl	24(%rbx), %ecx
    9043: 48 8b 55 08                  	movq	8(%rbp), %rdx
    9047: 31 c0                        	xorl	%eax, %eax
    9049: 48 8d 35 e8 a3 02 00         	leaq	173032(%rip), %rsi      # 0x33438 <strs.2+0x5a8>
    9050: bf 02 00 00 00               	movl	$2, %edi
    9055: e8 76 f0 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_MAP_FLAGS)
    905a: 8b 03                        	movl	(%rbx), %eax
    905c: a8 40                        	testb	$64, %al
    905e: 74 8e                        	je	0x8fee <fill_map_from_def+0x7e>
; 		pr_debug("map '%s': found map_flags = 0x%x.\n", map->name, def->map_flags);
    9060: 8b 4b 1c                     	movl	28(%rbx), %ecx
    9063: 48 8b 55 08                  	movq	8(%rbp), %rdx
    9067: 31 c0                        	xorl	%eax, %eax
    9069: 48 8d 35 f8 a3 02 00         	leaq	173048(%rip), %rsi      # 0x33468 <strs.2+0x5d8>
    9070: bf 02 00 00 00               	movl	$2, %edi
    9075: e8 56 f0 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_MAP_EXTRA)
    907a: 8b 03                        	movl	(%rbx), %eax
    907c: f6 c4 04                     	testb	$4, %ah
    907f: 0f 84 72 ff ff ff            	je	0x8ff7 <fill_map_from_def+0x87>
; 		pr_debug("map '%s': found map_extra = 0x%llx.\n", map->name,
    9085: 48 8b 4b 28                  	movq	40(%rbx), %rcx
    9089: 48 8b 55 08                  	movq	8(%rbp), %rdx
    908d: 31 c0                        	xorl	%eax, %eax
    908f: bf 02 00 00 00               	movl	$2, %edi
    9094: 48 8d 35 fd a3 02 00         	leaq	173053(%rip), %rsi      # 0x33498 <strs.2+0x608>
    909b: e8 30 f0 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_PINNING)
    90a0: 8b 03                        	movl	(%rbx), %eax
    90a2: f6 c4 01                     	testb	$1, %ah
    90a5: 0f 84 55 ff ff ff            	je	0x9000 <fill_map_from_def+0x90>
; 		pr_debug("map '%s': found pinning = %u.\n", map->name, def->pinning);
    90ab: 8b 4b 24                     	movl	36(%rbx), %ecx
    90ae: 48 8b 55 08                  	movq	8(%rbp), %rdx
    90b2: 31 c0                        	xorl	%eax, %eax
    90b4: 48 8d 35 0d a4 02 00         	leaq	173069(%rip), %rsi      # 0x334c8 <strs.2+0x638>
    90bb: bf 02 00 00 00               	movl	$2, %edi
    90c0: e8 0b f0 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_NUMA_NODE)
    90c5: 8b 03                        	movl	(%rbx), %eax
    90c7: a8 80                        	testb	$-128, %al
    90c9: 0f 84 39 ff ff ff            	je	0x9008 <fill_map_from_def+0x98>
; 		pr_debug("map '%s': found numa_node = %u.\n", map->name, def->numa_node);
    90cf: 8b 4b 20                     	movl	32(%rbx), %ecx
    90d2: 48 8b 55 08                  	movq	8(%rbp), %rdx
    90d6: 31 c0                        	xorl	%eax, %eax
    90d8: 48 8d 35 11 a4 02 00         	leaq	173073(%rip), %rsi      # 0x334f0 <strs.2+0x660>
    90df: bf 02 00 00 00               	movl	$2, %edi
    90e4: e8 e7 ef ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_INNER_MAP)
    90e9: 8b 03                        	movl	(%rbx), %eax
    90eb: f6 c4 02                     	testb	$2, %ah
    90ee: 0f 84 1d ff ff ff            	je	0x9011 <fill_map_from_def+0xa1>
; 		pr_debug("map '%s': found inner map definition.\n", map->name);
    90f4: 48 8b 55 08                  	movq	8(%rbp), %rdx
; }
    90f8: 48 83 c4 08                  	addq	$8, %rsp
; 		pr_debug("map '%s': found inner map definition.\n", map->name);
    90fc: 48 8d 35 1d a4 02 00         	leaq	173085(%rip), %rsi      # 0x33520 <strs.2+0x690>
    9103: 31 c0                        	xorl	%eax, %eax
; }
    9105: 5b                           	popq	%rbx
; 		pr_debug("map '%s': found inner map definition.\n", map->name);
    9106: bf 02 00 00 00               	movl	$2, %edi
; }
    910b: 5d                           	popq	%rbp
; 		pr_debug("map '%s': found inner map definition.\n", map->name);
    910c: e9 bf ef ff ff               	jmp	0x80d0 <libbpf_print>
    9111: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_debug("map '%s': found key_size = %u.\n", map->name, def->key_size);
    9118: 8b 4b 0c                     	movl	12(%rbx), %ecx
    911b: 48 8b 55 08                  	movq	8(%rbp), %rdx
    911f: 31 c0                        	xorl	%eax, %eax
    9121: 48 8d 35 88 a2 02 00         	leaq	172680(%rip), %rsi      # 0x333b0 <strs.2+0x520>
    9128: bf 02 00 00 00               	movl	$2, %edi
    912d: e8 9e ef ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_VALUE_TYPE)
    9132: 8b 03                        	movl	(%rbx), %eax
    9134: a8 08                        	testb	$8, %al
    9136: 0f 84 a6 fe ff ff            	je	0x8fe2 <fill_map_from_def+0x72>
; 		pr_debug("map '%s': found value [%u], sz = %u.\n",
    913c: 8b 4b 10                     	movl	16(%rbx), %ecx
    913f: 48 8b 55 08                  	movq	8(%rbp), %rdx
    9143: 31 c0                        	xorl	%eax, %eax
    9145: 48 8d 35 8c a2 02 00         	leaq	172684(%rip), %rsi      # 0x333d8 <strs.2+0x548>
    914c: 44 8b 43 14                  	movl	20(%rbx), %r8d
    9150: bf 02 00 00 00               	movl	$2, %edi
    9155: e8 76 ef ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_MAX_ENTRIES)
    915a: 8b 03                        	movl	(%rbx), %eax
    915c: e9 85 fe ff ff               	jmp	0x8fe6 <fill_map_from_def+0x76>
    9161: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_debug("map '%s': found key [%u], sz = %u.\n",
    9168: 8b 4b 08                     	movl	8(%rbx), %ecx
    916b: 48 8b 55 08                  	movq	8(%rbp), %rdx
    916f: 31 c0                        	xorl	%eax, %eax
    9171: 48 8d 35 08 a2 02 00         	leaq	172552(%rip), %rsi      # 0x33380 <strs.2+0x4f0>
    9178: 44 8b 43 0c                  	movl	12(%rbx), %r8d
    917c: bf 02 00 00 00               	movl	$2, %edi
    9181: e8 4a ef ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_VALUE_TYPE)
    9186: 8b 03                        	movl	(%rbx), %eax
    9188: e9 4d fe ff ff               	jmp	0x8fda <fill_map_from_def+0x6a>
    918d: 0f 1f 00                     	nopl	(%rax)
; 		pr_debug("map '%s': found type = %u.\n", map->name, def->map_type);
    9190: 8b 4b 04                     	movl	4(%rbx), %ecx
    9193: 48 8b 55 08                  	movq	8(%rbp), %rdx
    9197: 31 c0                        	xorl	%eax, %eax
    9199: 48 8d 35 b8 a1 02 00         	leaq	172472(%rip), %rsi      # 0x33358 <strs.2+0x4c8>
    91a0: bf 02 00 00 00               	movl	$2, %edi
    91a5: e8 26 ef ff ff               	callq	0x80d0 <libbpf_print>
; 	if (def->parts & MAP_DEF_KEY_TYPE)
    91aa: 8b 03                        	movl	(%rbx), %eax
    91ac: e9 19 fe ff ff               	jmp	0x8fca <fill_map_from_def+0x5a>
    91b1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		map->def.max_entries = adjust_ringbuf_sz(map->def.max_entries);
    91b8: e8 83 d5 ff ff               	callq	0x6740 <adjust_ringbuf_sz>
    91bd: 89 45 3c                     	movl	%eax, 60(%rbp)
    91c0: e9 fb fd ff ff               	jmp	0x8fc0 <fill_map_from_def+0x50>
    91c5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

00000000000091d0 <set_kcfg_value_num>:
; {
    91d0: 48 83 ec 08                  	subq	$8, %rsp
    91d4: 49 89 d1                     	movq	%rdx, %r9
; 	if (ext->kcfg.type != KCFG_INT && ext->kcfg.type != KCFG_CHAR &&
    91d7: 8b 57 20                     	movl	32(%rdi), %edx
; {
    91da: 48 89 f8                     	movq	%rdi, %rax
; 	if (ext->kcfg.type != KCFG_INT && ext->kcfg.type != KCFG_CHAR &&
    91dd: 8d 4a ff                     	leal	-1(%rdx), %ecx
    91e0: 83 f9 02                     	cmpl	$2, %ecx
    91e3: 0f 87 e6 00 00 00            	ja	0x92cf <set_kcfg_value_num+0xff>
    91e9: 48 89 f7                     	movq	%rsi, %rdi
; 	if (ext->kcfg.type == KCFG_BOOL && value > 1) {
    91ec: 83 fa 02                     	cmpl	$2, %edx
    91ef: 75 0a                        	jne	0x91fb <set_kcfg_value_num+0x2b>
    91f1: 49 83 f9 01                  	cmpq	$1, %r9
    91f5: 0f 87 b3 00 00 00            	ja	0x92ae <set_kcfg_value_num+0xde>
; 	int bit_sz = ext->kcfg.sz * 8;
    91fb: 44 8b 40 24                  	movl	36(%rax), %r8d
    91ff: 42 8d 34 c5 00 00 00 00      	leal	(,%r8,8), %esi
; 	if (ext->kcfg.sz == 8)
    9207: 41 83 f8 08                  	cmpl	$8, %r8d
    920b: 0f 84 8f 00 00 00            	je	0x92a0 <set_kcfg_value_num+0xd0>
; 	if (ext->kcfg.is_signed)
    9211: 80 78 30 00                  	cmpb	$0, 48(%rax)
    9215: 75 29                        	jne	0x9240 <set_kcfg_value_num+0x70>
; 		return (v >> bit_sz) == 0;
    9217: 4c 89 ca                     	movq	%r9, %rdx
    921a: 89 f1                        	movl	%esi, %ecx
    921c: 48 d3 ea                     	shrq	%cl, %rdx
; 	if (!is_kcfg_value_in_range(ext, value)) {
    921f: 48 85 d2                     	testq	%rdx, %rdx
    9222: 75 34                        	jne	0x9258 <set_kcfg_value_num+0x88>
; 	switch (ext->kcfg.sz) {
    9224: 41 83 f8 02                  	cmpl	$2, %r8d
    9228: 74 7e                        	je	0x92a8 <set_kcfg_value_num+0xd8>
    922a: 7f 54                        	jg	0x9280 <set_kcfg_value_num+0xb0>
    922c: 41 83 f8 01                  	cmpl	$1, %r8d
    9230: 75 5e                        	jne	0x9290 <set_kcfg_value_num+0xc0>
; 		case 1: *(__u8 *)ext_val = value; break;
    9232: 44 88 0f                     	movb	%r9b, (%rdi)
; 	ext->is_set = true;
    9235: c6 40 18 01                  	movb	$1, 24(%rax)
; 	return 0;
    9239: 31 c0                        	xorl	%eax, %eax
; }
    923b: 48 83 c4 08                  	addq	$8, %rsp
    923f: c3                           	retq
; 		return v + (1ULL << (bit_sz - 1)) < (1ULL << bit_sz);
    9240: 8d 4e ff                     	leal	-1(%rsi), %ecx
    9243: ba 01 00 00 00               	movl	$1, %edx
    9248: 48 d3 e2                     	shlq	%cl, %rdx
    924b: 89 f1                        	movl	%esi, %ecx
    924d: 4c 01 ca                     	addq	%r9, %rdx
    9250: 48 d3 ea                     	shrq	%cl, %rdx
; 	if (!is_kcfg_value_in_range(ext, value)) {
    9253: 48 85 d2                     	testq	%rdx, %rdx
    9256: 74 cc                        	je	0x9224 <set_kcfg_value_num+0x54>
; 		pr_warn("extern (kcfg) '%s': value '%llu' doesn't fit in %d bytes\n",
    9258: 48 8b 50 10                  	movq	16(%rax), %rdx
    925c: 4c 89 c9                     	movq	%r9, %rcx
    925f: 31 c0                        	xorl	%eax, %eax
    9261: 48 8d 35 88 a3 02 00         	leaq	172936(%rip), %rsi      # 0x335f0 <strs.2+0x760>
    9268: 31 ff                        	xorl	%edi, %edi
    926a: e8 61 ee ff ff               	callq	0x80d0 <libbpf_print>
; 		return -ERANGE;
    926f: b8 de ff ff ff               	movl	$4294967262, %eax       # imm = 0xFFFFFFDE
    9274: eb c5                        	jmp	0x923b <set_kcfg_value_num+0x6b>
    9276: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	switch (ext->kcfg.sz) {
    9280: 41 83 f8 04                  	cmpl	$4, %r8d
    9284: 75 0a                        	jne	0x9290 <set_kcfg_value_num+0xc0>
; 		case 4: *(__u32 *)ext_val = value; break;
    9286: 44 89 0f                     	movl	%r9d, (%rdi)
    9289: eb aa                        	jmp	0x9235 <set_kcfg_value_num+0x65>
    928b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	switch (ext->kcfg.sz) {
    9290: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
    9295: 48 83 c4 08                  	addq	$8, %rsp
    9299: c3                           	retq
    929a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		case 8: *(__u64 *)ext_val = value; break;
    92a0: 4c 89 0f                     	movq	%r9, (%rdi)
    92a3: eb 90                        	jmp	0x9235 <set_kcfg_value_num+0x65>
    92a5: 0f 1f 00                     	nopl	(%rax)
; 		case 2: *(__u16 *)ext_val = value; break;
    92a8: 66 44 89 0f                  	movw	%r9w, (%rdi)
    92ac: eb 87                        	jmp	0x9235 <set_kcfg_value_num+0x65>
; 		pr_warn("extern (kcfg) '%s': value '%llu' isn't boolean compatible\n",
    92ae: 48 8b 50 10                  	movq	16(%rax), %rdx
    92b2: 4c 89 c9                     	movq	%r9, %rcx
    92b5: 31 c0                        	xorl	%eax, %eax
    92b7: 48 8d 35 ea a2 02 00         	leaq	172778(%rip), %rsi      # 0x335a8 <strs.2+0x718>
    92be: 31 ff                        	xorl	%edi, %edi
    92c0: e8 0b ee ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
    92c5: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    92ca: e9 6c ff ff ff               	jmp	0x923b <set_kcfg_value_num+0x6b>
; 		pr_warn("extern (kcfg) '%s': value '%llu' implies integer, char, or boolean type\n",
    92cf: 48 8b 57 10                  	movq	16(%rdi), %rdx
    92d3: 31 c0                        	xorl	%eax, %eax
    92d5: 4c 89 c9                     	movq	%r9, %rcx
    92d8: 48 8d 35 71 a2 02 00         	leaq	172657(%rip), %rsi      # 0x33550 <strs.2+0x6c0>
    92df: 31 ff                        	xorl	%edi, %edi
    92e1: e8 ea ed ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
    92e6: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    92eb: e9 4b ff ff ff               	jmp	0x923b <set_kcfg_value_num+0x6b>

00000000000092f0 <bpf_object__process_kconfig_line.part.0>:
; static int bpf_object__process_kconfig_line(struct bpf_object *obj,
    92f0: 41 57                        	pushq	%r15
    92f2: 41 56                        	pushq	%r14
    92f4: 49 89 f6                     	movq	%rsi, %r14
; 	sep = strchr(buf, '=');
    92f7: be 3d 00 00 00               	movl	$61, %esi
; static int bpf_object__process_kconfig_line(struct bpf_object *obj,
    92fc: 41 55                        	pushq	%r13
    92fe: 41 54                        	pushq	%r12
    9300: 55                           	pushq	%rbp
    9301: 53                           	pushq	%rbx
    9302: 48 89 fb                     	movq	%rdi, %rbx
; 	sep = strchr(buf, '=');
    9305: 4c 89 f7                     	movq	%r14, %rdi
; static int bpf_object__process_kconfig_line(struct bpf_object *obj,
    9308: 48 83 ec 28                  	subq	$40, %rsp
    930c: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
    9311: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    931a: 48 89 44 24 18               	movq	%rax, 24(%rsp)
    931f: 31 c0                        	xorl	%eax, %eax
; 	sep = strchr(buf, '=');
    9321: e8 fa c4 ff ff               	callq	0x5820 <.plt.sec+0x1b0>
; 	if (!sep) {
    9326: 48 85 c0                     	testq	%rax, %rax
    9329: 0f 84 77 03 00 00            	je	0x96a6 <bpf_object__process_kconfig_line.part.0+0x3b6>
; 	len = strlen(buf);
    932f: 4c 89 f7                     	movq	%r14, %rdi
    9332: 49 89 c5                     	movq	%rax, %r13
    9335: e8 a6 c4 ff ff               	callq	0x57e0 <.plt.sec+0x170>
; 	if (buf[len - 1] == '\n')
    933a: 48 98                        	cltq
    933c: 49 8d 44 06 ff               	leaq	-1(%r14,%rax), %rax
    9341: 80 38 0a                     	cmpb	$10, (%rax)
    9344: 75 03                        	jne	0x9349 <bpf_object__process_kconfig_line.part.0+0x59>
; 		buf[len - 1] = '\0';
    9346: c6 00 00                     	movb	$0, (%rax)
; 	if (!sep[1]) {
    9349: 41 0f b6 45 01               	movzbl	1(%r13), %eax
; 	*sep = '\0';
    934e: 41 c6 45 00 00               	movb	$0, (%r13)
; 	if (!sep[1]) {
    9353: 88 44 24 07                  	movb	%al, 7(%rsp)
    9357: 84 c0                        	testb	%al, %al
    9359: 0f 84 dd 02 00 00            	je	0x963c <bpf_object__process_kconfig_line.part.0+0x34c>
; 	for (i = 0; i < obj->nr_extern; i++) {
    935f: 8b 83 90 00 00 00            	movl	144(%rbx), %eax
    9365: 85 c0                        	testl	%eax, %eax
    9367: 0f 8e 93 01 00 00            	jle	0x9500 <bpf_object__process_kconfig_line.part.0+0x210>
    936d: 8d 50 ff                     	leal	-1(%rax), %edx
    9370: 48 8b 9b 88 00 00 00         	movq	136(%rbx), %rbx
    9377: 48 8d 04 d5 00 00 00 00      	leaq	(,%rdx,8), %rax
    937f: 48 29 d0                     	subq	%rdx, %rax
    9382: 48 8d 6c c3 38               	leaq	56(%rbx,%rax,8), %rbp
    9387: eb 14                        	jmp	0x939d <bpf_object__process_kconfig_line.part.0+0xad>
    9389: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    9390: 48 83 c3 38                  	addq	$56, %rbx
    9394: 48 39 eb                     	cmpq	%rbp, %rbx
    9397: 0f 84 63 01 00 00            	je	0x9500 <bpf_object__process_kconfig_line.part.0+0x210>
; 		if (strcmp(obj->externs[i].name, name) == 0)
    939d: 4c 8b 7b 10                  	movq	16(%rbx), %r15
    93a1: 4c 89 f6                     	movq	%r14, %rsi
    93a4: 4c 89 ff                     	movq	%r15, %rdi
    93a7: e8 04 c6 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    93ac: 41 89 c4                     	movl	%eax, %r12d
    93af: 85 c0                        	testl	%eax, %eax
    93b1: 75 dd                        	jne	0x9390 <bpf_object__process_kconfig_line.part.0+0xa0>
; 	if (!ext || ext->is_set)
    93b3: 80 7b 18 00                  	cmpb	$0, 24(%rbx)
    93b7: 0f 85 a3 00 00 00            	jne	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
; 	value = sep + 1;
    93bd: 49 8d 45 01                  	leaq	1(%r13), %rax
; 	ext_val = data + ext->kcfg.data_off;
    93c1: 48 63 6b 2c                  	movslq	44(%rbx), %rbp
    93c5: 48 03 6c 24 08               	addq	8(%rsp), %rbp
; 	value = sep + 1;
    93ca: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	switch (*value) {
    93cf: 0f b6 44 24 07               	movzbl	7(%rsp), %eax
    93d4: 3c 6e                        	cmpb	$110, %al
    93d6: 0f 8f b4 00 00 00            	jg	0x9490 <bpf_object__process_kconfig_line.part.0+0x1a0>
    93dc: 3c 6c                        	cmpb	$108, %al
    93de: 0f 8f 9b 01 00 00            	jg	0x957f <bpf_object__process_kconfig_line.part.0+0x28f>
    93e4: 3c 22                        	cmpb	$34, %al
    93e6: 0f 85 ab 00 00 00            	jne	0x9497 <bpf_object__process_kconfig_line.part.0+0x1a7>
; 	if (ext->kcfg.type != KCFG_CHAR_ARR) {
    93ec: 83 7b 20 05                  	cmpl	$5, 32(%rbx)
    93f0: 0f 85 69 02 00 00            	jne	0x965f <bpf_object__process_kconfig_line.part.0+0x36f>
; 	len = strlen(value);
    93f6: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    93fb: e8 e0 c3 ff ff               	callq	0x57e0 <.plt.sec+0x170>
; 	if (value[len - 1] != '"') {
    9400: 41 80 7c 05 00 22            	cmpb	$34, (%r13,%rax)
    9406: 0f 85 b8 02 00 00            	jne	0x96c4 <bpf_object__process_kconfig_line.part.0+0x3d4>
; 	len -= 2;
    940c: 4c 8d 70 fe                  	leaq	-2(%rax), %r14
; 	if (len >= ext->kcfg.sz) {
    9410: 48 63 43 24                  	movslq	36(%rbx), %rax
    9414: 49 89 c1                     	movq	%rax, %r9
    9417: 49 39 c6                     	cmpq	%rax, %r14
    941a: 0f 83 31 01 00 00            	jae	0x9551 <bpf_object__process_kconfig_line.part.0+0x261>
;   return __builtin___memcpy_chk (__dest, __src, __len,
    9420: 49 8d 75 02                  	leaq	2(%r13), %rsi
    9424: 4c 89 f2                     	movq	%r14, %rdx
    9427: 48 89 ef                     	movq	%rbp, %rdi
    942a: e8 11 c6 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	ext_val[len] = '\0';
    942f: 42 c6 44 35 00 00            	movb	$0, (%rbp,%r14)
; 	pr_debug("extern (kcfg) '%s': set to %s\n", ext->name, value);
    9435: 4c 8b 7b 10                  	movq	16(%rbx), %r15
; 	ext->is_set = true;
    9439: c6 43 18 01                  	movb	$1, 24(%rbx)
; 	pr_debug("extern (kcfg) '%s': set to %s\n", ext->name, value);
    943d: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
    9442: 4c 89 fa                     	movq	%r15, %rdx
    9445: bf 02 00 00 00               	movl	$2, %edi
    944a: 31 c0                        	xorl	%eax, %eax
    944c: 48 8d 35 8d a4 02 00         	leaq	173197(%rip), %rsi      # 0x338e0 <strs.2+0xa50>
    9453: e8 78 ec ff ff               	callq	0x80d0 <libbpf_print>
; 	return 0;
    9458: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; }
    9460: 48 8b 44 24 18               	movq	24(%rsp), %rax
    9465: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    946e: 0f 85 93 02 00 00            	jne	0x9707 <bpf_object__process_kconfig_line.part.0+0x417>
    9474: 48 83 c4 28                  	addq	$40, %rsp
    9478: 44 89 e0                     	movl	%r12d, %eax
    947b: 5b                           	popq	%rbx
    947c: 5d                           	popq	%rbp
    947d: 41 5c                        	popq	%r12
    947f: 41 5d                        	popq	%r13
    9481: 41 5e                        	popq	%r14
    9483: 41 5f                        	popq	%r15
    9485: c3                           	retq
    9486: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	switch (*value) {
    9490: 80 7c 24 07 79               	cmpb	$121, 7(%rsp)
    9495: 74 79                        	je	0x9510 <bpf_object__process_kconfig_line.part.0+0x220>
; 	errno = 0;
    9497: e8 54 c2 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	*res = strtoull(value, &value_end, 0);
    949c: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    94a1: 31 d2                        	xorl	%edx, %edx
    94a3: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
; 	errno = 0;
    94a8: c7 00 00 00 00 00            	movl	$0, (%rax)
    94ae: 49 89 c5                     	movq	%rax, %r13
; 	*res = strtoull(value, &value_end, 0);
    94b1: e8 ca c4 ff ff               	callq	0x5980 <.plt.sec+0x310>
    94b6: 48 89 c2                     	movq	%rax, %rdx
; 	if (errno) {
    94b9: 41 8b 45 00                  	movl	(%r13), %eax
    94bd: 85 c0                        	testl	%eax, %eax
    94bf: 0f 85 2b 01 00 00            	jne	0x95f0 <bpf_object__process_kconfig_line.part.0+0x300>
; 	if (*value_end) {
    94c5: 48 8b 44 24 10               	movq	16(%rsp), %rax
    94ca: 80 38 00                     	cmpb	$0, (%rax)
    94cd: 0f 85 14 02 00 00            	jne	0x96e7 <bpf_object__process_kconfig_line.part.0+0x3f7>
; 		if (ext->kcfg.type != KCFG_INT && ext->kcfg.type != KCFG_CHAR) {
    94d3: 8b 43 20                     	movl	32(%rbx), %eax
    94d6: 83 e0 fd                     	andl	$-3, %eax
    94d9: 83 f8 01                     	cmpl	$1, %eax
    94dc: 0f 85 a0 01 00 00            	jne	0x9682 <bpf_object__process_kconfig_line.part.0+0x392>
; 		err = set_kcfg_value_num(ext, ext_val, num);
    94e2: 48 89 ee                     	movq	%rbp, %rsi
    94e5: 48 89 df                     	movq	%rbx, %rdi
    94e8: e8 e3 fc ff ff               	callq	0x91d0 <set_kcfg_value_num>
; 	if (err)
    94ed: 85 c0                        	testl	%eax, %eax
    94ef: 0f 84 3e 01 00 00            	je	0x9633 <bpf_object__process_kconfig_line.part.0+0x343>
    94f5: 41 89 c4                     	movl	%eax, %r12d
    94f8: e9 63 ff ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
    94fd: 0f 1f 00                     	nopl	(%rax)
; 		return 0;
    9500: 45 31 e4                     	xorl	%r12d, %r12d
    9503: e9 58 ff ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
    9508: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	switch (ext->kcfg.type) {
    9510: 8b 43 20                     	movl	32(%rbx), %eax
    9513: 83 f8 02                     	cmpl	$2, %eax
    9516: 0f 84 9c 00 00 00            	je	0x95b8 <bpf_object__process_kconfig_line.part.0+0x2c8>
    951c: 83 f8 04                     	cmpl	$4, %eax
    951f: 0f 84 a5 00 00 00            	je	0x95ca <bpf_object__process_kconfig_line.part.0+0x2da>
    9525: 83 f8 01                     	cmpl	$1, %eax
    9528: 0f 84 b4 00 00 00            	je	0x95e2 <bpf_object__process_kconfig_line.part.0+0x2f2>
; 	switch (*value) {
    952e: 0f be 4c 24 07               	movsbl	7(%rsp), %ecx
; 		pr_warn("extern (kcfg) '%s': value '%c' implies bool, tristate, or char type\n",
    9533: 4c 89 fa                     	movq	%r15, %rdx
    9536: 31 ff                        	xorl	%edi, %edi
    9538: 31 c0                        	xorl	%eax, %eax
    953a: 48 8d 35 97 a1 02 00         	leaq	172439(%rip), %rsi      # 0x336d8 <strs.2+0x848>
; 		return -EINVAL;
    9541: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("extern (kcfg) '%s': value '%c' implies bool, tristate, or char type\n",
    9547: e8 84 eb ff ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
    954c: e9 0f ff ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
; 		pr_warn("extern (kcfg) '%s': long string '%s' of (%zu bytes) truncated to %d bytes\n",
    9551: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
    9556: 4d 89 f0                     	movq	%r14, %r8
    9559: 31 c0                        	xorl	%eax, %eax
    955b: 41 83 e9 01                  	subl	$1, %r9d
    955f: 4c 89 fa                     	movq	%r15, %rdx
    9562: 48 8d 35 37 a2 02 00         	leaq	172599(%rip), %rsi      # 0x337a0 <strs.2+0x910>
    9569: 31 ff                        	xorl	%edi, %edi
    956b: e8 60 eb ff ff               	callq	0x80d0 <libbpf_print>
; 		len = ext->kcfg.sz - 1;
    9570: 8b 43 24                     	movl	36(%rbx), %eax
    9573: 44 8d 70 ff                  	leal	-1(%rax), %r14d
    9577: 4d 63 f6                     	movslq	%r14d, %r14
    957a: e9 a1 fe ff ff               	jmp	0x9420 <bpf_object__process_kconfig_line.part.0+0x130>
; 	switch (ext->kcfg.type) {
    957f: 8b 43 20                     	movl	32(%rbx), %eax
    9582: 83 f8 02                     	cmpl	$2, %eax
    9585: 75 95                        	jne	0x951c <bpf_object__process_kconfig_line.part.0+0x22c>
; 		if (value == 'm') {
    9587: 80 7c 24 07 6d               	cmpb	$109, 7(%rsp)
    958c: 75 2a                        	jne	0x95b8 <bpf_object__process_kconfig_line.part.0+0x2c8>
; 			pr_warn("extern (kcfg) '%s': value '%c' implies tristate or char type\n",
    958e: b9 6d 00 00 00               	movl	$109, %ecx
    9593: 4c 89 fa                     	movq	%r15, %rdx
    9596: 31 ff                        	xorl	%edi, %edi
    9598: 31 c0                        	xorl	%eax, %eax
    959a: 48 8d 35 ef a0 02 00         	leaq	172271(%rip), %rsi      # 0x33690 <strs.2+0x800>
; 			return -EINVAL;
    95a1: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("extern (kcfg) '%s': value '%c' implies tristate or char type\n",
    95a7: e8 24 eb ff ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
    95ac: e9 af fe ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
    95b1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		*(bool *)ext_val = value == 'y' ? true : false;
    95b8: 80 7c 24 07 79               	cmpb	$121, 7(%rsp)
    95bd: 0f 94 45 00                  	sete	(%rbp)
; 	ext->is_set = true;
    95c1: c6 43 18 01                  	movb	$1, 24(%rbx)
; 	if (err)
    95c5: e9 73 fe ff ff               	jmp	0x943d <bpf_object__process_kconfig_line.part.0+0x14d>
; 		if (value == 'y')
    95ca: 80 7c 24 07 79               	cmpb	$121, 7(%rsp)
    95cf: 74 59                        	je	0x962a <bpf_object__process_kconfig_line.part.0+0x33a>
; 			*(enum libbpf_tristate *)ext_val = TRI_MODULE;
    95d1: 31 c0                        	xorl	%eax, %eax
    95d3: 80 7c 24 07 6d               	cmpb	$109, 7(%rsp)
    95d8: 0f 94 c0                     	sete	%al
    95db: 01 c0                        	addl	%eax, %eax
    95dd: 89 45 00                     	movl	%eax, (%rbp)
    95e0: eb df                        	jmp	0x95c1 <bpf_object__process_kconfig_line.part.0+0x2d1>
; 		*(char *)ext_val = value;
    95e2: 0f b6 44 24 07               	movzbl	7(%rsp), %eax
    95e7: 88 45 00                     	movb	%al, (%rbp)
; 	pr_debug("extern (kcfg) '%s': set to %s\n", ext->name, value);
    95ea: 4c 8b 7b 10                  	movq	16(%rbx), %r15
; 		break;
    95ee: eb d1                        	jmp	0x95c1 <bpf_object__process_kconfig_line.part.0+0x2d1>
; 		err = -errno;
    95f0: f7 d8                        	negl	%eax
; 		pr_warn("failed to parse '%s' as integer: %d\n", value, err);
    95f2: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    95f7: 48 8d 35 fa a1 02 00         	leaq	172538(%rip), %rsi      # 0x337f8 <strs.2+0x968>
    95fe: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
    9600: 41 89 c4                     	movl	%eax, %r12d
; 		pr_warn("failed to parse '%s' as integer: %d\n", value, err);
    9603: 89 c1                        	movl	%eax, %ecx
    9605: 31 c0                        	xorl	%eax, %eax
    9607: e8 c4 ea ff ff               	callq	0x80d0 <libbpf_print>
; 			pr_warn("extern (kcfg) '%s': value '%s' isn't a valid integer\n", ext->name, value);
    960c: 48 8b 53 10                  	movq	16(%rbx), %rdx
    9610: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
    9615: 31 ff                        	xorl	%edi, %edi
    9617: 31 c0                        	xorl	%eax, %eax
    9619: 48 8d 35 40 a2 02 00         	leaq	172608(%rip), %rsi      # 0x33860 <strs.2+0x9d0>
    9620: e8 ab ea ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
    9625: e9 36 fe ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
; 			*(enum libbpf_tristate *)ext_val = TRI_YES;
    962a: c7 45 00 01 00 00 00         	movl	$1, (%rbp)
    9631: eb 8e                        	jmp	0x95c1 <bpf_object__process_kconfig_line.part.0+0x2d1>
; 	pr_debug("extern (kcfg) '%s': set to %s\n", ext->name, value);
    9633: 4c 8b 7b 10                  	movq	16(%rbx), %r15
    9637: e9 01 fe ff ff               	jmp	0x943d <bpf_object__process_kconfig_line.part.0+0x14d>
; 		*sep = '=';
    963c: 41 c6 45 00 3d               	movb	$61, (%r13)
; 		pr_warn("failed to parse '%s': no value\n", buf);
    9641: 4c 89 f2                     	movq	%r14, %rdx
    9644: 31 ff                        	xorl	%edi, %edi
    9646: 31 c0                        	xorl	%eax, %eax
    9648: 48 8d 35 19 a0 02 00         	leaq	172057(%rip), %rsi      # 0x33668 <strs.2+0x7d8>
; 		return -EINVAL;
    964f: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("failed to parse '%s': no value\n", buf);
    9655: e8 76 ea ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
    965a: e9 01 fe ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
; 		pr_warn("extern (kcfg) '%s': value '%s' implies char array type\n",
    965f: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
    9664: 4c 89 fa                     	movq	%r15, %rdx
    9667: 31 ff                        	xorl	%edi, %edi
    9669: 31 c0                        	xorl	%eax, %eax
    966b: 48 8d 35 b6 a0 02 00         	leaq	172214(%rip), %rsi      # 0x33728 <strs.2+0x898>
; 		return -EINVAL;
    9672: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("extern (kcfg) '%s': value '%s' implies char array type\n",
    9678: e8 53 ea ff ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
    967d: e9 de fd ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
; 			pr_warn("extern (kcfg) '%s': value '%s' implies integer type\n", ext->name, value);
    9682: 48 8b 53 10                  	movq	16(%rbx), %rdx
    9686: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
    968b: 31 ff                        	xorl	%edi, %edi
    968d: 31 c0                        	xorl	%eax, %eax
    968f: 48 8d 35 0a a2 02 00         	leaq	172554(%rip), %rsi      # 0x338a0 <strs.2+0xa10>
; 			return -EINVAL;
    9696: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("extern (kcfg) '%s': value '%s' implies integer type\n", ext->name, value);
    969c: e8 2f ea ff ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
    96a1: e9 ba fd ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
; 		pr_warn("failed to parse '%s': no separator\n", buf);
    96a6: 4c 89 f2                     	movq	%r14, %rdx
    96a9: 48 8d 35 88 9f 02 00         	leaq	171912(%rip), %rsi      # 0x33638 <strs.2+0x7a8>
    96b0: 31 ff                        	xorl	%edi, %edi
    96b2: 31 c0                        	xorl	%eax, %eax
    96b4: e8 17 ea ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
    96b9: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
    96bf: e9 9c fd ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
; 		pr_warn("extern (kcfg) '%s': invalid string config '%s'\n",
    96c4: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
    96c9: 4c 89 fa                     	movq	%r15, %rdx
    96cc: 31 ff                        	xorl	%edi, %edi
    96ce: 31 c0                        	xorl	%eax, %eax
    96d0: 48 8d 35 91 a0 02 00         	leaq	172177(%rip), %rsi      # 0x33768 <strs.2+0x8d8>
; 		return -EINVAL;
    96d7: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("extern (kcfg) '%s': invalid string config '%s'\n",
    96dd: e8 ee e9 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
    96e2: e9 79 fd ff ff               	jmp	0x9460 <bpf_object__process_kconfig_line.part.0+0x170>
; 		pr_warn("failed to parse '%s' as integer completely\n", value);
    96e7: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    96ec: 48 8d 35 35 a1 02 00         	leaq	172341(%rip), %rsi      # 0x33828 <strs.2+0x998>
    96f3: 31 ff                        	xorl	%edi, %edi
    96f5: 31 c0                        	xorl	%eax, %eax
; 		return -EINVAL;
    96f7: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("failed to parse '%s' as integer completely\n", value);
    96fd: e8 ce e9 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err) {
    9702: e9 05 ff ff ff               	jmp	0x960c <bpf_object__process_kconfig_line.part.0+0x31c>
; }
    9707: e8 f4 c0 ff ff               	callq	0x5800 <.plt.sec+0x190>
    970c: 0f 1f 40 00                  	nopl	(%rax)

0000000000009710 <bpf_object__read_kconfig_mem>:
; {
    9710: 41 56                        	pushq	%r14
    9712: 41 55                        	pushq	%r13
    9714: 41 54                        	pushq	%r12
    9716: 55                           	pushq	%rbp
    9717: 53                           	pushq	%rbx
    9718: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
    971f: 48 83 0c 24 00               	orq	$0, (%rsp)
    9724: 48 83 ec 10                  	subq	$16, %rsp
    9728: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    9731: 48 89 84 24 08 10 00 00      	movq	%rax, 4104(%rsp)
    9739: 31 c0                        	xorl	%eax, %eax
    973b: 48 89 fb                     	movq	%rdi, %rbx
; 	file = fmemopen((void *)config, strlen(config), "r");
    973e: 48 89 f7                     	movq	%rsi, %rdi
; {
    9741: 48 89 f5                     	movq	%rsi, %rbp
    9744: 49 89 d5                     	movq	%rdx, %r13
; 	file = fmemopen((void *)config, strlen(config), "r");
    9747: e8 94 c0 ff ff               	callq	0x57e0 <.plt.sec+0x170>
    974c: 48 8d 15 b6 84 02 00         	leaq	165046(%rip), %rdx      # 0x31c09 <_IO_stdin_used+0x1c09>
    9753: 48 89 ef                     	movq	%rbp, %rdi
    9756: 48 89 c6                     	movq	%rax, %rsi
    9759: e8 d2 bf ff ff               	callq	0x5730 <.plt.sec+0xc0>
; 	if (!file) {
    975e: 48 85 c0                     	testq	%rax, %rax
    9761: 0f 84 9a 00 00 00            	je	0x9801 <bpf_object__read_kconfig_mem+0xf1>
    9767: 48 89 c5                     	movq	%rax, %rbp
    976a: 49 89 e4                     	movq	%rsp, %r12
    976d: 0f 1f 00                     	nopl	(%rax)
;     return __fgets_alias (__s, __n, __stream);
    9770: 48 89 ea                     	movq	%rbp, %rdx
    9773: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
    9778: 4c 89 e7                     	movq	%r12, %rdi
    977b: e8 f0 c1 ff ff               	callq	0x5970 <.plt.sec+0x300>
; 	while (fgets(buf, sizeof(buf), file)) {
    9780: 48 85 c0                     	testq	%rax, %rax
    9783: 74 4b                        	je	0x97d0 <bpf_object__read_kconfig_mem+0xc0>
; 	if (!str_has_pfx(buf, "CONFIG_"))
    9785: 41 81 3c 24 43 4f 4e 46      	cmpl	$1179537219, (%r12)     # imm = 0x464E4F43
    978d: 75 e1                        	jne	0x9770 <bpf_object__read_kconfig_mem+0x60>
    978f: 66 41 81 7c 24 04 49 47      	cmpw	$18249, 4(%r12)         # imm = 0x4749
    9797: 75 d7                        	jne	0x9770 <bpf_object__read_kconfig_mem+0x60>
    9799: 41 80 7c 24 06 5f            	cmpb	$95, 6(%r12)
    979f: 75 cf                        	jne	0x9770 <bpf_object__read_kconfig_mem+0x60>
    97a1: 4c 89 ea                     	movq	%r13, %rdx
    97a4: 4c 89 e6                     	movq	%r12, %rsi
    97a7: 48 89 df                     	movq	%rbx, %rdi
    97aa: e8 41 fb ff ff               	callq	0x92f0 <bpf_object__process_kconfig_line.part.0>
    97af: 41 89 c6                     	movl	%eax, %r14d
; 		if (err) {
    97b2: 85 c0                        	testl	%eax, %eax
    97b4: 74 ba                        	je	0x9770 <bpf_object__read_kconfig_mem+0x60>
; 			pr_warn("error parsing in-memory Kconfig line '%s': %d\n",
    97b6: 89 c1                        	movl	%eax, %ecx
    97b8: 4c 89 e2                     	movq	%r12, %rdx
    97bb: 48 8d 35 76 a1 02 00         	leaq	172406(%rip), %rsi      # 0x33938 <strs.2+0xaa8>
    97c2: 31 ff                        	xorl	%edi, %edi
    97c4: 31 c0                        	xorl	%eax, %eax
    97c6: e8 05 e9 ff ff               	callq	0x80d0 <libbpf_print>
; 			break;
    97cb: eb 06                        	jmp	0x97d3 <bpf_object__read_kconfig_mem+0xc3>
    97cd: 0f 1f 00                     	nopl	(%rax)
    97d0: 45 31 f6                     	xorl	%r14d, %r14d
; 	fclose(file);
    97d3: 48 89 ef                     	movq	%rbp, %rdi
    97d6: e8 e5 bf ff ff               	callq	0x57c0 <.plt.sec+0x150>
; }
    97db: 48 8b 84 24 08 10 00 00      	movq	4104(%rsp), %rax
    97e3: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    97ec: 75 33                        	jne	0x9821 <bpf_object__read_kconfig_mem+0x111>
    97ee: 48 81 c4 10 10 00 00         	addq	$4112, %rsp             # imm = 0x1010
    97f5: 44 89 f0                     	movl	%r14d, %eax
    97f8: 5b                           	popq	%rbx
    97f9: 5d                           	popq	%rbp
    97fa: 41 5c                        	popq	%r12
    97fc: 41 5d                        	popq	%r13
    97fe: 41 5e                        	popq	%r14
    9800: c3                           	retq
; 		err = -errno;
    9801: e8 ea be ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to open in-memory Kconfig: %d\n", err);
    9806: 48 8d 35 fb a0 02 00         	leaq	172283(%rip), %rsi      # 0x33908 <strs.2+0xa78>
    980d: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
    980f: 44 8b 30                     	movl	(%rax), %r14d
; 		pr_warn("failed to open in-memory Kconfig: %d\n", err);
    9812: 31 c0                        	xorl	%eax, %eax
; 		err = -errno;
    9814: 41 f7 de                     	negl	%r14d
; 		pr_warn("failed to open in-memory Kconfig: %d\n", err);
    9817: 44 89 f2                     	movl	%r14d, %edx
    981a: e8 b1 e8 ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
    981f: eb ba                        	jmp	0x97db <bpf_object__read_kconfig_mem+0xcb>
; }
    9821: e8 da bf ff ff               	callq	0x5800 <.plt.sec+0x190>
    9826: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000009830 <bpf_object__read_kconfig_file>:
; {
    9830: 41 56                        	pushq	%r14
    9832: 41 55                        	pushq	%r13
    9834: 41 54                        	pushq	%r12
    9836: 55                           	pushq	%rbp
    9837: 53                           	pushq	%rbx
    9838: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
    983f: 48 83 0c 24 00               	orq	$0, (%rsp)
    9844: 48 81 ec a0 01 00 00         	subq	$416, %rsp              # imm = 0x1A0
; 	file = gzopen(buf, "r");
    984b: 4c 8d 35 b7 83 02 00         	leaq	164791(%rip), %r14      # 0x31c09 <_IO_stdin_used+0x1c09>
; {
    9852: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    985b: 48 89 84 24 98 11 00 00      	movq	%rax, 4504(%rsp)
    9863: 31 c0                        	xorl	%eax, %eax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    9865: 4c 8d a4 24 90 01 00 00      	leaq	400(%rsp), %r12
; {
    986d: 48 89 fb                     	movq	%rdi, %rbx
; 	uname(&uts);
    9870: 48 89 e7                     	movq	%rsp, %rdi
; {
    9873: 49 89 f5                     	movq	%rsi, %r13
; 	uname(&uts);
    9876: e8 05 c0 ff ff               	callq	0x5880 <.plt.sec+0x210>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    987b: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
    9880: 4c 89 e7                     	movq	%r12, %rdi
    9883: 31 c0                        	xorl	%eax, %eax
    9885: 4c 8d 8c 24 82 00 00 00      	leaq	130(%rsp), %r9
    988d: ba 01 00 00 00               	movl	$1, %edx
    9892: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
    9897: 4c 8d 05 dd 84 02 00         	leaq	165085(%rip), %r8       # 0x31d7b <_IO_stdin_used+0x1d7b>
    989e: e8 0d be ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	file = gzopen(buf, "r");
    98a3: 4c 89 f6                     	movq	%r14, %rsi
    98a6: 4c 89 e7                     	movq	%r12, %rdi
    98a9: e8 72 c1 ff ff               	callq	0x5a20 <.plt.sec+0x3b0>
    98ae: 48 89 c5                     	movq	%rax, %rbp
; 	if (!file)
    98b1: 48 85 c0                     	testq	%rax, %rax
    98b4: 0f 84 9e 00 00 00            	je	0x9958 <bpf_object__read_kconfig_file+0x128>
    98ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	while (gzgets(file, buf, sizeof(buf))) {
    98c0: ba 00 10 00 00               	movl	$4096, %edx             # imm = 0x1000
    98c5: 4c 89 e6                     	movq	%r12, %rsi
    98c8: 48 89 ef                     	movq	%rbp, %rdi
    98cb: e8 a0 be ff ff               	callq	0x5770 <.plt.sec+0x100>
    98d0: 48 85 c0                     	testq	%rax, %rax
    98d3: 74 7b                        	je	0x9950 <bpf_object__read_kconfig_file+0x120>
; 	if (!str_has_pfx(buf, "CONFIG_"))
    98d5: 41 81 3c 24 43 4f 4e 46      	cmpl	$1179537219, (%r12)     # imm = 0x464E4F43
    98dd: 75 e1                        	jne	0x98c0 <bpf_object__read_kconfig_file+0x90>
    98df: 66 41 81 7c 24 04 49 47      	cmpw	$18249, 4(%r12)         # imm = 0x4749
    98e7: 75 d7                        	jne	0x98c0 <bpf_object__read_kconfig_file+0x90>
    98e9: 41 80 7c 24 06 5f            	cmpb	$95, 6(%r12)
    98ef: 75 cf                        	jne	0x98c0 <bpf_object__read_kconfig_file+0x90>
    98f1: 4c 89 ea                     	movq	%r13, %rdx
    98f4: 4c 89 e6                     	movq	%r12, %rsi
    98f7: 48 89 df                     	movq	%rbx, %rdi
    98fa: e8 f1 f9 ff ff               	callq	0x92f0 <bpf_object__process_kconfig_line.part.0>
    98ff: 41 89 c6                     	movl	%eax, %r14d
; 		if (err) {
    9902: 85 c0                        	testl	%eax, %eax
    9904: 74 ba                        	je	0x98c0 <bpf_object__read_kconfig_file+0x90>
; 			pr_warn("error parsing system Kconfig line '%s': %d\n",
    9906: 89 c1                        	movl	%eax, %ecx
    9908: 4c 89 e2                     	movq	%r12, %rdx
    990b: 48 8d 35 86 a0 02 00         	leaq	172166(%rip), %rsi      # 0x33998 <strs.2+0xb08>
    9912: 31 ff                        	xorl	%edi, %edi
    9914: 31 c0                        	xorl	%eax, %eax
    9916: e8 b5 e7 ff ff               	callq	0x80d0 <libbpf_print>
; 	gzclose(file);
    991b: 48 89 ef                     	movq	%rbp, %rdi
    991e: e8 7d bd ff ff               	callq	0x56a0 <.plt.sec+0x30>
; }
    9923: 48 8b 84 24 98 11 00 00      	movq	4504(%rsp), %rax
    992b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    9934: 75 55                        	jne	0x998b <bpf_object__read_kconfig_file+0x15b>
    9936: 48 81 c4 a0 11 00 00         	addq	$4512, %rsp             # imm = 0x11A0
    993d: 44 89 f0                     	movl	%r14d, %eax
    9940: 5b                           	popq	%rbx
    9941: 5d                           	popq	%rbp
    9942: 41 5c                        	popq	%r12
    9944: 41 5d                        	popq	%r13
    9946: 41 5e                        	popq	%r14
    9948: c3                           	retq
    9949: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; out:
    9950: 45 31 f6                     	xorl	%r14d, %r14d
    9953: eb c6                        	jmp	0x991b <bpf_object__read_kconfig_file+0xeb>
    9955: 0f 1f 00                     	nopl	(%rax)
; 		file = gzopen("/proc/config.gz", "r");
    9958: 4c 89 f6                     	movq	%r14, %rsi
    995b: 48 8d 3d 29 84 02 00         	leaq	164905(%rip), %rdi      # 0x31d8b <_IO_stdin_used+0x1d8b>
    9962: e8 b9 c0 ff ff               	callq	0x5a20 <.plt.sec+0x3b0>
    9967: 48 89 c5                     	movq	%rax, %rbp
; 	if (!file) {
    996a: 48 85 c0                     	testq	%rax, %rax
    996d: 0f 85 4d ff ff ff            	jne	0x98c0 <bpf_object__read_kconfig_file+0x90>
; 		pr_warn("failed to open system Kconfig\n");
    9973: 48 8d 35 f6 9f 02 00         	leaq	172022(%rip), %rsi      # 0x33970 <strs.2+0xae0>
    997a: 31 ff                        	xorl	%edi, %edi
    997c: 31 c0                        	xorl	%eax, %eax
; 		return -ENOENT;
    997e: 41 be fe ff ff ff            	movl	$4294967294, %r14d      # imm = 0xFFFFFFFE
; 		pr_warn("failed to open system Kconfig\n");
    9984: e8 47 e7 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -ENOENT;
    9989: eb 98                        	jmp	0x9923 <bpf_object__read_kconfig_file+0xf3>
; }
    998b: e8 70 be ff ff               	callq	0x5800 <.plt.sec+0x190>

0000000000009990 <kallsyms_cb>:
; {
    9990: f3 0f 1e fa                  	endbr64
    9994: 41 57                        	pushq	%r15
    9996: 41 56                        	pushq	%r14
    9998: 41 55                        	pushq	%r13
    999a: 41 54                        	pushq	%r12
    999c: 55                           	pushq	%rbp
    999d: 53                           	pushq	%rbx
    999e: 48 83 ec 08                  	subq	$8, %rsp
; 	for (i = 0; i < obj->nr_extern; i++) {
    99a2: 8b 81 90 00 00 00            	movl	144(%rcx), %eax
    99a8: 85 c0                        	testl	%eax, %eax
    99aa: 7e 4d                        	jle	0x99f9 <kallsyms_cb+0x69>
    99ac: 49 89 d7                     	movq	%rdx, %r15
    99af: 8d 50 ff                     	leal	-1(%rax), %edx
    99b2: 48 8b 99 88 00 00 00         	movq	136(%rcx), %rbx
    99b9: 49 89 fe                     	movq	%rdi, %r14
    99bc: 48 8d 04 d5 00 00 00 00      	leaq	(,%rdx,8), %rax
    99c4: 49 89 cd                     	movq	%rcx, %r13
    99c7: 48 29 d0                     	subq	%rdx, %rax
    99ca: 48 8d 6c c3 38               	leaq	56(%rbx,%rax,8), %rbp
    99cf: eb 10                        	jmp	0x99e1 <kallsyms_cb+0x51>
    99d1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    99d8: 48 83 c3 38                  	addq	$56, %rbx
    99dc: 48 39 eb                     	cmpq	%rbp, %rbx
    99df: 74 18                        	je	0x99f9 <kallsyms_cb+0x69>
; 		if (strcmp(obj->externs[i].name, name) == 0)
    99e1: 48 8b 7b 10                  	movq	16(%rbx), %rdi
    99e5: 4c 89 fe                     	movq	%r15, %rsi
    99e8: e8 c3 bf ff ff               	callq	0x59b0 <.plt.sec+0x340>
    99ed: 41 89 c4                     	movl	%eax, %r12d
    99f0: 85 c0                        	testl	%eax, %eax
    99f2: 75 e4                        	jne	0x99d8 <kallsyms_cb+0x48>
; 	if (!ext || ext->type != EXT_KSYM)
    99f4: 83 3b 02                     	cmpl	$2, (%rbx)
    99f7: 74 17                        	je	0x9a10 <kallsyms_cb+0x80>
; 		return 0;
    99f9: 45 31 e4                     	xorl	%r12d, %r12d
; }
    99fc: 48 83 c4 08                  	addq	$8, %rsp
    9a00: 44 89 e0                     	movl	%r12d, %eax
    9a03: 5b                           	popq	%rbx
    9a04: 5d                           	popq	%rbp
    9a05: 41 5c                        	popq	%r12
    9a07: 41 5d                        	popq	%r13
    9a09: 41 5e                        	popq	%r14
    9a0b: 41 5f                        	popq	%r15
    9a0d: c3                           	retq
    9a0e: 66 90                        	nop
; 	t = btf__type_by_id(obj->btf, ext->btf_id);
    9a10: 8b 73 08                     	movl	8(%rbx), %esi
    9a13: 49 8b bd 10 01 00 00         	movq	272(%r13), %rdi
    9a1a: e8 81 05 02 00               	callq	0x29fa0 <btf__type_by_id>
; 	return BTF_INFO_KIND(t->info);
    9a1f: 0f b6 40 07                  	movzbl	7(%rax), %eax
    9a23: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_var(t))
    9a26: 66 83 f8 0e                  	cmpw	$14, %ax
    9a2a: 75 cd                        	jne	0x99f9 <kallsyms_cb+0x69>
; 	if (ext->is_set && ext->ksym.addr != sym_addr) {
    9a2c: 80 7b 18 00                  	cmpb	$0, 24(%rbx)
    9a30: 75 23                        	jne	0x9a55 <kallsyms_cb+0xc5>
; 		ext->is_set = true;
    9a32: c6 43 18 01                  	movb	$1, 24(%rbx)
; 		pr_debug("extern (ksym) '%s': set to 0x%llx\n", sym_name, sym_addr);
    9a36: 4c 89 f1                     	movq	%r14, %rcx
    9a39: 4c 89 fa                     	movq	%r15, %rdx
    9a3c: bf 02 00 00 00               	movl	$2, %edi
; 		ext->ksym.addr = sym_addr;
    9a41: 4c 89 73 20                  	movq	%r14, 32(%rbx)
; 		pr_debug("extern (ksym) '%s': set to 0x%llx\n", sym_name, sym_addr);
    9a45: 48 8d 35 cc 9f 02 00         	leaq	171980(%rip), %rsi      # 0x33a18 <strs.2+0xb88>
    9a4c: 31 c0                        	xorl	%eax, %eax
    9a4e: e8 7d e6 ff ff               	callq	0x80d0 <libbpf_print>
    9a53: eb a7                        	jmp	0x99fc <kallsyms_cb+0x6c>
; 	if (ext->is_set && ext->ksym.addr != sym_addr) {
    9a55: 48 8b 4b 20                  	movq	32(%rbx), %rcx
    9a59: 4c 39 f1                     	cmpq	%r14, %rcx
    9a5c: 74 9b                        	je	0x99f9 <kallsyms_cb+0x69>
; 		pr_warn("extern (ksym) '%s': resolution is ambiguous: 0x%llx or 0x%llx\n",
    9a5e: 4d 89 f0                     	movq	%r14, %r8
    9a61: 4c 89 fa                     	movq	%r15, %rdx
    9a64: 48 8d 35 65 9f 02 00         	leaq	171877(%rip), %rsi      # 0x339d0 <strs.2+0xb40>
    9a6b: 31 ff                        	xorl	%edi, %edi
    9a6d: 31 c0                        	xorl	%eax, %eax
; 		return -EINVAL;
    9a6f: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("extern (ksym) '%s': resolution is ambiguous: 0x%llx or 0x%llx\n",
    9a75: e8 56 e6 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
    9a7a: eb 80                        	jmp	0x99fc <kallsyms_cb+0x6c>
    9a7c: 0f 1f 40 00                  	nopl	(%rax)

0000000000009a80 <pr_perm_msg>:
; {
    9a80: 41 54                        	pushq	%r12
    9a82: 48 83 c4 80                  	addq	$-128, %rsp
    9a86: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    9a8f: 48 89 44 24 78               	movq	%rax, 120(%rsp)
    9a94: 31 c0                        	xorl	%eax, %eax
; 	if (err != -EPERM || geteuid() != 0)
    9a96: 83 ff ff                     	cmpl	$-1, %edi
    9a99: 74 25                        	je	0x9ac0 <pr_perm_msg+0x40>
; }
    9a9b: 48 8b 44 24 78               	movq	120(%rsp), %rax
    9aa0: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    9aa9: 0f 85 18 01 00 00            	jne	0x9bc7 <pr_perm_msg+0x147>
    9aaf: 48 83 ec 80                  	subq	$-128, %rsp
    9ab3: 41 5c                        	popq	%r12
    9ab5: c3                           	retq
    9ab6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	if (err != -EPERM || geteuid() != 0)
    9ac0: e8 0b be ff ff               	callq	0x58d0 <.plt.sec+0x260>
    9ac5: 85 c0                        	testl	%eax, %eax
    9ac7: 75 d2                        	jne	0x9a9b <pr_perm_msg+0x1b>
; 	err = getrlimit(RLIMIT_MEMLOCK, &limit);
    9ac9: 48 89 e6                     	movq	%rsp, %rsi
    9acc: bf 08 00 00 00               	movl	$8, %edi
    9ad1: e8 9a bf ff ff               	callq	0x5a70 <.plt.sec+0x400>
; 	if (err)
    9ad6: 85 c0                        	testl	%eax, %eax
    9ad8: 75 c1                        	jne	0x9a9b <pr_perm_msg+0x1b>
; 	if (limit.rlim_cur == RLIM_INFINITY)
    9ada: 4c 8b 0c 24                  	movq	(%rsp), %r9
    9ade: 49 83 f9 ff                  	cmpq	$-1, %r9
    9ae2: 74 b7                        	je	0x9a9b <pr_perm_msg+0x1b>
; 	if (limit.rlim_cur < 1024)
    9ae4: 49 81 f9 ff 03 00 00         	cmpq	$1023, %r9              # imm = 0x3FF
    9aeb: 0f 86 8f 00 00 00            	jbe	0x9b80 <pr_perm_msg+0x100>
; 	else if (limit.rlim_cur < 1024*1024)
    9af1: 49 81 f9 ff ff 0f 00         	cmpq	$1048575, %r9           # imm = 0xFFFFF
    9af8: 76 5e                        	jbe	0x9b58 <pr_perm_msg+0xd8>
; 		snprintf(buf, sizeof(buf), "%.1f MiB", (double)limit.rlim_cur / (1024*1024));
    9afa: 4d 85 c9                     	testq	%r9, %r9
    9afd: 0f 88 a5 00 00 00            	js	0x9ba8 <pr_perm_msg+0x128>
    9b03: 66 0f ef c0                  	pxor	%xmm0, %xmm0
    9b07: f2 49 0f 2a c1               	cvtsi2sd	%r9, %xmm0
    9b0c: f2 0f 59 05 4c f5 02 00      	mulsd	193868(%rip), %xmm0     # 0x39060 <strs.2+0x61d0>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    9b14: 4c 8d 64 24 10               	leaq	16(%rsp), %r12
    9b19: 4c 8d 05 8e 82 02 00         	leaq	164494(%rip), %r8       # 0x31dae <_IO_stdin_used+0x1dae>
    9b20: b9 64 00 00 00               	movl	$100, %ecx
    9b25: ba 01 00 00 00               	movl	$1, %edx
    9b2a: be 64 00 00 00               	movl	$100, %esi
    9b2f: 4c 89 e7                     	movq	%r12, %rdi
    9b32: b8 01 00 00 00               	movl	$1, %eax
    9b37: e8 74 bb ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	pr_warn("permission error while running as root; try raising 'ulimit -l'? current value: %s\n",
    9b3c: 4c 89 e2                     	movq	%r12, %rdx
    9b3f: 48 8d 35 02 9f 02 00         	leaq	171778(%rip), %rsi      # 0x33a48 <strs.2+0xbb8>
    9b46: 31 ff                        	xorl	%edi, %edi
    9b48: 31 c0                        	xorl	%eax, %eax
    9b4a: e8 81 e5 ff ff               	callq	0x80d0 <libbpf_print>
    9b4f: e9 47 ff ff ff               	jmp	0x9a9b <pr_perm_msg+0x1b>
    9b54: 0f 1f 40 00                  	nopl	(%rax)
; 		snprintf(buf, sizeof(buf), "%.1f KiB", (double)limit.rlim_cur / 1024);
    9b58: 66 0f ef c0                  	pxor	%xmm0, %xmm0
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    9b5c: 4c 8d 64 24 10               	leaq	16(%rsp), %r12
    9b61: 4c 8d 05 3d 82 02 00         	leaq	164413(%rip), %r8       # 0x31da5 <_IO_stdin_used+0x1da5>
; 		snprintf(buf, sizeof(buf), "%.1f KiB", (double)limit.rlim_cur / 1024);
    9b68: f2 49 0f 2a c1               	cvtsi2sd	%r9, %xmm0
    9b6d: f2 0f 59 05 e3 f4 02 00      	mulsd	193763(%rip), %xmm0     # 0x39058 <strs.2+0x61c8>
    9b75: eb a9                        	jmp	0x9b20 <pr_perm_msg+0xa0>
    9b77: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    9b80: 4c 8d 64 24 10               	leaq	16(%rsp), %r12
    9b85: b9 64 00 00 00               	movl	$100, %ecx
    9b8a: ba 01 00 00 00               	movl	$1, %edx
    9b8f: be 64 00 00 00               	movl	$100, %esi
    9b94: 4c 8d 05 00 82 02 00         	leaq	164352(%rip), %r8       # 0x31d9b <_IO_stdin_used+0x1d9b>
    9b9b: 4c 89 e7                     	movq	%r12, %rdi
    9b9e: e8 0d bb ff ff               	callq	0x56b0 <.plt.sec+0x40>
    9ba3: eb 97                        	jmp	0x9b3c <pr_perm_msg+0xbc>
    9ba5: 0f 1f 00                     	nopl	(%rax)
; 		snprintf(buf, sizeof(buf), "%.1f MiB", (double)limit.rlim_cur / (1024*1024));
    9ba8: 4c 89 c8                     	movq	%r9, %rax
    9bab: 41 83 e1 01                  	andl	$1, %r9d
    9baf: 66 0f ef c0                  	pxor	%xmm0, %xmm0
    9bb3: 48 d1 e8                     	shrq	%rax
    9bb6: 4c 09 c8                     	orq	%r9, %rax
    9bb9: f2 48 0f 2a c0               	cvtsi2sd	%rax, %xmm0
    9bbe: f2 0f 58 c0                  	addsd	%xmm0, %xmm0
    9bc2: e9 45 ff ff ff               	jmp	0x9b0c <pr_perm_msg+0x8c>
; }
    9bc7: e8 34 bc ff ff               	callq	0x5800 <.plt.sec+0x190>
    9bcc: 0f 1f 40 00                  	nopl	(%rax)

0000000000009bd0 <make_parent_dir>:
; {
    9bd0: 41 56                        	pushq	%r14
    9bd2: 41 55                        	pushq	%r13
    9bd4: 49 89 fd                     	movq	%rdi, %r13
    9bd7: 41 54                        	pushq	%r12
    9bd9: 55                           	pushq	%rbp
    9bda: 48 81 ec 98 00 00 00         	subq	$152, %rsp
    9be1: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    9bea: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
    9bf2: 31 c0                        	xorl	%eax, %eax
; 	dname = strdup(path);
    9bf4: e8 17 c0 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
; 	if (dname == NULL)
    9bf9: 48 85 c0                     	testq	%rax, %rax
    9bfc: 0f 84 b3 00 00 00            	je	0x9cb5 <make_parent_dir+0xe5>
; 	dir = dirname(dname);
    9c02: 48 89 c7                     	movq	%rax, %rdi
    9c05: 48 89 c5                     	movq	%rax, %rbp
    9c08: e8 83 bc ff ff               	callq	0x5890 <.plt.sec+0x220>
; 	if (mkdir(dir, 0700) && errno != EEXIST)
    9c0d: be c0 01 00 00               	movl	$448, %esi              # imm = 0x1C0
; 	dir = dirname(dname);
    9c12: 48 89 c7                     	movq	%rax, %rdi
; 	if (mkdir(dir, 0700) && errno != EEXIST)
    9c15: e8 36 bb ff ff               	callq	0x5750 <.plt.sec+0xe0>
    9c1a: 41 89 c4                     	movl	%eax, %r12d
    9c1d: 85 c0                        	testl	%eax, %eax
    9c1f: 74 4f                        	je	0x9c70 <make_parent_dir+0xa0>
    9c21: e8 ca ba ff ff               	callq	0x56f0 <.plt.sec+0x80>
    9c26: 44 8b 30                     	movl	(%rax), %r14d
    9c29: 41 83 fe 11                  	cmpl	$17, %r14d
    9c2d: 74 71                        	je	0x9ca0 <make_parent_dir+0xd0>
; 		err = -errno;
    9c2f: 45 89 f4                     	movl	%r14d, %r12d
; 	free(dname);
    9c32: 48 89 ef                     	movq	%rbp, %rdi
; 		err = -errno;
    9c35: 41 f7 dc                     	negl	%r12d
; 	free(dname);
    9c38: e8 83 ba ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (err) {
    9c3d: 45 85 f6                     	testl	%r14d, %r14d
    9c40: 74 6e                        	je	0x9cb0 <make_parent_dir+0xe0>
; 		cp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));
    9c42: 48 89 e6                     	movq	%rsp, %rsi
    9c45: 44 89 f7                     	movl	%r14d, %edi
    9c48: ba 80 00 00 00               	movl	$128, %edx
    9c4d: e8 7e 3d 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("failed to mkdir %s: %s\n", path, cp);
    9c52: 4c 89 ea                     	movq	%r13, %rdx
    9c55: 48 8d 35 4c 9e 02 00         	leaq	171596(%rip), %rsi      # 0x33aa8 <strs.2+0xc18>
    9c5c: 31 ff                        	xorl	%edi, %edi
; 		cp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));
    9c5e: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("failed to mkdir %s: %s\n", path, cp);
    9c61: 31 c0                        	xorl	%eax, %eax
    9c63: e8 68 e4 ff ff               	callq	0x80d0 <libbpf_print>
    9c68: eb 0e                        	jmp	0x9c78 <make_parent_dir+0xa8>
    9c6a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	free(dname);
    9c70: 48 89 ef                     	movq	%rbp, %rdi
    9c73: e8 48 ba ff ff               	callq	0x56c0 <.plt.sec+0x50>
; }
    9c78: 48 8b 84 24 88 00 00 00      	movq	136(%rsp), %rax
    9c80: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    9c89: 75 32                        	jne	0x9cbd <make_parent_dir+0xed>
    9c8b: 48 81 c4 98 00 00 00         	addq	$152, %rsp
    9c92: 44 89 e0                     	movl	%r12d, %eax
    9c95: 5d                           	popq	%rbp
    9c96: 41 5c                        	popq	%r12
    9c98: 41 5d                        	popq	%r13
    9c9a: 41 5e                        	popq	%r14
    9c9c: c3                           	retq
    9c9d: 0f 1f 00                     	nopl	(%rax)
; 	free(dname);
    9ca0: 48 89 ef                     	movq	%rbp, %rdi
; 	int err = 0;
    9ca3: 45 31 e4                     	xorl	%r12d, %r12d
; 	free(dname);
    9ca6: e8 15 ba ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (err) {
    9cab: eb cb                        	jmp	0x9c78 <make_parent_dir+0xa8>
    9cad: 0f 1f 00                     	nopl	(%rax)
    9cb0: 45 31 e4                     	xorl	%r12d, %r12d
    9cb3: eb c3                        	jmp	0x9c78 <make_parent_dir+0xa8>
; 		return -ENOMEM;
    9cb5: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
    9cbb: eb bb                        	jmp	0x9c78 <make_parent_dir+0xa8>
; }
    9cbd: e8 3e bb ff ff               	callq	0x5800 <.plt.sec+0x190>
    9cc2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    9ccd: 0f 1f 00                     	nopl	(%rax)

0000000000009cd0 <check_path>:
; {
    9cd0: 41 55                        	pushq	%r13
    9cd2: 41 54                        	pushq	%r12
    9cd4: 55                           	pushq	%rbp
    9cd5: 53                           	pushq	%rbx
    9cd6: 48 81 ec 18 01 00 00         	subq	$280, %rsp              # imm = 0x118
    9cdd: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    9ce6: 48 89 84 24 08 01 00 00      	movq	%rax, 264(%rsp)
    9cee: 31 c0                        	xorl	%eax, %eax
; 	if (path == NULL)
    9cf0: 48 85 ff                     	testq	%rdi, %rdi
    9cf3: 0f 84 d8 00 00 00            	je	0x9dd1 <check_path+0x101>
    9cf9: 49 89 fc                     	movq	%rdi, %r12
; 	dname = strdup(path);
    9cfc: e8 0f bf ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
    9d01: 48 89 c5                     	movq	%rax, %rbp
; 	if (dname == NULL)
    9d04: 48 85 c0                     	testq	%rax, %rax
    9d07: 0f 84 cf 00 00 00            	je	0x9ddc <check_path+0x10c>
; 	dir = dirname(dname);
    9d0d: 48 89 c7                     	movq	%rax, %rdi
    9d10: e8 7b bb ff ff               	callq	0x5890 <.plt.sec+0x220>
; 	if (statfs(dir, &st_fs)) {
    9d15: 48 89 e6                     	movq	%rsp, %rsi
    9d18: 48 89 c7                     	movq	%rax, %rdi
; 	dir = dirname(dname);
    9d1b: 49 89 c5                     	movq	%rax, %r13
; 	if (statfs(dir, &st_fs)) {
    9d1e: e8 8d bb ff ff               	callq	0x58b0 <.plt.sec+0x240>
    9d23: 85 c0                        	testl	%eax, %eax
    9d25: 75 41                        	jne	0x9d68 <check_path+0x98>
; 	free(dname);
    9d27: 48 89 ef                     	movq	%rbp, %rdi
    9d2a: e8 91 b9 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (!err && st_fs.f_type != BPF_FS_MAGIC) {
    9d2f: b8 11 4a fe ca               	movl	$3405662737, %eax       # imm = 0xCAFE4A11
    9d34: 48 39 04 24                  	cmpq	%rax, (%rsp)
    9d38: 75 79                        	jne	0x9db3 <check_path+0xe3>
    9d3a: 45 31 ed                     	xorl	%r13d, %r13d
; }
    9d3d: 48 8b 84 24 08 01 00 00      	movq	264(%rsp), %rax
    9d45: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    9d4e: 0f 85 93 00 00 00            	jne	0x9de7 <check_path+0x117>
    9d54: 48 81 c4 18 01 00 00         	addq	$280, %rsp              # imm = 0x118
    9d5b: 44 89 e8                     	movl	%r13d, %eax
    9d5e: 5b                           	popq	%rbx
    9d5f: 5d                           	popq	%rbp
    9d60: 41 5c                        	popq	%r12
    9d62: 41 5d                        	popq	%r13
    9d64: c3                           	retq
    9d65: 0f 1f 00                     	nopl	(%rax)
; 		cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    9d68: e8 83 b9 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    9d6d: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
    9d75: ba 80 00 00 00               	movl	$128, %edx
    9d7a: 8b 38                        	movl	(%rax), %edi
    9d7c: 48 89 c3                     	movq	%rax, %rbx
    9d7f: e8 4c 3c 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("failed to statfs %s: %s\n", dir, cp);
    9d84: 31 ff                        	xorl	%edi, %edi
    9d86: 4c 89 ea                     	movq	%r13, %rdx
    9d89: 48 8d 35 38 9d 02 00         	leaq	171320(%rip), %rsi      # 0x33ac8 <strs.2+0xc38>
; 		cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    9d90: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("failed to statfs %s: %s\n", dir, cp);
    9d93: 31 c0                        	xorl	%eax, %eax
    9d95: e8 36 e3 ff ff               	callq	0x80d0 <libbpf_print>
; 		err = -errno;
    9d9a: 8b 1b                        	movl	(%rbx), %ebx
; 	free(dname);
    9d9c: 48 89 ef                     	movq	%rbp, %rdi
; 		err = -errno;
    9d9f: 41 89 dd                     	movl	%ebx, %r13d
    9da2: 41 f7 dd                     	negl	%r13d
; 	free(dname);
    9da5: e8 16 b9 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (!err && st_fs.f_type != BPF_FS_MAGIC) {
    9daa: 85 db                        	testl	%ebx, %ebx
    9dac: 75 8f                        	jne	0x9d3d <check_path+0x6d>
    9dae: e9 7c ff ff ff               	jmp	0x9d2f <check_path+0x5f>
; 		pr_warn("specified path %s is not on BPF FS\n", path);
    9db3: 4c 89 e2                     	movq	%r12, %rdx
    9db6: 48 8d 35 33 9d 02 00         	leaq	171315(%rip), %rsi      # 0x33af0 <strs.2+0xc60>
    9dbd: 31 ff                        	xorl	%edi, %edi
    9dbf: 31 c0                        	xorl	%eax, %eax
    9dc1: e8 0a e3 ff ff               	callq	0x80d0 <libbpf_print>
; 		err = -EINVAL;
    9dc6: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
    9dcc: e9 6c ff ff ff               	jmp	0x9d3d <check_path+0x6d>
; 		return -EINVAL;
    9dd1: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
    9dd7: e9 61 ff ff ff               	jmp	0x9d3d <check_path+0x6d>
; 		return -ENOMEM;
    9ddc: 41 bd f4 ff ff ff            	movl	$4294967284, %r13d      # imm = 0xFFFFFFF4
    9de2: e9 56 ff ff ff               	jmp	0x9d3d <check_path+0x6d>
; }
    9de7: e8 14 ba ff ff               	callq	0x5800 <.plt.sec+0x190>
    9dec: 0f 1f 40 00                  	nopl	(%rax)

0000000000009df0 <__bpf_map__iter>:
; {
    9df0: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!obj || !obj->maps)
    9df4: 48 85 f6                     	testq	%rsi, %rsi
    9df7: 74 6e                        	je	0x9e67 <__bpf_map__iter+0x77>
    9df9: 48 8b 46 68                  	movq	104(%rsi), %rax
    9dfd: 48 85 c0                     	testq	%rax, %rax
    9e00: 74 65                        	je	0x9e67 <__bpf_map__iter+0x77>
; 	e = obj->maps + obj->nr_maps;
    9e02: 48 8b 76 70                  	movq	112(%rsi), %rsi
    9e06: 48 8d 0c b6                  	leaq	(%rsi,%rsi,4), %rcx
    9e0a: 48 c1 e1 05                  	shlq	$5, %rcx
    9e0e: 48 01 c1                     	addq	%rax, %rcx
; 	if ((m < s) || (m >= e)) {
    9e11: 48 39 cf                     	cmpq	%rcx, %rdi
    9e14: 73 3a                        	jae	0x9e50 <__bpf_map__iter+0x60>
    9e16: 48 39 f8                     	cmpq	%rdi, %rax
    9e19: 77 35                        	ja	0x9e50 <__bpf_map__iter+0x60>
; 	idx = (m - obj->maps) + i;
    9e1b: 48 b9 cd cc cc cc cc cc cc cc	movabsq	$-3689348814741910323, %rcx # imm = 0xCCCCCCCCCCCCCCCD
    9e25: 48 29 c7                     	subq	%rax, %rdi
    9e28: 48 63 d2                     	movslq	%edx, %rdx
    9e2b: 48 c1 ff 05                  	sarq	$5, %rdi
    9e2f: 48 0f af f9                  	imulq	%rcx, %rdi
; 	if (idx >= obj->nr_maps || idx < 0)
    9e33: 48 01 d7                     	addq	%rdx, %rdi
    9e36: 78 48                        	js	0x9e80 <__bpf_map__iter+0x90>
    9e38: 48 39 fe                     	cmpq	%rdi, %rsi
    9e3b: 76 43                        	jbe	0x9e80 <__bpf_map__iter+0x90>
; 	return &obj->maps[idx];
    9e3d: 48 8d 14 bf                  	leaq	(%rdi,%rdi,4), %rdx
; }
    9e41: 48 83 c4 08                  	addq	$8, %rsp
; 	return &obj->maps[idx];
    9e45: 48 c1 e2 05                  	shlq	$5, %rdx
    9e49: 48 01 d0                     	addq	%rdx, %rax
; }
    9e4c: c3                           	retq
    9e4d: 0f 1f 00                     	nopl	(%rax)
; 		pr_warn("error in %s: map handler doesn't belong to object\n",
    9e50: 48 8d 15 89 8f 02 00         	leaq	167817(%rip), %rdx      # 0x32de0 <__func__.15>
    9e57: 48 8d 35 c2 9c 02 00         	leaq	171202(%rip), %rsi      # 0x33b20 <strs.2+0xc90>
    9e5e: 31 ff                        	xorl	%edi, %edi
    9e60: 31 c0                        	xorl	%eax, %eax
    9e62: e8 69 e2 ff ff               	callq	0x80d0 <libbpf_print>
; 		return errno = EINVAL, NULL;
    9e67: e8 84 b8 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    9e6c: c7 00 16 00 00 00            	movl	$22, (%rax)
    9e72: 31 c0                        	xorl	%eax, %eax
; }
    9e74: 48 83 c4 08                  	addq	$8, %rsp
    9e78: c3                           	retq
    9e79: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return NULL;
    9e80: 31 c0                        	xorl	%eax, %eax
; }
    9e82: 48 83 c4 08                  	addq	$8, %rsp
    9e86: c3                           	retq
    9e87: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000009e90 <resolve_full_path>:
; {
    9e90: 41 57                        	pushq	%r15
; 	const char *search_paths[3] = {};
    9e92: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
    9e96: 41 56                        	pushq	%r14
    9e98: 41 55                        	pushq	%r13
    9e9a: 49 89 f5                     	movq	%rsi, %r13
    9e9d: 41 54                        	pushq	%r12
    9e9f: 49 89 fc                     	movq	%rdi, %r12
    9ea2: 55                           	pushq	%rbp
    9ea3: 53                           	pushq	%rbx
    9ea4: 48 89 d3                     	movq	%rdx, %rbx
    9ea7: 48 83 ec 38                  	subq	$56, %rsp
    9eab: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    9eb4: 48 89 44 24 28               	movq	%rax, 40(%rsp)
    9eb9: 31 c0                        	xorl	%eax, %eax
; 	const char *search_paths[3] = {};
    9ebb: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
    9ec0: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
; 	size_t str_len = strlen(str);
    9ec9: e8 12 b9 ff ff               	callq	0x57e0 <.plt.sec+0x170>
; 	if (sfx_len > str_len)
    9ece: 48 83 f8 02                  	cmpq	$2, %rax
    9ed2: 0f 86 90 00 00 00            	jbe	0x9f68 <resolve_full_path+0xd8>
; 	return strcmp(str + str_len - sfx_len, sfx) == 0;
    9ed8: 49 8d 7c 04 fd               	leaq	-3(%r12,%rax), %rdi
    9edd: 48 8d 35 d3 7e 02 00         	leaq	163539(%rip), %rsi      # 0x31db7 <_IO_stdin_used+0x1db7>
    9ee4: e8 c7 ba ff ff               	callq	0x59b0 <.plt.sec+0x340>
; 	if (str_has_sfx(file, ".so") || strstr(file, ".so.")) {
    9ee9: 85 c0                        	testl	%eax, %eax
    9eeb: 75 7b                        	jne	0x9f68 <resolve_full_path+0xd8>
; 		search_paths[0] = getenv("LD_LIBRARY_PATH");
    9eed: 48 8d 3d cc 7e 02 00         	leaq	163532(%rip), %rdi      # 0x31dc0 <_IO_stdin_used+0x1dc0>
; 		perm = R_OK;
    9ef4: 41 bf 04 00 00 00            	movl	$4, %r15d
; 		search_paths[0] = getenv("LD_LIBRARY_PATH");
    9efa: e8 81 b7 ff ff               	callq	0x5680 <.plt.sec+0x10>
    9eff: 49 89 c6                     	movq	%rax, %r14
; 		search_paths[1] = "/usr/lib64:/usr/lib";
    9f02: 48 8d 05 c7 7e 02 00         	leaq	163527(%rip), %rax      # 0x31dd0 <_IO_stdin_used+0x1dd0>
    9f09: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 		search_paths[2] = arch_specific_lib_paths();
    9f0e: 48 8d 05 cf 7e 02 00         	leaq	163535(%rip), %rax      # 0x31de4 <_IO_stdin_used+0x1de4>
    9f15: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	for (i = 0; i < ARRAY_SIZE(search_paths); i++) {
    9f1a: 48 8d 44 24 28               	leaq	40(%rsp), %rax
    9f1f: 48 8d 6c 24 10               	leaq	16(%rsp), %rbp
    9f24: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 		if (!search_paths[i])
    9f29: 4d 85 f6                     	testq	%r14, %r14
    9f2c: 0f 84 1e 01 00 00            	je	0xa050 <resolve_full_path+0x1c0>
; 				s++;
    9f32: 31 c0                        	xorl	%eax, %eax
    9f34: 41 80 3e 3a                  	cmpb	$58, (%r14)
; 			next_path = strchr(s, ':');
    9f38: be 3a 00 00 00               	movl	$58, %esi
; 				s++;
    9f3d: 0f 94 c0                     	sete	%al
    9f40: 49 01 c6                     	addq	%rax, %r14
; 			next_path = strchr(s, ':');
    9f43: 4c 89 f7                     	movq	%r14, %rdi
    9f46: e8 d5 b8 ff ff               	callq	0x5820 <.plt.sec+0x1b0>
; 			seg_len = next_path ? next_path - s : strlen(s);
    9f4b: 48 85 c0                     	testq	%rax, %rax
    9f4e: 74 60                        	je	0x9fb0 <resolve_full_path+0x120>
    9f50: 48 89 c2                     	movq	%rax, %rdx
    9f53: 4c 29 f2                     	subq	%r14, %rdx
    9f56: 41 89 d1                     	movl	%edx, %r9d
; 			if (!seg_len)
    9f59: 85 d2                        	testl	%edx, %edx
    9f5b: 75 66                        	jne	0x9fc3 <resolve_full_path+0x133>
; 		perm = R_OK | X_OK;
    9f5d: 49 89 c6                     	movq	%rax, %r14
    9f60: eb d0                        	jmp	0x9f32 <resolve_full_path+0xa2>
    9f62: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (str_has_sfx(file, ".so") || strstr(file, ".so.")) {
    9f68: 48 8d 35 4c 7e 02 00         	leaq	163404(%rip), %rsi      # 0x31dbb <_IO_stdin_used+0x1dbb>
    9f6f: 4c 89 e7                     	movq	%r12, %rdi
    9f72: e8 e9 bc ff ff               	callq	0x5c60 <.plt.sec+0x5f0>
    9f77: 48 85 c0                     	testq	%rax, %rax
    9f7a: 0f 85 6d ff ff ff            	jne	0x9eed <resolve_full_path+0x5d>
; 		search_paths[0] = getenv("PATH");
    9f80: 48 8d 3d 44 7e 02 00         	leaq	163396(%rip), %rdi      # 0x31dcb <_IO_stdin_used+0x1dcb>
; 		perm = R_OK | X_OK;
    9f87: 41 bf 05 00 00 00            	movl	$5, %r15d
; 		search_paths[0] = getenv("PATH");
    9f8d: e8 ee b6 ff ff               	callq	0x5680 <.plt.sec+0x10>
    9f92: 49 89 c6                     	movq	%rax, %r14
; 		search_paths[1] = "/usr/bin:/usr/sbin";
    9f95: 48 8d 05 5e 7e 02 00         	leaq	163422(%rip), %rax      # 0x31dfa <_IO_stdin_used+0x1dfa>
    9f9c: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 		perm = R_OK | X_OK;
    9fa1: e9 74 ff ff ff               	jmp	0x9f1a <resolve_full_path+0x8a>
    9fa6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 			seg_len = next_path ? next_path - s : strlen(s);
    9fb0: 4c 89 f7                     	movq	%r14, %rdi
    9fb3: e8 28 b8 ff ff               	callq	0x57e0 <.plt.sec+0x170>
    9fb8: 41 89 c1                     	movl	%eax, %r9d
; 			if (!seg_len)
    9fbb: 85 c0                        	testl	%eax, %eax
    9fbd: 0f 84 8d 00 00 00            	je	0xa050 <resolve_full_path+0x1c0>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    9fc3: 41 54                        	pushq	%r12
    9fc5: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
    9fcc: ba 01 00 00 00               	movl	$1, %edx
    9fd1: 31 c0                        	xorl	%eax, %eax
    9fd3: 41 56                        	pushq	%r14
    9fd5: 4c 8d 05 31 7e 02 00         	leaq	163377(%rip), %r8       # 0x31e0d <_IO_stdin_used+0x1e0d>
    9fdc: 48 89 de                     	movq	%rbx, %rsi
    9fdf: 4c 89 ef                     	movq	%r13, %rdi
    9fe2: e8 c9 b6 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 			if (access(result, perm) < 0)
    9fe7: 44 89 fe                     	movl	%r15d, %esi
    9fea: 4c 89 ef                     	movq	%r13, %rdi
    9fed: e8 ae bb ff ff               	callq	0x5ba0 <.plt.sec+0x530>
    9ff2: 5a                           	popq	%rdx
    9ff3: 59                           	popq	%rcx
    9ff4: 85 c0                        	testl	%eax, %eax
    9ff6: 78 40                        	js	0xa038 <resolve_full_path+0x1a8>
; 			pr_debug("resolved '%s' to '%s'\n", file, result);
    9ff8: 31 c0                        	xorl	%eax, %eax
    9ffa: 4c 89 e9                     	movq	%r13, %rcx
    9ffd: 4c 89 e2                     	movq	%r12, %rdx
    a000: bf 02 00 00 00               	movl	$2, %edi
    a005: 48 8d 35 54 9b 02 00         	leaq	170836(%rip), %rsi      # 0x33b60 <strs.2+0xcd0>
    a00c: e8 bf e0 ff ff               	callq	0x80d0 <libbpf_print>
; 			return 0;
    a011: 31 c0                        	xorl	%eax, %eax
; }
    a013: 48 8b 54 24 28               	movq	40(%rsp), %rdx
    a018: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    a021: 75 4c                        	jne	0xa06f <resolve_full_path+0x1df>
    a023: 48 83 c4 38                  	addq	$56, %rsp
    a027: 5b                           	popq	%rbx
    a028: 5d                           	popq	%rbp
    a029: 41 5c                        	popq	%r12
    a02b: 41 5d                        	popq	%r13
    a02d: 41 5e                        	popq	%r14
    a02f: 41 5f                        	popq	%r15
    a031: c3                           	retq
    a032: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		for (s = search_paths[i]; s != NULL; s = strchr(s, ':')) {
    a038: be 3a 00 00 00               	movl	$58, %esi
    a03d: 4c 89 f7                     	movq	%r14, %rdi
    a040: e8 db b7 ff ff               	callq	0x5820 <.plt.sec+0x1b0>
    a045: 48 85 c0                     	testq	%rax, %rax
    a048: 0f 85 0f ff ff ff            	jne	0x9f5d <resolve_full_path+0xcd>
    a04e: 66 90                        	nop
; 	for (i = 0; i < ARRAY_SIZE(search_paths); i++) {
    a050: 48 83 c5 08                  	addq	$8, %rbp
    a054: 48 39 6c 24 08               	cmpq	%rbp, 8(%rsp)
    a059: 74 0d                        	je	0xa068 <resolve_full_path+0x1d8>
; 		if (!search_paths[i])
    a05b: 4c 8b 75 00                  	movq	(%rbp), %r14
    a05f: e9 c5 fe ff ff               	jmp	0x9f29 <resolve_full_path+0x99>
    a064: 0f 1f 40 00                  	nopl	(%rax)
; 	return -ENOENT;
    a068: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
    a06d: eb a4                        	jmp	0xa013 <resolve_full_path+0x183>
; }
    a06f: e8 8c b7 ff ff               	callq	0x5800 <.plt.sec+0x190>
    a074: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    a07f: 90                           	nop

000000000000a080 <determine_tracepoint_id>:
; {
    a080: 41 55                        	pushq	%r13
    a082: 41 54                        	pushq	%r12
    a084: 55                           	pushq	%rbp
    a085: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
    a08c: 48 83 0c 24 00               	orq	$0, (%rsp)
    a091: 48 83 ec 10                  	subq	$16, %rsp
; 	if (has_debugfs < 0)
    a095: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    a09e: 48 89 84 24 08 10 00 00      	movq	%rax, 4104(%rsp)
    a0a6: 8b 05 64 cf 03 00            	movl	249700(%rip), %eax      # 0x47010 <has_debugfs.1>
; {
    a0ac: 49 89 fc                     	movq	%rdi, %r12
    a0af: 49 89 f5                     	movq	%rsi, %r13
; 	if (has_debugfs < 0)
    a0b2: 85 c0                        	testl	%eax, %eax
    a0b4: 0f 88 8e 00 00 00            	js	0xa148 <determine_tracepoint_id+0xc8>
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
    a0ba: 83 f8 01                     	cmpl	$1, %eax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    a0bd: 48 89 e5                     	movq	%rsp, %rbp
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
    a0c0: 48 8d 05 4e 7d 02 00         	leaq	163150(%rip), %rax      # 0x31e15 <_IO_stdin_used+0x1e15>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    a0c7: 41 55                        	pushq	%r13
    a0c9: 41 54                        	pushq	%r12
    a0cb: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
    a0d0: ba 01 00 00 00               	movl	$1, %edx
    a0d5: 48 89 ef                     	movq	%rbp, %rdi
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
    a0d8: 4c 8d 0d 95 7b 02 00         	leaq	162709(%rip), %r9       # 0x31c74 <_IO_stdin_used+0x1c74>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    a0df: 4c 8d 05 43 7d 02 00         	leaq	163139(%rip), %r8       # 0x31e29 <_IO_stdin_used+0x1e29>
    a0e6: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
    a0eb: 4c 0f 45 c8                  	cmovneq	%rax, %r9
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    a0ef: 31 c0                        	xorl	%eax, %eax
    a0f1: e8 ba b5 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (ret < 0)
    a0f6: 48 89 ec                     	movq	%rbp, %rsp
    a0f9: 85 c0                        	testl	%eax, %eax
    a0fb: 78 3b                        	js	0xa138 <determine_tracepoint_id+0xb8>
; 	if (ret >= sizeof(file)) {
    a0fd: 3d ff 0f 00 00               	cmpl	$4095, %eax             # imm = 0xFFF
    a102: 7f 65                        	jg	0xa169 <determine_tracepoint_id+0xe9>
; 	return parse_uint_from_file(file, "%d\n");
    a104: 48 8d 35 39 f1 02 00         	leaq	192825(%rip), %rsi      # 0x39244 <strs.2+0x63b4>
    a10b: 48 89 ef                     	movq	%rbp, %rdi
    a10e: e8 bd e2 ff ff               	callq	0x83d0 <parse_uint_from_file>
; }
    a113: 48 8b 94 24 08 10 00 00      	movq	4104(%rsp), %rdx
    a11b: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    a124: 75 63                        	jne	0xa189 <determine_tracepoint_id+0x109>
    a126: 48 81 c4 10 10 00 00         	addq	$4112, %rsp             # imm = 0x1010
    a12d: 5d                           	popq	%rbp
    a12e: 41 5c                        	popq	%r12
    a130: 41 5d                        	popq	%r13
    a132: c3                           	retq
    a133: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		return -errno;
    a138: e8 b3 b5 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    a13d: 8b 00                        	movl	(%rax), %eax
    a13f: f7 d8                        	negl	%eax
    a141: eb d0                        	jmp	0xa113 <determine_tracepoint_id+0x93>
    a143: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
    a148: 31 f6                        	xorl	%esi, %esi
    a14a: 48 8d 3d 23 7b 02 00         	leaq	162595(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
    a151: e8 4a ba ff ff               	callq	0x5ba0 <.plt.sec+0x530>
    a156: 85 c0                        	testl	%eax, %eax
    a158: 0f 94 c0                     	sete	%al
    a15b: 0f b6 c0                     	movzbl	%al, %eax
    a15e: 89 05 ac ce 03 00            	movl	%eax, 249516(%rip)      # 0x47010 <has_debugfs.1>
    a164: e9 51 ff ff ff               	jmp	0xa0ba <determine_tracepoint_id+0x3a>
; 		pr_debug("tracepoint %s/%s path is too long\n",
    a169: 31 c0                        	xorl	%eax, %eax
    a16b: 4c 89 e9                     	movq	%r13, %rcx
    a16e: 4c 89 e2                     	movq	%r12, %rdx
    a171: bf 02 00 00 00               	movl	$2, %edi
    a176: 48 8d 35 03 9a 02 00         	leaq	170499(%rip), %rsi      # 0x33b80 <strs.2+0xcf0>
    a17d: e8 4e df ff ff               	callq	0x80d0 <libbpf_print>
; 		return -E2BIG;
    a182: b8 f9 ff ff ff               	movl	$4294967289, %eax       # imm = 0xFFFFFFF9
    a187: eb 8a                        	jmp	0xa113 <determine_tracepoint_id+0x93>
; }
    a189: e8 72 b6 ff ff               	callq	0x5800 <.plt.sec+0x190>
    a18e: 66 90                        	nop

000000000000a190 <perf_buffer__free_cpu_buf>:
; 	if (!cpu_buf)
    a190: 48 85 f6                     	testq	%rsi, %rsi
    a193: 74 7b                        	je	0xa210 <perf_buffer__free_cpu_buf+0x80>
; {
    a195: 55                           	pushq	%rbp
; 	if (cpu_buf->base &&
    a196: 4c 8b 46 08                  	movq	8(%rsi), %r8
    a19a: 48 89 f5                     	movq	%rsi, %rbp
    a19d: 4d 85 c0                     	testq	%r8, %r8
    a1a0: 74 14                        	je	0xa1b6 <perf_buffer__free_cpu_buf+0x26>
; 	    munmap(cpu_buf->base, pb->mmap_size + pb->page_size))
    a1a2: 48 8b 77 20                  	movq	32(%rdi), %rsi
    a1a6: 48 03 77 28                  	addq	40(%rdi), %rsi
    a1aa: 4c 89 c7                     	movq	%r8, %rdi
    a1ad: e8 8e b9 ff ff               	callq	0x5b40 <.plt.sec+0x4d0>
; 	if (cpu_buf->base &&
    a1b2: 85 c0                        	testl	%eax, %eax
    a1b4: 75 3a                        	jne	0xa1f0 <perf_buffer__free_cpu_buf+0x60>
; 	if (cpu_buf->fd >= 0) {
    a1b6: 8b 7d 20                     	movl	32(%rbp), %edi
    a1b9: 85 ff                        	testl	%edi, %edi
    a1bb: 79 13                        	jns	0xa1d0 <perf_buffer__free_cpu_buf+0x40>
; 	free(cpu_buf->buf);
    a1bd: 48 8b 7d 10                  	movq	16(%rbp), %rdi
    a1c1: e8 fa b4 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(cpu_buf);
    a1c6: 48 89 ef                     	movq	%rbp, %rdi
; }
    a1c9: 5d                           	popq	%rbp
; 	free(cpu_buf);
    a1ca: e9 f1 b4 ff ff               	jmp	0x56c0 <.plt.sec+0x50>
    a1cf: 90                           	nop
; 		ioctl(cpu_buf->fd, PERF_EVENT_IOC_DISABLE, 0);
    a1d0: 31 d2                        	xorl	%edx, %edx
    a1d2: be 01 24 00 00               	movl	$9217, %esi             # imm = 0x2401
    a1d7: 31 c0                        	xorl	%eax, %eax
    a1d9: e8 12 b7 ff ff               	callq	0x58f0 <.plt.sec+0x280>
; 		close(cpu_buf->fd);
    a1de: 8b 7d 20                     	movl	32(%rbp), %edi
    a1e1: e8 1a b7 ff ff               	callq	0x5900 <.plt.sec+0x290>
    a1e6: eb d5                        	jmp	0xa1bd <perf_buffer__free_cpu_buf+0x2d>
    a1e8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		pr_warn("failed to munmap cpu_buf #%d\n", cpu_buf->cpu);
    a1f0: 8b 55 24                     	movl	36(%rbp), %edx
    a1f3: 31 ff                        	xorl	%edi, %edi
    a1f5: 48 8d 35 b4 99 02 00         	leaq	170420(%rip), %rsi      # 0x33bb0 <strs.2+0xd20>
    a1fc: 31 c0                        	xorl	%eax, %eax
    a1fe: e8 cd de ff ff               	callq	0x80d0 <libbpf_print>
; 	if (cpu_buf->fd >= 0) {
    a203: 8b 7d 20                     	movl	32(%rbp), %edi
    a206: 85 ff                        	testl	%edi, %edi
    a208: 78 b3                        	js	0xa1bd <perf_buffer__free_cpu_buf+0x2d>
    a20a: eb c4                        	jmp	0xa1d0 <perf_buffer__free_cpu_buf+0x40>
    a20c: 0f 1f 40 00                  	nopl	(%rax)
    a210: c3                           	retq
    a211: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    a21c: 0f 1f 40 00                  	nopl	(%rax)

000000000000a220 <perf_buffer__process_records.isra.0>:
; static int perf_buffer__process_records(struct perf_buffer *pb,
    a220: 41 57                        	pushq	%r15
    a222: 41 56                        	pushq	%r14
    a224: 41 55                        	pushq	%r13
    a226: 41 54                        	pushq	%r12
    a228: 55                           	pushq	%rbp
    a229: 53                           	pushq	%rbx
    a22a: 48 83 ec 38                  	subq	$56, %rsp
; 	ret = perf_event_read_simple(cpu_buf->base, pb->mmap_size,
    a22e: 48 8b 42 08                  	movq	8(%rdx), %rax
; static int perf_buffer__process_records(struct perf_buffer *pb,
    a232: 48 89 74 24 18               	movq	%rsi, 24(%rsp)
; 	return smp_load_acquire(&base->data_head);
    a237: 48 8b 88 00 04 00 00         	movq	1024(%rax), %rcx
; 	ret = perf_event_read_simple(cpu_buf->base, pb->mmap_size,
    a23e: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	return smp_load_acquire(&base->data_head);
    a243: 48 89 4c 24 10               	movq	%rcx, 16(%rsp)
; 	__u64 data_tail = header->data_tail;
    a248: 4c 8b b8 08 04 00 00         	movq	1032(%rax), %r15
; 	void *base = ((__u8 *)header) + page_size;
    a24f: 48 8d 1c 38                  	leaq	(%rax,%rdi), %rbx
; 	while (data_head != data_tail) {
    a253: 4c 39 f9                     	cmpq	%r15, %rcx
    a256: 0f 84 c6 01 00 00            	je	0xa422 <perf_buffer__process_records.isra.0+0x202>
; 		ehdr = base + (data_tail & (mmap_size - 1));
    a25c: 48 8d 46 ff                  	leaq	-1(%rsi), %rax
    a260: 49 89 d4                     	movq	%rdx, %r12
    a263: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 		if (((void *)ehdr) + ehdr_size > base + mmap_size) {
    a268: 48 8d 04 33                  	leaq	(%rbx,%rsi), %rax
    a26c: 48 89 04 24                  	movq	%rax, (%rsp)
    a270: eb 2f                        	jmp	0xa2a1 <perf_buffer__process_records.isra.0+0x81>
    a272: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return pb->event_cb(pb->ctx, cpu_buf->cpu, e);
    a278: 45 8b 5c 24 24               	movl	36(%r12), %r11d
    a27d: 48 89 f2                     	movq	%rsi, %rdx
    a280: 48 8b 78 18                  	movq	24(%rax), %rdi
    a284: 44 89 de                     	movl	%r11d, %esi
    a287: 41 ff d2                     	callq	*%r10
    a28a: 41 89 c6                     	movl	%eax, %r14d
; 		if (ret != LIBBPF_PERF_EVENT_CONT)
    a28d: 83 f8 fe                     	cmpl	$-2, %eax
    a290: 0f 85 e8 00 00 00            	jne	0xa37e <perf_buffer__process_records.isra.0+0x15e>
; 	while (data_head != data_tail) {
    a296: 4c 39 7c 24 10               	cmpq	%r15, 16(%rsp)
    a29b: 0f 84 d7 00 00 00            	je	0xa378 <perf_buffer__process_records.isra.0+0x158>
; 		ehdr = base + (data_tail & (mmap_size - 1));
    a2a1: 48 8b 44 24 08               	movq	8(%rsp), %rax
    a2a6: 4c 21 f8                     	andq	%r15, %rax
    a2a9: 48 8d 34 03                  	leaq	(%rbx,%rax), %rsi
; 		ehdr_size = ehdr->size;
    a2ad: 44 0f b7 6e 06               	movzwl	6(%rsi), %r13d
; 		if (((void *)ehdr) + ehdr_size > base + mmap_size) {
    a2b2: 4a 8d 14 2e                  	leaq	(%rsi,%r13), %rdx
    a2b6: 48 39 14 24                  	cmpq	%rdx, (%rsp)
    a2ba: 73 67                        	jae	0xa323 <perf_buffer__process_records.isra.0+0x103>
; 			size_t len_first = base + mmap_size - copy_start;
    a2bc: 48 8b 6c 24 18               	movq	24(%rsp), %rbp
; 			size_t len_secnd = ehdr_size - len_first;
    a2c1: 4d 89 ee                     	movq	%r13, %r14
; 				free(*copy_mem);
    a2c4: 49 8b 7c 24 10               	movq	16(%r12), %rdi
; 			size_t len_first = base + mmap_size - copy_start;
    a2c9: 48 29 c5                     	subq	%rax, %rbp
; 			size_t len_secnd = ehdr_size - len_first;
    a2cc: 49 29 ee                     	subq	%rbp, %r14
; 			if (*copy_size < ehdr_size) {
    a2cf: 4d 3b 6c 24 18               	cmpq	24(%r12), %r13
    a2d4: 76 2d                        	jbe	0xa303 <perf_buffer__process_records.isra.0+0xe3>
    a2d6: 48 89 74 24 20               	movq	%rsi, 32(%rsp)
; 				free(*copy_mem);
    a2db: e8 e0 b3 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 				*copy_mem = malloc(ehdr_size);
    a2e0: 4c 89 ef                     	movq	%r13, %rdi
    a2e3: e8 a8 b7 ff ff               	callq	0x5a90 <.plt.sec+0x420>
; 				if (!*copy_mem) {
    a2e8: 48 8b 74 24 20               	movq	32(%rsp), %rsi
    a2ed: 48 85 c0                     	testq	%rax, %rax
; 				*copy_mem = malloc(ehdr_size);
    a2f0: 49 89 44 24 10               	movq	%rax, 16(%r12)
    a2f5: 48 89 c7                     	movq	%rax, %rdi
; 				if (!*copy_mem) {
    a2f8: 0f 84 19 01 00 00            	je	0xa417 <perf_buffer__process_records.isra.0+0x1f7>
; 				*copy_size = ehdr_size;
    a2fe: 4d 89 6c 24 18               	movq	%r13, 24(%r12)
;   return __builtin___memcpy_chk (__dest, __src, __len,
    a303: 48 89 ea                     	movq	%rbp, %rdx
    a306: e8 35 b7 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 			memcpy(*copy_mem + len_first, base, len_secnd);
    a30b: 49 8b 7c 24 10               	movq	16(%r12), %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
    a310: 48 89 de                     	movq	%rbx, %rsi
    a313: 4c 89 f2                     	movq	%r14, %rdx
; 			memcpy(*copy_mem + len_first, base, len_secnd);
    a316: 48 01 ef                     	addq	%rbp, %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
    a319: e8 22 b7 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 			ehdr = *copy_mem;
    a31e: 49 8b 74 24 10               	movq	16(%r12), %rsi
; 	struct perf_buffer *pb = cpu_buf->pb;
    a323: 49 8b 04 24                  	movq	(%r12), %rax
; 		data_tail += ehdr_size;
    a327: 4d 01 ef                     	addq	%r13, %r15
; 	if (pb->event_cb)
    a32a: 4c 8b 10                     	movq	(%rax), %r10
    a32d: 4d 85 d2                     	testq	%r10, %r10
    a330: 0f 85 42 ff ff ff            	jne	0xa278 <perf_buffer__process_records.isra.0+0x58>
; 	switch (e->type) {
    a336: 8b 16                        	movl	(%rsi), %edx
    a338: 83 fa 02                     	cmpl	$2, %edx
    a33b: 74 73                        	je	0xa3b0 <perf_buffer__process_records.isra.0+0x190>
    a33d: 83 fa 09                     	cmpl	$9, %edx
    a340: 0f 85 92 00 00 00            	jne	0xa3d8 <perf_buffer__process_records.isra.0+0x1b8>
; 		if (pb->sample_cb)
    a346: 4c 8b 50 08                  	movq	8(%rax), %r10
    a34a: 4d 85 d2                     	testq	%r10, %r10
    a34d: 0f 84 43 ff ff ff            	je	0xa296 <perf_buffer__process_records.isra.0+0x76>
; 			pb->sample_cb(pb->ctx, cpu_buf->cpu, s->data, s->size);
    a353: 8b 4e 08                     	movl	8(%rsi), %ecx
    a356: 48 8d 56 0c                  	leaq	12(%rsi), %rdx
    a35a: 48 8b 78 18                  	movq	24(%rax), %rdi
    a35e: 41 8b 74 24 24               	movl	36(%r12), %esi
    a363: 41 ff d2                     	callq	*%r10
; 	while (data_head != data_tail) {
    a366: 4c 39 7c 24 10               	cmpq	%r15, 16(%rsp)
    a36b: 0f 85 30 ff ff ff            	jne	0xa2a1 <perf_buffer__process_records.isra.0+0x81>
    a371: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    a378: 41 be fe ff ff ff            	movl	$4294967294, %r14d      # imm = 0xFFFFFFFE
; 	smp_store_release(&base->data_tail, tail);
    a37e: 48 8b 44 24 28               	movq	40(%rsp), %rax
    a383: 4c 89 b8 08 04 00 00         	movq	%r15, 1032(%rax)
; 	if (ret < 0)
    a38a: 45 85 f6                     	testl	%r14d, %r14d
    a38d: 79 76                        	jns	0xa405 <perf_buffer__process_records.isra.0+0x1e5>
; 		errno = -ret;
    a38f: e8 5c b3 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    a394: 44 89 f2                     	movl	%r14d, %edx
    a397: f7 da                        	negl	%edx
    a399: 89 10                        	movl	%edx, (%rax)
; 	if (ret != LIBBPF_PERF_EVENT_CONT)
    a39b: 41 83 fe fe                  	cmpl	$-2, %r14d
    a39f: 75 64                        	jne	0xa405 <perf_buffer__process_records.isra.0+0x1e5>
; 	return 0;
    a3a1: 45 31 f6                     	xorl	%r14d, %r14d
    a3a4: eb 5f                        	jmp	0xa405 <perf_buffer__process_records.isra.0+0x1e5>
    a3a6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		if (pb->lost_cb)
    a3b0: 48 8b 48 10                  	movq	16(%rax), %rcx
    a3b4: 48 85 c9                     	testq	%rcx, %rcx
    a3b7: 0f 84 d9 fe ff ff            	je	0xa296 <perf_buffer__process_records.isra.0+0x76>
; 			pb->lost_cb(pb->ctx, cpu_buf->cpu, s->lost);
    a3bd: 48 8b 56 10                  	movq	16(%rsi), %rdx
    a3c1: 48 8b 78 18                  	movq	24(%rax), %rdi
    a3c5: 41 8b 74 24 24               	movl	36(%r12), %esi
    a3ca: ff d1                        	callq	*%rcx
; 		if (ret != LIBBPF_PERF_EVENT_CONT)
    a3cc: e9 c5 fe ff ff               	jmp	0xa296 <perf_buffer__process_records.isra.0+0x76>
    a3d1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("unknown perf sample type %d\n", e->type);
    a3d8: 48 8d 35 f9 97 02 00         	leaq	169977(%rip), %rsi      # 0x33bd8 <strs.2+0xd48>
    a3df: 31 ff                        	xorl	%edi, %edi
    a3e1: 31 c0                        	xorl	%eax, %eax
    a3e3: e8 e8 dc ff ff               	callq	0x80d0 <libbpf_print>
; 	smp_store_release(&base->data_tail, tail);
    a3e8: 48 8b 44 24 28               	movq	40(%rsp), %rax
; 		return LIBBPF_PERF_EVENT_ERROR;
    a3ed: 41 be ff ff ff ff            	movl	$4294967295, %r14d      # imm = 0xFFFFFFFF
; 	smp_store_release(&base->data_tail, tail);
    a3f3: 4c 89 b8 08 04 00 00         	movq	%r15, 1032(%rax)
; 		errno = -ret;
    a3fa: e8 f1 b2 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    a3ff: c7 00 01 00 00 00            	movl	$1, (%rax)
; }
    a405: 48 83 c4 38                  	addq	$56, %rsp
    a409: 44 89 f0                     	movl	%r14d, %eax
    a40c: 5b                           	popq	%rbx
    a40d: 5d                           	popq	%rbp
    a40e: 41 5c                        	popq	%r12
    a410: 41 5d                        	popq	%r13
    a412: 41 5e                        	popq	%r14
    a414: 41 5f                        	popq	%r15
    a416: c3                           	retq
; 					*copy_size = 0;
    a417: 49 c7 44 24 18 00 00 00 00   	movq	$0, 24(%r12)
; 	smp_store_release(&base->data_tail, tail);
    a420: eb c6                        	jmp	0xa3e8 <perf_buffer__process_records.isra.0+0x1c8>
    a422: 48 8b 44 24 28               	movq	40(%rsp), %rax
    a427: 48 8b 5c 24 10               	movq	16(%rsp), %rbx
; 	return 0;
    a42c: 45 31 f6                     	xorl	%r14d, %r14d
; 	smp_store_release(&base->data_tail, tail);
    a42f: 48 89 98 08 04 00 00         	movq	%rbx, 1032(%rax)
; 		errno = -ret;
    a436: e8 b5 b2 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    a43b: c7 00 02 00 00 00            	movl	$2, (%rax)
; 	if (ret != LIBBPF_PERF_EVENT_CONT)
    a441: eb c2                        	jmp	0xa405 <perf_buffer__process_records.isra.0+0x1e5>
    a443: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    a44e: 66 90                        	nop

000000000000a450 <kernel_supports.part.0>:
; bool kernel_supports(const struct bpf_object *obj, enum kern_feature_id feat_id)
    a450: 41 54                        	pushq	%r12
; 	if (READ_ONCE(feat->res) == FEAT_UNKNOWN) {
    a452: 4c 8d 25 c7 cb 03 00         	leaq	248775(%rip), %r12      # 0x47020 <feature_probes>
; bool kernel_supports(const struct bpf_object *obj, enum kern_feature_id feat_id)
    a459: 55                           	pushq	%rbp
    a45a: 53                           	pushq	%rbx
; 	if (READ_ONCE(feat->res) == FEAT_UNKNOWN) {
    a45b: 89 fb                        	movl	%edi, %ebx
    a45d: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
    a461: 49 8d 2c c4                  	leaq	(%r12,%rax,8), %rbp
    a465: 8b 45 10                     	movl	16(%rbp), %eax
    a468: 85 c0                        	testl	%eax, %eax
    a46a: 75 0e                        	jne	0xa47a <kernel_supports.part.0+0x2a>
; 		ret = feat->probe();
    a46c: ff 55 08                     	callq	*8(%rbp)
; 		if (ret > 0) {
    a46f: 85 c0                        	testl	%eax, %eax
    a471: 7e 1d                        	jle	0xa490 <kernel_supports.part.0+0x40>
; 			WRITE_ONCE(feat->res, FEAT_SUPPORTED);
    a473: c7 45 10 01 00 00 00         	movl	$1, 16(%rbp)
; 	return READ_ONCE(feat->res) == FEAT_SUPPORTED;
    a47a: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
; }
    a47e: 5b                           	popq	%rbx
    a47f: 5d                           	popq	%rbp
; 	return READ_ONCE(feat->res) == FEAT_SUPPORTED;
    a480: 49 8d 04 c4                  	leaq	(%r12,%rax,8), %rax
; }
    a484: 41 5c                        	popq	%r12
; 	return READ_ONCE(feat->res) == FEAT_SUPPORTED;
    a486: 8b 40 10                     	movl	16(%rax), %eax
    a489: 83 f8 01                     	cmpl	$1, %eax
    a48c: 0f 94 c0                     	sete	%al
; }
    a48f: c3                           	retq
; 		} else if (ret == 0) {
    a490: 75 0e                        	jne	0xa4a0 <kernel_supports.part.0+0x50>
; 			WRITE_ONCE(feat->res, FEAT_MISSING);
    a492: c7 45 10 02 00 00 00         	movl	$2, 16(%rbp)
    a499: eb df                        	jmp	0xa47a <kernel_supports.part.0+0x2a>
    a49b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			pr_warn("Detection of kernel %s support failed: %d\n", feat->desc, ret);
    a4a0: 48 8b 55 00                  	movq	(%rbp), %rdx
    a4a4: 89 c1                        	movl	%eax, %ecx
    a4a6: 48 8d 35 53 97 02 00         	leaq	169811(%rip), %rsi      # 0x33c00 <strs.2+0xd70>
    a4ad: 31 ff                        	xorl	%edi, %edi
    a4af: 31 c0                        	xorl	%eax, %eax
    a4b1: e8 1a dc ff ff               	callq	0x80d0 <libbpf_print>
    a4b6: eb da                        	jmp	0xa492 <kernel_supports.part.0+0x42>
    a4b8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000000a4c0 <bpf_program__attach_fd>:
; {
    a4c0: 41 56                        	pushq	%r14
; 	DECLARE_LIBBPF_OPTS(bpf_link_create_opts, opts,
    a4c2: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
    a4c6: 41 55                        	pushq	%r13
    a4c8: 41 54                        	pushq	%r12
    a4ca: 55                           	pushq	%rbp
    a4cb: 53                           	pushq	%rbx
    a4cc: 48 89 fb                     	movq	%rdi, %rbx
    a4cf: 48 81 ec 10 01 00 00         	subq	$272, %rsp              # imm = 0x110
    a4d6: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    a4df: 48 89 84 24 08 01 00 00      	movq	%rax, 264(%rsp)
    a4e7: 31 c0                        	xorl	%eax, %eax
; 	DECLARE_LIBBPF_OPTS(bpf_link_create_opts, opts,
    a4e9: 0f 11 44 24 58               	movups	%xmm0, 88(%rsp)
    a4ee: 0f 11 44 24 48               	movups	%xmm0, 72(%rsp)
    a4f3: 0f 11 44 24 68               	movups	%xmm0, 104(%rsp)
    a4f8: 66 0f 6f 5c 24 60            	movdqa	96(%rsp), %xmm3
    a4fe: 48 c7 44 24 78 00 00 00 00   	movq	$0, 120(%rsp)
    a507: 66 0f 6f 64 24 70            	movdqa	112(%rsp), %xmm4
    a50d: 48 c7 44 24 40 40 00 00 00   	movq	$64, 64(%rsp)
    a516: 66 0f 6f 4c 24 40            	movdqa	64(%rsp), %xmm1
    a51c: 89 54 24 5c                  	movl	%edx, 92(%rsp)
    a520: 66 0f 6f 54 24 50            	movdqa	80(%rsp), %xmm2
    a526: 0f 29 0c 24                  	movaps	%xmm1, (%rsp)
    a52a: 0f 29 54 24 10               	movaps	%xmm2, 16(%rsp)
    a52f: 0f 29 5c 24 20               	movaps	%xmm3, 32(%rsp)
    a534: 0f 29 64 24 30               	movaps	%xmm4, 48(%rsp)
; 	if (!prog)
    a539: 48 85 ff                     	testq	%rdi, %rdi
    a53c: 0f 84 fa 00 00 00            	je	0xa63c <bpf_program__attach_fd+0x17c>
; 	if (prog->fd < 0)
    a542: 8b 6f 78                     	movl	120(%rdi), %ebp
    a545: 85 ed                        	testl	%ebp, %ebp
    a547: 0f 88 bf 00 00 00            	js	0xa60c <bpf_program__attach_fd+0x14c>
    a54d: 41 89 f6                     	movl	%esi, %r14d
; 	link = calloc(1, sizeof(*link));
    a550: bf 01 00 00 00               	movl	$1, %edi
    a555: be 20 00 00 00               	movl	$32, %esi
    a55a: 49 89 cd                     	movq	%rcx, %r13
    a55d: e8 2e b4 ff ff               	callq	0x5990 <.plt.sec+0x320>
    a562: 49 89 c4                     	movq	%rax, %r12
; 	if (!link)
    a565: 48 85 c0                     	testq	%rax, %rax
    a568: 0f 84 e3 00 00 00            	je	0xa651 <bpf_program__attach_fd+0x191>
; 	link->detach = &bpf_link__detach_fd;
    a56e: 48 8d 05 5b d3 ff ff         	leaq	-11429(%rip), %rax      # 0x78d0 <bpf_link__detach_fd>
; 	link_fd = bpf_link_create(prog_fd, target_fd, attach_type, &opts);
    a575: 48 89 e1                     	movq	%rsp, %rcx
    a578: 44 89 f6                     	movl	%r14d, %esi
    a57b: 89 ef                        	movl	%ebp, %edi
; 	link->detach = &bpf_link__detach_fd;
    a57d: 49 89 04 24                  	movq	%rax, (%r12)
; 	link_fd = bpf_link_create(prog_fd, target_fd, attach_type, &opts);
    a581: 8b 93 84 00 00 00            	movl	132(%rbx), %edx
    a587: e8 c4 d7 01 00               	callq	0x27d50 <bpf_link_create>
; 	if (link_fd < 0) {
    a58c: 85 c0                        	testl	%eax, %eax
    a58e: 78 30                        	js	0xa5c0 <bpf_program__attach_fd+0x100>
; 	link->fd = link_fd;
    a590: 41 89 44 24 18               	movl	%eax, 24(%r12)
; }
    a595: 48 8b 84 24 08 01 00 00      	movq	264(%rsp), %rax
    a59d: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    a5a6: 0f 85 a0 00 00 00            	jne	0xa64c <bpf_program__attach_fd+0x18c>
    a5ac: 48 81 c4 10 01 00 00         	addq	$272, %rsp              # imm = 0x110
    a5b3: 4c 89 e0                     	movq	%r12, %rax
    a5b6: 5b                           	popq	%rbx
    a5b7: 5d                           	popq	%rbp
    a5b8: 41 5c                        	popq	%r12
    a5ba: 41 5d                        	popq	%r13
    a5bc: 41 5e                        	popq	%r14
    a5be: c3                           	retq
    a5bf: 90                           	nop
; 		link_fd = -errno;
    a5c0: e8 2b b1 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		free(link);
    a5c5: 4c 89 e7                     	movq	%r12, %rdi
; 		return libbpf_err_ptr(link_fd);
    a5c8: 45 31 e4                     	xorl	%r12d, %r12d
; 		link_fd = -errno;
    a5cb: 44 8b 30                     	movl	(%rax), %r14d
    a5ce: 48 89 c5                     	movq	%rax, %rbp
; 		free(link);
    a5d1: e8 ea b0 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 		pr_warn("prog '%s': failed to attach to %s: %s\n",
    a5d6: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
    a5de: ba 80 00 00 00               	movl	$128, %edx
; 		link_fd = -errno;
    a5e3: 44 89 f7                     	movl	%r14d, %edi
    a5e6: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to attach to %s: %s\n",
    a5e8: e8 e3 33 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
    a5ed: 48 8b 13                     	movq	(%rbx), %rdx
    a5f0: 4c 89 e9                     	movq	%r13, %rcx
    a5f3: 31 ff                        	xorl	%edi, %edi
    a5f5: 49 89 c0                     	movq	%rax, %r8
    a5f8: 48 8d 35 69 96 02 00         	leaq	169577(%rip), %rsi      # 0x33c68 <strs.2+0xdd8>
    a5ff: 31 c0                        	xorl	%eax, %eax
    a601: e8 ca da ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
    a606: 44 89 75 00                  	movl	%r14d, (%rbp)
; 		return libbpf_err_ptr(link_fd);
    a60a: eb 89                        	jmp	0xa595 <bpf_program__attach_fd+0xd5>
; 		errno = -ret;
    a60c: e8 df b0 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    a611: c7 00 02 00 00 00            	movl	$2, (%rax)
    a617: 48 89 c5                     	movq	%rax, %rbp
; 		pr_warn("prog '%s': can't attach before loaded\n", prog->name);
    a61a: 48 8b 13                     	movq	(%rbx), %rdx
    a61d: 48 8d 35 14 96 02 00         	leaq	169492(%rip), %rsi      # 0x33c38 <strs.2+0xda8>
    a624: 31 ff                        	xorl	%edi, %edi
    a626: 31 c0                        	xorl	%eax, %eax
; 		return libbpf_err_ptr(-EINVAL);
    a628: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_warn("prog '%s': can't attach before loaded\n", prog->name);
    a62b: e8 a0 da ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
    a630: c7 45 00 16 00 00 00         	movl	$22, (%rbp)
; 		return libbpf_err_ptr(-EINVAL);
    a637: e9 59 ff ff ff               	jmp	0xa595 <bpf_program__attach_fd+0xd5>
; 		errno = -ret;
    a63c: e8 af b0 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    a641: c7 00 16 00 00 00            	movl	$22, (%rax)
    a647: 48 89 c5                     	movq	%rax, %rbp
    a64a: eb ce                        	jmp	0xa61a <bpf_program__attach_fd+0x15a>
; }
    a64c: e8 af b1 ff ff               	callq	0x5800 <.plt.sec+0x190>
; 	errno = -err;
    a651: e8 9a b0 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    a656: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err_ptr(-ENOMEM);
    a65c: e9 34 ff ff ff               	jmp	0xa595 <bpf_program__attach_fd+0xd5>
    a661: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    a66c: 0f 1f 40 00                  	nopl	(%rax)

000000000000a670 <bpf_object__init_internal_map>:
; {
    a670: 41 57                        	pushq	%r15
    a672: 41 89 cf                     	movl	%ecx, %r15d
    a675: 41 56                        	pushq	%r14
    a677: 41 55                        	pushq	%r13
    a679: 4d 89 cd                     	movq	%r9, %r13
    a67c: 41 54                        	pushq	%r12
    a67e: 49 89 d4                     	movq	%rdx, %r12
    a681: 55                           	pushq	%rbp
    a682: 89 f5                        	movl	%esi, %ebp
    a684: 53                           	pushq	%rbx
    a685: 48 89 fb                     	movq	%rdi, %rbx
    a688: 48 83 ec 38                  	subq	$56, %rsp
    a68c: 4c 89 04 24                  	movq	%r8, (%rsp)
    a690: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    a699: 48 89 44 24 28               	movq	%rax, 40(%rsp)
    a69e: 31 c0                        	xorl	%eax, %eax
; 	map = bpf_object__add_map(obj);
    a6a0: e8 eb cd ff ff               	callq	0x7490 <bpf_object__add_map>
    a6a5: 49 89 c6                     	movq	%rax, %r14
; 	if (IS_ERR(map))
    a6a8: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
    a6ae: 76 30                        	jbe	0xa6e0 <bpf_object__init_internal_map+0x70>
; 		return PTR_ERR(map);
    a6b0: 41 89 c4                     	movl	%eax, %r12d
; }
    a6b3: 48 8b 44 24 28               	movq	40(%rsp), %rax
    a6b8: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    a6c1: 0f 85 fb 02 00 00            	jne	0xa9c2 <bpf_object__init_internal_map+0x352>
    a6c7: 48 83 c4 38                  	addq	$56, %rsp
    a6cb: 44 89 e0                     	movl	%r12d, %eax
    a6ce: 5b                           	popq	%rbx
    a6cf: 5d                           	popq	%rbp
    a6d0: 41 5c                        	popq	%r12
    a6d2: 41 5d                        	popq	%r13
    a6d4: 41 5e                        	popq	%r14
    a6d6: 41 5f                        	popq	%r15
    a6d8: c3                           	retq
    a6d9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	map->sec_idx = sec_idx;
    a6e0: 44 89 78 1c                  	movl	%r15d, 28(%rax)
; 	map->real_name = strdup(real_name);
    a6e4: 4c 89 e7                     	movq	%r12, %rdi
; 	map->libbpf_type = type;
    a6e7: 89 68 58                     	movl	%ebp, 88(%rax)
; 	map->sec_offset = 0;
    a6ea: 48 c7 40 20 00 00 00 00      	movq	$0, 32(%rax)
; 	map->real_name = strdup(real_name);
    a6f2: e8 19 b5 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
; 	int pfx_len, sfx_len = max((size_t)7, strlen(real_name));
    a6f7: 4c 89 e7                     	movq	%r12, %rdi
; 	map->real_name = strdup(real_name);
    a6fa: 49 89 46 10                  	movq	%rax, 16(%r14)
; 	int pfx_len, sfx_len = max((size_t)7, strlen(real_name));
    a6fe: e8 dd b0 ff ff               	callq	0x57e0 <.plt.sec+0x170>
    a703: ba 07 00 00 00               	movl	$7, %edx
; 	if (strchr(real_name + 1, '.') != NULL)
    a708: 49 8d 7c 24 01               	leaq	1(%r12), %rdi
    a70d: be 2e 00 00 00               	movl	$46, %esi
; 	int pfx_len, sfx_len = max((size_t)7, strlen(real_name));
    a712: 48 39 d0                     	cmpq	%rdx, %rax
    a715: 48 0f 43 d0                  	cmovaeq	%rax, %rdx
; 	if (sfx_len >= BPF_OBJ_NAME_LEN)
    a719: b8 0f 00 00 00               	movl	$15, %eax
    a71e: 83 fa 10                     	cmpl	$16, %edx
; 	int pfx_len, sfx_len = max((size_t)7, strlen(real_name));
    a721: 49 89 d7                     	movq	%rdx, %r15
; 	if (sfx_len >= BPF_OBJ_NAME_LEN)
    a724: 4c 0f 43 f8                  	cmovaeq	%rax, %r15
    a728: 44 89 7c 24 0c               	movl	%r15d, 12(%rsp)
; 	if (strchr(real_name + 1, '.') != NULL)
    a72d: e8 ee b0 ff ff               	callq	0x5820 <.plt.sec+0x1b0>
; 		pfx_len = 0;
    a732: 45 31 c9                     	xorl	%r9d, %r9d
; 	if (strchr(real_name + 1, '.') != NULL)
    a735: 48 85 c0                     	testq	%rax, %rax
    a738: 0f 84 e2 01 00 00            	je	0xa920 <bpf_object__init_internal_map+0x2b0>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    a73e: 4c 8d 7c 24 10               	leaq	16(%rsp), %r15
    a743: 48 83 ec 08                  	subq	$8, %rsp
    a747: b9 10 00 00 00               	movl	$16, %ecx
    a74c: ba 01 00 00 00               	movl	$1, %edx
    a751: 41 54                        	pushq	%r12
    a753: 8b 44 24 1c                  	movl	28(%rsp), %eax
    a757: be 10 00 00 00               	movl	$16, %esi
    a75c: 4c 89 ff                     	movq	%r15, %rdi
    a75f: 4c 8d 05 d6 76 02 00         	leaq	161494(%rip), %r8       # 0x31e3c <_IO_stdin_used+0x1e3c>
    a766: 50                           	pushq	%rax
    a767: 31 c0                        	xorl	%eax, %eax
    a769: 53                           	pushq	%rbx
    a76a: e8 41 af ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	for (p = map_name; *p && p < map_name + sizeof(map_name); p++)
    a76f: 44 0f b6 64 24 30            	movzbl	48(%rsp), %r12d
    a775: 48 83 c4 20                  	addq	$32, %rsp
    a779: 45 84 e4                     	testb	%r12b, %r12b
    a77c: 74 44                        	je	0xa7c2 <bpf_object__init_internal_map+0x152>
; 		if (!isalnum(*p) && *p != '_' && *p != '.')
    a77e: e8 fd b4 ff ff               	callq	0x5c80 <.plt.sec+0x610>
; 	for (p = map_name; *p && p < map_name + sizeof(map_name); p++)
    a783: 48 8d 7c 24 20               	leaq	32(%rsp), %rdi
; 		if (!isalnum(*p) && *p != '_' && *p != '.')
    a788: 48 8b 30                     	movq	(%rax), %rsi
; 	for (p = map_name; *p && p < map_name + sizeof(map_name); p++)
    a78b: 4c 89 f8                     	movq	%r15, %rax
    a78e: eb 05                        	jmp	0xa795 <bpf_object__init_internal_map+0x125>
    a790: 48 39 f8                     	cmpq	%rdi, %rax
    a793: 73 2d                        	jae	0xa7c2 <bpf_object__init_internal_map+0x152>
; 		if (!isalnum(*p) && *p != '_' && *p != '.')
    a795: 49 0f be d4                  	movsbq	%r12b, %rdx
    a799: f6 04 56 08                  	testb	$8, (%rsi,%rdx,2)
    a79d: 75 15                        	jne	0xa7b4 <bpf_object__init_internal_map+0x144>
    a79f: 41 80 fc 5f                  	cmpb	$95, %r12b
    a7a3: 0f 95 c1                     	setne	%cl
    a7a6: 41 80 fc 2e                  	cmpb	$46, %r12b
    a7aa: 0f 95 c2                     	setne	%dl
    a7ad: 84 d1                        	testb	%dl, %cl
    a7af: 74 03                        	je	0xa7b4 <bpf_object__init_internal_map+0x144>
; 			*p = '_';
    a7b1: c6 00 5f                     	movb	$95, (%rax)
; 	for (p = map_name; *p && p < map_name + sizeof(map_name); p++)
    a7b4: 44 0f b6 60 01               	movzbl	1(%rax), %r12d
    a7b9: 48 83 c0 01                  	addq	$1, %rax
    a7bd: 45 84 e4                     	testb	%r12b, %r12b
    a7c0: 75 ce                        	jne	0xa790 <bpf_object__init_internal_map+0x120>
; 	return strdup(map_name);
    a7c2: 4c 89 ff                     	movq	%r15, %rdi
    a7c5: e8 46 b4 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
; 	if (!map->real_name || !map->name) {
    a7ca: 49 8b 7e 10                  	movq	16(%r14), %rdi
; 	map->name = internal_map_name(obj, real_name);
    a7ce: 49 89 46 08                  	movq	%rax, 8(%r14)
; 	return strdup(map_name);
    a7d2: 48 89 c2                     	movq	%rax, %rdx
; 	if (!map->real_name || !map->name) {
    a7d5: 48 85 ff                     	testq	%rdi, %rdi
    a7d8: 0f 84 bb 01 00 00            	je	0xa999 <bpf_object__init_internal_map+0x329>
    a7de: 48 85 c0                     	testq	%rax, %rax
    a7e1: 0f 84 b2 01 00 00            	je	0xa999 <bpf_object__init_internal_map+0x329>
; 	def->map_flags = type == LIBBPF_MAP_RODATA || type == LIBBPF_MAP_KCONFIG
    a7e7: 83 ed 03                     	subl	$3, %ebp
; 			 ? BPF_F_RDONLY_PROG : 0;
    a7ea: 45 31 c9                     	xorl	%r9d, %r9d
; 	def->value_size = data_sz;
    a7ed: 45 89 6e 38                  	movl	%r13d, 56(%r14)
; 	pr_debug("map '%s' (global data): at sec_idx %d, offset %zu, flags %x.\n",
    a7f1: 41 8b 4e 1c                  	movl	28(%r14), %ecx
; 			 ? BPF_F_RDONLY_PROG : 0;
    a7f5: 83 fd 01                     	cmpl	$1, %ebp
; 	def->max_entries = 1;
    a7f8: 41 c7 46 3c 01 00 00 00      	movl	$1, 60(%r14)
; 	pr_debug("map '%s' (global data): at sec_idx %d, offset %zu, flags %x.\n",
    a800: 4d 8b 46 20                  	movq	32(%r14), %r8
; 	def->type = BPF_MAP_TYPE_ARRAY;
    a804: 48 b8 02 00 00 00 04 00 00 00	movabsq	$17179869186, %rax      # imm = 0x400000002
; 			 ? BPF_F_RDONLY_PROG : 0;
    a80e: 41 0f 96 c1                  	setbe	%r9b
; 	def->type = BPF_MAP_TYPE_ARRAY;
    a812: 49 89 46 30                  	movq	%rax, 48(%r14)
; 	pr_debug("map '%s' (global data): at sec_idx %d, offset %zu, flags %x.\n",
    a816: bf 02 00 00 00               	movl	$2, %edi
    a81b: 31 c0                        	xorl	%eax, %eax
; 			 ? BPF_F_RDONLY_PROG : 0;
    a81d: 41 c1 e1 07                  	shll	$7, %r9d
; 	pr_debug("map '%s' (global data): at sec_idx %d, offset %zu, flags %x.\n",
    a821: 48 8d 35 70 94 02 00         	leaq	169072(%rip), %rsi      # 0x33c98 <strs.2+0xe08>
; 	def->map_flags |= BPF_F_MMAPABLE;
    a828: 41 81 c9 00 04 00 00         	orl	$1024, %r9d             # imm = 0x400
    a82f: 45 89 4e 40                  	movl	%r9d, 64(%r14)
; 	pr_debug("map '%s' (global data): at sec_idx %d, offset %zu, flags %x.\n",
    a833: e8 98 d8 ff ff               	callq	0x80d0 <libbpf_print>
; 	long page_sz = sysconf(_SC_PAGE_SIZE);
    a838: bf 1e 00 00 00               	movl	$30, %edi
    a83d: e8 6e b3 ff ff               	callq	0x5bb0 <.plt.sec+0x540>
; 	map->mmaped = mmap(NULL, bpf_map_mmap_sz(map), PROT_READ | PROT_WRITE,
    a842: 45 31 c9                     	xorl	%r9d, %r9d
    a845: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
    a84b: 31 ff                        	xorl	%edi, %edi
; 	long page_sz = sysconf(_SC_PAGE_SIZE);
    a84d: 48 89 c1                     	movq	%rax, %rcx
; 	map_sz = (size_t)roundup(map->def.value_size, 8) * map->def.max_entries;
    a850: 41 8b 46 38                  	movl	56(%r14), %eax
    a854: 8d 50 07                     	leal	7(%rax), %edx
    a857: 41 8b 46 3c                  	movl	60(%r14), %eax
    a85b: 83 e2 f8                     	andl	$-8, %edx
    a85e: 48 0f af d0                  	imulq	%rax, %rdx
; 	map_sz = roundup(map_sz, page_sz);
    a862: 48 8d 44 11 ff               	leaq	-1(%rcx,%rdx), %rax
    a867: 31 d2                        	xorl	%edx, %edx
    a869: 48 f7 f1                     	divq	%rcx
; 	map->mmaped = mmap(NULL, bpf_map_mmap_sz(map), PROT_READ | PROT_WRITE,
    a86c: ba 03 00 00 00               	movl	$3, %edx
; 	map_sz = roundup(map_sz, page_sz);
    a871: 48 0f af c1                  	imulq	%rcx, %rax
; 	map->mmaped = mmap(NULL, bpf_map_mmap_sz(map), PROT_READ | PROT_WRITE,
    a875: b9 21 00 00 00               	movl	$33, %ecx
; 	map_sz = roundup(map_sz, page_sz);
    a87a: 48 89 c6                     	movq	%rax, %rsi
; 	map->mmaped = mmap(NULL, bpf_map_mmap_sz(map), PROT_READ | PROT_WRITE,
    a87d: e8 fe b1 ff ff               	callq	0x5a80 <.plt.sec+0x410>
    a882: 49 89 46 60                  	movq	%rax, 96(%r14)
; 	if (map->mmaped == MAP_FAILED) {
    a886: 48 83 f8 ff                  	cmpq	$-1, %rax
    a88a: 0f 84 b8 00 00 00            	je	0xa948 <bpf_object__init_internal_map+0x2d8>
; 	if (!obj->btf)
    a890: 48 8b bb 10 01 00 00         	movq	272(%rbx), %rdi
    a897: 48 85 ff                     	testq	%rdi, %rdi
    a89a: 74 34                        	je	0xa8d0 <bpf_object__init_internal_map+0x260>
; 	if (map->sec_idx == obj->efile.btf_maps_shndx || bpf_map__is_struct_ops(map))
    a89c: 8b 83 fc 00 00 00            	movl	252(%rbx), %eax
    a8a2: 41 39 46 1c                  	cmpl	%eax, 28(%r14)
    a8a6: 74 28                        	je	0xa8d0 <bpf_object__init_internal_map+0x260>
    a8a8: 41 83 7e 30 1a               	cmpl	$26, 48(%r14)
    a8ad: 74 21                        	je	0xa8d0 <bpf_object__init_internal_map+0x260>
; 	if (!bpf_map__is_internal(map))
    a8af: 41 8b 46 58                  	movl	88(%r14), %eax
    a8b3: 85 c0                        	testl	%eax, %eax
    a8b5: 74 19                        	je	0xa8d0 <bpf_object__init_internal_map+0x260>
; 	id = btf__find_by_name(obj->btf, map->real_name);
    a8b7: 49 8b 76 10                  	movq	16(%r14), %rsi
    a8bb: e8 00 10 02 00               	callq	0x2b8c0 <btf__find_by_name>
; 	if (id < 0)
    a8c0: 85 c0                        	testl	%eax, %eax
    a8c2: 78 0c                        	js	0xa8d0 <bpf_object__init_internal_map+0x260>
; 	map->btf_key_type_id = 0;
    a8c4: 41 c7 46 4c 00 00 00 00      	movl	$0, 76(%r14)
; 	map->btf_value_type_id = id;
    a8cc: 41 89 46 50                  	movl	%eax, 80(%r14)
; 	if (data)
    a8d0: 48 8b 34 24                  	movq	(%rsp), %rsi
    a8d4: 48 85 f6                     	testq	%rsi, %rsi
    a8d7: 74 0c                        	je	0xa8e5 <bpf_object__init_internal_map+0x275>
;   return __builtin___memcpy_chk (__dest, __src, __len,
    a8d9: 49 8b 7e 60                  	movq	96(%r14), %rdi
    a8dd: 4c 89 ea                     	movq	%r13, %rdx
    a8e0: e8 5b b1 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	pr_debug("map %td is \"%s\"\n", map - obj->maps, map->name);
    a8e5: 4c 89 f2                     	movq	%r14, %rdx
    a8e8: 48 2b 53 68                  	subq	104(%rbx), %rdx
    a8ec: 49 8b 4e 08                  	movq	8(%r14), %rcx
    a8f0: bf 02 00 00 00               	movl	$2, %edi
    a8f5: 48 c1 fa 05                  	sarq	$5, %rdx
    a8f9: 48 8d 35 45 75 02 00         	leaq	161093(%rip), %rsi      # 0x31e45 <_IO_stdin_used+0x1e45>
; 	return 0;
    a900: 45 31 e4                     	xorl	%r12d, %r12d
; 	pr_debug("map %td is \"%s\"\n", map - obj->maps, map->name);
    a903: 48 b8 cd cc cc cc cc cc cc cc	movabsq	$-3689348814741910323, %rax # imm = 0xCCCCCCCCCCCCCCCD
    a90d: 48 0f af d0                  	imulq	%rax, %rdx
    a911: 31 c0                        	xorl	%eax, %eax
    a913: e8 b8 d7 ff ff               	callq	0x80d0 <libbpf_print>
; 	return 0;
    a918: e9 96 fd ff ff               	jmp	0xa6b3 <bpf_object__init_internal_map+0x43>
    a91d: 0f 1f 00                     	nopl	(%rax)
; 		pfx_len = min((size_t)BPF_OBJ_NAME_LEN - sfx_len - 1, strlen(obj->name));
    a920: 48 89 df                     	movq	%rbx, %rdi
    a923: e8 b8 ae ff ff               	callq	0x57e0 <.plt.sec+0x170>
    a928: 49 63 d7                     	movslq	%r15d, %rdx
    a92b: 41 bf 0f 00 00 00            	movl	$15, %r15d
    a931: 49 29 d7                     	subq	%rdx, %r15
    a934: 49 39 c7                     	cmpq	%rax, %r15
    a937: 49 0f 46 c7                  	cmovbeq	%r15, %rax
    a93b: 49 89 c1                     	movq	%rax, %r9
    a93e: e9 fb fd ff ff               	jmp	0xa73e <bpf_object__init_internal_map+0xce>
    a943: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		err = -errno;
    a948: e8 a3 ad ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to alloc map '%s' content buffer: %d\n",
    a94d: 49 8b 56 08                  	movq	8(%r14), %rdx
    a951: 48 8d 35 88 93 02 00         	leaq	168840(%rip), %rsi      # 0x33ce0 <strs.2+0xe50>
    a958: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
    a95a: 44 8b 20                     	movl	(%rax), %r12d
; 		map->mmaped = NULL;
    a95d: 49 c7 46 60 00 00 00 00      	movq	$0, 96(%r14)
; 		pr_warn("failed to alloc map '%s' content buffer: %d\n",
    a965: 31 c0                        	xorl	%eax, %eax
; 		err = -errno;
    a967: 41 f7 dc                     	negl	%r12d
; 		pr_warn("failed to alloc map '%s' content buffer: %d\n",
    a96a: 44 89 e1                     	movl	%r12d, %ecx
    a96d: e8 5e d7 ff ff               	callq	0x80d0 <libbpf_print>
; 		zfree(&map->real_name);
    a972: 49 8b 7e 10                  	movq	16(%r14), %rdi
    a976: e8 45 ad ff ff               	callq	0x56c0 <.plt.sec+0x50>
    a97b: 49 c7 46 10 00 00 00 00      	movq	$0, 16(%r14)
; 		zfree(&map->name);
    a983: 49 8b 7e 08                  	movq	8(%r14), %rdi
    a987: e8 34 ad ff ff               	callq	0x56c0 <.plt.sec+0x50>
    a98c: 49 c7 46 08 00 00 00 00      	movq	$0, 8(%r14)
; 		return err;
    a994: e9 1a fd ff ff               	jmp	0xa6b3 <bpf_object__init_internal_map+0x43>
; 		zfree(&map->real_name);
    a999: e8 22 ad ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 		zfree(&map->name);
    a99e: 49 8b 7e 08                  	movq	8(%r14), %rdi
; 		zfree(&map->real_name);
    a9a2: 49 c7 46 10 00 00 00 00      	movq	$0, 16(%r14)
; 		return -ENOMEM;
    a9aa: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
; 		zfree(&map->name);
    a9b0: e8 0b ad ff ff               	callq	0x56c0 <.plt.sec+0x50>
    a9b5: 49 c7 46 08 00 00 00 00      	movq	$0, 8(%r14)
; 		return -ENOMEM;
    a9bd: e9 f1 fc ff ff               	jmp	0xa6b3 <bpf_object__init_internal_map+0x43>
; }
    a9c2: e8 39 ae ff ff               	callq	0x5800 <.plt.sec+0x190>
    a9c7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000000a9d0 <libbpf_find_prog_btf_id>:
; {
    a9d0: 41 56                        	pushq	%r14
    a9d2: 41 89 f6                     	movl	%esi, %r14d
;   return __builtin___memset_chk (__dest, __ch, __len,
    a9d5: b9 1d 00 00 00               	movl	$29, %ecx
; {
    a9da: 41 55                        	pushq	%r13
    a9dc: 49 89 fd                     	movq	%rdi, %r13
    a9df: 41 54                        	pushq	%r12
    a9e1: 55                           	pushq	%rbp
    a9e2: 48 81 ec 08 01 00 00         	subq	$264, %rsp              # imm = 0x108
    a9e9: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    a9f2: 48 89 84 24 f8 00 00 00      	movq	%rax, 248(%rsp)
    a9fa: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
    a9fc: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
; 	err = bpf_obj_get_info_by_fd(attach_prog_fd, &info, &info_len);
    aa01: 48 8d 54 24 0c               	leaq	12(%rsp), %rdx
; 	__u32 info_len = sizeof(info);
    aa06: c7 44 24 0c e8 00 00 00      	movl	$232, 12(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    aa0e: 48 89 f7                     	movq	%rsi, %rdi
    aa11: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	err = bpf_obj_get_info_by_fd(attach_prog_fd, &info, &info_len);
    aa14: 44 89 f7                     	movl	%r14d, %edi
    aa17: e8 a4 d1 01 00               	callq	0x27bc0 <bpf_obj_get_info_by_fd>
; 	if (err) {
    aa1c: 85 c0                        	testl	%eax, %eax
    aa1e: 0f 85 bc 00 00 00            	jne	0xaae0 <libbpf_find_prog_btf_id+0x110>
; 	if (!info.btf_id) {
    aa24: 8b bc 24 90 00 00 00         	movl	144(%rsp), %edi
    aa2b: 85 ff                        	testl	%edi, %edi
    aa2d: 0f 84 e5 00 00 00            	je	0xab18 <libbpf_find_prog_btf_id+0x148>
; 	btf = btf__load_from_kernel_by_id(info.btf_id);
    aa33: e8 a8 12 02 00               	callq	0x2bce0 <btf__load_from_kernel_by_id>
    aa38: 48 89 c5                     	movq	%rax, %rbp
; 	if (!IS_ERR_OR_NULL(ptr))
    aa3b: 48 85 c0                     	testq	%rax, %rax
    aa3e: 74 58                        	je	0xaa98 <libbpf_find_prog_btf_id+0xc8>
    aa40: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
    aa46: 77 50                        	ja	0xaa98 <libbpf_find_prog_btf_id+0xc8>
; 	err = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);
    aa48: 48 89 ef                     	movq	%rbp, %rdi
    aa4b: ba 0c 00 00 00               	movl	$12, %edx
    aa50: 4c 89 ee                     	movq	%r13, %rsi
    aa53: e8 78 10 02 00               	callq	0x2bad0 <btf__find_by_name_kind>
; 	btf__free(btf);
    aa58: 48 89 ef                     	movq	%rbp, %rdi
; 	err = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);
    aa5b: 41 89 c4                     	movl	%eax, %r12d
; 	btf__free(btf);
    aa5e: e8 8d fd 01 00               	callq	0x2a7f0 <btf__free>
; 	if (err <= 0) {
    aa63: 45 85 e4                     	testl	%r12d, %r12d
    aa66: 0f 8e 94 00 00 00            	jle	0xab00 <libbpf_find_prog_btf_id+0x130>
; }
    aa6c: 48 8b 84 24 f8 00 00 00      	movq	248(%rsp), %rax
    aa74: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    aa7d: 0f 85 ae 00 00 00            	jne	0xab31 <libbpf_find_prog_btf_id+0x161>
    aa83: 48 81 c4 08 01 00 00         	addq	$264, %rsp              # imm = 0x108
    aa8a: 44 89 e0                     	movl	%r12d, %eax
    aa8d: 5d                           	popq	%rbp
    aa8e: 41 5c                        	popq	%r12
    aa90: 41 5d                        	popq	%r13
    aa92: 41 5e                        	popq	%r14
    aa94: c3                           	retq
    aa95: 0f 1f 00                     	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
    aa98: e8 53 ac ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
    aa9d: 48 81 fd 00 f0 ff ff         	cmpq	$-4096, %rbp            # imm = 0xF000
    aaa4: 77 2a                        	ja	0xaad0 <libbpf_find_prog_btf_id+0x100>
; 	return -errno;
    aaa6: 44 8b 20                     	movl	(%rax), %r12d
; 	if (err) {
    aaa9: 45 85 e4                     	testl	%r12d, %r12d
    aaac: 74 9a                        	je	0xaa48 <libbpf_find_prog_btf_id+0x78>
; 	return -errno;
    aaae: 41 f7 dc                     	negl	%r12d
; 		pr_warn("Failed to get BTF %d of the program: %d\n", info.btf_id, err);
    aab1: 8b 94 24 90 00 00 00         	movl	144(%rsp), %edx
    aab8: 31 ff                        	xorl	%edi, %edi
    aaba: 31 c0                        	xorl	%eax, %eax
    aabc: 44 89 e1                     	movl	%r12d, %ecx
    aabf: 48 8d 35 ba 92 02 00         	leaq	168634(%rip), %rsi      # 0x33d80 <strs.2+0xef0>
    aac6: e8 05 d6 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto out;
    aacb: eb 9f                        	jmp	0xaa6c <libbpf_find_prog_btf_id+0x9c>
    aacd: 0f 1f 00                     	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
    aad0: 41 89 ec                     	movl	%ebp, %r12d
    aad3: 41 f7 dc                     	negl	%r12d
    aad6: 44 89 20                     	movl	%r12d, (%rax)
    aad9: eb ce                        	jmp	0xaaa9 <libbpf_find_prog_btf_id+0xd9>
    aadb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    aae0: 41 89 c4                     	movl	%eax, %r12d
; 		pr_warn("failed bpf_obj_get_info_by_fd for FD %d: %d\n",
    aae3: 89 c1                        	movl	%eax, %ecx
    aae5: 44 89 f2                     	movl	%r14d, %edx
    aae8: 31 ff                        	xorl	%edi, %edi
    aaea: 48 8d 35 27 92 02 00         	leaq	168487(%rip), %rsi      # 0x33d18 <strs.2+0xe88>
    aaf1: 31 c0                        	xorl	%eax, %eax
    aaf3: e8 d8 d5 ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
    aaf8: e9 6f ff ff ff               	jmp	0xaa6c <libbpf_find_prog_btf_id+0x9c>
    aafd: 0f 1f 00                     	nopl	(%rax)
; 		pr_warn("%s is not found in prog's BTF\n", name);
    ab00: 4c 89 ea                     	movq	%r13, %rdx
    ab03: 48 8d 35 ae 92 02 00         	leaq	168622(%rip), %rsi      # 0x33db8 <strs.2+0xf28>
    ab0a: 31 ff                        	xorl	%edi, %edi
    ab0c: 31 c0                        	xorl	%eax, %eax
    ab0e: e8 bd d5 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto out;
    ab13: e9 54 ff ff ff               	jmp	0xaa6c <libbpf_find_prog_btf_id+0x9c>
; 		pr_warn("The target program doesn't have BTF\n");
    ab18: 48 8d 35 31 92 02 00         	leaq	168497(%rip), %rsi      # 0x33d50 <strs.2+0xec0>
    ab1f: 31 c0                        	xorl	%eax, %eax
; 	err = -EINVAL;
    ab21: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("The target program doesn't have BTF\n");
    ab27: e8 a4 d5 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto out;
    ab2c: e9 3b ff ff ff               	jmp	0xaa6c <libbpf_find_prog_btf_id+0x9c>
; }
    ab31: e8 ca ac ff ff               	callq	0x5800 <.plt.sec+0x190>
    ab36: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000000ab40 <elf_sec_name>:
; {
    ab40: 41 56                        	pushq	%r14
    ab42: 41 55                        	pushq	%r13
    ab44: 41 54                        	pushq	%r12
    ab46: 55                           	pushq	%rbp
    ab47: 53                           	pushq	%rbx
; 	if (!scn)
    ab48: 48 85 f6                     	testq	%rsi, %rsi
    ab4b: 74 43                        	je	0xab90 <elf_sec_name+0x50>
    ab4d: 48 89 fb                     	movq	%rdi, %rbx
; 	shdr = elf64_getshdr(scn);
    ab50: 48 89 f7                     	movq	%rsi, %rdi
    ab53: 48 89 f5                     	movq	%rsi, %rbp
    ab56: e8 c5 ad ff ff               	callq	0x5920 <.plt.sec+0x2b0>
    ab5b: 49 89 c4                     	movq	%rax, %r12
; 	if (!shdr) {
    ab5e: 48 85 c0                     	testq	%rax, %rax
    ab61: 74 3d                        	je	0xaba0 <elf_sec_name+0x60>
; 	name = elf_sec_str(obj, sh->sh_name);
    ab63: 44 8b 30                     	movl	(%rax), %r14d
; 	name = elf_strptr(obj->efile.elf, obj->efile.shstrndx, off);
    ab66: 48 8b b3 e0 00 00 00         	movq	224(%rbx), %rsi
    ab6d: 48 8b bb c0 00 00 00         	movq	192(%rbx), %rdi
    ab74: 4c 89 f2                     	movq	%r14, %rdx
    ab77: e8 f4 ac ff ff               	callq	0x5870 <.plt.sec+0x200>
    ab7c: 49 89 c4                     	movq	%rax, %r12
; 	if (!name) {
    ab7f: 48 85 c0                     	testq	%rax, %rax
    ab82: 74 54                        	je	0xabd8 <elf_sec_name+0x98>
; }
    ab84: 5b                           	popq	%rbx
    ab85: 4c 89 e0                     	movq	%r12, %rax
    ab88: 5d                           	popq	%rbp
    ab89: 41 5c                        	popq	%r12
    ab8b: 41 5d                        	popq	%r13
    ab8d: 41 5e                        	popq	%r14
    ab8f: c3                           	retq
; 		return NULL;
    ab90: 45 31 e4                     	xorl	%r12d, %r12d
; }
    ab93: 5b                           	popq	%rbx
    ab94: 5d                           	popq	%rbp
    ab95: 4c 89 e0                     	movq	%r12, %rax
    ab98: 41 5c                        	popq	%r12
    ab9a: 41 5d                        	popq	%r13
    ab9c: 41 5e                        	popq	%r14
    ab9e: c3                           	retq
    ab9f: 90                           	nop
; 		pr_warn("elf: failed to get section(%zu) header from %s: %s\n",
    aba0: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
    aba5: e8 b6 ae ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    abaa: 48 89 ef                     	movq	%rbp, %rdi
    abad: 49 89 c5                     	movq	%rax, %r13
    abb0: e8 2b b0 ff ff               	callq	0x5be0 <.plt.sec+0x570>
    abb5: 48 8d 8b 90 01 00 00         	leaq	400(%rbx), %rcx
    abbc: 4d 89 e8                     	movq	%r13, %r8
    abbf: 31 ff                        	xorl	%edi, %edi
    abc1: 48 89 c2                     	movq	%rax, %rdx
    abc4: 48 8d 35 4d 87 02 00         	leaq	165709(%rip), %rsi      # 0x33318 <strs.2+0x488>
    abcb: 31 c0                        	xorl	%eax, %eax
    abcd: e8 fe d4 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (!sh)
    abd2: eb b0                        	jmp	0xab84 <elf_sec_name+0x44>
    abd4: 0f 1f 40 00                  	nopl	(%rax)
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
    abd8: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
    abdd: 4c 8d ab 90 01 00 00         	leaq	400(%rbx), %r13
    abe4: e8 77 ae ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    abe9: 4c 89 e9                     	movq	%r13, %rcx
    abec: 4c 89 f2                     	movq	%r14, %rdx
    abef: 31 ff                        	xorl	%edi, %edi
    abf1: 49 89 c0                     	movq	%rax, %r8
    abf4: 48 8d 35 e5 91 02 00         	leaq	168421(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
    abfb: 31 c0                        	xorl	%eax, %eax
    abfd: e8 ce d4 ff ff               	callq	0x80d0 <libbpf_print>
; 		pr_warn("elf: failed to get section(%zu) name from %s: %s\n",
    ac02: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
    ac07: e8 54 ae ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    ac0c: 48 89 ef                     	movq	%rbp, %rdi
    ac0f: 48 89 c3                     	movq	%rax, %rbx
    ac12: e8 c9 af ff ff               	callq	0x5be0 <.plt.sec+0x570>
    ac17: 49 89 d8                     	movq	%rbx, %r8
    ac1a: 4c 89 e9                     	movq	%r13, %rcx
    ac1d: 31 ff                        	xorl	%edi, %edi
    ac1f: 48 89 c2                     	movq	%rax, %rdx
    ac22: 48 8d 35 07 92 02 00         	leaq	168455(%rip), %rsi      # 0x33e30 <strs.2+0xfa0>
    ac29: 31 c0                        	xorl	%eax, %eax
    ac2b: e8 a0 d4 ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
    ac30: e9 4f ff ff ff               	jmp	0xab84 <elf_sec_name+0x44>
    ac35: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

000000000000ac40 <elf_sec_by_name>:
; {
    ac40: 41 55                        	pushq	%r13
    ac42: 41 54                        	pushq	%r12
    ac44: 49 89 f4                     	movq	%rsi, %r12
    ac47: 55                           	pushq	%rbp
; 	Elf_Scn *scn = NULL;
    ac48: 31 ed                        	xorl	%ebp, %ebp
; {
    ac4a: 53                           	pushq	%rbx
    ac4b: 48 89 fb                     	movq	%rdi, %rbx
    ac4e: 48 83 ec 08                  	subq	$8, %rsp
; 	Elf *elf = obj->efile.elf;
    ac52: 4c 8b af c0 00 00 00         	movq	192(%rdi), %r13
; 	while ((scn = elf_nextscn(elf, scn)) != NULL) {
    ac59: 48 89 ee                     	movq	%rbp, %rsi
    ac5c: 4c 89 ef                     	movq	%r13, %rdi
    ac5f: e8 2c af ff ff               	callq	0x5b90 <.plt.sec+0x520>
    ac64: 48 89 c5                     	movq	%rax, %rbp
    ac67: 48 85 c0                     	testq	%rax, %rax
    ac6a: 74 34                        	je	0xaca0 <elf_sec_by_name+0x60>
; 		sec_name = elf_sec_name(obj, scn);
    ac6c: 48 89 df                     	movq	%rbx, %rdi
    ac6f: 48 89 ee                     	movq	%rbp, %rsi
    ac72: e8 c9 fe ff ff               	callq	0xab40 <elf_sec_name>
    ac77: 48 89 c7                     	movq	%rax, %rdi
; 		if (!sec_name)
    ac7a: 48 85 c0                     	testq	%rax, %rax
    ac7d: 74 21                        	je	0xaca0 <elf_sec_by_name+0x60>
; 		if (strcmp(sec_name, name) != 0)
    ac7f: 4c 89 e6                     	movq	%r12, %rsi
    ac82: e8 29 ad ff ff               	callq	0x59b0 <.plt.sec+0x340>
    ac87: 85 c0                        	testl	%eax, %eax
    ac89: 75 ce                        	jne	0xac59 <elf_sec_by_name+0x19>
; }
    ac8b: 48 83 c4 08                  	addq	$8, %rsp
    ac8f: 48 89 e8                     	movq	%rbp, %rax
    ac92: 5b                           	popq	%rbx
    ac93: 5d                           	popq	%rbp
    ac94: 41 5c                        	popq	%r12
    ac96: 41 5d                        	popq	%r13
    ac98: c3                           	retq
    ac99: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    aca0: 48 83 c4 08                  	addq	$8, %rsp
; 			return NULL;
    aca4: 31 ed                        	xorl	%ebp, %ebp
; }
    aca6: 5b                           	popq	%rbx
    aca7: 48 89 e8                     	movq	%rbp, %rax
    acaa: 5d                           	popq	%rbp
    acab: 41 5c                        	popq	%r12
    acad: 41 5d                        	popq	%r13
    acaf: c3                           	retq

000000000000acb0 <bpf_object__init_btf>:
; {
    acb0: 41 57                        	pushq	%r15
    acb2: 41 56                        	pushq	%r14
    acb4: 41 55                        	pushq	%r13
    acb6: 41 54                        	pushq	%r12
    acb8: 55                           	pushq	%rbp
    acb9: 48 89 fd                     	movq	%rdi, %rbp
    acbc: 53                           	pushq	%rbx
    acbd: 48 89 d3                     	movq	%rdx, %rbx
    acc0: 48 83 ec 28                  	subq	$40, %rsp
    acc4: 64 48 8b 14 25 28 00 00 00   	movq	%fs:40, %rdx
    accd: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
    acd2: 31 d2                        	xorl	%edx, %edx
; 	if (btf_data) {
    acd4: 48 85 f6                     	testq	%rsi, %rsi
    acd7: 0f 84 63 02 00 00            	je	0xaf40 <bpf_object__init_btf+0x290>
    acdd: 48 89 f0                     	movq	%rsi, %rax
; 		obj->btf = btf__new(btf_data->d_buf, btf_data->d_size);
    ace0: 8b 76 10                     	movl	16(%rsi), %esi
    ace3: 48 8b 38                     	movq	(%rax), %rdi
    ace6: e8 c5 01 02 00               	callq	0x2aeb0 <btf__new>
    aceb: 48 89 85 10 01 00 00         	movq	%rax, 272(%rbp)
    acf2: 49 89 c5                     	movq	%rax, %r13
; 	if (!IS_ERR_OR_NULL(ptr))
    acf5: 48 85 c0                     	testq	%rax, %rax
    acf8: 0f 84 62 01 00 00            	je	0xae60 <bpf_object__init_btf+0x1b0>
    acfe: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
    ad04: 0f 87 56 01 00 00            	ja	0xae60 <bpf_object__init_btf+0x1b0>
; 		btf__set_pointer_size(obj->btf, 8);
    ad0a: be 08 00 00 00               	movl	$8, %esi
    ad0f: 4c 89 ef                     	movq	%r13, %rdi
; 		err = libbpf_get_error(obj->btf);
    ad12: 45 31 e4                     	xorl	%r12d, %r12d
; 		btf__set_pointer_size(obj->btf, 8);
    ad15: e8 36 f9 01 00               	callq	0x2a650 <btf__set_pointer_size>
; 	if (btf_ext_data) {
    ad1a: 48 85 db                     	testq	%rbx, %rbx
    ad1d: 0f 84 0d 01 00 00            	je	0xae30 <bpf_object__init_btf+0x180>
; 		if (!obj->btf) {
    ad23: 48 83 bd 10 01 00 00 00      	cmpq	$0, 272(%rbp)
    ad2b: 0f 84 2c 02 00 00            	je	0xaf5d <bpf_object__init_btf+0x2ad>
; 		obj->btf_ext = btf_ext__new(btf_ext_data->d_buf, btf_ext_data->d_size);
    ad31: 8b 73 10                     	movl	16(%rbx), %esi
    ad34: 48 8b 3b                     	movq	(%rbx), %rdi
    ad37: e8 c4 25 02 00               	callq	0x2d300 <btf_ext__new>
    ad3c: 48 89 85 18 01 00 00         	movq	%rax, 280(%rbp)
    ad43: 48 89 c3                     	movq	%rax, %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
    ad46: 48 85 c0                     	testq	%rax, %rax
    ad49: 0f 84 79 01 00 00            	je	0xaec8 <bpf_object__init_btf+0x218>
    ad4f: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
    ad55: 0f 87 6d 01 00 00            	ja	0xaec8 <bpf_object__init_btf+0x218>
; 			if (seg->sec_cnt == 0)
    ad5b: 48 63 7b 20                  	movslq	32(%rbx), %rdi
; 		ext_segs[0] = &obj->btf_ext->func_info;
    ad5f: 4c 8d 7b 08                  	leaq	8(%rbx), %r15
; 		ext_segs[1] = &obj->btf_ext->line_info;
    ad63: 48 8d 43 28                  	leaq	40(%rbx), %rax
; 		ext_segs[2] = &obj->btf_ext->core_relo_info;
    ad67: 48 83 c3 48                  	addq	$72, %rbx
; 		ext_segs[1] = &obj->btf_ext->line_info;
    ad6b: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 		ext_segs[2] = &obj->btf_ext->core_relo_info;
    ad70: 49 89 e5                     	movq	%rsp, %r13
    ad73: 4c 8d 74 24 18               	leaq	24(%rsp), %r14
    ad78: 48 89 5c 24 10               	movq	%rbx, 16(%rsp)
; 			if (seg->sec_cnt == 0)
    ad7d: 85 ff                        	testl	%edi, %edi
    ad7f: 75 19                        	jne	0xad9a <bpf_object__init_btf+0xea>
; 		for (seg_num = 0; seg_num < ARRAY_SIZE(ext_segs); seg_num++) {
    ad81: 49 83 c5 08                  	addq	$8, %r13
    ad85: 4d 39 ee                     	cmpq	%r13, %r14
    ad88: 0f 84 a2 00 00 00            	je	0xae30 <bpf_object__init_btf+0x180>
; 			struct btf_ext_info *seg = ext_segs[seg_num];
    ad8e: 4d 8b 7d 00                  	movq	(%r13), %r15
; 			if (seg->sec_cnt == 0)
    ad92: 49 63 7f 18                  	movslq	24(%r15), %rdi
    ad96: 85 ff                        	testl	%edi, %edi
    ad98: 74 e7                        	je	0xad81 <bpf_object__init_btf+0xd1>
; 			seg->sec_idxs = calloc(seg->sec_cnt, sizeof(*seg->sec_idxs));
    ad9a: be 04 00 00 00               	movl	$4, %esi
    ad9f: e8 ec ab ff ff               	callq	0x5990 <.plt.sec+0x320>
    ada4: 49 89 47 10                  	movq	%rax, 16(%r15)
; 			if (!seg->sec_idxs) {
    ada8: 48 85 c0                     	testq	%rax, %rax
    adab: 0f 84 f2 01 00 00            	je	0xafa3 <bpf_object__init_btf+0x2f3>
; 			for_each_btf_ext_sec(seg, sec) {
    adb1: 49 8b 1f                     	movq	(%r15), %rbx
    adb4: 41 8b 47 0c                  	movl	12(%r15), %eax
    adb8: 48 01 d8                     	addq	%rbx, %rax
    adbb: 48 39 c3                     	cmpq	%rax, %rbx
    adbe: 73 c1                        	jae	0xad81 <bpf_object__init_btf+0xd1>
    adc0: 45 31 e4                     	xorl	%r12d, %r12d
    adc3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 				sec_name = btf__name_by_offset(obj->btf, sec->sec_name_off);
    adc8: 8b 33                        	movl	(%rbx), %esi
    adca: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
    add1: e8 1a 0d 02 00               	callq	0x2baf0 <btf__name_by_offset>
    add6: 48 89 c6                     	movq	%rax, %rsi
; 	return !s || !s[0];
    add9: 48 85 c0                     	testq	%rax, %rax
    addc: 74 22                        	je	0xae00 <bpf_object__init_btf+0x150>
    adde: 80 38 00                     	cmpb	$0, (%rax)
    ade1: 74 1d                        	je	0xae00 <bpf_object__init_btf+0x150>
; 				scn = elf_sec_by_name(obj, sec_name);
    ade3: 48 89 ef                     	movq	%rbp, %rdi
    ade6: e8 55 fe ff ff               	callq	0xac40 <elf_sec_by_name>
    adeb: 48 89 c7                     	movq	%rax, %rdi
; 				if (!scn)
    adee: 48 85 c0                     	testq	%rax, %rax
    adf1: 74 0d                        	je	0xae00 <bpf_object__init_btf+0x150>
; 				seg->sec_idxs[sec_num - 1] = elf_ndxscn(scn);
    adf3: e8 e8 ad ff ff               	callq	0x5be0 <.plt.sec+0x570>
    adf8: 49 8b 57 10                  	movq	16(%r15), %rdx
    adfc: 42 89 04 22                  	movl	%eax, (%rdx,%r12)
; 			for_each_btf_ext_sec(seg, sec) {
    ae00: 41 8b 47 08                  	movl	8(%r15), %eax
    ae04: 0f af 43 04                  	imull	4(%rbx), %eax
    ae08: 49 83 c4 04                  	addq	$4, %r12
    ae0c: 48 8d 5c 03 08               	leaq	8(%rbx,%rax), %rbx
    ae11: 41 8b 47 0c                  	movl	12(%r15), %eax
    ae15: 49 03 07                     	addq	(%r15), %rax
    ae18: 48 39 c3                     	cmpq	%rax, %rbx
    ae1b: 72 ab                        	jb	0xadc8 <bpf_object__init_btf+0x118>
; 		for (seg_num = 0; seg_num < ARRAY_SIZE(ext_segs); seg_num++) {
    ae1d: 49 83 c5 08                  	addq	$8, %r13
    ae21: 4d 39 ee                     	cmpq	%r13, %r14
    ae24: 0f 85 64 ff ff ff            	jne	0xad8e <bpf_object__init_btf+0xde>
    ae2a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return 0;
    ae30: 45 31 e4                     	xorl	%r12d, %r12d
; }
    ae33: 48 8b 44 24 18               	movq	24(%rsp), %rax
    ae38: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    ae41: 0f 85 57 01 00 00            	jne	0xaf9e <bpf_object__init_btf+0x2ee>
    ae47: 48 83 c4 28                  	addq	$40, %rsp
    ae4b: 44 89 e0                     	movl	%r12d, %eax
    ae4e: 5b                           	popq	%rbx
    ae4f: 5d                           	popq	%rbp
    ae50: 41 5c                        	popq	%r12
    ae52: 41 5d                        	popq	%r13
    ae54: 41 5e                        	popq	%r14
    ae56: 41 5f                        	popq	%r15
    ae58: c3                           	retq
    ae59: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
    ae60: e8 8b a8 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
    ae65: 49 81 fd 00 f0 ff ff         	cmpq	$-4096, %r13            # imm = 0xF000
    ae6c: 0f 87 0e 01 00 00            	ja	0xaf80 <bpf_object__init_btf+0x2d0>
; 	return -errno;
    ae72: 44 8b 20                     	movl	(%rax), %r12d
; 		if (err) {
    ae75: 45 85 e4                     	testl	%r12d, %r12d
    ae78: 0f 84 8c fe ff ff            	je	0xad0a <bpf_object__init_btf+0x5a>
; 	return -errno;
    ae7e: 41 f7 dc                     	negl	%r12d
; 			pr_warn("Error loading ELF section %s: %d.\n", BTF_ELF_SEC, err);
    ae81: 48 8d 15 d6 6f 02 00         	leaq	159702(%rip), %rdx      # 0x31e5e <_IO_stdin_used+0x1e5e>
    ae88: 31 ff                        	xorl	%edi, %edi
    ae8a: 31 c0                        	xorl	%eax, %eax
; 			obj->btf = NULL;
    ae8c: 48 c7 85 10 01 00 00 00 00 00 00     	movq	$0, 272(%rbp)
; 			pr_warn("Error loading ELF section %s: %d.\n", BTF_ELF_SEC, err);
    ae97: 44 89 e1                     	movl	%r12d, %ecx
    ae9a: 48 8d 35 cf 8f 02 00         	leaq	167887(%rip), %rsi      # 0x33e70 <strs.2+0xfe0>
    aea1: e8 2a d2 ff ff               	callq	0x80d0 <libbpf_print>
; 	       obj->efile.st_ops_shndx >= 0 ||
    aea6: 8b 8d fc 00 00 00            	movl	252(%rbp), %ecx
    aeac: 85 c9                        	testl	%ecx, %ecx
    aeae: 78 71                        	js	0xaf21 <bpf_object__init_btf+0x271>
; 		pr_warn("BTF is required, but is missing or corrupted.\n");
    aeb0: 48 8d 35 89 90 02 00         	leaq	168073(%rip), %rsi      # 0x33f40 <strs.2+0x10b0>
    aeb7: 31 ff                        	xorl	%edi, %edi
    aeb9: 31 c0                        	xorl	%eax, %eax
    aebb: e8 10 d2 ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
    aec0: e9 6e ff ff ff               	jmp	0xae33 <bpf_object__init_btf+0x183>
    aec5: 0f 1f 00                     	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
    aec8: e8 23 a8 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
    aecd: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
    aed4: 0f 87 b6 00 00 00            	ja	0xaf90 <bpf_object__init_btf+0x2e0>
; 	return -errno;
    aeda: 44 8b 20                     	movl	(%rax), %r12d
; 		if (err) {
    aedd: 45 85 e4                     	testl	%r12d, %r12d
    aee0: 0f 84 75 fe ff ff            	je	0xad5b <bpf_object__init_btf+0xab>
; 	return -errno;
    aee6: 41 f7 dc                     	negl	%r12d
; 			pr_warn("Error loading ELF section %s: %d. Ignored and continue.\n",
    aee9: 48 8d 15 73 6f 02 00         	leaq	159603(%rip), %rdx      # 0x31e63 <_IO_stdin_used+0x1e63>
    aef0: 31 ff                        	xorl	%edi, %edi
    aef2: 31 c0                        	xorl	%eax, %eax
    aef4: 44 89 e1                     	movl	%r12d, %ecx
    aef7: 48 8d 35 fa 8f 02 00         	leaq	167930(%rip), %rsi      # 0x33ef8 <strs.2+0x1068>
    aefe: e8 cd d1 ff ff               	callq	0x80d0 <libbpf_print>
; 			obj->btf_ext = NULL;
    af03: 48 c7 85 18 01 00 00 00 00 00 00     	movq	$0, 280(%rbp)
; 	if (err && libbpf_needs_btf(obj)) {
    af0e: 45 85 e4                     	testl	%r12d, %r12d
    af11: 0f 84 19 ff ff ff            	je	0xae30 <bpf_object__init_btf+0x180>
; 	       obj->efile.st_ops_shndx >= 0 ||
    af17: 8b 8d fc 00 00 00            	movl	252(%rbp), %ecx
    af1d: 85 c9                        	testl	%ecx, %ecx
    af1f: 79 8f                        	jns	0xaeb0 <bpf_object__init_btf+0x200>
; 	return obj->efile.btf_maps_shndx >= 0 ||
    af21: 8b 95 0c 01 00 00            	movl	268(%rbp), %edx
    af27: 85 d2                        	testl	%edx, %edx
    af29: 79 85                        	jns	0xaeb0 <bpf_object__init_btf+0x200>
; 	       obj->efile.st_ops_shndx >= 0 ||
    af2b: 8b 85 90 00 00 00            	movl	144(%rbp), %eax
    af31: 85 c0                        	testl	%eax, %eax
    af33: 0f 8f 77 ff ff ff            	jg	0xaeb0 <bpf_object__init_btf+0x200>
    af39: e9 f2 fe ff ff               	jmp	0xae30 <bpf_object__init_btf+0x180>
    af3e: 66 90                        	nop
; 	int err = -ENOENT;
    af40: 41 bc fe ff ff ff            	movl	$4294967294, %r12d      # imm = 0xFFFFFFFE
; 	if (btf_ext_data) {
    af46: 48 85 db                     	testq	%rbx, %rbx
    af49: 0f 84 57 ff ff ff            	je	0xaea6 <bpf_object__init_btf+0x1f6>
; 		if (!obj->btf) {
    af4f: 48 83 bd 10 01 00 00 00      	cmpq	$0, 272(%rbp)
    af57: 0f 85 d4 fd ff ff            	jne	0xad31 <bpf_object__init_btf+0x81>
; 			pr_debug("Ignore ELF section %s because its depending ELF section %s is not found.\n",
    af5d: 48 8d 0d fa 6e 02 00         	leaq	159482(%rip), %rcx      # 0x31e5e <_IO_stdin_used+0x1e5e>
    af64: 48 8d 15 f8 6e 02 00         	leaq	159480(%rip), %rdx      # 0x31e63 <_IO_stdin_used+0x1e63>
    af6b: bf 02 00 00 00               	movl	$2, %edi
    af70: 31 c0                        	xorl	%eax, %eax
    af72: 48 8d 35 27 8f 02 00         	leaq	167719(%rip), %rsi      # 0x33ea0 <strs.2+0x1010>
    af79: e8 52 d1 ff ff               	callq	0x80d0 <libbpf_print>
; 			goto out;
    af7e: eb 8e                        	jmp	0xaf0e <bpf_object__init_btf+0x25e>
; 		errno = -PTR_ERR(ptr);
    af80: 45 89 ec                     	movl	%r13d, %r12d
    af83: 41 f7 dc                     	negl	%r12d
    af86: 44 89 20                     	movl	%r12d, (%rax)
    af89: e9 e7 fe ff ff               	jmp	0xae75 <bpf_object__init_btf+0x1c5>
    af8e: 66 90                        	nop
    af90: 41 89 dc                     	movl	%ebx, %r12d
    af93: 41 f7 dc                     	negl	%r12d
    af96: 44 89 20                     	movl	%r12d, (%rax)
    af99: e9 3f ff ff ff               	jmp	0xaedd <bpf_object__init_btf+0x22d>
; }
    af9e: e8 5d a8 ff ff               	callq	0x5800 <.plt.sec+0x190>
; 				err = -ENOMEM;
    afa3: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
    afa9: e9 f8 fe ff ff               	jmp	0xaea6 <bpf_object__init_btf+0x1f6>
    afae: 66 90                        	nop

000000000000afb0 <elf_sec_data>:
; {
    afb0: 41 56                        	pushq	%r14
    afb2: 41 55                        	pushq	%r13
    afb4: 41 54                        	pushq	%r12
    afb6: 55                           	pushq	%rbp
    afb7: 53                           	pushq	%rbx
; 	if (!scn)
    afb8: 48 85 f6                     	testq	%rsi, %rsi
    afbb: 74 2b                        	je	0xafe8 <elf_sec_data+0x38>
    afbd: 48 89 f5                     	movq	%rsi, %rbp
; 	data = elf_getdata(scn, 0);
    afc0: 49 89 fd                     	movq	%rdi, %r13
    afc3: 31 f6                        	xorl	%esi, %esi
    afc5: 48 89 ef                     	movq	%rbp, %rdi
    afc8: e8 73 a9 ff ff               	callq	0x5940 <.plt.sec+0x2d0>
    afcd: 49 89 c4                     	movq	%rax, %r12
; 	if (!data) {
    afd0: 48 85 c0                     	testq	%rax, %rax
    afd3: 74 2b                        	je	0xb000 <elf_sec_data+0x50>
; }
    afd5: 5b                           	popq	%rbx
    afd6: 4c 89 e0                     	movq	%r12, %rax
    afd9: 5d                           	popq	%rbp
    afda: 41 5c                        	popq	%r12
    afdc: 41 5d                        	popq	%r13
    afde: 41 5e                        	popq	%r14
    afe0: c3                           	retq
    afe1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return NULL;
    afe8: 45 31 e4                     	xorl	%r12d, %r12d
; }
    afeb: 5b                           	popq	%rbx
    afec: 5d                           	popq	%rbp
    afed: 4c 89 e0                     	movq	%r12, %rax
    aff0: 41 5c                        	popq	%r12
    aff2: 41 5d                        	popq	%r13
    aff4: 41 5e                        	popq	%r14
    aff6: c3                           	retq
    aff7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		pr_warn("elf: failed to get section(%zu) %s data from %s: %s\n",
    b000: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
    b005: 4d 8d b5 90 01 00 00         	leaq	400(%r13), %r14
    b00c: e8 4f aa ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
    b011: 48 89 ee                     	movq	%rbp, %rsi
    b014: 4c 89 ef                     	movq	%r13, %rdi
    b017: 48 89 c3                     	movq	%rax, %rbx
    b01a: e8 21 fb ff ff               	callq	0xab40 <elf_sec_name>
    b01f: 48 89 ef                     	movq	%rbp, %rdi
    b022: 48 85 c0                     	testq	%rax, %rax
    b025: 49 89 c5                     	movq	%rax, %r13
    b028: 48 8d 05 3d 6e 02 00         	leaq	159293(%rip), %rax      # 0x31e6c <_IO_stdin_used+0x1e6c>
    b02f: 4c 0f 44 e8                  	cmoveq	%rax, %r13
    b033: e8 a8 ab ff ff               	callq	0x5be0 <.plt.sec+0x570>
    b038: 49 89 d9                     	movq	%rbx, %r9
    b03b: 4d 89 f0                     	movq	%r14, %r8
    b03e: 31 ff                        	xorl	%edi, %edi
    b040: 48 89 c2                     	movq	%rax, %rdx
    b043: 4c 89 e9                     	movq	%r13, %rcx
    b046: 48 8d 35 2b 8f 02 00         	leaq	167723(%rip), %rsi      # 0x33f78 <strs.2+0x10e8>
    b04d: 31 c0                        	xorl	%eax, %eax
    b04f: e8 7c d0 ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
    b054: e9 7c ff ff ff               	jmp	0xafd5 <elf_sec_data+0x25>
    b059: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000b060 <bpf_program__attach_btf_id>:
; {
    b060: 41 55                        	pushq	%r13
; 	LIBBPF_OPTS(bpf_link_create_opts, link_opts);
    b062: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
    b066: 41 54                        	pushq	%r12
    b068: 55                           	pushq	%rbp
    b069: 48 89 fd                     	movq	%rdi, %rbp
    b06c: 53                           	pushq	%rbx
    b06d: 48 89 f3                     	movq	%rsi, %rbx
    b070: 48 81 ec 18 01 00 00         	subq	$280, %rsp              # imm = 0x118
    b077: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    b080: 48 89 84 24 08 01 00 00      	movq	%rax, 264(%rsp)
    b088: 31 c0                        	xorl	%eax, %eax
; 	LIBBPF_OPTS(bpf_link_create_opts, link_opts);
    b08a: 0f 11 44 24 48               	movups	%xmm0, 72(%rsp)
    b08f: 0f 11 44 24 58               	movups	%xmm0, 88(%rsp)
    b094: 66 0f 6f 54 24 50            	movdqa	80(%rsp), %xmm2
    b09a: 0f 11 44 24 68               	movups	%xmm0, 104(%rsp)
    b09f: 66 0f 6f 5c 24 60            	movdqa	96(%rsp), %xmm3
    b0a5: 48 c7 44 24 78 00 00 00 00   	movq	$0, 120(%rsp)
    b0ae: 66 0f 6f 64 24 70            	movdqa	112(%rsp), %xmm4
    b0b4: 48 c7 44 24 40 40 00 00 00   	movq	$64, 64(%rsp)
    b0bd: 66 0f 6f 4c 24 40            	movdqa	64(%rsp), %xmm1
    b0c3: 0f 29 54 24 10               	movaps	%xmm2, 16(%rsp)
    b0c8: 0f 29 0c 24                  	movaps	%xmm1, (%rsp)
    b0cc: 0f 29 5c 24 20               	movaps	%xmm3, 32(%rsp)
    b0d1: 0f 29 64 24 30               	movaps	%xmm4, 48(%rsp)
; 	if (!OPTS_VALID(opts, bpf_trace_opts))
    b0d6: 48 85 f6                     	testq	%rsi, %rsi
    b0d9: 74 5d                        	je	0xb138 <bpf_program__attach_btf_id+0xd8>
    b0db: 48 8b 0e                     	movq	(%rsi), %rcx
; 	if (user_sz < sizeof(size_t)) {
    b0de: 48 83 f9 07                  	cmpq	$7, %rcx
    b0e2: 0f 86 f8 00 00 00            	jbe	0xb1e0 <bpf_program__attach_btf_id+0x180>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
    b0e8: 48 8d 51 f0                  	leaq	-16(%rcx), %rdx
    b0ec: 48 8d 46 10                  	leaq	16(%rsi), %rax
; 	while (len > 0) {
    b0f0: 48 85 d2                     	testq	%rdx, %rdx
    b0f3: 7e 43                        	jle	0xb138 <bpf_program__attach_btf_id+0xd8>
    b0f5: 48 01 f1                     	addq	%rsi, %rcx
    b0f8: eb 0f                        	jmp	0xb109 <bpf_program__attach_btf_id+0xa9>
    b0fa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		p++;
    b100: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
    b104: 48 39 c1                     	cmpq	%rax, %rcx
    b107: 74 2f                        	je	0xb138 <bpf_program__attach_btf_id+0xd8>
; 		if (*p)
    b109: 80 38 00                     	cmpb	$0, (%rax)
    b10c: 74 f2                        	je	0xb100 <bpf_program__attach_btf_id+0xa0>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
    b10e: 48 8d 15 5b 6d 02 00         	leaq	159067(%rip), %rdx      # 0x31e70 <_IO_stdin_used+0x1e70>
    b115: 48 8d 35 f4 8e 02 00         	leaq	167668(%rip), %rsi      # 0x34010 <strs.2+0x1180>
    b11c: 31 ff                        	xorl	%edi, %edi
    b11e: 31 c0                        	xorl	%eax, %eax
    b120: e8 ab cf ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
    b125: e8 c6 a5 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
    b12a: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
    b12d: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
    b133: eb 6d                        	jmp	0xb1a2 <bpf_program__attach_btf_id+0x142>
    b135: 0f 1f 00                     	nopl	(%rax)
; 	if (!prog)
    b138: 48 85 ed                     	testq	%rbp, %rbp
    b13b: 0f 84 35 01 00 00            	je	0xb276 <bpf_program__attach_btf_id+0x216>
; 	if (prog->fd < 0)
    b141: 44 8b 6d 78                  	movl	120(%rbp), %r13d
    b145: 45 85 ed                     	testl	%r13d, %r13d
    b148: 0f 88 f8 00 00 00            	js	0xb246 <bpf_program__attach_btf_id+0x1e6>
; 	link = calloc(1, sizeof(*link));
    b14e: be 20 00 00 00               	movl	$32, %esi
    b153: bf 01 00 00 00               	movl	$1, %edi
    b158: e8 33 a8 ff ff               	callq	0x5990 <.plt.sec+0x320>
    b15d: 49 89 c4                     	movq	%rax, %r12
; 	if (!link)
    b160: 48 85 c0                     	testq	%rax, %rax
    b163: 0f 84 1d 01 00 00            	je	0xb286 <bpf_program__attach_btf_id+0x226>
; 	link->detach = &bpf_link__detach_fd;
    b169: 48 8d 05 60 c7 ff ff         	leaq	-14496(%rip), %rax      # 0x78d0 <bpf_link__detach_fd>
    b170: 49 89 04 24                  	movq	%rax, (%r12)
; 	link_opts.tracing.cookie = OPTS_GET(opts, cookie, 0);
    b174: 31 c0                        	xorl	%eax, %eax
    b176: 48 85 db                     	testq	%rbx, %rbx
    b179: 74 06                        	je	0xb181 <bpf_program__attach_btf_id+0x121>
    b17b: 48 83 3b 0f                  	cmpq	$15, (%rbx)
    b17f: 77 4f                        	ja	0xb1d0 <bpf_program__attach_btf_id+0x170>
; 	pfd = bpf_link_create(prog_fd, 0, bpf_program__expected_attach_type(prog), &link_opts);
    b181: 8b 95 84 00 00 00            	movl	132(%rbp), %edx
    b187: 31 f6                        	xorl	%esi, %esi
    b189: 48 89 e1                     	movq	%rsp, %rcx
    b18c: 44 89 ef                     	movl	%r13d, %edi
; 	link_opts.tracing.cookie = OPTS_GET(opts, cookie, 0);
    b18f: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	pfd = bpf_link_create(prog_fd, 0, bpf_program__expected_attach_type(prog), &link_opts);
    b194: e8 b7 cb 01 00               	callq	0x27d50 <bpf_link_create>
; 	if (pfd < 0) {
    b199: 85 c0                        	testl	%eax, %eax
    b19b: 78 5d                        	js	0xb1fa <bpf_program__attach_btf_id+0x19a>
; 	link->fd = pfd;
    b19d: 41 89 44 24 18               	movl	%eax, 24(%r12)
; }
    b1a2: 48 8b 84 24 08 01 00 00      	movq	264(%rsp), %rax
    b1aa: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    b1b3: 0f 85 dd 00 00 00            	jne	0xb296 <bpf_program__attach_btf_id+0x236>
    b1b9: 48 81 c4 18 01 00 00         	addq	$280, %rsp              # imm = 0x118
    b1c0: 4c 89 e0                     	movq	%r12, %rax
    b1c3: 5b                           	popq	%rbx
    b1c4: 5d                           	popq	%rbp
    b1c5: 41 5c                        	popq	%r12
    b1c7: 41 5d                        	popq	%r13
    b1c9: c3                           	retq
    b1ca: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	link_opts.tracing.cookie = OPTS_GET(opts, cookie, 0);
    b1d0: 48 8b 43 08                  	movq	8(%rbx), %rax
    b1d4: eb ab                        	jmp	0xb181 <bpf_program__attach_btf_id+0x121>
    b1d6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
    b1e0: 48 8d 15 89 6c 02 00         	leaq	158857(%rip), %rdx      # 0x31e70 <_IO_stdin_used+0x1e70>
    b1e7: 48 8d 35 ca 8d 02 00         	leaq	167370(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
    b1ee: 31 ff                        	xorl	%edi, %edi
    b1f0: e8 db ce ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
    b1f5: e9 2b ff ff ff               	jmp	0xb125 <bpf_program__attach_btf_id+0xc5>
; 		pfd = -errno;
    b1fa: e8 f1 a4 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		free(link);
    b1ff: 4c 89 e7                     	movq	%r12, %rdi
; 		return libbpf_err_ptr(pfd);
    b202: 45 31 e4                     	xorl	%r12d, %r12d
; 		pfd = -errno;
    b205: 44 8b 28                     	movl	(%rax), %r13d
    b208: 48 89 c3                     	movq	%rax, %rbx
; 		free(link);
    b20b: e8 b0 a4 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 		pr_warn("prog '%s': failed to attach: %s\n",
    b210: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
    b218: ba 80 00 00 00               	movl	$128, %edx
; 		pfd = -errno;
    b21d: 44 89 ef                     	movl	%r13d, %edi
    b220: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to attach: %s\n",
    b222: e8 a9 27 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
    b227: 48 8b 55 00                  	movq	(%rbp), %rdx
    b22b: 48 8d 35 ae 8d 02 00         	leaq	167342(%rip), %rsi      # 0x33fe0 <strs.2+0x1150>
    b232: 31 ff                        	xorl	%edi, %edi
    b234: 48 89 c1                     	movq	%rax, %rcx
    b237: 31 c0                        	xorl	%eax, %eax
    b239: e8 92 ce ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
    b23e: 44 89 2b                     	movl	%r13d, (%rbx)
; 		return libbpf_err_ptr(pfd);
    b241: e9 5c ff ff ff               	jmp	0xb1a2 <bpf_program__attach_btf_id+0x142>
; 		errno = -ret;
    b246: e8 a5 a4 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    b24b: c7 00 02 00 00 00            	movl	$2, (%rax)
    b251: 48 89 c3                     	movq	%rax, %rbx
; 		pr_warn("prog '%s': can't attach before loaded\n", prog->name);
    b254: 48 8b 55 00                  	movq	(%rbp), %rdx
    b258: 48 8d 35 d9 89 02 00         	leaq	166361(%rip), %rsi      # 0x33c38 <strs.2+0xda8>
    b25f: 31 ff                        	xorl	%edi, %edi
    b261: 31 c0                        	xorl	%eax, %eax
; 		return libbpf_err_ptr(-EINVAL);
    b263: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_warn("prog '%s': can't attach before loaded\n", prog->name);
    b266: e8 65 ce ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
    b26b: c7 03 16 00 00 00            	movl	$22, (%rbx)
; 		return libbpf_err_ptr(-EINVAL);
    b271: e9 2c ff ff ff               	jmp	0xb1a2 <bpf_program__attach_btf_id+0x142>
; 		errno = -ret;
    b276: e8 75 a4 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    b27b: c7 00 16 00 00 00            	movl	$22, (%rax)
    b281: 48 89 c3                     	movq	%rax, %rbx
    b284: eb ce                        	jmp	0xb254 <bpf_program__attach_btf_id+0x1f4>
; 	errno = -err;
    b286: e8 65 a4 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    b28b: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err_ptr(-ENOMEM);
    b291: e9 0c ff ff ff               	jmp	0xb1a2 <bpf_program__attach_btf_id+0x142>
; }
    b296: e8 65 a5 ff ff               	callq	0x5800 <.plt.sec+0x190>
    b29b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000b2a0 <attach_trace>:
; {
    b2a0: f3 0f 1e fa                  	endbr64
    b2a4: 55                           	pushq	%rbp
; 	return bpf_program__attach_btf_id(prog, NULL);
    b2a5: 31 f6                        	xorl	%esi, %esi
; {
    b2a7: 48 89 d5                     	movq	%rdx, %rbp
    b2aa: 53                           	pushq	%rbx
    b2ab: 48 83 ec 08                  	subq	$8, %rsp
; 	return bpf_program__attach_btf_id(prog, NULL);
    b2af: e8 ac fd ff ff               	callq	0xb060 <bpf_program__attach_btf_id>
; 	*link = bpf_program__attach_trace(prog);
    b2b4: 48 89 45 00                  	movq	%rax, (%rbp)
; 	return bpf_program__attach_btf_id(prog, NULL);
    b2b8: 48 89 c3                     	movq	%rax, %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
    b2bb: 48 85 c0                     	testq	%rax, %rax
    b2be: 74 18                        	je	0xb2d8 <attach_trace+0x38>
    b2c0: 31 c0                        	xorl	%eax, %eax
    b2c2: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
    b2c9: 77 0d                        	ja	0xb2d8 <attach_trace+0x38>
; }
    b2cb: 48 83 c4 08                  	addq	$8, %rsp
    b2cf: 5b                           	popq	%rbx
    b2d0: 5d                           	popq	%rbp
    b2d1: c3                           	retq
    b2d2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
    b2d8: e8 13 a4 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    b2dd: 48 89 c2                     	movq	%rax, %rdx
; 	if (IS_ERR(ptr))
    b2e0: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
    b2e7: 76 17                        	jbe	0xb300 <attach_trace+0x60>
; 		errno = -PTR_ERR(ptr);
    b2e9: 89 d8                        	movl	%ebx, %eax
    b2eb: f7 d8                        	negl	%eax
    b2ed: 89 02                        	movl	%eax, (%rdx)
; 	return -errno;
    b2ef: f7 d8                        	negl	%eax
; }
    b2f1: 48 83 c4 08                  	addq	$8, %rsp
    b2f5: 5b                           	popq	%rbx
    b2f6: 5d                           	popq	%rbp
    b2f7: c3                           	retq
    b2f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	return -errno;
    b300: 8b 00                        	movl	(%rax), %eax
    b302: f7 d8                        	negl	%eax
    b304: eb eb                        	jmp	0xb2f1 <attach_trace+0x51>
    b306: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000000b310 <attach_lsm>:
    b310: f3 0f 1e fa                  	endbr64
    b314: 55                           	pushq	%rbp
    b315: 31 f6                        	xorl	%esi, %esi
    b317: 48 89 d5                     	movq	%rdx, %rbp
    b31a: 53                           	pushq	%rbx
    b31b: 48 83 ec 08                  	subq	$8, %rsp
    b31f: e8 3c fd ff ff               	callq	0xb060 <bpf_program__attach_btf_id>
    b324: 48 89 45 00                  	movq	%rax, (%rbp)
    b328: 48 89 c3                     	movq	%rax, %rbx
    b32b: 48 85 c0                     	testq	%rax, %rax
    b32e: 74 18                        	je	0xb348 <attach_lsm+0x38>
    b330: 31 c0                        	xorl	%eax, %eax
    b332: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
    b339: 77 0d                        	ja	0xb348 <attach_lsm+0x38>
    b33b: 48 83 c4 08                  	addq	$8, %rsp
    b33f: 5b                           	popq	%rbx
    b340: 5d                           	popq	%rbp
    b341: c3                           	retq
    b342: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
    b348: e8 a3 a3 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    b34d: 48 89 c2                     	movq	%rax, %rdx
    b350: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
    b357: 76 17                        	jbe	0xb370 <attach_lsm+0x60>
    b359: 89 d8                        	movl	%ebx, %eax
    b35b: f7 d8                        	negl	%eax
    b35d: 89 02                        	movl	%eax, (%rdx)
    b35f: f7 d8                        	negl	%eax
    b361: 48 83 c4 08                  	addq	$8, %rsp
    b365: 5b                           	popq	%rbx
    b366: 5d                           	popq	%rbp
    b367: c3                           	retq
    b368: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
    b370: 8b 00                        	movl	(%rax), %eax
    b372: f7 d8                        	negl	%eax
    b374: eb eb                        	jmp	0xb361 <attach_lsm+0x51>
    b376: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000000b380 <libbpf_set_strict_mode>:
; {
    b380: f3 0f 1e fa                  	endbr64
; }
    b384: 31 c0                        	xorl	%eax, %eax
    b386: c3                           	retq
    b387: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000000b390 <libbpf_major_version>:
; {
    b390: f3 0f 1e fa                  	endbr64
; }
    b394: b8 01 00 00 00               	movl	$1, %eax
    b399: c3                           	retq
    b39a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000000b3a0 <libbpf_minor_version>:
; {
    b3a0: f3 0f 1e fa                  	endbr64
; }
    b3a4: 31 c0                        	xorl	%eax, %eax
    b3a6: c3                           	retq
    b3a7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000000b3b0 <libbpf_version_string>:
; {
    b3b0: f3 0f 1e fa                  	endbr64
; 	return  "v" _S(LIBBPF_MAJOR_VERSION) "." _S(LIBBPF_MINOR_VERSION);
    b3b4: 48 8d 05 c4 6a 02 00         	leaq	158404(%rip), %rax      # 0x31e7f <_IO_stdin_used+0x1e7f>
; }
    b3bb: c3                           	retq
    b3bc: 0f 1f 40 00                  	nopl	(%rax)

000000000000b3c0 <bpf_program__unload>:
; {
    b3c0: f3 0f 1e fa                  	endbr64
; 	if (!prog)
    b3c4: 48 85 ff                     	testq	%rdi, %rdi
    b3c7: 74 57                        	je	0xb420 <bpf_program__unload+0x60>
; {
    b3c9: 53                           	pushq	%rbx
    b3ca: 48 89 fb                     	movq	%rdi, %rbx
; 	zclose(prog->fd);
    b3cd: 8b 7f 78                     	movl	120(%rdi), %edi
    b3d0: 85 ff                        	testl	%edi, %edi
    b3d2: 79 3c                        	jns	0xb410 <bpf_program__unload+0x50>
    b3d4: c7 43 78 ff ff ff ff         	movl	$4294967295, 120(%rbx)  # imm = 0xFFFFFFFF
; 	zfree(&prog->func_info);
    b3db: 48 8b bb 98 00 00 00         	movq	152(%rbx), %rdi
    b3e2: e8 d9 a2 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zfree(&prog->line_info);
    b3e7: 48 8b bb a8 00 00 00         	movq	168(%rbx), %rdi
; 	zfree(&prog->func_info);
    b3ee: 48 c7 83 98 00 00 00 00 00 00 00     	movq	$0, 152(%rbx)
; 	zfree(&prog->line_info);
    b3f9: e8 c2 a2 ff ff               	callq	0x56c0 <.plt.sec+0x50>
    b3fe: 48 c7 83 a8 00 00 00 00 00 00 00     	movq	$0, 168(%rbx)
; }
    b409: 5b                           	popq	%rbx
    b40a: c3                           	retq
    b40b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	zclose(prog->fd);
    b410: e8 eb a4 ff ff               	callq	0x5900 <.plt.sec+0x290>
    b415: eb bd                        	jmp	0xb3d4 <bpf_program__unload+0x14>
    b417: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
    b420: c3                           	retq
    b421: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    b42c: 0f 1f 40 00                  	nopl	(%rax)

000000000000b430 <get_kernel_version>:
; {
    b430: f3 0f 1e fa                  	endbr64
    b434: 41 55                        	pushq	%r13
; 	if (access(ubuntu_kver_file, R_OK) == 0) {
    b436: be 04 00 00 00               	movl	$4, %esi
; {
    b43b: 41 54                        	pushq	%r12
    b43d: 55                           	pushq	%rbp
; 	if (access(ubuntu_kver_file, R_OK) == 0) {
    b43e: 48 8d 2d 3f 6a 02 00         	leaq	158271(%rip), %rbp      # 0x31e84 <_IO_stdin_used+0x1e84>
; {
    b445: 53                           	pushq	%rbx
; 	if (access(ubuntu_kver_file, R_OK) == 0) {
    b446: 48 89 ef                     	movq	%rbp, %rdi
; {
    b449: 48 81 ec a8 01 00 00         	subq	$424, %rsp              # imm = 0x1A8
    b450: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    b459: 48 89 84 24 98 01 00 00      	movq	%rax, 408(%rsp)
    b461: 31 c0                        	xorl	%eax, %eax
; 	if (access(ubuntu_kver_file, R_OK) == 0) {
    b463: e8 38 a7 ff ff               	callq	0x5ba0 <.plt.sec+0x530>
    b468: 85 c0                        	testl	%eax, %eax
    b46a: 0f 84 a0 00 00 00            	je	0xb510 <get_kernel_version+0xe0>
    b470: 48 8d 5c 24 0c               	leaq	12(%rsp), %rbx
    b475: 4c 8d 6c 24 08               	leaq	8(%rsp), %r13
    b47a: 4c 8d 64 24 04               	leaq	4(%rsp), %r12
; 	uname(&info);
    b47f: 48 8d 7c 24 10               	leaq	16(%rsp), %rdi
    b484: e8 f7 a3 ff ff               	callq	0x5880 <.plt.sec+0x210>
; 	if (sscanf(info.release, "%u.%u.%u", &major, &minor, &patch) != 3)
    b489: 49 89 d8                     	movq	%rbx, %r8
    b48c: 4c 89 e9                     	movq	%r13, %rcx
    b48f: 4c 89 e2                     	movq	%r12, %rdx
    b492: 48 8d bc 24 92 00 00 00      	leaq	146(%rsp), %rdi
    b49a: 48 8d 35 0d 6a 02 00         	leaq	158221(%rip), %rsi      # 0x31eae <_IO_stdin_used+0x1eae>
    b4a1: 31 c0                        	xorl	%eax, %eax
    b4a3: e8 18 a6 ff ff               	callq	0x5ac0 <.plt.sec+0x450>
    b4a8: 41 89 c0                     	movl	%eax, %r8d
; 		return 0;
    b4ab: 31 c0                        	xorl	%eax, %eax
; 	if (sscanf(info.release, "%u.%u.%u", &major, &minor, &patch) != 3)
    b4ad: 41 83 f8 03                  	cmpl	$3, %r8d
    b4b1: 74 35                        	je	0xb4e8 <get_kernel_version+0xb8>
; }
    b4b3: 48 8b 94 24 98 01 00 00      	movq	408(%rsp), %rdx
    b4bb: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    b4c4: 0f 85 9c 00 00 00            	jne	0xb566 <get_kernel_version+0x136>
    b4ca: 48 81 c4 a8 01 00 00         	addq	$424, %rsp              # imm = 0x1A8
    b4d1: 5b                           	popq	%rbx
    b4d2: 5d                           	popq	%rbp
    b4d3: 41 5c                        	popq	%r12
    b4d5: 41 5d                        	popq	%r13
    b4d7: c3                           	retq
    b4d8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 				fclose(f);
    b4e0: e8 db a2 ff ff               	callq	0x57c0 <.plt.sec+0x150>
; 				return KERNEL_VERSION(major, minor, patch);
    b4e5: 0f 1f 00                     	nopl	(%rax)
; 	return KERNEL_VERSION(major, minor, patch);
    b4e8: 8b 44 24 04                  	movl	4(%rsp), %eax
    b4ec: 8b 54 24 08                  	movl	8(%rsp), %edx
    b4f0: b9 ff 00 00 00               	movl	$255, %ecx
    b4f5: c1 e2 08                     	shll	$8, %edx
    b4f8: c1 e0 10                     	shll	$16, %eax
    b4fb: 01 d0                        	addl	%edx, %eax
    b4fd: 8b 54 24 0c                  	movl	12(%rsp), %edx
    b501: 39 ca                        	cmpl	%ecx, %edx
    b503: 0f 47 d1                     	cmoval	%ecx, %edx
    b506: 01 d0                        	addl	%edx, %eax
    b508: eb a9                        	jmp	0xb4b3 <get_kernel_version+0x83>
    b50a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		f = fopen(ubuntu_kver_file, "r");
    b510: 48 89 ef                     	movq	%rbp, %rdi
; 			if (fscanf(f, "%*s %*s %d.%d.%d\n", &major, &minor, &patch) == 3) {
    b513: 48 8d 5c 24 0c               	leaq	12(%rsp), %rbx
    b518: 4c 8d 6c 24 08               	leaq	8(%rsp), %r13
; 		f = fopen(ubuntu_kver_file, "r");
    b51d: 48 8d 35 e5 66 02 00         	leaq	157413(%rip), %rsi      # 0x31c09 <_IO_stdin_used+0x1c09>
; 			if (fscanf(f, "%*s %*s %d.%d.%d\n", &major, &minor, &patch) == 3) {
    b524: 4c 8d 64 24 04               	leaq	4(%rsp), %r12
; 		f = fopen(ubuntu_kver_file, "r");
    b529: e8 e2 a4 ff ff               	callq	0x5a10 <.plt.sec+0x3a0>
    b52e: 48 89 c5                     	movq	%rax, %rbp
; 		if (f) {
    b531: 48 85 c0                     	testq	%rax, %rax
    b534: 0f 84 45 ff ff ff            	je	0xb47f <get_kernel_version+0x4f>
; 			if (fscanf(f, "%*s %*s %d.%d.%d\n", &major, &minor, &patch) == 3) {
    b53a: 48 89 c7                     	movq	%rax, %rdi
    b53d: 49 89 d8                     	movq	%rbx, %r8
    b540: 4c 89 e9                     	movq	%r13, %rcx
    b543: 4c 89 e2                     	movq	%r12, %rdx
    b546: 48 8d 35 4f 69 02 00         	leaq	158031(%rip), %rsi      # 0x31e9c <_IO_stdin_used+0x1e9c>
    b54d: 31 c0                        	xorl	%eax, %eax
    b54f: e8 8c a3 ff ff               	callq	0x58e0 <.plt.sec+0x270>
; 				fclose(f);
    b554: 48 89 ef                     	movq	%rbp, %rdi
; 			if (fscanf(f, "%*s %*s %d.%d.%d\n", &major, &minor, &patch) == 3) {
    b557: 83 f8 03                     	cmpl	$3, %eax
    b55a: 74 84                        	je	0xb4e0 <get_kernel_version+0xb0>
; 			fclose(f);
    b55c: e8 5f a2 ff ff               	callq	0x57c0 <.plt.sec+0x150>
    b561: e9 19 ff ff ff               	jmp	0xb47f <get_kernel_version+0x4f>
; }
    b566: e8 95 a2 ff ff               	callq	0x5800 <.plt.sec+0x190>
    b56b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000b570 <skip_mods_and_typedefs>:
; {
    b570: f3 0f 1e fa                  	endbr64
    b574: 41 54                        	pushq	%r12
    b576: 41 89 f4                     	movl	%esi, %r12d
    b579: 55                           	pushq	%rbp
    b57a: 48 89 fd                     	movq	%rdi, %rbp
    b57d: 53                           	pushq	%rbx
    b57e: 48 89 d3                     	movq	%rdx, %rbx
; 	const struct btf_type *t = btf__type_by_id(btf, id);
    b581: e8 1a ea 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	if (res_id)
    b586: 48 85 db                     	testq	%rbx, %rbx
    b589: 74 03                        	je	0xb58e <skip_mods_and_typedefs+0x1e>
; 		*res_id = id;
    b58b: 44 89 23                     	movl	%r12d, (%rbx)
; 	return BTF_INFO_KIND(t->info);
    b58e: 0f b6 50 07                  	movzbl	7(%rax), %edx
; 	while (btf_is_mod(t) || btf_is_typedef(t)) {
    b592: b9 00 0f 04 00               	movl	$265984, %ecx           # imm = 0x40F00
    b597: 83 e2 1f                     	andl	$31, %edx
    b59a: 48 0f a3 d1                  	btq	%rdx, %rcx
    b59e: 73 32                        	jae	0xb5d2 <skip_mods_and_typedefs+0x62>
    b5a0: 41 bc 00 0f 04 00            	movl	$265984, %r12d          # imm = 0x40F00
    b5a6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		if (res_id)
    b5b0: 48 85 db                     	testq	%rbx, %rbx
    b5b3: 74 05                        	je	0xb5ba <skip_mods_and_typedefs+0x4a>
; 			*res_id = t->type;
    b5b5: 8b 50 08                     	movl	8(%rax), %edx
    b5b8: 89 13                        	movl	%edx, (%rbx)
; 		t = btf__type_by_id(btf, t->type);
    b5ba: 8b 70 08                     	movl	8(%rax), %esi
    b5bd: 48 89 ef                     	movq	%rbp, %rdi
    b5c0: e8 db e9 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	return BTF_INFO_KIND(t->info);
    b5c5: 0f b6 50 07                  	movzbl	7(%rax), %edx
; 	while (btf_is_mod(t) || btf_is_typedef(t)) {
    b5c9: 83 e2 1f                     	andl	$31, %edx
    b5cc: 49 0f a3 d4                  	btq	%rdx, %r12
    b5d0: 72 de                        	jb	0xb5b0 <skip_mods_and_typedefs+0x40>
; }
    b5d2: 5b                           	popq	%rbx
    b5d3: 5d                           	popq	%rbp
    b5d4: 41 5c                        	popq	%r12
    b5d6: c3                           	retq
    b5d7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000000b5e0 <find_kcfg_type>:
; {
    b5e0: 41 54                        	pushq	%r12
    b5e2: 49 89 fc                     	movq	%rdi, %r12
    b5e5: 55                           	pushq	%rbp
    b5e6: 48 89 d5                     	movq	%rdx, %rbp
; 	t = skip_mods_and_typedefs(btf, id, NULL);
    b5e9: 31 d2                        	xorl	%edx, %edx
; {
    b5eb: 53                           	pushq	%rbx
; 	t = skip_mods_and_typedefs(btf, id, NULL);
    b5ec: e8 7f ff ff ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	name = btf__name_by_offset(btf, t->name_off);
    b5f1: 4c 89 e7                     	movq	%r12, %rdi
    b5f4: 8b 30                        	movl	(%rax), %esi
; 	t = skip_mods_and_typedefs(btf, id, NULL);
    b5f6: 48 89 c3                     	movq	%rax, %rbx
; 	name = btf__name_by_offset(btf, t->name_off);
    b5f9: e8 f2 04 02 00               	callq	0x2baf0 <btf__name_by_offset>
; 	if (is_signed)
    b5fe: 48 85 ed                     	testq	%rbp, %rbp
    b601: 74 04                        	je	0xb607 <find_kcfg_type+0x27>
; 		*is_signed = false;
    b603: c6 45 00 00                  	movb	$0, (%rbp)
; 	return BTF_INFO_KIND(t->info);
    b607: 0f b6 4b 07                  	movzbl	7(%rbx), %ecx
    b60b: 83 e1 1f                     	andl	$31, %ecx
; 	switch (btf_kind(t)) {
    b60e: 66 83 f9 06                  	cmpw	$6, %cx
    b612: 0f 84 88 00 00 00            	je	0xb6a0 <find_kcfg_type+0xc0>
    b618: 77 26                        	ja	0xb640 <find_kcfg_type+0x60>
    b61a: 66 83 f9 01                  	cmpw	$1, %cx
    b61e: 74 48                        	je	0xb668 <find_kcfg_type+0x88>
    b620: 66 83 f9 03                  	cmpw	$3, %cx
    b624: 75 12                        	jne	0xb638 <find_kcfg_type+0x58>
; 		if (btf_array(t)->nelems == 0)
    b626: 8b 43 14                     	movl	20(%rbx), %eax
    b629: 85 c0                        	testl	%eax, %eax
    b62b: 0f 85 7f 00 00 00            	jne	0xb6b0 <find_kcfg_type+0xd0>
    b631: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			return KCFG_UNKNOWN;
    b638: 31 c0                        	xorl	%eax, %eax
; }
    b63a: 5b                           	popq	%rbx
    b63b: 5d                           	popq	%rbp
    b63c: 41 5c                        	popq	%r12
    b63e: c3                           	retq
    b63f: 90                           	nop
; 	switch (btf_kind(t)) {
    b640: 66 83 f9 13                  	cmpw	$19, %cx
    b644: 75 f2                        	jne	0xb638 <find_kcfg_type+0x58>
; 		if (strcmp(name, "libbpf_tristate"))
    b646: 48 8d 35 6a 68 02 00         	leaq	157802(%rip), %rsi      # 0x31eb7 <_IO_stdin_used+0x1eb7>
    b64d: 48 89 c7                     	movq	%rax, %rdi
    b650: e8 5b a3 ff ff               	callq	0x59b0 <.plt.sec+0x340>
; }
    b655: 5b                           	popq	%rbx
    b656: 5d                           	popq	%rbp
; 		if (strcmp(name, "libbpf_tristate"))
    b657: 85 c0                        	testl	%eax, %eax
; }
    b659: 41 5c                        	popq	%r12
; 		if (strcmp(name, "libbpf_tristate"))
    b65b: 0f 94 c0                     	sete	%al
    b65e: 0f b6 c0                     	movzbl	%al, %eax
    b661: c1 e0 02                     	shll	$2, %eax
; }
    b664: c3                           	retq
    b665: 0f 1f 00                     	nopl	(%rax)
; 	return BTF_INT_ENCODING(*(__u32 *)(t + 1));
    b668: 0f b6 53 0f                  	movzbl	15(%rbx), %edx
; 			return t->size == 1 ? KCFG_BOOL : KCFG_UNKNOWN;
    b66c: 8b 43 08                     	movl	8(%rbx), %eax
; 		if (enc & BTF_INT_BOOL)
    b66f: f6 c2 04                     	testb	$4, %dl
    b672: 75 5c                        	jne	0xb6d0 <find_kcfg_type+0xf0>
; 		if (is_signed)
    b674: 48 85 ed                     	testq	%rbp, %rbp
    b677: 74 07                        	je	0xb680 <find_kcfg_type+0xa0>
; 			*is_signed = enc & BTF_INT_SIGNED;
    b679: 88 55 00                     	movb	%dl, (%rbp)
    b67c: 80 65 00 01                  	andb	$1, (%rbp)
; 		if (t->size == 1)
    b680: 83 f8 01                     	cmpl	$1, %eax
    b683: 74 b5                        	je	0xb63a <find_kcfg_type+0x5a>
; 		if (t->size < 1 || t->size > 8 || (t->size & (t->size - 1)))
    b685: 8d 50 ff                     	leal	-1(%rax), %edx
    b688: 83 fa 07                     	cmpl	$7, %edx
    b68b: 77 ab                        	ja	0xb638 <find_kcfg_type+0x58>
    b68d: 85 c2                        	testl	%eax, %edx
    b68f: 75 a7                        	jne	0xb638 <find_kcfg_type+0x58>
; 		return KCFG_INT;
    b691: b8 03 00 00 00               	movl	$3, %eax
    b696: eb a2                        	jmp	0xb63a <find_kcfg_type+0x5a>
    b698: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		if (t->size != 4)
    b6a0: 83 7b 08 04                  	cmpl	$4, 8(%rbx)
    b6a4: 75 92                        	jne	0xb638 <find_kcfg_type+0x58>
    b6a6: eb 9e                        	jmp	0xb646 <find_kcfg_type+0x66>
    b6a8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		if (find_kcfg_type(btf, btf_array(t)->type, NULL) != KCFG_CHAR)
    b6b0: 8b 73 0c                     	movl	12(%rbx), %esi
    b6b3: 31 d2                        	xorl	%edx, %edx
    b6b5: 4c 89 e7                     	movq	%r12, %rdi
    b6b8: e8 23 ff ff ff               	callq	0xb5e0 <find_kcfg_type>
    b6bd: 83 f8 01                     	cmpl	$1, %eax
    b6c0: 0f 85 72 ff ff ff            	jne	0xb638 <find_kcfg_type+0x58>
; 		return KCFG_CHAR_ARR;
    b6c6: b8 05 00 00 00               	movl	$5, %eax
    b6cb: e9 6a ff ff ff               	jmp	0xb63a <find_kcfg_type+0x5a>
; 			return t->size == 1 ? KCFG_BOOL : KCFG_UNKNOWN;
    b6d0: 83 f8 01                     	cmpl	$1, %eax
    b6d3: 0f 94 c0                     	sete	%al
    b6d6: 0f b6 c0                     	movzbl	%al, %eax
    b6d9: 01 c0                        	addl	%eax, %eax
    b6db: e9 5a ff ff ff               	jmp	0xb63a <find_kcfg_type+0x5a>

000000000000b6e0 <get_map_field_int>:
; {
    b6e0: 41 57                        	pushq	%r15
    b6e2: 41 56                        	pushq	%r14
    b6e4: 41 55                        	pushq	%r13
    b6e6: 49 89 cd                     	movq	%rcx, %r13
    b6e9: 41 54                        	pushq	%r12
    b6eb: 49 89 fc                     	movq	%rdi, %r12
    b6ee: 55                           	pushq	%rbp
    b6ef: 48 89 f5                     	movq	%rsi, %rbp
    b6f2: 53                           	pushq	%rbx
; 	const struct btf_type *t = skip_mods_and_typedefs(btf, m->type, NULL);
    b6f3: 48 89 ef                     	movq	%rbp, %rdi
; {
    b6f6: 48 89 d3                     	movq	%rdx, %rbx
    b6f9: 48 83 ec 08                  	subq	$8, %rsp
; 	const struct btf_type *t = skip_mods_and_typedefs(btf, m->type, NULL);
    b6fd: 8b 72 04                     	movl	4(%rdx), %esi
    b700: 31 d2                        	xorl	%edx, %edx
    b702: e8 69 fe ff ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	const char *name = btf__name_by_offset(btf, m->name_off);
    b707: 8b 33                        	movl	(%rbx), %esi
    b709: 48 89 ef                     	movq	%rbp, %rdi
; 	const struct btf_type *t = skip_mods_and_typedefs(btf, m->type, NULL);
    b70c: 49 89 c7                     	movq	%rax, %r15
; 	const char *name = btf__name_by_offset(btf, m->name_off);
    b70f: e8 dc 03 02 00               	callq	0x2baf0 <btf__name_by_offset>
; 	return BTF_INFO_KIND(t->info);
    b714: 41 0f b6 7f 07               	movzbl	7(%r15), %edi
; 	const char *name = btf__name_by_offset(btf, m->name_off);
    b719: 49 89 c6                     	movq	%rax, %r14
; 	return BTF_INFO_KIND(t->info);
    b71c: 83 e7 1f                     	andl	$31, %edi
; 	if (!btf_is_ptr(t)) {
    b71f: 66 83 ff 02                  	cmpw	$2, %di
    b723: 74 3b                        	je	0xb760 <get_map_field_int+0x80>
; 	return __btf_kind_str(btf_kind(t));
    b725: 0f b7 ff                     	movzwl	%di, %edi
; 		pr_warn("map '%s': attr '%s': expected PTR, got %s.\n",
    b728: 4c 89 f1                     	movq	%r14, %rcx
    b72b: 48 8d 35 06 89 02 00         	leaq	166150(%rip), %rsi      # 0x34038 <strs.2+0x11a8>
; 	return __btf_kind_str(btf_kind(t));
    b732: e8 59 ac ff ff               	callq	0x6390 <__btf_kind_str>
; 		pr_warn("map '%s': attr '%s': expected PTR, got %s.\n",
    b737: 4c 89 e2                     	movq	%r12, %rdx
    b73a: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
    b73c: 49 89 c0                     	movq	%rax, %r8
; 		pr_warn("map '%s': attr '%s': expected PTR, got %s.\n",
    b73f: 31 c0                        	xorl	%eax, %eax
    b741: e8 8a c9 ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
    b746: 31 c0                        	xorl	%eax, %eax
; }
    b748: 48 83 c4 08                  	addq	$8, %rsp
    b74c: 5b                           	popq	%rbx
    b74d: 5d                           	popq	%rbp
    b74e: 41 5c                        	popq	%r12
    b750: 41 5d                        	popq	%r13
    b752: 41 5e                        	popq	%r14
    b754: 41 5f                        	popq	%r15
    b756: c3                           	retq
    b757: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	arr_t = btf__type_by_id(btf, t->type);
    b760: 41 8b 77 08                  	movl	8(%r15), %esi
    b764: 48 89 ef                     	movq	%rbp, %rdi
    b767: e8 34 e8 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	if (!arr_t) {
    b76c: 48 85 c0                     	testq	%rax, %rax
    b76f: 74 67                        	je	0xb7d8 <get_map_field_int+0xf8>
; 	return BTF_INFO_KIND(t->info);
    b771: 0f b6 78 07                  	movzbl	7(%rax), %edi
    b775: 83 e7 1f                     	andl	$31, %edi
; 	if (!btf_is_array(arr_t)) {
    b778: 66 83 ff 03                  	cmpw	$3, %di
    b77c: 75 22                        	jne	0xb7a0 <get_map_field_int+0xc0>
; 	*res = arr_info->nelems;
    b77e: 8b 40 14                     	movl	20(%rax), %eax
    b781: 41 89 45 00                  	movl	%eax, (%r13)
; }
    b785: 48 83 c4 08                  	addq	$8, %rsp
; 	return true;
    b789: b8 01 00 00 00               	movl	$1, %eax
; }
    b78e: 5b                           	popq	%rbx
    b78f: 5d                           	popq	%rbp
    b790: 41 5c                        	popq	%r12
    b792: 41 5d                        	popq	%r13
    b794: 41 5e                        	popq	%r14
    b796: 41 5f                        	popq	%r15
    b798: c3                           	retq
    b799: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return __btf_kind_str(btf_kind(t));
    b7a0: 0f b7 ff                     	movzwl	%di, %edi
; 		pr_warn("map '%s': attr '%s': expected ARRAY, got %s.\n",
    b7a3: 4c 89 f1                     	movq	%r14, %rcx
    b7a6: 48 8d 35 fb 88 02 00         	leaq	166139(%rip), %rsi      # 0x340a8 <strs.2+0x1218>
; 	return __btf_kind_str(btf_kind(t));
    b7ad: e8 de ab ff ff               	callq	0x6390 <__btf_kind_str>
; 		pr_warn("map '%s': attr '%s': expected ARRAY, got %s.\n",
    b7b2: 4c 89 e2                     	movq	%r12, %rdx
    b7b5: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
    b7b7: 49 89 c0                     	movq	%rax, %r8
; 		pr_warn("map '%s': attr '%s': expected ARRAY, got %s.\n",
    b7ba: 31 c0                        	xorl	%eax, %eax
    b7bc: e8 0f c9 ff ff               	callq	0x80d0 <libbpf_print>
; }
    b7c1: 48 83 c4 08                  	addq	$8, %rsp
; 		return false;
    b7c5: 31 c0                        	xorl	%eax, %eax
; }
    b7c7: 5b                           	popq	%rbx
    b7c8: 5d                           	popq	%rbp
    b7c9: 41 5c                        	popq	%r12
    b7cb: 41 5d                        	popq	%r13
    b7cd: 41 5e                        	popq	%r14
    b7cf: 41 5f                        	popq	%r15
    b7d1: c3                           	retq
    b7d2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("map '%s': attr '%s': type [%u] not found.\n",
    b7d8: 45 8b 47 08                  	movl	8(%r15), %r8d
    b7dc: 4c 89 f1                     	movq	%r14, %rcx
    b7df: 4c 89 e2                     	movq	%r12, %rdx
    b7e2: 31 ff                        	xorl	%edi, %edi
    b7e4: 48 8d 35 85 88 02 00         	leaq	166021(%rip), %rsi      # 0x34070 <strs.2+0x11e0>
    b7eb: e8 e0 c8 ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
    b7f0: 31 c0                        	xorl	%eax, %eax
    b7f2: e9 51 ff ff ff               	jmp	0xb748 <get_map_field_int+0x68>
    b7f7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000000b800 <btf_kind_str>:
; {
    b800: f3 0f 1e fa                  	endbr64
; 	return BTF_INFO_KIND(t->info);
    b804: 0f b6 7f 07                  	movzbl	7(%rdi), %edi
; 	return __btf_kind_str(btf_kind(t));
    b808: 83 e7 1f                     	andl	$31, %edi
    b80b: e9 80 ab ff ff               	jmp	0x6390 <__btf_kind_str>

000000000000b810 <parse_btf_map_def>:
; {
    b810: f3 0f 1e fa                  	endbr64
    b814: 41 57                        	pushq	%r15
    b816: 41 56                        	pushq	%r14
    b818: 41 55                        	pushq	%r13
    b81a: 41 54                        	pushq	%r12
    b81c: 55                           	pushq	%rbp
    b81d: 4c 89 c5                     	movq	%r8, %rbp
    b820: 53                           	pushq	%rbx
    b821: 48 81 ec d8 00 00 00         	subq	$216, %rsp
    b828: 48 89 7c 24 08               	movq	%rdi, 8(%rsp)
    b82d: 4c 89 4c 24 10               	movq	%r9, 16(%rsp)
    b832: 88 4c 24 1f                  	movb	%cl, 31(%rsp)
    b836: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    b83f: 48 89 84 24 c8 00 00 00      	movq	%rax, 200(%rsp)
    b847: 31 c0                        	xorl	%eax, %eax
; 	return BTF_INFO_VLEN(t->info);
    b849: 0f b7 42 04                  	movzwl	4(%rdx), %eax
    b84d: 89 44 24 18                  	movl	%eax, 24(%rsp)
; 	for (i = 0; i < vlen; i++, m++) {
    b851: 85 c0                        	testl	%eax, %eax
    b853: 0f 84 4f 02 00 00            	je	0xbaa8 <parse_btf_map_def+0x298>
    b859: 49 89 f5                     	movq	%rsi, %r13
    b85c: 48 8d 5a 0c                  	leaq	12(%rdx), %rbx
    b860: 45 31 e4                     	xorl	%r12d, %r12d
; 		if (strcmp(name, "type") == 0) {
    b863: 4c 8d 35 7f 66 02 00         	leaq	157311(%rip), %r14      # 0x31ee9 <_IO_stdin_used+0x1ee9>
    b86a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		const char *name = btf__name_by_offset(btf, m->name_off);
    b870: 8b 33                        	movl	(%rbx), %esi
    b872: 4c 89 ef                     	movq	%r13, %rdi
    b875: e8 76 02 02 00               	callq	0x2baf0 <btf__name_by_offset>
    b87a: 49 89 c7                     	movq	%rax, %r15
; 		if (!name) {
    b87d: 48 85 c0                     	testq	%rax, %rax
    b880: 0f 84 5a 04 00 00            	je	0xbce0 <parse_btf_map_def+0x4d0>
; 		if (strcmp(name, "type") == 0) {
    b886: 4c 89 f6                     	movq	%r14, %rsi
    b889: 48 89 c7                     	movq	%rax, %rdi
    b88c: e8 1f a1 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b891: 85 c0                        	testl	%eax, %eax
    b893: 0f 84 47 02 00 00            	je	0xbae0 <parse_btf_map_def+0x2d0>
; 		} else if (strcmp(name, "max_entries") == 0) {
    b899: 48 8d 35 4e 66 02 00         	leaq	157262(%rip), %rsi      # 0x31eee <_IO_stdin_used+0x1eee>
    b8a0: 4c 89 ff                     	movq	%r15, %rdi
    b8a3: e8 08 a1 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b8a8: 85 c0                        	testl	%eax, %eax
    b8aa: 0f 84 68 02 00 00            	je	0xbb18 <parse_btf_map_def+0x308>
; 		} else if (strcmp(name, "map_flags") == 0) {
    b8b0: 48 8d 35 43 66 02 00         	leaq	157251(%rip), %rsi      # 0x31efa <_IO_stdin_used+0x1efa>
    b8b7: 4c 89 ff                     	movq	%r15, %rdi
    b8ba: e8 f1 a0 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b8bf: 85 c0                        	testl	%eax, %eax
    b8c1: 0f 84 79 02 00 00            	je	0xbb40 <parse_btf_map_def+0x330>
; 		} else if (strcmp(name, "numa_node") == 0) {
    b8c7: 48 8d 35 36 66 02 00         	leaq	157238(%rip), %rsi      # 0x31f04 <_IO_stdin_used+0x1f04>
    b8ce: 4c 89 ff                     	movq	%r15, %rdi
    b8d1: e8 da a0 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b8d6: 85 c0                        	testl	%eax, %eax
    b8d8: 0f 84 8a 02 00 00            	je	0xbb68 <parse_btf_map_def+0x358>
; 		} else if (strcmp(name, "key_size") == 0) {
    b8de: 48 8d 35 29 66 02 00         	leaq	157225(%rip), %rsi      # 0x31f0e <_IO_stdin_used+0x1f0e>
    b8e5: 4c 89 ff                     	movq	%r15, %rdi
    b8e8: e8 c3 a0 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b8ed: 85 c0                        	testl	%eax, %eax
    b8ef: 0f 84 9b 02 00 00            	je	0xbb90 <parse_btf_map_def+0x380>
; 		} else if (strcmp(name, "key") == 0) {
    b8f5: 48 8d 35 1b 66 02 00         	leaq	157211(%rip), %rsi      # 0x31f17 <_IO_stdin_used+0x1f17>
    b8fc: 4c 89 ff                     	movq	%r15, %rdi
    b8ff: e8 ac a0 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b904: 85 c0                        	testl	%eax, %eax
    b906: 0f 84 c4 02 00 00            	je	0xbbd0 <parse_btf_map_def+0x3c0>
; 		} else if (strcmp(name, "value_size") == 0) {
    b90c: 48 8d 35 08 66 02 00         	leaq	157192(%rip), %rsi      # 0x31f1b <_IO_stdin_used+0x1f1b>
    b913: 4c 89 ff                     	movq	%r15, %rdi
    b916: e8 95 a0 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b91b: 85 c0                        	testl	%eax, %eax
    b91d: 0f 84 75 03 00 00            	je	0xbc98 <parse_btf_map_def+0x488>
; 		} else if (strcmp(name, "value") == 0) {
    b923: 48 8d 35 b9 65 02 00         	leaq	157113(%rip), %rsi      # 0x31ee3 <_IO_stdin_used+0x1ee3>
    b92a: 4c 89 ff                     	movq	%r15, %rdi
    b92d: e8 7e a0 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b932: 85 c0                        	testl	%eax, %eax
    b934: 0f 84 ce 03 00 00            	je	0xbd08 <parse_btf_map_def+0x4f8>
; 		else if (strcmp(name, "values") == 0) {
    b93a: 48 8d 35 e5 65 02 00         	leaq	157157(%rip), %rsi      # 0x31f26 <_IO_stdin_used+0x1f26>
    b941: 4c 89 ff                     	movq	%r15, %rdi
    b944: e8 67 a0 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    b949: 85 c0                        	testl	%eax, %eax
    b94b: 0f 85 e7 02 00 00            	jne	0xbc38 <parse_btf_map_def+0x428>
; 			bool is_map_in_map = bpf_map_type__is_map_in_map(map_def->map_type);
    b951: 8b 45 04                     	movl	4(%rbp), %eax
; 		return true;
    b954: 48 8d 15 7d 65 02 00         	leaq	157053(%rip), %rdx      # 0x31ed8 <_IO_stdin_used+0x1ed8>
; 			bool is_map_in_map = bpf_map_type__is_map_in_map(map_def->map_type);
    b95b: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
    b95f: 83 e8 0c                     	subl	$12, %eax
; 		return true;
    b962: 83 f8 02                     	cmpl	$2, %eax
    b965: 40 0f 92 c6                  	setb	%sil
    b969: 83 f8 01                     	cmpl	$1, %eax
    b96c: 48 8d 05 54 65 02 00         	leaq	157012(%rip), %rax      # 0x31ec7 <_IO_stdin_used+0x1ec7>
    b973: 48 0f 47 c2                  	cmovaq	%rdx, %rax
; 			if (is_inner) {
    b977: 48 83 7c 24 10 00            	cmpq	$0, 16(%rsp)
; 		return true;
    b97d: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 			if (is_inner) {
    b982: 0f 84 9e 06 00 00            	je	0xc026 <parse_btf_map_def+0x816>
; 			if (i != vlen - 1) {
    b988: 8b 44 24 18                  	movl	24(%rsp), %eax
    b98c: 83 e8 01                     	subl	$1, %eax
    b98f: 44 39 e0                     	cmpl	%r12d, %eax
    b992: 0f 85 b2 05 00 00            	jne	0xbf4a <parse_btf_map_def+0x73a>
; 			if (!is_map_in_map && !is_prog_array) {
    b998: 40 84 f6                     	testb	%sil, %sil
    b99b: 75 0b                        	jne	0xb9a8 <parse_btf_map_def+0x198>
    b99d: 83 7c 24 20 03               	cmpl	$3, 32(%rsp)
    b9a2: 0f 85 7a 04 00 00            	jne	0xbe22 <parse_btf_map_def+0x612>
; 			if (map_def->value_size && map_def->value_size != 4) {
    b9a8: 8b 4d 14                     	movl	20(%rbp), %ecx
    b9ab: f7 c1 fb ff ff ff            	testl	$4294967291, %ecx       # imm = 0xFFFFFFFB
    b9b1: 0f 85 2a 06 00 00            	jne	0xbfe1 <parse_btf_map_def+0x7d1>
; 			map_def->value_size = 4;
    b9b7: c7 45 14 04 00 00 00         	movl	$4, 20(%rbp)
; 			t = btf__type_by_id(btf, m->type);
    b9be: 8b 73 04                     	movl	4(%rbx), %esi
    b9c1: 4c 89 ef                     	movq	%r13, %rdi
    b9c4: e8 d7 e5 01 00               	callq	0x29fa0 <btf__type_by_id>
; 			if (!t) {
    b9c9: 48 85 c0                     	testq	%rax, %rax
    b9cc: 0f 84 2e 06 00 00            	je	0xc000 <parse_btf_map_def+0x7f0>
; 	return BTF_INFO_KIND(t->info);
    b9d2: 0f b6 50 07                  	movzbl	7(%rax), %edx
    b9d6: 83 e2 1f                     	andl	$31, %edx
; 			if (!btf_is_array(t) || btf_array(t)->nelems) {
    b9d9: 66 83 fa 03                  	cmpw	$3, %dx
    b9dd: 0f 85 43 05 00 00            	jne	0xbf26 <parse_btf_map_def+0x716>
    b9e3: 8b 50 14                     	movl	20(%rax), %edx
    b9e6: 85 d2                        	testl	%edx, %edx
    b9e8: 0f 85 38 05 00 00            	jne	0xbf26 <parse_btf_map_def+0x716>
; 			t = skip_mods_and_typedefs(btf, btf_array(t)->type, NULL);
    b9ee: 8b 70 0c                     	movl	12(%rax), %esi
    b9f1: 31 d2                        	xorl	%edx, %edx
    b9f3: 4c 89 ef                     	movq	%r13, %rdi
    b9f6: e8 75 fb ff ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	return BTF_INFO_KIND(t->info);
    b9fb: 0f b6 50 07                  	movzbl	7(%rax), %edx
    b9ff: 83 e2 1f                     	andl	$31, %edx
; 			if (!btf_is_ptr(t)) {
    ba02: 66 83 fa 02                  	cmpw	$2, %dx
    ba06: 0f 85 39 06 00 00            	jne	0xc045 <parse_btf_map_def+0x835>
; 			t = skip_mods_and_typedefs(btf, t->type, NULL);
    ba0c: 8b 70 08                     	movl	8(%rax), %esi
    ba0f: 31 d2                        	xorl	%edx, %edx
    ba11: 4c 89 ef                     	movq	%r13, %rdi
    ba14: e8 57 fb ff ff               	callq	0xb570 <skip_mods_and_typedefs>
    ba19: 49 89 c2                     	movq	%rax, %r10
; 	return BTF_INFO_KIND(t->info);
    ba1c: 0f b6 40 07                  	movzbl	7(%rax), %eax
    ba20: 83 e0 1f                     	andl	$31, %eax
; 			if (is_prog_array) {
    ba23: 83 7c 24 20 03               	cmpl	$3, 32(%rsp)
    ba28: 0f 84 9e 03 00 00            	je	0xbdcc <parse_btf_map_def+0x5bc>
; 			if (!btf_is_struct(t)) {
    ba2e: 66 83 f8 04                  	cmpw	$4, %ax
    ba32: 0f 85 6e 06 00 00            	jne	0xc0a6 <parse_btf_map_def+0x896>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    ba38: 4c 8b 4c 24 08               	movq	8(%rsp), %r9
    ba3d: 4c 8d 7c 24 40               	leaq	64(%rsp), %r15
    ba42: b9 80 00 00 00               	movl	$128, %ecx
    ba47: 31 c0                        	xorl	%eax, %eax
    ba49: 4c 8d 05 dd 64 02 00         	leaq	156893(%rip), %r8       # 0x31f2d <_IO_stdin_used+0x1f2d>
    ba50: ba 01 00 00 00               	movl	$1, %edx
    ba55: be 80 00 00 00               	movl	$128, %esi
    ba5a: 4c 89 ff                     	movq	%r15, %rdi
    ba5d: 4c 89 54 24 20               	movq	%r10, 32(%rsp)
    ba62: e8 49 9c ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 			err = parse_btf_map_def(inner_map_name, btf, t, strict, inner_def, NULL);
    ba67: 0f b6 4c 24 1f               	movzbl	31(%rsp), %ecx
    ba6c: 45 31 c9                     	xorl	%r9d, %r9d
    ba6f: 4c 89 ee                     	movq	%r13, %rsi
    ba72: 4c 8b 44 24 10               	movq	16(%rsp), %r8
    ba77: 48 8b 54 24 20               	movq	32(%rsp), %rdx
    ba7c: 4c 89 ff                     	movq	%r15, %rdi
    ba7f: e8 8c fd ff ff               	callq	0xb810 <parse_btf_map_def>
; 			if (err)
    ba84: 85 c0                        	testl	%eax, %eax
    ba86: 75 2d                        	jne	0xbab5 <parse_btf_map_def+0x2a5>
; 			map_def->parts |= MAP_DEF_INNER_MAP;
    ba88: 81 4d 00 00 02 00 00         	orl	$512, (%rbp)            # imm = 0x200
; 	for (i = 0; i < vlen; i++, m++) {
    ba8f: 41 83 c4 01                  	addl	$1, %r12d
    ba93: 48 83 c3 0c                  	addq	$12, %rbx
    ba97: 44 39 64 24 18               	cmpl	%r12d, 24(%rsp)
    ba9c: 0f 85 ce fd ff ff            	jne	0xb870 <parse_btf_map_def+0x60>
    baa2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (map_def->map_type == BPF_MAP_TYPE_UNSPEC) {
    baa8: 8b 4d 04                     	movl	4(%rbp), %ecx
    baab: 85 c9                        	testl	%ecx, %ecx
    baad: 0f 84 37 06 00 00            	je	0xc0ea <parse_btf_map_def+0x8da>
; 	return 0;
    bab3: 31 c0                        	xorl	%eax, %eax
; }
    bab5: 48 8b 94 24 c8 00 00 00      	movq	200(%rsp), %rdx
    babd: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    bac6: 0f 85 38 06 00 00            	jne	0xc104 <parse_btf_map_def+0x8f4>
    bacc: 48 81 c4 d8 00 00 00         	addq	$216, %rsp
    bad3: 5b                           	popq	%rbx
    bad4: 5d                           	popq	%rbp
    bad5: 41 5c                        	popq	%r12
    bad7: 41 5d                        	popq	%r13
    bad9: 41 5e                        	popq	%r14
    badb: 41 5f                        	popq	%r15
    badd: c3                           	retq
    bade: 66 90                        	nop
; 			if (!get_map_field_int(map_name, btf, m, &map_def->map_type))
    bae0: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    bae5: 48 8d 4d 04                  	leaq	4(%rbp), %rcx
    bae9: 48 89 da                     	movq	%rbx, %rdx
    baec: 4c 89 ee                     	movq	%r13, %rsi
    baef: e8 ec fb ff ff               	callq	0xb6e0 <get_map_field_int>
    baf4: 84 c0                        	testb	%al, %al
    baf6: 0f 84 84 02 00 00            	je	0xbd80 <parse_btf_map_def+0x570>
; 			map_def->parts |= MAP_DEF_MAP_TYPE;
    bafc: 83 4d 00 01                  	orl	$1, (%rbp)
; 	for (i = 0; i < vlen; i++, m++) {
    bb00: 41 83 c4 01                  	addl	$1, %r12d
    bb04: 48 83 c3 0c                  	addq	$12, %rbx
    bb08: 44 39 64 24 18               	cmpl	%r12d, 24(%rsp)
    bb0d: 0f 85 5d fd ff ff            	jne	0xb870 <parse_btf_map_def+0x60>
    bb13: eb 93                        	jmp	0xbaa8 <parse_btf_map_def+0x298>
    bb15: 0f 1f 00                     	nopl	(%rax)
; 			if (!get_map_field_int(map_name, btf, m, &map_def->max_entries))
    bb18: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    bb1d: 48 8d 4d 18                  	leaq	24(%rbp), %rcx
    bb21: 48 89 da                     	movq	%rbx, %rdx
    bb24: 4c 89 ee                     	movq	%r13, %rsi
    bb27: e8 b4 fb ff ff               	callq	0xb6e0 <get_map_field_int>
    bb2c: 84 c0                        	testb	%al, %al
    bb2e: 0f 84 4c 02 00 00            	je	0xbd80 <parse_btf_map_def+0x570>
; 			map_def->parts |= MAP_DEF_MAX_ENTRIES;
    bb34: 83 4d 00 20                  	orl	$32, (%rbp)
    bb38: eb c6                        	jmp	0xbb00 <parse_btf_map_def+0x2f0>
    bb3a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			if (!get_map_field_int(map_name, btf, m, &map_def->map_flags))
    bb40: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    bb45: 48 8d 4d 1c                  	leaq	28(%rbp), %rcx
    bb49: 48 89 da                     	movq	%rbx, %rdx
    bb4c: 4c 89 ee                     	movq	%r13, %rsi
    bb4f: e8 8c fb ff ff               	callq	0xb6e0 <get_map_field_int>
    bb54: 84 c0                        	testb	%al, %al
    bb56: 0f 84 24 02 00 00            	je	0xbd80 <parse_btf_map_def+0x570>
; 			map_def->parts |= MAP_DEF_MAP_FLAGS;
    bb5c: 83 4d 00 40                  	orl	$64, (%rbp)
    bb60: eb 9e                        	jmp	0xbb00 <parse_btf_map_def+0x2f0>
    bb62: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			if (!get_map_field_int(map_name, btf, m, &map_def->numa_node))
    bb68: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    bb6d: 48 8d 4d 20                  	leaq	32(%rbp), %rcx
    bb71: 48 89 da                     	movq	%rbx, %rdx
    bb74: 4c 89 ee                     	movq	%r13, %rsi
    bb77: e8 64 fb ff ff               	callq	0xb6e0 <get_map_field_int>
    bb7c: 84 c0                        	testb	%al, %al
    bb7e: 0f 84 fc 01 00 00            	je	0xbd80 <parse_btf_map_def+0x570>
; 			map_def->parts |= MAP_DEF_NUMA_NODE;
    bb84: 81 4d 00 80 00 00 00         	orl	$128, (%rbp)
    bb8b: e9 70 ff ff ff               	jmp	0xbb00 <parse_btf_map_def+0x2f0>
; 			if (!get_map_field_int(map_name, btf, m, &sz))
    bb90: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    bb95: 48 8d 4c 24 3c               	leaq	60(%rsp), %rcx
    bb9a: 48 89 da                     	movq	%rbx, %rdx
    bb9d: 4c 89 ee                     	movq	%r13, %rsi
    bba0: e8 3b fb ff ff               	callq	0xb6e0 <get_map_field_int>
    bba5: 84 c0                        	testb	%al, %al
    bba7: 0f 84 d3 01 00 00            	je	0xbd80 <parse_btf_map_def+0x570>
; 			if (map_def->key_size && map_def->key_size != sz) {
    bbad: 8b 4d 0c                     	movl	12(%rbp), %ecx
    bbb0: 44 8b 44 24 3c               	movl	60(%rsp), %r8d
    bbb5: 85 c9                        	testl	%ecx, %ecx
    bbb7: 74 09                        	je	0xbbc2 <parse_btf_map_def+0x3b2>
    bbb9: 44 39 c1                     	cmpl	%r8d, %ecx
    bbbc: 0f 85 a8 01 00 00            	jne	0xbd6a <parse_btf_map_def+0x55a>
; 			map_def->parts |= MAP_DEF_KEY_SIZE;
    bbc2: 83 4d 00 04                  	orl	$4, (%rbp)
; 			map_def->key_size = sz;
    bbc6: 44 89 45 0c                  	movl	%r8d, 12(%rbp)
; 			map_def->parts |= MAP_DEF_KEY_SIZE;
    bbca: e9 31 ff ff ff               	jmp	0xbb00 <parse_btf_map_def+0x2f0>
    bbcf: 90                           	nop
; 			t = btf__type_by_id(btf, m->type);
    bbd0: 8b 73 04                     	movl	4(%rbx), %esi
    bbd3: 4c 89 ef                     	movq	%r13, %rdi
    bbd6: e8 c5 e3 01 00               	callq	0x29fa0 <btf__type_by_id>
    bbdb: 49 89 c7                     	movq	%rax, %r15
; 			if (!t) {
    bbde: 48 85 c0                     	testq	%rax, %rax
    bbe1: 0f 84 ca 02 00 00            	je	0xbeb1 <parse_btf_map_def+0x6a1>
; 	return BTF_INFO_KIND(t->info);
    bbe7: 0f b6 40 07                  	movzbl	7(%rax), %eax
    bbeb: 83 e0 1f                     	andl	$31, %eax
; 			if (!btf_is_ptr(t)) {
    bbee: 66 83 f8 02                  	cmpw	$2, %ax
    bbf2: 0f 85 04 03 00 00            	jne	0xbefc <parse_btf_map_def+0x6ec>
; 			sz = btf__resolve_size(btf, t->type);
    bbf8: 41 8b 77 08                  	movl	8(%r15), %esi
    bbfc: 4c 89 ef                     	movq	%r13, %rdi
    bbff: e8 bc f8 01 00               	callq	0x2b4c0 <btf__resolve_size>
; 			if (sz < 0) {
    bc04: 48 85 c0                     	testq	%rax, %rax
    bc07: 0f 88 c6 02 00 00            	js	0xbed3 <parse_btf_map_def+0x6c3>
; 			if (map_def->key_size && map_def->key_size != sz) {
    bc0d: 8b 4d 0c                     	movl	12(%rbp), %ecx
    bc10: 85 c9                        	testl	%ecx, %ecx
    bc12: 74 0b                        	je	0xbc1f <parse_btf_map_def+0x40f>
    bc14: 89 ce                        	movl	%ecx, %esi
    bc16: 48 39 c6                     	cmpq	%rax, %rsi
    bc19: 0f 85 e1 01 00 00            	jne	0xbe00 <parse_btf_map_def+0x5f0>
; 			map_def->key_size = sz;
    bc1f: 89 45 0c                     	movl	%eax, 12(%rbp)
; 			map_def->key_type_id = t->type;
    bc22: 41 8b 47 08                  	movl	8(%r15), %eax
; 			map_def->parts |= MAP_DEF_KEY_SIZE | MAP_DEF_KEY_TYPE;
    bc26: 83 4d 00 06                  	orl	$6, (%rbp)
; 			map_def->key_type_id = t->type;
    bc2a: 89 45 08                     	movl	%eax, 8(%rbp)
; 			map_def->parts |= MAP_DEF_KEY_SIZE | MAP_DEF_KEY_TYPE;
    bc2d: e9 ce fe ff ff               	jmp	0xbb00 <parse_btf_map_def+0x2f0>
    bc32: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		} else if (strcmp(name, "pinning") == 0) {
    bc38: 48 8d 35 f7 62 02 00         	leaq	156407(%rip), %rsi      # 0x31f36 <_IO_stdin_used+0x1f36>
    bc3f: 4c 89 ff                     	movq	%r15, %rdi
    bc42: e8 69 9d ff ff               	callq	0x59b0 <.plt.sec+0x340>
    bc47: 85 c0                        	testl	%eax, %eax
    bc49: 0f 85 3b 01 00 00            	jne	0xbd8a <parse_btf_map_def+0x57a>
; 			if (is_inner) {
    bc4f: 48 83 7c 24 10 00            	cmpq	$0, 16(%rsp)
    bc55: 0f 84 33 04 00 00            	je	0xc08e <parse_btf_map_def+0x87e>
; 			if (!get_map_field_int(map_name, btf, m, &val))
    bc5b: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    bc60: 48 8d 4c 24 3c               	leaq	60(%rsp), %rcx
    bc65: 48 89 da                     	movq	%rbx, %rdx
    bc68: 4c 89 ee                     	movq	%r13, %rsi
    bc6b: e8 70 fa ff ff               	callq	0xb6e0 <get_map_field_int>
    bc70: 84 c0                        	testb	%al, %al
    bc72: 0f 84 08 01 00 00            	je	0xbd80 <parse_btf_map_def+0x570>
; 			if (val != LIBBPF_PIN_NONE && val != LIBBPF_PIN_BY_NAME) {
    bc78: 8b 4c 24 3c                  	movl	60(%rsp), %ecx
    bc7c: 83 f9 01                     	cmpl	$1, %ecx
    bc7f: 0f 87 ef 03 00 00            	ja	0xc074 <parse_btf_map_def+0x864>
; 			map_def->parts |= MAP_DEF_PINNING;
    bc85: 81 4d 00 00 01 00 00         	orl	$256, (%rbp)            # imm = 0x100
; 			map_def->pinning = val;
    bc8c: 89 4d 24                     	movl	%ecx, 36(%rbp)
; 			map_def->parts |= MAP_DEF_PINNING;
    bc8f: e9 6c fe ff ff               	jmp	0xbb00 <parse_btf_map_def+0x2f0>
    bc94: 0f 1f 40 00                  	nopl	(%rax)
; 			if (!get_map_field_int(map_name, btf, m, &sz))
    bc98: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    bc9d: 48 8d 4c 24 3c               	leaq	60(%rsp), %rcx
    bca2: 48 89 da                     	movq	%rbx, %rdx
    bca5: 4c 89 ee                     	movq	%r13, %rsi
    bca8: e8 33 fa ff ff               	callq	0xb6e0 <get_map_field_int>
    bcad: 84 c0                        	testb	%al, %al
    bcaf: 0f 84 cb 00 00 00            	je	0xbd80 <parse_btf_map_def+0x570>
; 			if (map_def->value_size && map_def->value_size != sz) {
    bcb5: 8b 4d 14                     	movl	20(%rbp), %ecx
    bcb8: 44 8b 44 24 3c               	movl	60(%rsp), %r8d
    bcbd: 85 c9                        	testl	%ecx, %ecx
    bcbf: 74 09                        	je	0xbcca <parse_btf_map_def+0x4ba>
    bcc1: 44 39 c1                     	cmpl	%r8d, %ecx
    bcc4: 0f 85 77 01 00 00            	jne	0xbe41 <parse_btf_map_def+0x631>
; 			map_def->parts |= MAP_DEF_VALUE_SIZE;
    bcca: 83 4d 00 10                  	orl	$16, (%rbp)
; 			map_def->value_size = sz;
    bcce: 44 89 45 14                  	movl	%r8d, 20(%rbp)
; 			map_def->parts |= MAP_DEF_VALUE_SIZE;
    bcd2: e9 29 fe ff ff               	jmp	0xbb00 <parse_btf_map_def+0x2f0>
    bcd7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 			pr_warn("map '%s': invalid field #%d.\n", map_name, i);
    bce0: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bce5: 31 c0                        	xorl	%eax, %eax
    bce7: 44 89 e1                     	movl	%r12d, %ecx
    bcea: 31 ff                        	xorl	%edi, %edi
    bcec: 48 8d 35 ed 83 02 00         	leaq	164845(%rip), %rsi      # 0x340e0 <strs.2+0x1250>
    bcf3: e8 d8 c3 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
    bcf8: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bcfd: e9 b3 fd ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
    bd02: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			t = btf__type_by_id(btf, m->type);
    bd08: 8b 73 04                     	movl	4(%rbx), %esi
    bd0b: 4c 89 ef                     	movq	%r13, %rdi
    bd0e: e8 8d e2 01 00               	callq	0x29fa0 <btf__type_by_id>
    bd13: 49 89 c7                     	movq	%rax, %r15
; 			if (!t) {
    bd16: 48 85 c0                     	testq	%rax, %rax
    bd19: 0f 84 a0 02 00 00            	je	0xbfbf <parse_btf_map_def+0x7af>
; 	return BTF_INFO_KIND(t->info);
    bd1f: 0f b6 40 07                  	movzbl	7(%rax), %eax
    bd23: 83 e0 1f                     	andl	$31, %eax
; 			if (!btf_is_ptr(t)) {
    bd26: 66 83 f8 02                  	cmpw	$2, %ax
    bd2a: 0f 85 3c 02 00 00            	jne	0xbf6c <parse_btf_map_def+0x75c>
; 			sz = btf__resolve_size(btf, t->type);
    bd30: 41 8b 77 08                  	movl	8(%r15), %esi
    bd34: 4c 89 ef                     	movq	%r13, %rdi
    bd37: e8 84 f7 01 00               	callq	0x2b4c0 <btf__resolve_size>
; 			if (sz < 0) {
    bd3c: 48 85 c0                     	testq	%rax, %rax
    bd3f: 0f 88 51 02 00 00            	js	0xbf96 <parse_btf_map_def+0x786>
; 			if (map_def->value_size && map_def->value_size != sz) {
    bd45: 8b 4d 14                     	movl	20(%rbp), %ecx
    bd48: 85 c9                        	testl	%ecx, %ecx
    bd4a: 74 0b                        	je	0xbd57 <parse_btf_map_def+0x547>
    bd4c: 89 ce                        	movl	%ecx, %esi
    bd4e: 48 39 c6                     	cmpq	%rax, %rsi
    bd51: 0f 85 04 01 00 00            	jne	0xbe5b <parse_btf_map_def+0x64b>
; 			map_def->value_size = sz;
    bd57: 89 45 14                     	movl	%eax, 20(%rbp)
; 			map_def->value_type_id = t->type;
    bd5a: 41 8b 47 08                  	movl	8(%r15), %eax
; 			map_def->parts |= MAP_DEF_VALUE_SIZE | MAP_DEF_VALUE_TYPE;
    bd5e: 83 4d 00 18                  	orl	$24, (%rbp)
; 			map_def->value_type_id = t->type;
    bd62: 89 45 10                     	movl	%eax, 16(%rbp)
; 			map_def->parts |= MAP_DEF_VALUE_SIZE | MAP_DEF_VALUE_TYPE;
    bd65: e9 96 fd ff ff               	jmp	0xbb00 <parse_btf_map_def+0x2f0>
; 				pr_warn("map '%s': conflicting key size %u != %u.\n",
    bd6a: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bd6f: 48 8d 35 92 83 02 00         	leaq	164754(%rip), %rsi      # 0x34108 <strs.2+0x1278>
    bd76: 31 ff                        	xorl	%edi, %edi
    bd78: 31 c0                        	xorl	%eax, %eax
    bd7a: e8 51 c3 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    bd7f: 90                           	nop
; 		return -EINVAL;
    bd80: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bd85: e9 2b fd ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 		} else if (strcmp(name, "map_extra") == 0) {
    bd8a: 48 8d 35 ad 61 02 00         	leaq	156077(%rip), %rsi      # 0x31f3e <_IO_stdin_used+0x1f3e>
    bd91: 4c 89 ff                     	movq	%r15, %rdi
    bd94: e8 17 9c ff ff               	callq	0x59b0 <.plt.sec+0x340>
    bd99: 85 c0                        	testl	%eax, %eax
    bd9b: 0f 84 df 00 00 00            	je	0xbe80 <parse_btf_map_def+0x670>
; 			if (strict) {
    bda1: 80 7c 24 1f 00               	cmpb	$0, 31(%rsp)
; 				pr_warn("map '%s': unknown field '%s'.\n", map_name, name);
    bda6: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bdab: 4c 89 f9                     	movq	%r15, %rcx
; 			if (strict) {
    bdae: 0f 85 1c 03 00 00            	jne	0xc0d0 <parse_btf_map_def+0x8c0>
; 			pr_debug("map '%s': ignoring unknown field '%s'.\n", map_name, name);
    bdb4: 48 8d 35 0d 88 02 00         	leaq	165901(%rip), %rsi      # 0x345c8 <strs.2+0x1738>
    bdbb: bf 02 00 00 00               	movl	$2, %edi
    bdc0: 31 c0                        	xorl	%eax, %eax
    bdc2: e8 09 c3 ff ff               	callq	0x80d0 <libbpf_print>
    bdc7: e9 34 fd ff ff               	jmp	0xbb00 <parse_btf_map_def+0x2f0>
; 				if (!btf_is_func_proto(t)) {
    bdcc: 66 83 f8 0d                  	cmpw	$13, %ax
    bdd0: 0f 84 2a fd ff ff            	je	0xbb00 <parse_btf_map_def+0x2f0>
; 	return __btf_kind_str(btf_kind(t));
    bdd6: 0f b7 f8                     	movzwl	%ax, %edi
; 					pr_warn("map '%s': prog-array value def is of unexpected kind %s.\n",
    bdd9: 48 8d 35 d0 86 02 00         	leaq	165584(%rip), %rsi      # 0x344b0 <strs.2+0x1620>
; 	return __btf_kind_str(btf_kind(t));
    bde0: e8 ab a5 ff ff               	callq	0x6390 <__btf_kind_str>
; 					pr_warn("map '%s': prog-array value def is of unexpected kind %s.\n",
    bde5: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bdea: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
    bdec: 48 89 c1                     	movq	%rax, %rcx
; 					pr_warn("map '%s': prog-array value def is of unexpected kind %s.\n",
    bdef: 31 c0                        	xorl	%eax, %eax
    bdf1: e8 da c2 ff ff               	callq	0x80d0 <libbpf_print>
; 					return -EINVAL;
    bdf6: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bdfb: e9 b5 fc ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': conflicting key size %u != %zd.\n",
    be00: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    be05: 49 89 c0                     	movq	%rax, %r8
    be08: 48 8d 35 d1 83 02 00         	leaq	164817(%rip), %rsi      # 0x341e0 <strs.2+0x1350>
    be0f: 31 c0                        	xorl	%eax, %eax
    be11: 31 ff                        	xorl	%edi, %edi
    be13: e8 b8 c2 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    be18: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    be1d: e9 93 fc ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': should be map-in-map or prog-array.\n",
    be22: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    be27: 31 c0                        	xorl	%eax, %eax
    be29: 48 8d 35 70 85 02 00         	leaq	165232(%rip), %rsi      # 0x343a0 <strs.2+0x1510>
    be30: 31 ff                        	xorl	%edi, %edi
    be32: e8 99 c2 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -ENOTSUP;
    be37: b8 a1 ff ff ff               	movl	$4294967201, %eax       # imm = 0xFFFFFFA1
    be3c: e9 74 fc ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': conflicting value size %u != %u.\n",
    be41: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    be46: 48 8d 35 cb 83 02 00         	leaq	164811(%rip), %rsi      # 0x34218 <strs.2+0x1388>
    be4d: 31 ff                        	xorl	%edi, %edi
    be4f: 31 c0                        	xorl	%eax, %eax
    be51: e8 7a c2 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    be56: e9 25 ff ff ff               	jmp	0xbd80 <parse_btf_map_def+0x570>
; 				pr_warn("map '%s': conflicting value size %u != %zd.\n",
    be5b: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    be60: 49 89 c0                     	movq	%rax, %r8
    be63: 48 8d 35 8e 84 02 00         	leaq	165006(%rip), %rsi      # 0x342f8 <strs.2+0x1468>
    be6a: 31 c0                        	xorl	%eax, %eax
    be6c: 31 ff                        	xorl	%edi, %edi
    be6e: e8 5d c2 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    be73: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    be78: e9 38 fc ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
    be7d: 0f 1f 00                     	nopl	(%rax)
; 			if (!get_map_field_int(map_name, btf, m, &map_extra))
    be80: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    be85: 48 8d 4c 24 3c               	leaq	60(%rsp), %rcx
    be8a: 48 89 da                     	movq	%rbx, %rdx
    be8d: 4c 89 ee                     	movq	%r13, %rsi
    be90: e8 4b f8 ff ff               	callq	0xb6e0 <get_map_field_int>
    be95: 84 c0                        	testb	%al, %al
    be97: 0f 84 e3 fe ff ff            	je	0xbd80 <parse_btf_map_def+0x570>
; 			map_def->map_extra = map_extra;
    be9d: 8b 44 24 3c                  	movl	60(%rsp), %eax
; 			map_def->parts |= MAP_DEF_MAP_EXTRA;
    bea1: 81 4d 00 00 04 00 00         	orl	$1024, (%rbp)           # imm = 0x400
; 			map_def->map_extra = map_extra;
    bea8: 48 89 45 28                  	movq	%rax, 40(%rbp)
; 			map_def->parts |= MAP_DEF_MAP_EXTRA;
    beac: e9 4f fc ff ff               	jmp	0xbb00 <parse_btf_map_def+0x2f0>
; 				pr_warn("map '%s': key type [%d] not found.\n",
    beb1: 8b 4b 04                     	movl	4(%rbx), %ecx
    beb4: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    beb9: 31 c0                        	xorl	%eax, %eax
    bebb: 31 ff                        	xorl	%edi, %edi
    bebd: 48 8d 35 7c 82 02 00         	leaq	164476(%rip), %rsi      # 0x34140 <strs.2+0x12b0>
    bec4: e8 07 c2 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    bec9: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bece: e9 e2 fb ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': can't determine key size for type [%u]: %zd.\n",
    bed3: 4c 89 fa                     	movq	%r15, %rdx
    bed6: 49 89 c0                     	movq	%rax, %r8
    bed9: 49 89 c7                     	movq	%rax, %r15
    bedc: 31 ff                        	xorl	%edi, %edi
    bede: 8b 4a 08                     	movl	8(%rdx), %ecx
    bee1: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bee6: 31 c0                        	xorl	%eax, %eax
    bee8: 48 8d 35 b1 82 02 00         	leaq	164529(%rip), %rsi      # 0x341a0 <strs.2+0x1310>
    beef: e8 dc c1 ff ff               	callq	0x80d0 <libbpf_print>
; 				return sz;
    bef4: 44 89 f8                     	movl	%r15d, %eax
    bef7: e9 b9 fb ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 	return __btf_kind_str(btf_kind(t));
    befc: 0f b7 f8                     	movzwl	%ax, %edi
; 				pr_warn("map '%s': key spec is not PTR: %s.\n",
    beff: 48 8d 35 6a 82 02 00         	leaq	164458(%rip), %rsi      # 0x34170 <strs.2+0x12e0>
; 	return __btf_kind_str(btf_kind(t));
    bf06: e8 85 a4 ff ff               	callq	0x6390 <__btf_kind_str>
; 				pr_warn("map '%s': key spec is not PTR: %s.\n",
    bf0b: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bf10: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
    bf12: 48 89 c1                     	movq	%rax, %rcx
; 				pr_warn("map '%s': key spec is not PTR: %s.\n",
    bf15: 31 c0                        	xorl	%eax, %eax
    bf17: e8 b4 c1 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    bf1c: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bf21: e9 8f fb ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': %s spec is not a zero-sized array.\n",
    bf26: 48 8b 4c 24 28               	movq	40(%rsp), %rcx
    bf2b: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bf30: 31 c0                        	xorl	%eax, %eax
    bf32: 31 ff                        	xorl	%edi, %edi
    bf34: 48 8d 35 05 85 02 00         	leaq	165125(%rip), %rsi      # 0x34440 <strs.2+0x15b0>
    bf3b: e8 90 c1 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    bf40: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bf45: e9 6b fb ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': '%s' member should be last.\n",
    bf4a: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bf4f: 31 c0                        	xorl	%eax, %eax
    bf51: 4c 89 f9                     	movq	%r15, %rcx
    bf54: 31 ff                        	xorl	%edi, %edi
    bf56: 48 8d 35 13 84 02 00         	leaq	164883(%rip), %rsi      # 0x34370 <strs.2+0x14e0>
    bf5d: e8 6e c1 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    bf62: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bf67: e9 49 fb ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 	return __btf_kind_str(btf_kind(t));
    bf6c: 0f b7 f8                     	movzwl	%ax, %edi
; 				pr_warn("map '%s': value spec is not PTR: %s.\n",
    bf6f: 48 8d 35 0a 83 02 00         	leaq	164618(%rip), %rsi      # 0x34280 <strs.2+0x13f0>
; 	return __btf_kind_str(btf_kind(t));
    bf76: e8 15 a4 ff ff               	callq	0x6390 <__btf_kind_str>
; 				pr_warn("map '%s': value spec is not PTR: %s.\n",
    bf7b: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bf80: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
    bf82: 48 89 c1                     	movq	%rax, %rcx
; 				pr_warn("map '%s': value spec is not PTR: %s.\n",
    bf85: 31 c0                        	xorl	%eax, %eax
    bf87: e8 44 c1 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    bf8c: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bf91: e9 1f fb ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': can't determine value size for type [%u]: %zd.\n",
    bf96: 4c 89 fa                     	movq	%r15, %rdx
    bf99: 49 89 c0                     	movq	%rax, %r8
    bf9c: 49 89 c7                     	movq	%rax, %r15
    bf9f: 31 ff                        	xorl	%edi, %edi
    bfa1: 8b 4a 08                     	movl	8(%rdx), %ecx
    bfa4: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bfa9: 31 c0                        	xorl	%eax, %eax
    bfab: 48 8d 35 fe 82 02 00         	leaq	164606(%rip), %rsi      # 0x342b0 <strs.2+0x1420>
    bfb2: e8 19 c1 ff ff               	callq	0x80d0 <libbpf_print>
; 				return sz;
    bfb7: 44 89 f8                     	movl	%r15d, %eax
    bfba: e9 f6 fa ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': value type [%d] not found.\n",
    bfbf: 8b 4b 04                     	movl	4(%rbx), %ecx
    bfc2: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bfc7: 31 c0                        	xorl	%eax, %eax
    bfc9: 31 ff                        	xorl	%edi, %edi
    bfcb: 48 8d 35 7e 82 02 00         	leaq	164478(%rip), %rsi      # 0x34250 <strs.2+0x13c0>
    bfd2: e8 f9 c0 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    bfd7: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bfdc: e9 d4 fa ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': conflicting value size %u != 4.\n",
    bfe1: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    bfe6: 31 c0                        	xorl	%eax, %eax
    bfe8: 48 8d 35 e9 83 02 00         	leaq	164841(%rip), %rsi      # 0x343d8 <strs.2+0x1548>
    bfef: 31 ff                        	xorl	%edi, %edi
    bff1: e8 da c0 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    bff6: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    bffb: e9 b5 fa ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': %s type [%d] not found.\n",
    c000: 44 8b 43 04                  	movl	4(%rbx), %r8d
    c004: 48 8b 4c 24 28               	movq	40(%rsp), %rcx
    c009: 48 8d 35 00 84 02 00         	leaq	164864(%rip), %rsi      # 0x34410 <strs.2+0x1580>
    c010: 31 ff                        	xorl	%edi, %edi
    c012: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    c017: e8 b4 c0 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    c01c: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    c021: e9 8f fa ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': multi-level inner maps not supported.\n",
    c026: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    c02b: 31 c0                        	xorl	%eax, %eax
    c02d: 48 8d 35 fc 82 02 00         	leaq	164604(%rip), %rsi      # 0x34330 <strs.2+0x14a0>
    c034: 31 ff                        	xorl	%edi, %edi
    c036: e8 95 c0 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -ENOTSUP;
    c03b: b8 a1 ff ff ff               	movl	$4294967201, %eax       # imm = 0xFFFFFFA1
    c040: e9 70 fa ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 	return __btf_kind_str(btf_kind(t));
    c045: 0f b7 fa                     	movzwl	%dx, %edi
; 				pr_warn("map '%s': %s def is of unexpected kind %s.\n",
    c048: 48 8d 35 29 84 02 00         	leaq	164905(%rip), %rsi      # 0x34478 <strs.2+0x15e8>
; 	return __btf_kind_str(btf_kind(t));
    c04f: e8 3c a3 ff ff               	callq	0x6390 <__btf_kind_str>
; 				pr_warn("map '%s': %s def is of unexpected kind %s.\n",
    c054: 48 8b 4c 24 28               	movq	40(%rsp), %rcx
    c059: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    c05e: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
    c060: 49 89 c0                     	movq	%rax, %r8
; 				pr_warn("map '%s': %s def is of unexpected kind %s.\n",
    c063: 31 c0                        	xorl	%eax, %eax
    c065: e8 66 c0 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    c06a: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    c06f: e9 41 fa ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': invalid pinning value %u.\n",
    c074: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    c079: 48 8d 35 f0 84 02 00         	leaq	165104(%rip), %rsi      # 0x34570 <strs.2+0x16e0>
    c080: 31 ff                        	xorl	%edi, %edi
    c082: 31 c0                        	xorl	%eax, %eax
    c084: e8 47 c0 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    c089: e9 f2 fc ff ff               	jmp	0xbd80 <parse_btf_map_def+0x570>
; 				pr_warn("map '%s': inner def can't be pinned.\n", map_name);
    c08e: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    c093: 48 8d 35 a6 84 02 00         	leaq	165030(%rip), %rsi      # 0x34540 <strs.2+0x16b0>
    c09a: 31 ff                        	xorl	%edi, %edi
    c09c: e8 2f c0 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    c0a1: e9 da fc ff ff               	jmp	0xbd80 <parse_btf_map_def+0x570>
; 	return __btf_kind_str(btf_kind(t));
    c0a6: 0f b7 f8                     	movzwl	%ax, %edi
; 				pr_warn("map '%s': map-in-map inner def is of unexpected kind %s.\n",
    c0a9: 48 8d 35 48 84 02 00         	leaq	164936(%rip), %rsi      # 0x344f8 <strs.2+0x1668>
; 	return __btf_kind_str(btf_kind(t));
    c0b0: e8 db a2 ff ff               	callq	0x6390 <__btf_kind_str>
; 				pr_warn("map '%s': map-in-map inner def is of unexpected kind %s.\n",
    c0b5: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    c0ba: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
    c0bc: 48 89 c1                     	movq	%rax, %rcx
; 				pr_warn("map '%s': map-in-map inner def is of unexpected kind %s.\n",
    c0bf: 31 c0                        	xorl	%eax, %eax
    c0c1: e8 0a c0 ff ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
    c0c6: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    c0cb: e9 e5 f9 ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 				pr_warn("map '%s': unknown field '%s'.\n", map_name, name);
    c0d0: 31 c0                        	xorl	%eax, %eax
    c0d2: 48 8d 35 c7 84 02 00         	leaq	165063(%rip), %rsi      # 0x345a0 <strs.2+0x1710>
    c0d9: 31 ff                        	xorl	%edi, %edi
    c0db: e8 f0 bf ff ff               	callq	0x80d0 <libbpf_print>
; 				return -ENOTSUP;
    c0e0: b8 a1 ff ff ff               	movl	$4294967201, %eax       # imm = 0xFFFFFFA1
    c0e5: e9 cb f9 ff ff               	jmp	0xbab5 <parse_btf_map_def+0x2a5>
; 		pr_warn("map '%s': map type isn't specified.\n", map_name);
    c0ea: 48 8b 54 24 08               	movq	8(%rsp), %rdx
    c0ef: 48 8d 35 02 85 02 00         	leaq	165122(%rip), %rsi      # 0x345f8 <strs.2+0x1768>
    c0f6: 31 ff                        	xorl	%edi, %edi
    c0f8: 31 c0                        	xorl	%eax, %eax
    c0fa: e8 d1 bf ff ff               	callq	0x80d0 <libbpf_print>
    c0ff: e9 7c fc ff ff               	jmp	0xbd80 <parse_btf_map_def+0x570>
; }
    c104: e8 f7 96 ff ff               	callq	0x5800 <.plt.sec+0x190>
    c109: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000c110 <bpf_map__autocreate>:
; {
    c110: f3 0f 1e fa                  	endbr64
; 	return map->autocreate;
    c114: 0f b6 87 92 00 00 00         	movzbl	146(%rdi), %eax
; }
    c11b: c3                           	retq
    c11c: 0f 1f 40 00                  	nopl	(%rax)

000000000000c120 <bpf_map__set_autocreate>:
; {
    c120: f3 0f 1e fa                  	endbr64
; 	if (map->obj->loaded)
    c124: 48 8b 07                     	movq	(%rdi), %rax
    c127: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    c12e: 75 0a                        	jne	0xc13a <bpf_map__set_autocreate+0x1a>
; 	map->autocreate = autocreate;
    c130: 40 88 b7 92 00 00 00         	movb	%sil, 146(%rdi)
; 	return 0;
    c137: 31 c0                        	xorl	%eax, %eax
; }
    c139: c3                           	retq
; {
    c13a: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
    c13e: e8 ad 95 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    c143: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
    c149: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
    c14e: 48 83 c4 08                  	addq	$8, %rsp
    c152: c3                           	retq
    c153: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    c15e: 66 90                        	nop

000000000000c160 <bpf_map__reuse_fd>:
; {
    c160: f3 0f 1e fa                  	endbr64
    c164: 41 56                        	pushq	%r14
;   return __builtin___memset_chk (__dest, __ch, __len,
    c166: b9 0b 00 00 00               	movl	$11, %ecx
; {
    c16b: 41 55                        	pushq	%r13
    c16d: 41 89 f5                     	movl	%esi, %r13d
    c170: 41 54                        	pushq	%r12
    c172: 55                           	pushq	%rbp
    c173: 53                           	pushq	%rbx
    c174: 48 89 fb                     	movq	%rdi, %rbx
    c177: 48 83 ec 70                  	subq	$112, %rsp
    c17b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    c184: 48 89 44 24 68               	movq	%rax, 104(%rsp)
    c189: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
    c18b: 48 8d 6c 24 10               	leaq	16(%rsp), %rbp
; 	err = bpf_obj_get_info_by_fd(fd, &info, &len);
    c190: 48 8d 54 24 0c               	leaq	12(%rsp), %rdx
; 	__u32 len = sizeof(info), name_len;
    c195: c7 44 24 0c 58 00 00 00      	movl	$88, 12(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    c19d: 48 89 ef                     	movq	%rbp, %rdi
; 	err = bpf_obj_get_info_by_fd(fd, &info, &len);
    c1a0: 48 89 ee                     	movq	%rbp, %rsi
;   return __builtin___memset_chk (__dest, __ch, __len,
    c1a3: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	err = bpf_obj_get_info_by_fd(fd, &info, &len);
    c1a6: 44 89 ef                     	movl	%r13d, %edi
    c1a9: e8 12 ba 01 00               	callq	0x27bc0 <bpf_obj_get_info_by_fd>
; 	if (err && errno == EINVAL)
    c1ae: 85 c0                        	testl	%eax, %eax
    c1b0: 74 58                        	je	0xc20a <bpf_map__reuse_fd+0xaa>
    c1b2: 41 89 c4                     	movl	%eax, %r12d
    c1b5: e8 36 95 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    c1ba: 83 38 16                     	cmpl	$22, (%rax)
    c1bd: 49 89 c6                     	movq	%rax, %r14
    c1c0: 74 36                        	je	0xc1f8 <bpf_map__reuse_fd+0x98>
; 	if (ret < 0)
    c1c2: 45 85 e4                     	testl	%r12d, %r12d
    c1c5: 79 09                        	jns	0xc1d0 <bpf_map__reuse_fd+0x70>
; 		errno = -ret;
    c1c7: 44 89 e0                     	movl	%r12d, %eax
    c1ca: f7 d8                        	negl	%eax
    c1cc: 41 89 06                     	movl	%eax, (%r14)
    c1cf: 90                           	nop
; }
    c1d0: 48 8b 44 24 68               	movq	104(%rsp), %rax
    c1d5: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    c1de: 0f 85 5c 01 00 00            	jne	0xc340 <bpf_map__reuse_fd+0x1e0>
    c1e4: 48 83 c4 70                  	addq	$112, %rsp
    c1e8: 44 89 e0                     	movl	%r12d, %eax
    c1eb: 5b                           	popq	%rbx
    c1ec: 5d                           	popq	%rbp
    c1ed: 41 5c                        	popq	%r12
    c1ef: 41 5d                        	popq	%r13
    c1f1: 41 5e                        	popq	%r14
    c1f3: c3                           	retq
    c1f4: 0f 1f 40 00                  	nopl	(%rax)
; 		err = bpf_get_map_info_from_fdinfo(fd, &info);
    c1f8: 48 89 ee                     	movq	%rbp, %rsi
    c1fb: 44 89 ef                     	movl	%r13d, %edi
    c1fe: e8 bd bf ff ff               	callq	0x81c0 <bpf_get_map_info_from_fdinfo>
    c203: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
    c206: 85 c0                        	testl	%eax, %eax
    c208: 75 b8                        	jne	0xc1c2 <bpf_map__reuse_fd+0x62>
; 	name_len = strlen(info.name);
    c20a: 48 8d 6c 24 28               	leaq	40(%rsp), %rbp
    c20f: 48 89 ef                     	movq	%rbp, %rdi
    c212: e8 c9 95 ff ff               	callq	0x57e0 <.plt.sec+0x170>
; 	if (name_len == BPF_OBJ_NAME_LEN - 1 && strncmp(map->name, info.name, name_len) == 0)
    c217: 48 83 f8 0f                  	cmpq	$15, %rax
    c21b: 75 1c                        	jne	0xc239 <bpf_map__reuse_fd+0xd9>
    c21d: 4c 8b 63 08                  	movq	8(%rbx), %r12
    c221: ba 0f 00 00 00               	movl	$15, %edx
    c226: 48 89 ee                     	movq	%rbp, %rsi
    c229: 4c 89 e7                     	movq	%r12, %rdi
    c22c: e8 ef 94 ff ff               	callq	0x5720 <.plt.sec+0xb0>
    c231: 85 c0                        	testl	%eax, %eax
    c233: 0f 84 f7 00 00 00            	je	0xc330 <bpf_map__reuse_fd+0x1d0>
; 		new_name = strdup(info.name);
    c239: 48 89 ef                     	movq	%rbp, %rdi
    c23c: e8 cf 99 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
    c241: 48 89 c5                     	movq	%rax, %rbp
; 	if (!new_name)
    c244: 48 85 ed                     	testq	%rbp, %rbp
    c247: 0f 84 f8 00 00 00            	je	0xc345 <bpf_map__reuse_fd+0x1e5>
;       return __open_alias (__path, __oflag, __va_arg_pack ());
    c24d: be 00 00 08 00               	movl	$524288, %esi           # imm = 0x80000
    c252: 48 8d 3d 38 5f 02 00         	leaq	155448(%rip), %rdi      # 0x32191 <_IO_stdin_used+0x2191>
    c259: 31 c0                        	xorl	%eax, %eax
    c25b: e8 00 99 ff ff               	callq	0x5b60 <.plt.sec+0x4f0>
    c260: 89 c6                        	movl	%eax, %esi
; 	if (new_fd < 0) {
    c262: 85 c0                        	testl	%eax, %eax
    c264: 78 4a                        	js	0xc2b0 <bpf_map__reuse_fd+0x150>
; 	new_fd = dup3(fd, new_fd, O_CLOEXEC);
    c266: 44 89 ef                     	movl	%r13d, %edi
    c269: ba 00 00 08 00               	movl	$524288, %edx           # imm = 0x80000
    c26e: e8 3d 95 ff ff               	callq	0x57b0 <.plt.sec+0x140>
    c273: 41 89 c5                     	movl	%eax, %r13d
; 	if (new_fd < 0) {
    c276: 85 c0                        	testl	%eax, %eax
    c278: 78 17                        	js	0xc291 <bpf_map__reuse_fd+0x131>
; 	err = zclose(map->fd);
    c27a: 8b 7b 18                     	movl	24(%rbx), %edi
    c27d: 85 ff                        	testl	%edi, %edi
    c27f: 78 5f                        	js	0xc2e0 <bpf_map__reuse_fd+0x180>
    c281: e8 7a 96 ff ff               	callq	0x5900 <.plt.sec+0x290>
    c286: c7 43 18 ff ff ff ff         	movl	$4294967295, 24(%rbx)   # imm = 0xFFFFFFFF
; 	if (err) {
    c28d: 85 c0                        	testl	%eax, %eax
    c28f: 74 4f                        	je	0xc2e0 <bpf_map__reuse_fd+0x180>
; 		err = -errno;
    c291: e8 5a 94 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	close(new_fd);
    c296: 44 89 ef                     	movl	%r13d, %edi
; 		err = -errno;
    c299: 44 8b 20                     	movl	(%rax), %r12d
    c29c: 41 f7 dc                     	negl	%r12d
; 	close(new_fd);
    c29f: e8 5c 96 ff ff               	callq	0x5900 <.plt.sec+0x290>
    c2a4: eb 15                        	jmp	0xc2bb <bpf_map__reuse_fd+0x15b>
    c2a6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		err = -errno;
    c2b0: e8 3b 94 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    c2b5: 44 8b 20                     	movl	(%rax), %r12d
    c2b8: 41 f7 dc                     	negl	%r12d
; 	free(new_name);
    c2bb: 48 89 ef                     	movq	%rbp, %rdi
    c2be: e8 fd 93 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (ret < 0)
    c2c3: 45 85 e4                     	testl	%r12d, %r12d
    c2c6: 0f 89 04 ff ff ff            	jns	0xc1d0 <bpf_map__reuse_fd+0x70>
; 		errno = -ret;
    c2cc: e8 1f 94 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    c2d1: 44 89 e2                     	movl	%r12d, %edx
    c2d4: f7 da                        	negl	%edx
    c2d6: 89 10                        	movl	%edx, (%rax)
    c2d8: e9 f3 fe ff ff               	jmp	0xc1d0 <bpf_map__reuse_fd+0x70>
    c2dd: 0f 1f 00                     	nopl	(%rax)
; 	free(map->name);
    c2e0: 48 8b 7b 08                  	movq	8(%rbx), %rdi
; 	return 0;
    c2e4: 45 31 e4                     	xorl	%r12d, %r12d
; 	free(map->name);
    c2e7: e8 d4 93 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	map->def.type = info.type;
    c2ec: 8b 44 24 10                  	movl	16(%rsp), %eax
; 	map->fd = new_fd;
    c2f0: 44 89 6b 18                  	movl	%r13d, 24(%rbx)
; 	map->name = new_name;
    c2f4: 48 89 6b 08                  	movq	%rbp, 8(%rbx)
; 	map->def.type = info.type;
    c2f8: 89 43 30                     	movl	%eax, 48(%rbx)
; 	map->def.key_size = info.key_size;
    c2fb: 48 8b 44 24 18               	movq	24(%rsp), %rax
; 	map->reused = true;
    c300: c6 83 91 00 00 00 01         	movb	$1, 145(%rbx)
; 	map->def.key_size = info.key_size;
    c307: 48 89 43 34                  	movq	%rax, 52(%rbx)
; 	map->def.max_entries = info.max_entries;
    c30b: 48 8b 44 24 20               	movq	32(%rsp), %rax
    c310: 48 89 43 3c                  	movq	%rax, 60(%rbx)
; 	map->btf_key_type_id = info.btf_key_type_id;
    c314: 48 8b 44 24 54               	movq	84(%rsp), %rax
    c319: 48 89 43 4c                  	movq	%rax, 76(%rbx)
; 	map->map_extra = info.map_extra;
    c31d: 48 8b 44 24 60               	movq	96(%rsp), %rax
    c322: 48 89 83 98 00 00 00         	movq	%rax, 152(%rbx)
; 	return 0;
    c329: e9 a2 fe ff ff               	jmp	0xc1d0 <bpf_map__reuse_fd+0x70>
    c32e: 66 90                        	nop
; 		new_name = strdup(map->name);
    c330: 4c 89 e7                     	movq	%r12, %rdi
    c333: e8 d8 98 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
    c338: 48 89 c5                     	movq	%rax, %rbp
    c33b: e9 04 ff ff ff               	jmp	0xc244 <bpf_map__reuse_fd+0xe4>
; }
    c340: e8 bb 94 ff ff               	callq	0x5800 <.plt.sec+0x190>
; 		return libbpf_err(-errno);
    c345: e8 a6 93 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    c34a: 8b 00                        	movl	(%rax), %eax
    c34c: 41 89 c4                     	movl	%eax, %r12d
    c34f: 41 f7 dc                     	negl	%r12d
; 	if (ret < 0)
    c352: 85 c0                        	testl	%eax, %eax
    c354: 0f 8e 76 fe ff ff            	jle	0xc1d0 <bpf_map__reuse_fd+0x70>
    c35a: 44 89 e7                     	movl	%r12d, %edi
    c35d: e8 0e af ff ff               	callq	0x7270 <libbpf_err.part.0>
    c362: e9 69 fe ff ff               	jmp	0xc1d0 <bpf_map__reuse_fd+0x70>
    c367: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000000c370 <bpf_map__max_entries>:
; {
    c370: f3 0f 1e fa                  	endbr64
; 	return map->def.max_entries;
    c374: 8b 47 3c                     	movl	60(%rdi), %eax
; }
    c377: c3                           	retq
    c378: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000000c380 <bpf_map__inner_map>:
; {
    c380: f3 0f 1e fa                  	endbr64
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
    c384: 8b 47 30                     	movl	48(%rdi), %eax
    c387: 83 e8 0c                     	subl	$12, %eax
    c38a: 83 f8 01                     	cmpl	$1, %eax
    c38d: 76 19                        	jbe	0xc3a8 <bpf_map__inner_map+0x28>
; {
    c38f: 48 83 ec 08                  	subq	$8, %rsp
; 		return errno = EINVAL, NULL;
    c393: e8 58 93 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    c398: c7 00 16 00 00 00            	movl	$22, (%rax)
    c39e: 31 c0                        	xorl	%eax, %eax
; }
    c3a0: 48 83 c4 08                  	addq	$8, %rsp
    c3a4: c3                           	retq
    c3a5: 0f 1f 00                     	nopl	(%rax)
; 	return map->inner_map;
    c3a8: 48 8b 47 70                  	movq	112(%rdi), %rax
; }
    c3ac: c3                           	retq
    c3ad: 0f 1f 00                     	nopl	(%rax)

000000000000c3b0 <bpf_map__set_max_entries>:
; {
    c3b0: f3 0f 1e fa                  	endbr64
    c3b4: 41 54                        	pushq	%r12
    c3b6: 53                           	pushq	%rbx
    c3b7: 48 83 ec 08                  	subq	$8, %rsp
; 	if (map->obj->loaded)
    c3bb: 48 8b 07                     	movq	(%rdi), %rax
    c3be: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    c3c5: 75 36                        	jne	0xc3fd <bpf_map__set_max_entries+0x4d>
; 	return 0;
    c3c7: 45 31 e4                     	xorl	%r12d, %r12d
; 	if (map->def.type == BPF_MAP_TYPE_RINGBUF)
    c3ca: 83 7f 30 1b                  	cmpl	$27, 48(%rdi)
; 	map->def.max_entries = max_entries;
    c3ce: 89 77 3c                     	movl	%esi, 60(%rdi)
    c3d1: 48 89 fb                     	movq	%rdi, %rbx
; 	if (map->def.type == BPF_MAP_TYPE_RINGBUF)
    c3d4: 74 12                        	je	0xc3e8 <bpf_map__set_max_entries+0x38>
; }
    c3d6: 48 83 c4 08                  	addq	$8, %rsp
    c3da: 44 89 e0                     	movl	%r12d, %eax
    c3dd: 5b                           	popq	%rbx
    c3de: 41 5c                        	popq	%r12
    c3e0: c3                           	retq
    c3e1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		map->def.max_entries = adjust_ringbuf_sz(map->def.max_entries);
    c3e8: 89 f7                        	movl	%esi, %edi
    c3ea: e8 51 a3 ff ff               	callq	0x6740 <adjust_ringbuf_sz>
    c3ef: 89 43 3c                     	movl	%eax, 60(%rbx)
; }
    c3f2: 48 83 c4 08                  	addq	$8, %rsp
    c3f6: 44 89 e0                     	movl	%r12d, %eax
    c3f9: 5b                           	popq	%rbx
    c3fa: 41 5c                        	popq	%r12
    c3fc: c3                           	retq
; 		errno = -ret;
    c3fd: e8 ee 92 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EBUSY);
    c402: 41 bc f0 ff ff ff            	movl	$4294967280, %r12d      # imm = 0xFFFFFFF0
; 		errno = -ret;
    c408: c7 00 10 00 00 00            	movl	$16, (%rax)
    c40e: eb c6                        	jmp	0xc3d6 <bpf_map__set_max_entries+0x26>

000000000000c410 <kernel_supports>:
; {
    c410: f3 0f 1e fa                  	endbr64
; 	if (obj && obj->gen_loader)
    c414: 48 85 ff                     	testq	%rdi, %rdi
    c417: 74 17                        	je	0xc430 <kernel_supports+0x20>
    c419: 48 83 bf a0 00 00 00 00      	cmpq	$0, 160(%rdi)
; 		return true;
    c421: b8 01 00 00 00               	movl	$1, %eax
; 	if (obj && obj->gen_loader)
    c426: 74 08                        	je	0xc430 <kernel_supports+0x20>
; }
    c428: c3                           	retq
    c429: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; {
    c430: 41 54                        	pushq	%r12
; 	if (READ_ONCE(feat->res) == FEAT_UNKNOWN) {
    c432: 4c 8d 25 e7 ab 03 00         	leaq	240615(%rip), %r12      # 0x47020 <feature_probes>
; {
    c439: 55                           	pushq	%rbp
    c43a: 53                           	pushq	%rbx
; 	if (READ_ONCE(feat->res) == FEAT_UNKNOWN) {
    c43b: 89 f3                        	movl	%esi, %ebx
    c43d: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
    c441: 49 8d 2c c4                  	leaq	(%r12,%rax,8), %rbp
    c445: 8b 45 10                     	movl	16(%rbp), %eax
    c448: 85 c0                        	testl	%eax, %eax
    c44a: 75 0e                        	jne	0xc45a <kernel_supports+0x4a>
; 		ret = feat->probe();
    c44c: ff 55 08                     	callq	*8(%rbp)
; 		if (ret > 0) {
    c44f: 85 c0                        	testl	%eax, %eax
    c451: 7e 1d                        	jle	0xc470 <kernel_supports+0x60>
; 			WRITE_ONCE(feat->res, FEAT_SUPPORTED);
    c453: c7 45 10 01 00 00 00         	movl	$1, 16(%rbp)
; 	return READ_ONCE(feat->res) == FEAT_SUPPORTED;
    c45a: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
; }
    c45e: 5b                           	popq	%rbx
    c45f: 5d                           	popq	%rbp
; 	return READ_ONCE(feat->res) == FEAT_SUPPORTED;
    c460: 49 8d 04 c4                  	leaq	(%r12,%rax,8), %rax
; }
    c464: 41 5c                        	popq	%r12
; 	return READ_ONCE(feat->res) == FEAT_SUPPORTED;
    c466: 8b 40 10                     	movl	16(%rax), %eax
    c469: 83 f8 01                     	cmpl	$1, %eax
    c46c: 0f 94 c0                     	sete	%al
; }
    c46f: c3                           	retq
; 		} else if (ret == 0) {
    c470: 75 0e                        	jne	0xc480 <kernel_supports+0x70>
; 			WRITE_ONCE(feat->res, FEAT_MISSING);
    c472: c7 45 10 02 00 00 00         	movl	$2, 16(%rbp)
    c479: eb df                        	jmp	0xc45a <kernel_supports+0x4a>
    c47b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			pr_warn("Detection of kernel %s support failed: %d\n", feat->desc, ret);
    c480: 48 8b 55 00                  	movq	(%rbp), %rdx
    c484: 89 c1                        	movl	%eax, %ecx
    c486: 48 8d 35 73 77 02 00         	leaq	161651(%rip), %rsi      # 0x33c00 <strs.2+0xd70>
    c48d: 31 ff                        	xorl	%edi, %edi
    c48f: 31 c0                        	xorl	%eax, %eax
    c491: e8 3a bc ff ff               	callq	0x80d0 <libbpf_print>
    c496: eb da                        	jmp	0xc472 <kernel_supports+0x62>
    c498: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000000c4a0 <bpf_object__reloc_code>:
; {
    c4a0: 41 57                        	pushq	%r15
    c4a2: 41 56                        	pushq	%r14
    c4a4: 41 55                        	pushq	%r13
    c4a6: 41 54                        	pushq	%r12
    c4a8: 49 89 fc                     	movq	%rdi, %r12
    c4ab: 55                           	pushq	%rbp
    c4ac: 48 89 d5                     	movq	%rdx, %rbp
    c4af: 53                           	pushq	%rbx
    c4b0: 48 89 f3                     	movq	%rsi, %rbx
    c4b3: 48 83 ec 18                  	subq	$24, %rsp
; 	if (!obj->btf_ext || !kernel_supports(obj, FEAT_BTF_FUNC))
    c4b7: 48 83 bf 18 01 00 00 00      	cmpq	$0, 280(%rdi)
    c4bf: 0f 84 cb 00 00 00            	je	0xc590 <bpf_object__reloc_code+0xf0>
    c4c5: be 03 00 00 00               	movl	$3, %esi
    c4ca: e8 41 ff ff ff               	callq	0xc410 <kernel_supports>
    c4cf: 84 c0                        	testb	%al, %al
    c4d1: 0f 84 b9 00 00 00            	je	0xc590 <bpf_object__reloc_code+0xf0>
; 	if (main_prog != prog && !main_prog->func_info)
    c4d7: 48 39 eb                     	cmpq	%rbp, %rbx
    c4da: 0f 84 56 04 00 00            	je	0xc936 <bpf_object__reloc_code+0x496>
    c4e0: 48 83 bb 98 00 00 00 00      	cmpq	$0, 152(%rbx)
    c4e8: 74 61                        	je	0xc54b <bpf_object__reloc_code+0xab>
; 	err = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->func_info,
    c4ea: 49 8b 84 24 18 01 00 00      	movq	280(%r12), %rax
    c4f2: 48 8d 8b a4 00 00 00         	leaq	164(%rbx), %rcx
    c4f9: 48 89 ef                     	movq	%rbp, %rdi
    c4fc: 48 8d 93 98 00 00 00         	leaq	152(%rbx), %rdx
    c503: 4c 8d 83 a0 00 00 00         	leaq	160(%rbx), %r8
    c50a: 48 8d 70 08                  	leaq	8(%rax), %rsi
    c50e: e8 ad b0 ff ff               	callq	0x75c0 <adjust_prog_btf_ext_info.constprop.0>
    c513: 41 89 c7                     	movl	%eax, %r15d
; 	if (err) {
    c516: 85 c0                        	testl	%eax, %eax
    c518: 74 31                        	je	0xc54b <bpf_object__reloc_code+0xab>
; 		if (err != -ENOENT) {
    c51a: 41 83 ff fe                  	cmpl	$-2, %r15d
    c51e: 0f 85 4b 04 00 00            	jne	0xc96f <bpf_object__reloc_code+0x4cf>
; 		if (main_prog->func_info) {
    c524: 48 83 bb 98 00 00 00 00      	cmpq	$0, 152(%rbx)
; 			pr_warn("prog '%s': missing .BTF.ext function info.\n", prog->name);
    c52c: 48 8b 55 00                  	movq	(%rbp), %rdx
; 		if (main_prog->func_info) {
    c530: 0f 85 96 04 00 00            	jne	0xc9cc <bpf_object__reloc_code+0x52c>
; 		pr_warn("prog '%s': missing .BTF.ext function info for the main program, skipping all of .BTF.ext func info.\n",
    c536: 31 ff                        	xorl	%edi, %edi
    c538: 31 c0                        	xorl	%eax, %eax
    c53a: 48 8d 35 5f 81 02 00         	leaq	164191(%rip), %rsi      # 0x346a0 <strs.2+0x1810>
    c541: e8 8a bb ff ff               	callq	0x80d0 <libbpf_print>
; 	if (main_prog != prog && !main_prog->line_info)
    c546: 48 39 eb                     	cmpq	%rbp, %rbx
    c549: 74 0a                        	je	0xc555 <bpf_object__reloc_code+0xb5>
    c54b: 48 83 bb a8 00 00 00 00      	cmpq	$0, 168(%rbx)
    c553: 74 3b                        	je	0xc590 <bpf_object__reloc_code+0xf0>
; 	err = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->line_info,
    c555: 49 8b 84 24 18 01 00 00      	movq	280(%r12), %rax
    c55d: 48 8d 8b b4 00 00 00         	leaq	180(%rbx), %rcx
    c564: 48 89 ef                     	movq	%rbp, %rdi
    c567: 48 8d 93 a8 00 00 00         	leaq	168(%rbx), %rdx
    c56e: 4c 8d 83 b0 00 00 00         	leaq	176(%rbx), %r8
    c575: 48 8d 70 28                  	leaq	40(%rax), %rsi
    c579: e8 42 b0 ff ff               	callq	0x75c0 <adjust_prog_btf_ext_info.constprop.0>
    c57e: 41 89 c7                     	movl	%eax, %r15d
; 	if (err) {
    c581: 85 c0                        	testl	%eax, %eax
    c583: 0f 85 59 03 00 00            	jne	0xc8e2 <bpf_object__reloc_code+0x442>
    c589: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	for (insn_idx = 0; insn_idx < prog->sec_insn_cnt; insn_idx++) {
    c590: 45 31 f6                     	xorl	%r14d, %r14d
    c593: 48 83 7d 28 00               	cmpq	$0, 40(%rbp)
    c598: 0f 84 68 02 00 00            	je	0xc806 <bpf_object__reloc_code+0x366>
    c59e: 4c 89 64 24 08               	movq	%r12, 8(%rsp)
    c5a3: eb 29                        	jmp	0xc5ce <bpf_object__reloc_code+0x12e>
    c5a5: 0f 1f 00                     	nopl	(%rax)
; 	return is_ldimm64_insn(insn) && insn->src_reg == BPF_PSEUDO_FUNC;
    c5a8: 41 80 f8 18                  	cmpb	$24, %r8b
    c5ac: 75 12                        	jne	0xc5c0 <bpf_object__reloc_code+0x120>
    c5ae: 41 0f b6 43 01               	movzbl	1(%r11), %eax
    c5b3: 83 e0 f0                     	andl	$-16, %eax
    c5b6: 3c 40                        	cmpb	$64, %al
    c5b8: 0f 84 ca 02 00 00            	je	0xc888 <bpf_object__reloc_code+0x3e8>
    c5be: 66 90                        	nop
; 	for (insn_idx = 0; insn_idx < prog->sec_insn_cnt; insn_idx++) {
    c5c0: 49 83 c6 01                  	addq	$1, %r14
    c5c4: 4c 39 75 28                  	cmpq	%r14, 40(%rbp)
    c5c8: 0f 86 38 02 00 00            	jbe	0xc806 <bpf_object__reloc_code+0x366>
; 		insn = &main_prog->insns[prog->sub_insn_off + insn_idx];
    c5ce: 4c 8b 6d 30                  	movq	48(%rbp), %r13
    c5d2: 4c 8b 7b 38                  	movq	56(%rbx), %r15
    c5d6: 4b 8d 44 35 00               	leaq	(%r13,%r14), %rax
    c5db: 4d 8d 1c c7                  	leaq	(%r15,%rax,8), %r11
; 	return BPF_CLASS(insn->code) == BPF_JMP &&
    c5df: 45 0f b6 03                  	movzbl	(%r11), %r8d
; 	       insn->dst_reg == 0 &&
    c5e3: 44 89 c0                     	movl	%r8d, %eax
    c5e6: 83 e0 f7                     	andl	$-9, %eax
    c5e9: 3c 85                        	cmpb	$-123, %al
    c5eb: 75 bb                        	jne	0xc5a8 <bpf_object__reloc_code+0x108>
; 	       BPF_OP(insn->code) == BPF_CALL &&
    c5ed: 41 f6 c0 08                  	testb	$8, %r8b
    c5f1: 75 cd                        	jne	0xc5c0 <bpf_object__reloc_code+0x120>
; 	       insn->dst_reg == 0 &&
    c5f3: 41 8b 03                     	movl	(%r11), %eax
    c5f6: 30 c0                        	xorb	%al, %al
    c5f8: 3d 00 10 00 00               	cmpl	$4096, %eax             # imm = 0x1000
    c5fd: 75 c1                        	jne	0xc5c0 <bpf_object__reloc_code+0x120>
; 		relo = find_prog_insn_relo(prog, insn_idx);
    c5ff: 48 63 75 50                  	movslq	80(%rbp), %rsi
; 	if (!prog->nr_reloc)
    c603: 48 8b 7d 48                  	movq	72(%rbp), %rdi
    c607: 85 f6                        	testl	%esi, %esi
    c609: 74 4c                        	je	0xc657 <bpf_object__reloc_code+0x1b7>
;   __l = 0;
    c60b: 31 c9                        	xorl	%ecx, %ecx
    c60d: eb 09                        	jmp	0xc618 <bpf_object__reloc_code+0x178>
    c60f: 90                           	nop
; 	__u = __idx;
    c610: 48 89 c6                     	movq	%rax, %rsi
;   while (__l < __u)
    c613: 48 39 ce                     	cmpq	%rcx, %rsi
    c616: 76 29                        	jbe	0xc641 <bpf_object__reloc_code+0x1a1>
;       __idx = (__l + __u) / 2;
    c618: 48 8d 04 31                  	leaq	(%rcx,%rsi), %rax
    c61c: 48 d1 e8                     	shrq	%rax
;       __p = (const void *) (((const char *) __base) + (__idx * __size));
    c61f: 48 89 c2                     	movq	%rax, %rdx
    c622: 48 c1 e2 04                  	shlq	$4, %rdx
    c626: 48 01 fa                     	addq	%rdi, %rdx
; 	if (insn_idx == relo->insn_idx)
    c629: 4c 63 4a 04                  	movslq	4(%rdx), %r9
    c62d: 4d 39 f1                     	cmpq	%r14, %r9
    c630: 0f 84 da 01 00 00            	je	0xc810 <bpf_object__reloc_code+0x370>
; 	return insn_idx < relo->insn_idx ? -1 : 1;
    c636: 77 d8                        	ja	0xc610 <bpf_object__reloc_code+0x170>
; 	__l = __idx + 1;
    c638: 48 8d 48 01                  	leaq	1(%rax), %rcx
;   while (__l < __u)
    c63c: 48 39 ce                     	cmpq	%rcx, %rsi
    c63f: 77 d7                        	ja	0xc618 <bpf_object__reloc_code+0x178>
; 	return is_ldimm64_insn(insn) && insn->src_reg == BPF_PSEUDO_FUNC;
    c641: 41 80 f8 18                  	cmpb	$24, %r8b
    c645: 75 10                        	jne	0xc657 <bpf_object__reloc_code+0x1b7>
    c647: 41 0f b6 43 01               	movzbl	1(%r11), %eax
    c64c: 83 e0 f0                     	andl	$-16, %eax
    c64f: 3c 40                        	cmpb	$64, %al
    c651: 0f 84 41 02 00 00            	je	0xc898 <bpf_object__reloc_code+0x3f8>
; 			sub_insn_idx = prog->sec_insn_off + insn_idx + insn->imm + 1;
    c657: 48 8b 45 20                  	movq	32(%rbp), %rax
    c65b: 49 8d 54 06 01               	leaq	1(%r14,%rax), %rdx
    c660: 49 63 43 04                  	movslq	4(%r11), %rax
    c664: 48 01 c2                     	addq	%rax, %rdx
; 		subprog = find_prog_by_sec_insn(obj, obj->efile.text_shndx, sub_insn_idx);
    c667: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    c66c: 48 63 b7 04 01 00 00         	movslq	260(%rdi), %rsi
    c673: e8 a8 9e ff ff               	callq	0x6520 <find_prog_by_sec_insn>
    c678: 49 89 c4                     	movq	%rax, %r12
; 		if (!subprog) {
    c67b: 48 85 c0                     	testq	%rax, %rax
    c67e: 0f 84 96 02 00 00            	je	0xc91a <bpf_object__reloc_code+0x47a>
; 		if (subprog->sub_insn_off == 0) {
    c684: 48 8b 40 30                  	movq	48(%rax), %rax
    c688: 48 85 c0                     	testq	%rax, %rax
    c68b: 0f 85 31 01 00 00            	jne	0xc7c2 <bpf_object__reloc_code+0x322>
; 			subprog->sub_insn_off = main_prog->insns_cnt;
    c691: 4c 8b 6b 40                  	movq	64(%rbx), %r13
    c695: 4d 89 6c 24 30               	movq	%r13, 48(%r12)
; 			new_cnt = main_prog->insns_cnt + subprog->insns_cnt;
    c69a: 4d 03 6c 24 40               	addq	64(%r12), %r13
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    c69f: 4c 89 e8                     	movq	%r13, %rax
    c6a2: 4a 8d 34 ed 00 00 00 00      	leaq	(,%r13,8), %rsi
    c6aa: 48 c1 e8 3d                  	shrq	$61, %rax
    c6ae: 0f 85 03 02 00 00            	jne	0xc8b7 <bpf_object__reloc_code+0x417>
; 	return realloc(ptr, total);
    c6b4: 4c 89 ff                     	movq	%r15, %rdi
    c6b7: e8 64 94 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 			if (!insns) {
    c6bc: 48 85 c0                     	testq	%rax, %rax
    c6bf: 0f 84 f2 01 00 00            	je	0xc8b7 <bpf_object__reloc_code+0x417>
; 			memcpy(main_prog->insns + subprog->sub_insn_off, subprog->insns,
    c6c5: 49 8b 54 24 30               	movq	48(%r12), %rdx
; 			main_prog->insns = insns;
    c6ca: 48 89 43 38                  	movq	%rax, 56(%rbx)
; 			main_prog->insns_cnt = new_cnt;
    c6ce: 4c 89 6b 40                  	movq	%r13, 64(%rbx)
;   return __builtin___memcpy_chk (__dest, __src, __len,
    c6d2: 49 8b 74 24 38               	movq	56(%r12), %rsi
; 			memcpy(main_prog->insns + subprog->sub_insn_off, subprog->insns,
    c6d7: 48 8d 3c d0                  	leaq	(%rax,%rdx,8), %rdi
    c6db: 49 8b 44 24 40               	movq	64(%r12), %rax
    c6e0: 48 8d 14 c5 00 00 00 00      	leaq	(,%rax,8), %rdx
;   return __builtin___memcpy_chk (__dest, __src, __len,
    c6e8: e8 53 93 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 			pr_debug("prog '%s': added %zu insns from sub-prog '%s'\n",
    c6ed: 49 8b 4c 24 40               	movq	64(%r12), %rcx
    c6f2: 4d 8b 04 24                  	movq	(%r12), %r8
    c6f6: 31 c0                        	xorl	%eax, %eax
    c6f8: 48 8b 13                     	movq	(%rbx), %rdx
    c6fb: 48 8d 35 a6 81 02 00         	leaq	164262(%rip), %rsi      # 0x348a8 <strs.2+0x1a18>
    c702: bf 02 00 00 00               	movl	$2, %edi
    c707: e8 c4 b9 ff ff               	callq	0x80d0 <libbpf_print>
; 	int new_cnt = main_prog->nr_reloc + subprog->nr_reloc;
    c70c: 45 8b 6c 24 50               	movl	80(%r12), %r13d
    c711: 44 03 6b 50                  	addl	80(%rbx), %r13d
; 	if (main_prog == subprog)
    c715: 4c 39 e3                     	cmpq	%r12, %rbx
    c718: 74 7a                        	je	0xc794 <bpf_object__reloc_code+0x2f4>
; 	relos = libbpf_reallocarray(main_prog->reloc_desc, new_cnt, sizeof(*relos));
    c71a: 49 63 c5                     	movslq	%r13d, %rax
    c71d: 48 8b 7b 48                  	movq	72(%rbx), %rdi
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    c721: 48 89 c6                     	movq	%rax, %rsi
    c724: 48 c1 e6 04                  	shlq	$4, %rsi
    c728: 48 c1 e8 3c                  	shrq	$60, %rax
    c72c: 0f 85 e0 01 00 00            	jne	0xc912 <bpf_object__reloc_code+0x472>
; 	return realloc(ptr, total);
    c732: e8 e9 93 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
    c737: 49 89 c7                     	movq	%rax, %r15
; 	if (!relos)
    c73a: 48 85 c0                     	testq	%rax, %rax
    c73d: 0f 84 cf 01 00 00            	je	0xc912 <bpf_object__reloc_code+0x472>
; 	if (subprog->nr_reloc)
    c743: 41 8b 44 24 50               	movl	80(%r12), %eax
    c748: 85 c0                        	testl	%eax, %eax
    c74a: 0f 85 10 01 00 00            	jne	0xc860 <bpf_object__reloc_code+0x3c0>
; 	for (i = main_prog->nr_reloc; i < new_cnt; i++)
    c750: 8b 53 50                     	movl	80(%rbx), %edx
    c753: 41 39 d5                     	cmpl	%edx, %r13d
    c756: 7e 34                        	jle	0xc78c <bpf_object__reloc_code+0x2ec>
    c758: 44 89 ef                     	movl	%r13d, %edi
    c75b: 48 63 f2                     	movslq	%edx, %rsi
; 		relos[i].insn_idx += subprog->sub_insn_off;
    c75e: 41 8b 4c 24 30               	movl	48(%r12), %ecx
    c763: 29 d7                        	subl	%edx, %edi
    c765: 48 89 f0                     	movq	%rsi, %rax
    c768: 8d 57 ff                     	leal	-1(%rdi), %edx
    c76b: 48 c1 e0 04                  	shlq	$4, %rax
    c76f: 48 8d 54 16 01               	leaq	1(%rsi,%rdx), %rdx
    c774: 4c 01 f8                     	addq	%r15, %rax
    c777: 48 c1 e2 04                  	shlq	$4, %rdx
    c77b: 4c 01 fa                     	addq	%r15, %rdx
    c77e: 66 90                        	nop
    c780: 01 48 04                     	addl	%ecx, 4(%rax)
; 	for (i = main_prog->nr_reloc; i < new_cnt; i++)
    c783: 48 83 c0 10                  	addq	$16, %rax
    c787: 48 39 c2                     	cmpq	%rax, %rdx
    c78a: 75 f4                        	jne	0xc780 <bpf_object__reloc_code+0x2e0>
; 	main_prog->reloc_desc = relos;
    c78c: 4c 89 7b 48                  	movq	%r15, 72(%rbx)
; 	main_prog->nr_reloc = new_cnt;
    c790: 44 89 6b 50                  	movl	%r13d, 80(%rbx)
; 			err = bpf_object__reloc_code(obj, main_prog, subprog);
    c794: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    c799: 4c 89 e2                     	movq	%r12, %rdx
    c79c: 48 89 de                     	movq	%rbx, %rsi
    c79f: e8 fc fc ff ff               	callq	0xc4a0 <bpf_object__reloc_code>
; 			if (err)
    c7a4: 85 c0                        	testl	%eax, %eax
    c7a6: 0f 85 18 02 00 00            	jne	0xc9c4 <bpf_object__reloc_code+0x524>
; 		insn = &main_prog->insns[prog->sub_insn_off + insn_idx];
    c7ac: 4c 8b 6d 30                  	movq	48(%rbp), %r13
    c7b0: 48 8b 53 38                  	movq	56(%rbx), %rdx
; 		insn->imm = subprog->sub_insn_off - (prog->sub_insn_off + insn_idx) - 1;
    c7b4: 49 8b 44 24 30               	movq	48(%r12), %rax
; 		insn = &main_prog->insns[prog->sub_insn_off + insn_idx];
    c7b9: 4b 8d 4c 35 00               	leaq	(%r13,%r14), %rcx
    c7be: 4c 8d 1c ca                  	leaq	(%rdx,%rcx,8), %r11
; 		insn->imm = subprog->sub_insn_off - (prog->sub_insn_off + insn_idx) - 1;
    c7c2: 41 89 c0                     	movl	%eax, %r8d
; 		pr_debug("prog '%s': insn #%zu relocated, imm %d points to subprog '%s' (now at %zu offset)\n",
    c7c5: 48 83 ec 08                  	subq	$8, %rsp
    c7c9: 48 8b 55 00                  	movq	(%rbp), %rdx
    c7cd: 4d 8b 0c 24                  	movq	(%r12), %r9
; 		insn->imm = subprog->sub_insn_off - (prog->sub_insn_off + insn_idx) - 1;
    c7d1: 45 29 f0                     	subl	%r14d, %r8d
; 		pr_debug("prog '%s': insn #%zu relocated, imm %d points to subprog '%s' (now at %zu offset)\n",
    c7d4: 4c 89 f1                     	movq	%r14, %rcx
    c7d7: bf 02 00 00 00               	movl	$2, %edi
; 	for (insn_idx = 0; insn_idx < prog->sec_insn_cnt; insn_idx++) {
    c7dc: 49 83 c6 01                  	addq	$1, %r14
; 		insn->imm = subprog->sub_insn_off - (prog->sub_insn_off + insn_idx) - 1;
    c7e0: 45 29 e8                     	subl	%r13d, %r8d
; 		pr_debug("prog '%s': insn #%zu relocated, imm %d points to subprog '%s' (now at %zu offset)\n",
    c7e3: 48 8d 35 f6 80 02 00         	leaq	164086(%rip), %rsi      # 0x348e0 <strs.2+0x1a50>
; 		insn->imm = subprog->sub_insn_off - (prog->sub_insn_off + insn_idx) - 1;
    c7ea: 41 83 e8 01                  	subl	$1, %r8d
    c7ee: 45 89 43 04                  	movl	%r8d, 4(%r11)
; 		pr_debug("prog '%s': insn #%zu relocated, imm %d points to subprog '%s' (now at %zu offset)\n",
    c7f2: 50                           	pushq	%rax
    c7f3: 31 c0                        	xorl	%eax, %eax
    c7f5: e8 d6 b8 ff ff               	callq	0x80d0 <libbpf_print>
    c7fa: 58                           	popq	%rax
    c7fb: 5a                           	popq	%rdx
; 	for (insn_idx = 0; insn_idx < prog->sec_insn_cnt; insn_idx++) {
    c7fc: 4c 39 75 28                  	cmpq	%r14, 40(%rbp)
    c800: 0f 87 c8 fd ff ff            	ja	0xc5ce <bpf_object__reloc_code+0x12e>
; 	return 0;
    c806: 45 31 ff                     	xorl	%r15d, %r15d
    c809: e9 c2 00 00 00               	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
    c80e: 66 90                        	nop
; 		if (relo && relo->type == RELO_EXTERN_FUNC)
    c810: 44 8b 02                     	movl	(%rdx), %r8d
    c813: 41 83 f8 04                  	cmpl	$4, %r8d
    c817: 0f 84 a3 fd ff ff            	je	0xc5c0 <bpf_object__reloc_code+0x120>
; 		if (relo && relo->type != RELO_CALL && relo->type != RELO_SUBPROG_ADDR) {
    c81d: 44 89 c0                     	movl	%r8d, %eax
    c820: 83 e0 fb                     	andl	$-5, %eax
    c823: 83 f8 01                     	cmpl	$1, %eax
    c826: 0f 85 76 01 00 00            	jne	0xc9a2 <bpf_object__reloc_code+0x502>
; 				sub_insn_idx = relo->sym_off / BPF_INSN_SZ + insn->imm + 1;
    c82c: 48 63 42 0c                  	movslq	12(%rdx), %rax
    c830: 49 63 53 04                  	movslq	4(%r11), %rdx
; 			if (relo->type == RELO_CALL)
    c834: 41 83 f8 01                  	cmpl	$1, %r8d
    c838: 74 16                        	je	0xc850 <bpf_object__reloc_code+0x3b0>
; 				sub_insn_idx = (relo->sym_off + insn->imm) / BPF_INSN_SZ;
    c83a: 01 c2                        	addl	%eax, %edx
    c83c: 48 63 d2                     	movslq	%edx, %rdx
    c83f: 48 c1 ea 03                  	shrq	$3, %rdx
    c843: e9 1f fe ff ff               	jmp	0xc667 <bpf_object__reloc_code+0x1c7>
    c848: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 				sub_insn_idx = relo->sym_off / BPF_INSN_SZ + insn->imm + 1;
    c850: 48 c1 e8 03                  	shrq	$3, %rax
    c854: 48 8d 54 10 01               	leaq	1(%rax,%rdx), %rdx
    c859: e9 09 fe ff ff               	jmp	0xc667 <bpf_object__reloc_code+0x1c7>
    c85e: 66 90                        	nop
; 		memcpy(relos + main_prog->nr_reloc, subprog->reloc_desc,
    c860: 48 63 7b 50                  	movslq	80(%rbx), %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
    c864: 49 8b 74 24 48               	movq	72(%r12), %rsi
; 		       sizeof(*relos) * subprog->nr_reloc);
    c869: 48 63 d0                     	movslq	%eax, %rdx
; 		memcpy(relos + main_prog->nr_reloc, subprog->reloc_desc,
    c86c: 48 c1 e2 04                  	shlq	$4, %rdx
    c870: 48 c1 e7 04                  	shlq	$4, %rdi
    c874: 4c 01 ff                     	addq	%r15, %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
    c877: e8 c4 91 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
    c87c: e9 cf fe ff ff               	jmp	0xc750 <bpf_object__reloc_code+0x2b0>
    c881: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		relo = find_prog_insn_relo(prog, insn_idx);
    c888: 48 63 75 50                  	movslq	80(%rbp), %rsi
; 	if (!prog->nr_reloc)
    c88c: 48 8b 7d 48                  	movq	72(%rbp), %rdi
    c890: 85 f6                        	testl	%esi, %esi
    c892: 0f 85 73 fd ff ff            	jne	0xc60b <bpf_object__reloc_code+0x16b>
; 			pr_warn("prog '%s': missing subprog addr relo for insn #%zu\n",
    c898: 48 8b 55 00                  	movq	(%rbp), %rdx
    c89c: 4c 89 f1                     	movq	%r14, %rcx
    c89f: 48 8d 35 9a 80 02 00         	leaq	163994(%rip), %rsi      # 0x34940 <strs.2+0x1ab0>
    c8a6: 31 ff                        	xorl	%edi, %edi
    c8a8: 31 c0                        	xorl	%eax, %eax
; 			return -LIBBPF_ERRNO__RELOC;
    c8aa: 41 bf 5b f0 ff ff            	movl	$4294963291, %r15d      # imm = 0xFFFFF05B
; 			pr_warn("prog '%s': missing subprog addr relo for insn #%zu\n",
    c8b0: e8 1b b8 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -LIBBPF_ERRNO__RELOC;
    c8b5: eb 19                        	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
; 				pr_warn("prog '%s': failed to realloc prog code\n", main_prog->name);
    c8b7: 48 8b 13                     	movq	(%rbx), %rdx
    c8ba: 48 8d 35 b7 7f 02 00         	leaq	163767(%rip), %rsi      # 0x34878 <strs.2+0x19e8>
    c8c1: 31 ff                        	xorl	%edi, %edi
    c8c3: 31 c0                        	xorl	%eax, %eax
; 				return -ENOMEM;
    c8c5: 41 bf f4 ff ff ff            	movl	$4294967284, %r15d      # imm = 0xFFFFFFF4
; 				pr_warn("prog '%s': failed to realloc prog code\n", main_prog->name);
    c8cb: e8 00 b8 ff ff               	callq	0x80d0 <libbpf_print>
; }
    c8d0: 48 83 c4 18                  	addq	$24, %rsp
    c8d4: 44 89 f8                     	movl	%r15d, %eax
    c8d7: 5b                           	popq	%rbx
    c8d8: 5d                           	popq	%rbp
    c8d9: 41 5c                        	popq	%r12
    c8db: 41 5d                        	popq	%r13
    c8dd: 41 5e                        	popq	%r14
    c8df: 41 5f                        	popq	%r15
    c8e1: c3                           	retq
; 			pr_warn("prog '%s': error relocating .BTF.ext line info: %d\n",
    c8e2: 48 8b 55 00                  	movq	(%rbp), %rdx
; 		if (err != -ENOENT) {
    c8e6: 83 f8 fe                     	cmpl	$-2, %eax
    c8e9: 0f 85 9c 00 00 00            	jne	0xc98b <bpf_object__reloc_code+0x4eb>
; 		if (main_prog->line_info) {
    c8ef: 48 83 bb a8 00 00 00 00      	cmpq	$0, 168(%rbx)
    c8f7: 0f 85 e4 00 00 00            	jne	0xc9e1 <bpf_object__reloc_code+0x541>
; 		pr_warn("prog '%s': missing .BTF.ext line info for the main program, skipping all of .BTF.ext line info.\n",
    c8fd: 48 8d 35 7c 7e 02 00         	leaq	163452(%rip), %rsi      # 0x34780 <strs.2+0x18f0>
    c904: 31 ff                        	xorl	%edi, %edi
    c906: 31 c0                        	xorl	%eax, %eax
    c908: e8 c3 b7 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
    c90d: e9 7e fc ff ff               	jmp	0xc590 <bpf_object__reloc_code+0xf0>
; 		return -ENOMEM;
    c912: 41 bf f4 ff ff ff            	movl	$4294967284, %r15d      # imm = 0xFFFFFFF4
    c918: eb b6                        	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
; 			pr_warn("prog '%s': no .text section found yet sub-program call exists\n",
    c91a: 48 8b 55 00                  	movq	(%rbp), %rdx
    c91e: 48 8d 35 0b 7f 02 00         	leaq	163595(%rip), %rsi      # 0x34830 <strs.2+0x19a0>
    c925: 31 ff                        	xorl	%edi, %edi
    c927: 31 c0                        	xorl	%eax, %eax
; 			return -LIBBPF_ERRNO__RELOC;
    c929: 41 bf 5b f0 ff ff            	movl	$4294963291, %r15d      # imm = 0xFFFFF05B
; 			pr_warn("prog '%s': no .text section found yet sub-program call exists\n",
    c92f: e8 9c b7 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -LIBBPF_ERRNO__RELOC;
    c934: eb 9a                        	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
; 	err = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->func_info,
    c936: 49 8b 84 24 18 01 00 00      	movq	280(%r12), %rax
    c93e: 48 8d 8b a4 00 00 00         	leaq	164(%rbx), %rcx
    c945: 48 89 df                     	movq	%rbx, %rdi
    c948: 48 8d 93 98 00 00 00         	leaq	152(%rbx), %rdx
    c94f: 4c 8d 83 a0 00 00 00         	leaq	160(%rbx), %r8
    c956: 48 8d 70 08                  	leaq	8(%rax), %rsi
    c95a: e8 61 ac ff ff               	callq	0x75c0 <adjust_prog_btf_ext_info.constprop.0>
    c95f: 41 89 c7                     	movl	%eax, %r15d
; 	if (err) {
    c962: 85 c0                        	testl	%eax, %eax
    c964: 0f 84 eb fb ff ff            	je	0xc555 <bpf_object__reloc_code+0xb5>
    c96a: e9 ab fb ff ff               	jmp	0xc51a <bpf_object__reloc_code+0x7a>
; 			pr_warn("prog '%s': error relocating .BTF.ext function info: %d\n",
    c96f: 48 8b 55 00                  	movq	(%rbp), %rdx
    c973: 44 89 f9                     	movl	%r15d, %ecx
    c976: 48 8d 35 ab 7c 02 00         	leaq	162987(%rip), %rsi      # 0x34628 <strs.2+0x1798>
    c97d: 31 ff                        	xorl	%edi, %edi
    c97f: 31 c0                        	xorl	%eax, %eax
    c981: e8 4a b7 ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
    c986: e9 45 ff ff ff               	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
; 			pr_warn("prog '%s': error relocating .BTF.ext line info: %d\n",
    c98b: 89 c1                        	movl	%eax, %ecx
    c98d: 48 8d 35 7c 7d 02 00         	leaq	163196(%rip), %rsi      # 0x34710 <strs.2+0x1880>
    c994: 31 ff                        	xorl	%edi, %edi
    c996: 31 c0                        	xorl	%eax, %eax
    c998: e8 33 b7 ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
    c99d: e9 2e ff ff ff               	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
; 			pr_warn("prog '%s': unexpected relo for insn #%zu, type %d\n",
    c9a2: 48 8b 55 00                  	movq	(%rbp), %rdx
    c9a6: 4c 89 f1                     	movq	%r14, %rcx
    c9a9: 48 8d 35 40 7e 02 00         	leaq	163392(%rip), %rsi      # 0x347f0 <strs.2+0x1960>
    c9b0: 31 ff                        	xorl	%edi, %edi
    c9b2: 31 c0                        	xorl	%eax, %eax
; 			return -LIBBPF_ERRNO__RELOC;
    c9b4: 41 bf 5b f0 ff ff            	movl	$4294963291, %r15d      # imm = 0xFFFFF05B
; 			pr_warn("prog '%s': unexpected relo for insn #%zu, type %d\n",
    c9ba: e8 11 b7 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -LIBBPF_ERRNO__RELOC;
    c9bf: e9 0c ff ff ff               	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
    c9c4: 41 89 c7                     	movl	%eax, %r15d
    c9c7: e9 04 ff ff ff               	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
; 			pr_warn("prog '%s': missing .BTF.ext function info.\n", prog->name);
    c9cc: 48 8d 35 95 7c 02 00         	leaq	162965(%rip), %rsi      # 0x34668 <strs.2+0x17d8>
    c9d3: 31 ff                        	xorl	%edi, %edi
    c9d5: 31 c0                        	xorl	%eax, %eax
    c9d7: e8 f4 b6 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
    c9dc: e9 ef fe ff ff               	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
; 			pr_warn("prog '%s': missing .BTF.ext line info.\n", prog->name);
    c9e1: 48 8d 35 68 7d 02 00         	leaq	163176(%rip), %rsi      # 0x34750 <strs.2+0x18c0>
    c9e8: 31 ff                        	xorl	%edi, %edi
    c9ea: 31 c0                        	xorl	%eax, %eax
    c9ec: e8 df b6 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
    c9f1: e9 da fe ff ff               	jmp	0xc8d0 <bpf_object__reloc_code+0x430>
    c9f6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000000ca00 <bpf_object__create_map>:
; {
    ca00: 41 57                        	pushq	%r15
;   return __builtin___memset_chk (__dest, __ch, __len,
    ca02: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
    ca06: 41 56                        	pushq	%r14
    ca08: 45 31 f6                     	xorl	%r14d, %r14d
    ca0b: 41 55                        	pushq	%r13
    ca0d: 41 89 d5                     	movl	%edx, %r13d
    ca10: 41 54                        	pushq	%r12
    ca12: 55                           	pushq	%rbp
    ca13: 48 89 fd                     	movq	%rdi, %rbp
    ca16: 53                           	pushq	%rbx
    ca17: 48 89 f3                     	movq	%rsi, %rbx
; 	if (kernel_supports(obj, FEAT_PROG_NAME))
    ca1a: 31 f6                        	xorl	%esi, %esi
; {
    ca1c: 48 81 ec d8 00 00 00         	subq	$216, %rsp
    ca23: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    ca2c: 48 89 84 24 c8 00 00 00      	movq	%rax, 200(%rsp)
    ca34: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
    ca36: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
    ca3b: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
; 	LIBBPF_OPTS(bpf_map_create_opts, create_attr);
    ca44: 48 c7 44 24 10 30 00 00 00   	movq	$48, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    ca4d: 0f 11 44 24 28               	movups	%xmm0, 40(%rsp)
; 	if (kernel_supports(obj, FEAT_PROG_NAME))
    ca52: e8 b9 f9 ff ff               	callq	0xc410 <kernel_supports>
    ca57: 84 c0                        	testb	%al, %al
    ca59: 74 04                        	je	0xca5f <bpf_object__create_map+0x5f>
; 		map_name = map->name;
    ca5b: 4c 8b 73 08                  	movq	8(%rbx), %r14
; 	create_attr.map_ifindex = map->map_ifindex;
    ca5f: 8b 43 28                     	movl	40(%rbx), %eax
; 	return map->def.type == BPF_MAP_TYPE_STRUCT_OPS;
    ca62: 44 8b 53 30                  	movl	48(%rbx), %r10d
; 	create_attr.map_ifindex = map->map_ifindex;
    ca66: 89 44 24 3c                  	movl	%eax, 60(%rsp)
; 	create_attr.map_flags = def->map_flags;
    ca6a: 8b 43 40                     	movl	64(%rbx), %eax
    ca6d: 89 44 24 2c                  	movl	%eax, 44(%rsp)
; 	create_attr.numa_node = map->numa_node;
    ca71: 8b 43 44                     	movl	68(%rbx), %eax
    ca74: 89 44 24 38                  	movl	%eax, 56(%rsp)
; 	create_attr.map_extra = map->map_extra;
    ca78: 48 8b 83 98 00 00 00         	movq	152(%rbx), %rax
    ca7f: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	if (bpf_map__is_struct_ops(map))
    ca84: 41 83 fa 1a                  	cmpl	$26, %r10d
    ca88: 0f 84 22 02 00 00            	je	0xccb0 <bpf_object__create_map+0x2b0>
; 	if (obj->btf && btf__fd(obj->btf) >= 0) {
    ca8e: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
    ca95: 48 85 ff                     	testq	%rdi, %rdi
    ca98: 74 11                        	je	0xcaab <bpf_object__create_map+0xab>
    ca9a: e8 91 e7 01 00               	callq	0x2b230 <btf__fd>
    ca9f: 85 c0                        	testl	%eax, %eax
    caa1: 0f 89 e1 00 00 00            	jns	0xcb88 <bpf_object__create_map+0x188>
; 	if (bpf_map_type__is_map_in_map(def->type)) {
    caa7: 44 8b 53 30                  	movl	48(%rbx), %r10d
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
    caab: 41 8d 42 f4                  	leal	-12(%r10), %eax
    caaf: 83 f8 01                     	cmpl	$1, %eax
    cab2: 0f 86 28 02 00 00            	jbe	0xcce0 <bpf_object__create_map+0x2e0>
; 	switch (def->type) {
    cab8: 41 83 fa 19                  	cmpl	$25, %r10d
    cabc: 77 24                        	ja	0xcae2 <bpf_object__create_map+0xe2>
    cabe: b8 90 f1 c7 02               	movl	$46657936, %eax         # imm = 0x2C7F190
    cac3: 4c 0f a3 d0                  	btq	%r10, %rax
    cac7: 73 19                        	jae	0xcae2 <bpf_object__create_map+0xe2>
; 		create_attr.btf_fd = 0;
    cac9: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 		create_attr.btf_value_type_id = 0;
    cad2: c7 44 24 20 00 00 00 00      	movl	$0, 32(%rsp)
; 		map->btf_key_type_id = 0;
    cada: 48 c7 43 4c 00 00 00 00      	movq	$0, 76(%rbx)
; 	if (obj->gen_loader) {
    cae2: 48 8b bd a0 00 00 00         	movq	160(%rbp), %rdi
; 		bpf_gen__map_create(obj->gen_loader, def->type, map_name,
    cae9: 44 8b 43 3c                  	movl	60(%rbx), %r8d
    caed: 8b 4b 38                     	movl	56(%rbx), %ecx
    caf0: 44 8b 5b 34                  	movl	52(%rbx), %r11d
; 	if (obj->gen_loader) {
    caf4: 48 85 ff                     	testq	%rdi, %rdi
    caf7: 0f 84 b3 00 00 00            	je	0xcbb0 <bpf_object__create_map+0x1b0>
; 		bpf_gen__map_create(obj->gen_loader, def->type, map_name,
    cafd: b8 ff ff ff ff               	movl	$4294967295, %eax       # imm = 0xFFFFFFFF
    cb02: 45 84 ed                     	testb	%r13b, %r13b
    cb05: 74 69                        	je	0xcb70 <bpf_object__create_map+0x170>
    cb07: 50                           	pushq	%rax
    cb08: 45 89 c1                     	movl	%r8d, %r9d
    cb0b: 4c 89 f2                     	movq	%r14, %rdx
    cb0e: 41 89 c8                     	movl	%ecx, %r8d
    cb11: 44 89 d6                     	movl	%r10d, %esi
    cb14: 44 89 d9                     	movl	%r11d, %ecx
    cb17: 48 8d 44 24 18               	leaq	24(%rsp), %rax
    cb1c: 50                           	pushq	%rax
    cb1d: e8 be 2d 01 00               	callq	0x1f8e0 <bpf_gen__map_create>
; 		map->fd = 0;
    cb22: c7 43 18 00 00 00 00         	movl	$0, 24(%rbx)
    cb29: 58                           	popq	%rax
    cb2a: 5a                           	popq	%rdx
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
    cb2b: 8b 43 30                     	movl	48(%rbx), %eax
; 	err = map->fd < 0 ? -errno : 0;
    cb2e: 45 31 e4                     	xorl	%r12d, %r12d
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
    cb31: 83 e8 0c                     	subl	$12, %eax
    cb34: 83 f8 01                     	cmpl	$1, %eax
    cb37: 0f 86 33 01 00 00            	jbe	0xcc70 <bpf_object__create_map+0x270>
; }
    cb3d: 48 8b 84 24 c8 00 00 00      	movq	200(%rsp), %rax
    cb45: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    cb4e: 0f 85 19 02 00 00            	jne	0xcd6d <bpf_object__create_map+0x36d>
    cb54: 48 81 c4 d8 00 00 00         	addq	$216, %rsp
    cb5b: 44 89 e0                     	movl	%r12d, %eax
    cb5e: 5b                           	popq	%rbx
    cb5f: 5d                           	popq	%rbp
    cb60: 41 5c                        	popq	%r12
    cb62: 41 5d                        	popq	%r13
    cb64: 41 5e                        	popq	%r14
    cb66: 41 5f                        	popq	%r15
    cb68: c3                           	retq
    cb69: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 				    &create_attr, is_inner ? -1 : map - obj->maps);
    cb70: 48 89 d8                     	movq	%rbx, %rax
    cb73: 48 2b 45 68                  	subq	104(%rbp), %rax
    cb77: 48 c1 f8 05                  	sarq	$5, %rax
; 		bpf_gen__map_create(obj->gen_loader, def->type, map_name,
    cb7b: 69 c0 cd cc cc cc            	imull	$3435973837, %eax, %eax # imm = 0xCCCCCCCD
    cb81: eb 84                        	jmp	0xcb07 <bpf_object__create_map+0x107>
    cb83: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		create_attr.btf_fd = btf__fd(obj->btf);
    cb88: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
    cb8f: e8 9c e6 01 00               	callq	0x2b230 <btf__fd>
    cb94: 89 44 24 18                  	movl	%eax, 24(%rsp)
; 		create_attr.btf_key_type_id = map->btf_key_type_id;
    cb98: 48 8b 43 4c                  	movq	76(%rbx), %rax
    cb9c: 48 89 44 24 1c               	movq	%rax, 28(%rsp)
    cba1: e9 01 ff ff ff               	jmp	0xcaa7 <bpf_object__create_map+0xa7>
    cba6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		map->fd = bpf_map_create(def->type, map_name,
    cbb0: 4c 8d 6c 24 10               	leaq	16(%rsp), %r13
    cbb5: 44 89 da                     	movl	%r11d, %edx
    cbb8: 4c 89 f6                     	movq	%r14, %rsi
    cbbb: 44 89 d7                     	movl	%r10d, %edi
    cbbe: 4d 89 e9                     	movq	%r13, %r9
    cbc1: e8 da 8c 01 00               	callq	0x258a0 <bpf_map_create>
    cbc6: 89 43 18                     	movl	%eax, 24(%rbx)
; 	if (map->fd < 0 && (create_attr.btf_key_type_id ||
    cbc9: 85 c0                        	testl	%eax, %eax
    cbcb: 0f 89 5a ff ff ff            	jns	0xcb2b <bpf_object__create_map+0x12b>
    cbd1: 8b 54 24 1c                  	movl	28(%rsp), %edx
    cbd5: 0b 54 24 20                  	orl	32(%rsp), %edx
    cbd9: 89 54 24 0c                  	movl	%edx, 12(%rsp)
; 		err = -errno;
    cbdd: e8 0e 8b ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (map->fd < 0 && (create_attr.btf_key_type_id ||
    cbe2: 8b 54 24 0c                  	movl	12(%rsp), %edx
; 		err = -errno;
    cbe6: 44 8b 20                     	movl	(%rax), %r12d
    cbe9: 49 89 c7                     	movq	%rax, %r15
; 	if (map->fd < 0 && (create_attr.btf_key_type_id ||
    cbec: 85 d2                        	testl	%edx, %edx
    cbee: 74 6e                        	je	0xcc5e <bpf_object__create_map+0x25e>
; 		err = -errno;
    cbf0: 41 f7 dc                     	negl	%r12d
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
    cbf3: 48 8d 74 24 40               	leaq	64(%rsp), %rsi
    cbf8: ba 80 00 00 00               	movl	$128, %edx
    cbfd: 44 89 e7                     	movl	%r12d, %edi
    cc00: e8 cb 0d 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("Error in bpf_create_map_xattr(%s):%s(%d). Retrying without BTF.\n",
    cc05: 48 8b 53 08                  	movq	8(%rbx), %rdx
    cc09: 45 89 e0                     	movl	%r12d, %r8d
    cc0c: 31 ff                        	xorl	%edi, %edi
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
    cc0e: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("Error in bpf_create_map_xattr(%s):%s(%d). Retrying without BTF.\n",
    cc11: 48 8d 35 a0 7d 02 00         	leaq	163232(%rip), %rsi      # 0x349b8 <strs.2+0x1b28>
    cc18: 31 c0                        	xorl	%eax, %eax
    cc1a: e8 b1 b4 ff ff               	callq	0x80d0 <libbpf_print>
; 		map->fd = bpf_map_create(def->type, map_name,
    cc1f: 8b 4b 38                     	movl	56(%rbx), %ecx
    cc22: 8b 53 34                     	movl	52(%rbx), %edx
    cc25: 4d 89 e9                     	movq	%r13, %r9
; 		map->btf_key_type_id = 0;
    cc28: 48 c7 43 4c 00 00 00 00      	movq	$0, 76(%rbx)
; 		map->fd = bpf_map_create(def->type, map_name,
    cc30: 8b 7b 30                     	movl	48(%rbx), %edi
    cc33: 4c 89 f6                     	movq	%r14, %rsi
    cc36: 44 8b 43 3c                  	movl	60(%rbx), %r8d
; 		create_attr.btf_value_type_id = 0;
    cc3a: c7 44 24 20 00 00 00 00      	movl	$0, 32(%rsp)
; 		create_attr.btf_fd = 0;
    cc42: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 		map->fd = bpf_map_create(def->type, map_name,
    cc4b: e8 50 8c 01 00               	callq	0x258a0 <bpf_map_create>
    cc50: 89 43 18                     	movl	%eax, 24(%rbx)
; 	err = map->fd < 0 ? -errno : 0;
    cc53: 85 c0                        	testl	%eax, %eax
    cc55: 0f 89 d0 fe ff ff            	jns	0xcb2b <bpf_object__create_map+0x12b>
    cc5b: 45 8b 27                     	movl	(%r15), %r12d
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
    cc5e: 8b 43 30                     	movl	48(%rbx), %eax
; 	err = map->fd < 0 ? -errno : 0;
    cc61: 41 f7 dc                     	negl	%r12d
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
    cc64: 83 e8 0c                     	subl	$12, %eax
    cc67: 83 f8 01                     	cmpl	$1, %eax
    cc6a: 0f 87 cd fe ff ff            	ja	0xcb3d <bpf_object__create_map+0x13d>
; 	if (bpf_map_type__is_map_in_map(def->type) && map->inner_map) {
    cc70: 48 8b 7b 70                  	movq	112(%rbx), %rdi
    cc74: 48 85 ff                     	testq	%rdi, %rdi
    cc77: 0f 84 c0 fe ff ff            	je	0xcb3d <bpf_object__create_map+0x13d>
; 		if (obj->gen_loader)
    cc7d: 48 83 bd a0 00 00 00 00      	cmpq	$0, 160(%rbp)
    cc85: 74 07                        	je	0xcc8e <bpf_object__create_map+0x28e>
; 			map->inner_map->fd = -1;
    cc87: c7 47 18 ff ff ff ff         	movl	$4294967295, 24(%rdi)   # imm = 0xFFFFFFFF
; 		bpf_map__destroy(map->inner_map);
    cc8e: e8 3d ae ff ff               	callq	0x7ad0 <bpf_map__destroy>
; 		zfree(&map->inner_map);
    cc93: 48 8b 7b 70                  	movq	112(%rbx), %rdi
    cc97: e8 24 8a ff ff               	callq	0x56c0 <.plt.sec+0x50>
    cc9c: 48 c7 43 70 00 00 00 00      	movq	$0, 112(%rbx)
    cca4: e9 94 fe ff ff               	jmp	0xcb3d <bpf_object__create_map+0x13d>
    cca9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		create_attr.btf_vmlinux_value_type_id = map->btf_vmlinux_value_type_id;
    ccb0: 8b 43 54                     	movl	84(%rbx), %eax
; 	if (obj->btf && btf__fd(obj->btf) >= 0) {
    ccb3: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
; 		create_attr.btf_vmlinux_value_type_id = map->btf_vmlinux_value_type_id;
    ccba: 89 44 24 24                  	movl	%eax, 36(%rsp)
; 	if (obj->btf && btf__fd(obj->btf) >= 0) {
    ccbe: 48 85 ff                     	testq	%rdi, %rdi
    ccc1: 0f 84 1b fe ff ff            	je	0xcae2 <bpf_object__create_map+0xe2>
    ccc7: e8 64 e5 01 00               	callq	0x2b230 <btf__fd>
    cccc: 85 c0                        	testl	%eax, %eax
    ccce: 0f 88 d3 fd ff ff            	js	0xcaa7 <bpf_object__create_map+0xa7>
    ccd4: e9 af fe ff ff               	jmp	0xcb88 <bpf_object__create_map+0x188>
    ccd9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (map->inner_map) {
    cce0: 48 8b 73 70                  	movq	112(%rbx), %rsi
    cce4: 48 85 f6                     	testq	%rsi, %rsi
    cce7: 74 3f                        	je	0xcd28 <bpf_object__create_map+0x328>
; 			err = bpf_object__create_map(obj, map->inner_map, true);
    cce9: ba 01 00 00 00               	movl	$1, %edx
    ccee: 48 89 ef                     	movq	%rbp, %rdi
    ccf1: e8 0a fd ff ff               	callq	0xca00 <bpf_object__create_map>
    ccf6: 41 89 c4                     	movl	%eax, %r12d
; 			if (err) {
    ccf9: 85 c0                        	testl	%eax, %eax
    ccfb: 75 3b                        	jne	0xcd38 <bpf_object__create_map+0x338>
; 			map->inner_map_fd = bpf_map__fd(map->inner_map);
    ccfd: 48 8b 43 70                  	movq	112(%rbx), %rax
; 	return map ? map->fd : libbpf_err(-EINVAL);
    cd01: 48 85 c0                     	testq	%rax, %rax
    cd04: 74 4d                        	je	0xcd53 <bpf_object__create_map+0x353>
    cd06: 8b 40 18                     	movl	24(%rax), %eax
; 	switch (def->type) {
    cd09: 44 8b 53 30                  	movl	48(%rbx), %r10d
; 			map->inner_map_fd = bpf_map__fd(map->inner_map);
    cd0d: 89 43 2c                     	movl	%eax, 44(%rbx)
; 		if (map->inner_map_fd >= 0)
    cd10: 85 c0                        	testl	%eax, %eax
    cd12: 0f 88 a0 fd ff ff            	js	0xcab8 <bpf_object__create_map+0xb8>
; 			create_attr.inner_map_fd = map->inner_map_fd;
    cd18: 89 44 24 28                  	movl	%eax, 40(%rsp)
    cd1c: e9 97 fd ff ff               	jmp	0xcab8 <bpf_object__create_map+0xb8>
    cd21: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (map->inner_map_fd >= 0)
    cd28: 8b 43 2c                     	movl	44(%rbx), %eax
    cd2b: 85 c0                        	testl	%eax, %eax
    cd2d: 79 e9                        	jns	0xcd18 <bpf_object__create_map+0x318>
    cd2f: e9 95 fd ff ff               	jmp	0xcac9 <bpf_object__create_map+0xc9>
    cd34: 0f 1f 40 00                  	nopl	(%rax)
; 				pr_warn("map '%s': failed to create inner map: %d\n",
    cd38: 48 8b 53 08                  	movq	8(%rbx), %rdx
    cd3c: 89 c1                        	movl	%eax, %ecx
    cd3e: 48 8d 35 3b 7c 02 00         	leaq	162875(%rip), %rsi      # 0x34980 <strs.2+0x1af0>
    cd45: 31 ff                        	xorl	%edi, %edi
    cd47: 31 c0                        	xorl	%eax, %eax
    cd49: e8 82 b3 ff ff               	callq	0x80d0 <libbpf_print>
; 				return err;
    cd4e: e9 ea fd ff ff               	jmp	0xcb3d <bpf_object__create_map+0x13d>
; 	if (ret < 0)
    cd53: bf ea ff ff ff               	movl	$4294967274, %edi       # imm = 0xFFFFFFEA
    cd58: e8 13 a5 ff ff               	callq	0x7270 <libbpf_err.part.0>
; 			map->inner_map_fd = bpf_map__fd(map->inner_map);
    cd5d: c7 43 2c ea ff ff ff         	movl	$4294967274, 44(%rbx)   # imm = 0xFFFFFFEA
; 	switch (def->type) {
    cd64: 44 8b 53 30                  	movl	48(%rbx), %r10d
    cd68: e9 4b fd ff ff               	jmp	0xcab8 <bpf_object__create_map+0xb8>
; }
    cd6d: e8 8e 8a ff ff               	callq	0x5800 <.plt.sec+0x190>
    cd72: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    cd7d: 0f 1f 00                     	nopl	(%rax)

000000000000cd80 <bpf_object_load_prog>:
; {
    cd80: 41 57                        	pushq	%r15
    cd82: 41 56                        	pushq	%r14
    cd84: 41 55                        	pushq	%r13
    cd86: 49 89 d5                     	movq	%rdx, %r13
    cd89: 41 54                        	pushq	%r12
    cd8b: 55                           	pushq	%rbp
    cd8c: 53                           	pushq	%rbx
    cd8d: 48 89 f3                     	movq	%rsi, %rbx
    cd90: 48 81 ec f8 08 00 00         	subq	$2296, %rsp             # imm = 0x8F8
; 	if (prog->type == BPF_PROG_TYPE_UNSPEC) {
    cd97: 44 8b 9e 80 00 00 00         	movl	128(%rsi), %r11d
; {
    cd9e: 48 8b 84 24 30 09 00 00      	movq	2352(%rsp), %rax
    cda6: 48 89 7c 24 18               	movq	%rdi, 24(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    cdab: 48 8d 54 24 58               	leaq	88(%rsp), %rdx
; {
    cdb0: 89 4c 24 10                  	movl	%ecx, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    cdb4: 48 89 d7                     	movq	%rdx, %rdi
    cdb7: b9 0c 00 00 00               	movl	$12, %ecx
; {
    cdbc: 48 89 44 24 38               	movq	%rax, 56(%rsp)
    cdc1: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    cdca: 48 89 84 24 e8 08 00 00      	movq	%rax, 2280(%rsp)
    cdd2: 31 c0                        	xorl	%eax, %eax
; 	LIBBPF_OPTS(bpf_prog_load_opts, load_attr);
    cdd4: 48 c7 44 24 50 68 00 00 00   	movq	$104, 80(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    cddd: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	__u32 log_level = prog->log_level;
    cde0: 8b 46 68                     	movl	104(%rsi), %eax
    cde3: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	if (prog->type == BPF_PROG_TYPE_UNSPEC) {
    cde7: 45 85 db                     	testl	%r11d, %r11d
    cdea: 0f 84 32 09 00 00            	je	0xd722 <bpf_object_load_prog+0x9a2>
; 	if (!insns || !insns_cnt)
    cdf0: 44 8b 54 24 10               	movl	16(%rsp), %r10d
    cdf5: 4d 85 ed                     	testq	%r13, %r13
    cdf8: 0f 94 c2                     	sete	%dl
    cdfb: 45 85 d2                     	testl	%r10d, %r10d
    cdfe: 0f 94 c0                     	sete	%al
    ce01: 08 c2                        	orb	%al, %dl
    ce03: 88 54 24 37                  	movb	%dl, 55(%rsp)
    ce07: 0f 85 0a 09 00 00            	jne	0xd717 <bpf_object_load_prog+0x997>
; 	load_attr.expected_attach_type = prog->expected_attach_type;
    ce0d: 8b 86 84 00 00 00            	movl	132(%rsi), %eax
; 	if (kernel_supports(obj, FEAT_PROG_NAME))
    ce13: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
    ce18: 31 f6                        	xorl	%esi, %esi
    ce1a: 4d 89 c6                     	movq	%r8, %r14
    ce1d: 45 89 cc                     	movl	%r9d, %r12d
; 	const char *prog_name = NULL;
    ce20: 45 31 ff                     	xorl	%r15d, %r15d
; 	load_attr.expected_attach_type = prog->expected_attach_type;
    ce23: 89 44 24 5c                  	movl	%eax, 92(%rsp)
; 	if (kernel_supports(obj, FEAT_PROG_NAME))
    ce27: e8 e4 f5 ff ff               	callq	0xc410 <kernel_supports>
    ce2c: 84 c0                        	testb	%al, %al
    ce2e: 0f 85 8c 04 00 00            	jne	0xd2c0 <bpf_object_load_prog+0x540>
; 	load_attr.attach_btf_obj_fd = prog->attach_btf_obj_fd;
    ce34: 8b 83 8c 00 00 00            	movl	140(%rbx), %eax
; 	return obj->btf ? btf__fd(obj->btf) : -1;
    ce3a: 48 8b 6c 24 18               	movq	24(%rsp), %rbp
; 	load_attr.kern_version = kern_version;
    ce3f: 44 89 64 24 6c               	movl	%r12d, 108(%rsp)
; 	load_attr.attach_btf_obj_fd = prog->attach_btf_obj_fd;
    ce44: 89 44 24 78                  	movl	%eax, 120(%rsp)
; 	load_attr.attach_btf_id = prog->attach_btf_id;
    ce48: 48 8b 83 90 00 00 00         	movq	144(%rbx), %rax
; 	return obj->btf ? btf__fd(obj->btf) : -1;
    ce4f: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
; 	load_attr.attach_btf_id = prog->attach_btf_id;
    ce56: 48 89 44 24 70               	movq	%rax, 112(%rsp)
; 	load_attr.prog_ifindex = prog->prog_ifindex;
    ce5b: 8b 83 88 00 00 00            	movl	136(%rbx), %eax
    ce61: 89 44 24 68                  	movl	%eax, 104(%rsp)
; 	return obj->btf ? btf__fd(obj->btf) : -1;
    ce65: 48 85 ff                     	testq	%rdi, %rdi
    ce68: 74 10                        	je	0xce7a <bpf_object_load_prog+0xfa>
    ce6a: e8 c1 e3 01 00               	callq	0x2b230 <btf__fd>
    ce6f: 41 89 c4                     	movl	%eax, %r12d
; 	if (btf_fd >= 0 && kernel_supports(obj, FEAT_BTF_FUNC)) {
    ce72: 85 c0                        	testl	%eax, %eax
    ce74: 0f 89 56 04 00 00            	jns	0xd2d0 <bpf_object_load_prog+0x550>
; 	load_attr.log_level = log_level;
    ce7a: 8b 44 24 08                  	movl	8(%rsp), %eax
    ce7e: 89 84 24 a8 00 00 00         	movl	%eax, 168(%rsp)
; 	load_attr.prog_flags = prog->prog_flags;
    ce85: 8b 83 b8 00 00 00            	movl	184(%rbx), %eax
    ce8b: 89 44 24 64                  	movl	%eax, 100(%rsp)
; 	load_attr.fd_array = obj->fd_array;
    ce8f: 48 8b 44 24 18               	movq	24(%rsp), %rax
    ce94: 48 8b 80 70 01 00 00         	movq	368(%rax), %rax
    ce9b: 48 89 84 24 80 00 00 00      	movq	%rax, 128(%rsp)
; 	if (prog->sec_def && prog->sec_def->prog_prepare_load_fn) {
    cea3: 48 8b 43 18                  	movq	24(%rbx), %rax
    cea7: 48 85 c0                     	testq	%rax, %rax
    ceaa: 74 2a                        	je	0xced6 <bpf_object_load_prog+0x156>
    ceac: 48 8b 48 28                  	movq	40(%rax), %rcx
    ceb0: 48 85 c9                     	testq	%rcx, %rcx
    ceb3: 74 21                        	je	0xced6 <bpf_object_load_prog+0x156>
; 		err = prog->sec_def->prog_prepare_load_fn(prog, &load_attr, prog->sec_def->cookie);
    ceb5: 48 8b 50 10                  	movq	16(%rax), %rdx
    ceb9: 48 8d 74 24 50               	leaq	80(%rsp), %rsi
    cebe: 48 89 df                     	movq	%rbx, %rdi
    cec1: ff d1                        	callq	*%rcx
; 		if (err < 0) {
    cec3: 85 c0                        	testl	%eax, %eax
    cec5: 0f 88 4f 07 00 00            	js	0xd61a <bpf_object_load_prog+0x89a>
; 		insns_cnt = prog->insns_cnt;
    cecb: 8b 43 40                     	movl	64(%rbx), %eax
; 		insns = prog->insns;
    cece: 4c 8b 6b 38                  	movq	56(%rbx), %r13
; 		insns_cnt = prog->insns_cnt;
    ced2: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 	if (obj->gen_loader) {
    ced6: 48 8b 44 24 18               	movq	24(%rsp), %rax
; 	size_t log_buf_size = 0;
    cedb: 31 ed                        	xorl	%ebp, %ebp
; 	if (obj->gen_loader) {
    cedd: 4c 8b 98 a0 00 00 00         	movq	160(%rax), %r11
    cee4: 4d 85 db                     	testq	%r11, %r11
    cee7: 0f 85 5b 04 00 00            	jne	0xd348 <bpf_object_load_prog+0x5c8>
    ceed: 4c 89 6c 24 20               	movq	%r13, 32(%rsp)
    cef2: 4d 89 dc                     	movq	%r11, %r12
    cef5: e9 b2 00 00 00               	jmp	0xcfac <bpf_object_load_prog+0x22c>
    cefa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		} else if (obj->log_buf) {
    cf00: 48 8b 44 24 18               	movq	24(%rsp), %rax
    cf05: 4c 8b a8 58 01 00 00         	movq	344(%rax), %r13
    cf0c: 4d 85 ed                     	testq	%r13, %r13
    cf0f: 0f 85 2b 03 00 00            	jne	0xd240 <bpf_object_load_prog+0x4c0>
; 			log_buf_size = max((size_t)BPF_LOG_BUF_SIZE, log_buf_size * 2);
    cf15: 48 8d 44 2d 00               	leaq	(%rbp,%rbp), %rax
    cf1a: bd ff ff ff 00               	movl	$16777215, %ebp         # imm = 0xFFFFFF
; 			tmp = realloc(log_buf, log_buf_size);
    cf1f: 4c 89 e7                     	movq	%r12, %rdi
; 			log_buf_size = max((size_t)BPF_LOG_BUF_SIZE, log_buf_size * 2);
    cf22: 48 39 e8                     	cmpq	%rbp, %rax
    cf25: 48 89 44 24 28               	movq	%rax, 40(%rsp)
    cf2a: 48 0f 43 e8                  	cmovaeq	%rax, %rbp
; 			tmp = realloc(log_buf, log_buf_size);
    cf2e: 48 89 ee                     	movq	%rbp, %rsi
    cf31: e8 ea 8b ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
    cf36: 49 89 c5                     	movq	%rax, %r13
; 			if (!tmp) {
    cf39: 48 85 c0                     	testq	%rax, %rax
    cf3c: 0f 84 02 08 00 00            	je	0xd744 <bpf_object_load_prog+0x9c4>
; 			log_buf[0] = '\0';
    cf42: c6 00 00                     	movb	$0, (%rax)
; 	ret = bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
    cf45: 4c 63 44 24 10               	movslq	16(%rsp), %r8
    cf4a: 4c 8d 4c 24 50               	leaq	80(%rsp), %r9
    cf4f: 4c 89 f2                     	movq	%r14, %rdx
; 	load_attr.log_buf = log_buf;
    cf52: 48 89 84 24 b0 00 00 00      	movq	%rax, 176(%rsp)
; 	ret = bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
    cf5a: 8b bb 80 00 00 00            	movl	128(%rbx), %edi
    cf60: 4c 89 fe                     	movq	%r15, %rsi
; 	load_attr.log_level = log_level;
    cf63: 8b 44 24 08                  	movl	8(%rsp), %eax
; 	ret = bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
    cf67: 48 8b 4c 24 20               	movq	32(%rsp), %rcx
; 	load_attr.log_size = log_buf_size;
    cf6c: 89 ac 24 ac 00 00 00         	movl	%ebp, 172(%rsp)
; 	load_attr.log_level = log_level;
    cf73: 89 84 24 a8 00 00 00         	movl	%eax, 168(%rsp)
; 	ret = bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
    cf7a: e8 d1 8c 01 00               	callq	0x25c50 <bpf_prog_load>
; 	if (ret >= 0) {
    cf7f: 85 c0                        	testl	%eax, %eax
    cf81: 0f 89 d5 07 00 00            	jns	0xd75c <bpf_object_load_prog+0x9dc>
; 	if (own_log_buf && errno == ENOSPC && log_buf_size <= UINT_MAX / 2)
    cf87: e8 64 87 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    cf8c: ba 00 00 00 80               	movl	$2147483648, %edx       # imm = 0x80000000
    cf91: 44 8b 00                     	movl	(%rax), %r8d
    cf94: 48 39 54 24 28               	cmpq	%rdx, 40(%rsp)
    cf99: 0f 83 01 04 00 00            	jae	0xd3a0 <bpf_object_load_prog+0x620>
    cf9f: 41 83 f8 1c                  	cmpl	$28, %r8d
    cfa3: 0f 85 f7 03 00 00            	jne	0xd3a0 <bpf_object_load_prog+0x620>
    cfa9: 4d 89 ec                     	movq	%r13, %r12
; 	if (log_level) {
    cfac: 8b 7c 24 08                  	movl	8(%rsp), %edi
    cfb0: 85 ff                        	testl	%edi, %edi
    cfb2: 75 4a                        	jne	0xcffe <bpf_object_load_prog+0x27e>
; 	ret = bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
    cfb4: 4c 63 44 24 10               	movslq	16(%rsp), %r8
    cfb9: 48 8b 4c 24 20               	movq	32(%rsp), %rcx
    cfbe: 4c 89 f2                     	movq	%r14, %rdx
    cfc1: 4c 89 fe                     	movq	%r15, %rsi
    cfc4: 8b bb 80 00 00 00            	movl	128(%rbx), %edi
    cfca: 4c 8d 4c 24 50               	leaq	80(%rsp), %r9
; 	load_attr.log_buf = log_buf;
    cfcf: 4c 89 a4 24 b0 00 00 00      	movq	%r12, 176(%rsp)
; 	load_attr.log_size = log_buf_size;
    cfd7: 89 ac 24 ac 00 00 00         	movl	%ebp, 172(%rsp)
; 	load_attr.log_level = log_level;
    cfde: c7 84 24 a8 00 00 00 00 00 00 00     	movl	$0, 168(%rsp)
; 	ret = bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
    cfe9: e8 62 8c 01 00               	callq	0x25c50 <bpf_prog_load>
; 	if (ret >= 0) {
    cfee: 85 c0                        	testl	%eax, %eax
    cff0: 0f 89 62 02 00 00            	jns	0xd258 <bpf_object_load_prog+0x4d8>
; 		log_level = 1;
    cff6: c7 44 24 08 01 00 00 00      	movl	$1, 8(%rsp)
; 		if (prog->log_buf) {
    cffe: 4c 8b 6b 58                  	movq	88(%rbx), %r13
    d002: 4d 85 ed                     	testq	%r13, %r13
    d005: 0f 84 f5 fe ff ff            	je	0xcf00 <bpf_object_load_prog+0x180>
; 			log_buf_size = prog->log_size;
    d00b: 4d 89 ec                     	movq	%r13, %r12
    d00e: 48 8b 6b 60                  	movq	96(%rbx), %rbp
    d012: 4c 8b 6c 24 20               	movq	32(%rsp), %r13
; 	load_attr.log_level = log_level;
    d017: 8b 44 24 08                  	movl	8(%rsp), %eax
; 	ret = bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
    d01b: 8b bb 80 00 00 00            	movl	128(%rbx), %edi
    d021: 4c 89 e9                     	movq	%r13, %rcx
    d024: 4c 89 f2                     	movq	%r14, %rdx
    d027: 4c 63 44 24 10               	movslq	16(%rsp), %r8
    d02c: 4c 8d 4c 24 50               	leaq	80(%rsp), %r9
    d031: 4c 89 fe                     	movq	%r15, %rsi
; 	load_attr.log_buf = log_buf;
    d034: 4c 89 a4 24 b0 00 00 00      	movq	%r12, 176(%rsp)
; 	load_attr.log_size = log_buf_size;
    d03c: 89 ac 24 ac 00 00 00         	movl	%ebp, 172(%rsp)
; 	load_attr.log_level = log_level;
    d043: 89 84 24 a8 00 00 00         	movl	%eax, 168(%rsp)
; 	ret = bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
    d04a: e8 01 8c 01 00               	callq	0x25c50 <bpf_prog_load>
    d04f: 41 89 c1                     	movl	%eax, %r9d
; 	if (ret >= 0) {
    d052: 85 c0                        	testl	%eax, %eax
    d054: 0f 89 f5 06 00 00            	jns	0xd74f <bpf_object_load_prog+0x9cf>
; 	if (own_log_buf && errno == ENOSPC && log_buf_size <= UINT_MAX / 2)
    d05a: e8 91 86 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    d05f: 44 8b 00                     	movl	(%rax), %r8d
    d062: 49 89 c3                     	movq	%rax, %r11
; 	ret = -errno;
    d065: 45 89 c2                     	movl	%r8d, %r10d
; 	log_sz = strlen(buf) + 1;
    d068: 4c 89 e7                     	movq	%r12, %rdi
    d06b: 4c 89 5c 24 18               	movq	%r11, 24(%rsp)
; 	ret = -errno;
    d070: 41 f7 da                     	negl	%r10d
    d073: 44 89 44 24 10               	movl	%r8d, 16(%rsp)
    d078: 44 89 54 24 08               	movl	%r10d, 8(%rsp)
; 	log_sz = strlen(buf) + 1;
    d07d: e8 5e 87 ff ff               	callq	0x57e0 <.plt.sec+0x170>
; 	if (cur == buf) /* end of a log buf */
    d082: 44 8b 54 24 08               	movl	8(%rsp), %r10d
    d087: 44 8b 44 24 10               	movl	16(%rsp), %r8d
; 	next_line = buf + log_sz - 1;
    d08c: 4d 8d 3c 04                  	leaq	(%r12,%rax), %r15
; 	log_sz = strlen(buf) + 1;
    d090: 48 8d 70 01                  	leaq	1(%rax), %rsi
; 	if (cur == buf) /* end of a log buf */
    d094: 4c 8b 5c 24 18               	movq	24(%rsp), %r11
    d099: 4d 39 e7                     	cmpq	%r12, %r15
; 	log_sz = strlen(buf) + 1;
    d09c: 48 89 74 24 28               	movq	%rsi, 40(%rsp)
; 	if (cur == buf) /* end of a log buf */
    d0a1: 0f 84 c5 04 00 00            	je	0xd56c <bpf_object_load_prog+0x7ec>
; 	for (i = 0; i < max_last_line_cnt; i++, next_line = cur_line) {
    d0a7: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
    d0af: 4d 89 e6                     	movq	%r12, %r14
    d0b2: 4d 89 dd                     	movq	%r11, %r13
    d0b5: 49 89 dc                     	movq	%rbx, %r12
    d0b8: 44 89 44 24 20               	movl	%r8d, 32(%rsp)
    d0bd: 48 89 6c 24 18               	movq	%rbp, 24(%rsp)
    d0c2: 44 89 54 24 10               	movl	%r10d, 16(%rsp)
; 	p = cur - 1;
    d0c7: 49 8d 5f ff                  	leaq	-1(%r15), %rbx
; 	while (p - 1 >= buf && *(p - 1) != '\n')
    d0cb: eb 08                        	jmp	0xd0d5 <bpf_object_load_prog+0x355>
    d0cd: 0f 1f 00                     	nopl	(%rax)
    d0d0: 80 3b 0a                     	cmpb	$10, (%rbx)
    d0d3: 74 0c                        	je	0xd0e1 <bpf_object_load_prog+0x361>
    d0d5: 48 89 dd                     	movq	%rbx, %rbp
    d0d8: 48 83 eb 01                  	subq	$1, %rbx
    d0dc: 4c 39 f3                     	cmpq	%r14, %rbx
    d0df: 73 ef                        	jae	0xd0d0 <bpf_object_load_prog+0x350>
; 		if (str_has_pfx(cur_line, "invalid func unknown#195896080\n")) {
    d0e1: ba 1f 00 00 00               	movl	$31, %edx
    d0e6: 48 8d 35 1b 7a 02 00         	leaq	162331(%rip), %rsi      # 0x34b08 <strs.2+0x1c78>
    d0ed: 48 89 ef                     	movq	%rbp, %rdi
    d0f0: e8 2b 86 ff ff               	callq	0x5720 <.plt.sec+0xb0>
    d0f5: 85 c0                        	testl	%eax, %eax
    d0f7: 0f 84 b3 02 00 00            	je	0xd3b0 <bpf_object_load_prog+0x630>
; 		} else if (str_has_pfx(cur_line, "invalid func unknown#"MAP_LDIMM64_POISON_PFX)) {
    d0fd: ba 1b 00 00 00               	movl	$27, %edx
    d102: 48 8d 35 43 4e 02 00         	leaq	151107(%rip), %rsi      # 0x31f4c <_IO_stdin_used+0x1f4c>
    d109: 48 89 ef                     	movq	%rbp, %rdi
    d10c: e8 0f 86 ff ff               	callq	0x5720 <.plt.sec+0xb0>
; 	if (cur == buf) /* end of a log buf */
    d111: 4c 39 f5                     	cmpq	%r14, %rbp
; 		} else if (str_has_pfx(cur_line, "invalid func unknown#"MAP_LDIMM64_POISON_PFX)) {
    d114: 41 89 c1                     	movl	%eax, %r9d
; 	if (cur == buf) /* end of a log buf */
    d117: 0f 94 c0                     	sete	%al
    d11a: 45 85 c9                     	testl	%r9d, %r9d
    d11d: 0f 85 d5 04 00 00            	jne	0xd5f8 <bpf_object_load_prog+0x878>
    d123: 84 c0                        	testb	%al, %al
    d125: 0f 85 cd 04 00 00            	jne	0xd5f8 <bpf_object_load_prog+0x878>
    d12b: 4c 89 e0                     	movq	%r12, %rax
    d12e: 48 8b 6c 24 18               	movq	24(%rsp), %rbp
    d133: 4d 89 f4                     	movq	%r14, %r12
    d136: 44 8b 54 24 10               	movl	16(%rsp), %r10d
    d13b: 49 89 de                     	movq	%rbx, %r14
    d13e: 4d 89 eb                     	movq	%r13, %r11
    d141: 48 89 c3                     	movq	%rax, %rbx
    d144: eb 10                        	jmp	0xd156 <bpf_object_load_prog+0x3d6>
    d146: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	while (p - 1 >= buf && *(p - 1) != '\n')
    d150: 41 80 3e 0a                  	cmpb	$10, (%r14)
    d154: 74 0c                        	je	0xd162 <bpf_object_load_prog+0x3e2>
    d156: 4d 89 f5                     	movq	%r14, %r13
    d159: 49 83 ee 01                  	subq	$1, %r14
    d15d: 4d 39 e6                     	cmpq	%r12, %r14
    d160: 73 ee                        	jae	0xd150 <bpf_object_load_prog+0x3d0>
; 	if (sscanf(line1, "%d: (%*d) call unknown#%d\n", &insn_idx, &map_idx) != 2)
    d162: 31 c0                        	xorl	%eax, %eax
    d164: 48 8d 4c 24 4c               	leaq	76(%rsp), %rcx
    d169: 48 8d 54 24 48               	leaq	72(%rsp), %rdx
    d16e: 4c 89 ef                     	movq	%r13, %rdi
    d171: 48 8d 35 f0 4d 02 00         	leaq	151024(%rip), %rsi      # 0x31f68 <_IO_stdin_used+0x1f68>
    d178: 4c 89 5c 24 10               	movq	%r11, 16(%rsp)
    d17d: 4c 8b 73 70                  	movq	112(%rbx), %r14
    d181: 44 89 54 24 08               	movl	%r10d, 8(%rsp)
    d186: e8 35 89 ff ff               	callq	0x5ac0 <.plt.sec+0x450>
    d18b: 44 8b 54 24 08               	movl	8(%rsp), %r10d
    d190: 4c 8b 5c 24 10               	movq	16(%rsp), %r11
    d195: 83 f8 02                     	cmpl	$2, %eax
    d198: 0f 85 fa 02 00 00            	jne	0xd498 <bpf_object_load_prog+0x718>
; 	map_idx -= MAP_LDIMM64_POISON_BASE;
    d19e: 8b 44 24 4c                  	movl	76(%rsp), %eax
    d1a2: 2d 40 d6 44 77               	subl	$2001000000, %eax       # imm = 0x7744D640
    d1a7: 89 44 24 4c                  	movl	%eax, 76(%rsp)
; 	if (map_idx < 0 || map_idx >= obj->nr_maps)
    d1ab: 0f 88 e7 02 00 00            	js	0xd498 <bpf_object_load_prog+0x718>
    d1b1: 48 98                        	cltq
    d1b3: 4c 89 f6                     	movq	%r14, %rsi
    d1b6: 49 3b 46 70                  	cmpq	112(%r14), %rax
    d1ba: 0f 83 d8 02 00 00            	jae	0xd498 <bpf_object_load_prog+0x718>
; 		 insn_idx, map->name);
    d1c0: 48 8d 04 80                  	leaq	(%rax,%rax,4), %rax
    d1c4: 44 89 54 24 10               	movl	%r10d, 16(%rsp)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    d1c9: 4c 8d b4 24 e0 06 00 00      	leaq	1760(%rsp), %r14
    d1d1: 48 83 ec 08                  	subq	$8, %rsp
; 		 insn_idx, map->name);
    d1d5: 48 c1 e0 05                  	shlq	$5, %rax
    d1d9: 48 03 46 68                  	addq	104(%rsi), %rax
    d1dd: 4c 89 5c 24 10               	movq	%r11, 16(%rsp)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    d1e2: 4c 89 f7                     	movq	%r14, %rdi
    d1e5: ff 70 08                     	pushq	8(%rax)
    d1e8: 44 8b 4c 24 58               	movl	88(%rsp), %r9d
    d1ed: b9 80 00 00 00               	movl	$128, %ecx
    d1f2: 31 c0                        	xorl	%eax, %eax
    d1f4: 4c 8d 05 9d 79 02 00         	leaq	162205(%rip), %r8       # 0x34b98 <strs.2+0x1d08>
    d1fb: ba 01 00 00 00               	movl	$1, %edx
    d200: be 80 00 00 00               	movl	$128, %esi
; 	patch_log(buf, buf_sz, log_sz, line1, line3 - line1, patch);
    d205: 4d 29 ef                     	subq	%r13, %r15
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    d208: e8 a3 84 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	patch_log(buf, buf_sz, log_sz, line1, line3 - line1, patch);
    d20d: 48 8b 54 24 38               	movq	56(%rsp), %rdx
    d212: 4d 89 f8                     	movq	%r15, %r8
    d215: 4d 89 f1                     	movq	%r14, %r9
    d218: 4c 89 e9                     	movq	%r13, %rcx
    d21b: 48 89 ee                     	movq	%rbp, %rsi
    d21e: 4c 89 e7                     	movq	%r12, %rdi
    d221: e8 3a 9e ff ff               	callq	0x7060 <patch_log>
; 	cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    d226: 4c 8b 5c 24 18               	movq	24(%rsp), %r11
    d22b: 58                           	popq	%rax
    d22c: 5a                           	popq	%rdx
    d22d: 44 8b 54 24 10               	movl	16(%rsp), %r10d
    d232: 45 8b 03                     	movl	(%r11), %r8d
    d235: e9 3a 03 00 00               	jmp	0xd574 <bpf_object_load_prog+0x7f4>
    d23a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			log_buf_size = obj->log_size;
    d240: 4d 89 ec                     	movq	%r13, %r12
    d243: 48 8b a8 60 01 00 00         	movq	352(%rax), %rbp
    d24a: 4c 8b 6c 24 20               	movq	32(%rsp), %r13
; 			own_log_buf = false;
    d24f: e9 c3 fd ff ff               	jmp	0xd017 <bpf_object_load_prog+0x297>
    d254: 0f 1f 40 00                  	nopl	(%rax)
; 	if (ret >= 0) {
    d258: c6 44 24 37 01               	movb	$1, 55(%rsp)
    d25d: 4d 89 e3                     	movq	%r12, %r11
    d260: 41 89 c1                     	movl	%eax, %r9d
; 		if (obj->has_rodata && kernel_supports(obj, FEAT_PROG_BIND_MAP)) {
    d263: 48 8b 44 24 18               	movq	24(%rsp), %rax
    d268: 80 b8 9a 00 00 00 00         	cmpb	$0, 154(%rax)
    d26f: 0f 85 33 02 00 00            	jne	0xd4a8 <bpf_object_load_prog+0x728>
; 		*prog_fd = ret;
    d275: 48 8b 44 24 38               	movq	56(%rsp), %rax
; 	if (own_log_buf)
    d27a: 80 7c 24 37 00               	cmpb	$0, 55(%rsp)
; 		*prog_fd = ret;
    d27f: 44 89 08                     	movl	%r9d, (%rax)
; 	if (own_log_buf)
    d282: 0f 85 84 04 00 00            	jne	0xd70c <bpf_object_load_prog+0x98c>
    d288: 45 31 d2                     	xorl	%r10d, %r10d
; }
    d28b: 48 8b 84 24 e8 08 00 00      	movq	2280(%rsp), %rax
    d293: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    d29c: 0f 85 b5 04 00 00            	jne	0xd757 <bpf_object_load_prog+0x9d7>
    d2a2: 48 81 c4 f8 08 00 00         	addq	$2296, %rsp             # imm = 0x8F8
    d2a9: 44 89 d0                     	movl	%r10d, %eax
    d2ac: 5b                           	popq	%rbx
    d2ad: 5d                           	popq	%rbp
    d2ae: 41 5c                        	popq	%r12
    d2b0: 41 5d                        	popq	%r13
    d2b2: 41 5e                        	popq	%r14
    d2b4: 41 5f                        	popq	%r15
    d2b6: c3                           	retq
    d2b7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		prog_name = prog->name;
    d2c0: 4c 8b 3b                     	movq	(%rbx), %r15
    d2c3: e9 6c fb ff ff               	jmp	0xce34 <bpf_object_load_prog+0xb4>
    d2c8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (btf_fd >= 0 && kernel_supports(obj, FEAT_BTF_FUNC)) {
    d2d0: be 03 00 00 00               	movl	$3, %esi
    d2d5: 48 89 ef                     	movq	%rbp, %rdi
    d2d8: e8 33 f1 ff ff               	callq	0xc410 <kernel_supports>
    d2dd: 84 c0                        	testb	%al, %al
    d2df: 0f 84 95 fb ff ff            	je	0xce7a <bpf_object_load_prog+0xfa>
; 		load_attr.func_info = prog->func_info;
    d2e5: 48 8b 83 98 00 00 00         	movq	152(%rbx), %rax
; 		load_attr.prog_btf_fd = btf_fd;
    d2ec: 44 89 64 24 60               	movl	%r12d, 96(%rsp)
; 		load_attr.func_info = prog->func_info;
    d2f1: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
; 		load_attr.func_info_rec_size = prog->func_info_rec_size;
    d2f9: 8b 83 a0 00 00 00            	movl	160(%rbx), %eax
    d2ff: 89 84 24 94 00 00 00         	movl	%eax, 148(%rsp)
; 		load_attr.func_info_cnt = prog->func_info_cnt;
    d306: 8b 83 a4 00 00 00            	movl	164(%rbx), %eax
    d30c: 89 84 24 90 00 00 00         	movl	%eax, 144(%rsp)
; 		load_attr.line_info = prog->line_info;
    d313: 48 8b 83 a8 00 00 00         	movq	168(%rbx), %rax
    d31a: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
; 		load_attr.line_info_rec_size = prog->line_info_rec_size;
    d322: 8b 83 b0 00 00 00            	movl	176(%rbx), %eax
    d328: 89 84 24 a4 00 00 00         	movl	%eax, 164(%rsp)
; 		load_attr.line_info_cnt = prog->line_info_cnt;
    d32f: 8b 83 b4 00 00 00            	movl	180(%rbx), %eax
    d335: 89 84 24 a0 00 00 00         	movl	%eax, 160(%rsp)
    d33c: e9 39 fb ff ff               	jmp	0xce7a <bpf_object_load_prog+0xfa>
    d341: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 				   prog - obj->programs);
    d348: 48 89 c1                     	movq	%rax, %rcx
    d34b: 48 89 d8                     	movq	%rbx, %rax
; 		bpf_gen__prog_load(obj->gen_loader, prog->type, prog->name,
    d34e: 8b b3 80 00 00 00            	movl	128(%rbx), %esi
    d354: 4d 89 e8                     	movq	%r13, %r8
; 				   prog - obj->programs);
    d357: 48 2b 41 58                  	subq	88(%rcx), %rax
; 		bpf_gen__prog_load(obj->gen_loader, prog->type, prog->name,
    d35b: 4c 89 df                     	movq	%r11, %rdi
    d35e: 4c 89 f1                     	movq	%r14, %rcx
; 				   prog - obj->programs);
    d361: 48 ba ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rdx # imm = 0xAAAAAAAAAAAAAAAB
    d36b: 48 c1 f8 06                  	sarq	$6, %rax
    d36f: 48 0f af c2                  	imulq	%rdx, %rax
; 		bpf_gen__prog_load(obj->gen_loader, prog->type, prog->name,
    d373: 48 8b 13                     	movq	(%rbx), %rdx
    d376: 50                           	pushq	%rax
    d377: 48 8d 44 24 58               	leaq	88(%rsp), %rax
    d37c: 50                           	pushq	%rax
    d37d: 4c 63 4c 24 20               	movslq	32(%rsp), %r9
    d382: e8 09 2a 01 00               	callq	0x1fd90 <bpf_gen__prog_load>
; 		*prog_fd = -1;
    d387: 48 8b 44 24 48               	movq	72(%rsp), %rax
; 		return 0;
    d38c: 45 31 d2                     	xorl	%r10d, %r10d
; 		*prog_fd = -1;
    d38f: c7 00 ff ff ff ff            	movl	$4294967295, (%rax)     # imm = 0xFFFFFFFF
; 		return 0;
    d395: 41 58                        	popq	%r8
    d397: 41 59                        	popq	%r9
    d399: e9 ed fe ff ff               	jmp	0xd28b <bpf_object_load_prog+0x50b>
    d39e: 66 90                        	nop
    d3a0: c6 44 24 37 01               	movb	$1, 55(%rsp)
    d3a5: 49 89 c3                     	movq	%rax, %r11
    d3a8: 4d 89 ec                     	movq	%r13, %r12
    d3ab: e9 b5 fc ff ff               	jmp	0xd065 <bpf_object_load_prog+0x2e5>
; 	if (cur == buf) /* end of a log buf */
    d3b0: 4c 89 e0                     	movq	%r12, %rax
    d3b3: 4d 89 eb                     	movq	%r13, %r11
    d3b6: 4d 89 f4                     	movq	%r14, %r12
    d3b9: 49 89 ed                     	movq	%rbp, %r13
    d3bc: 49 89 de                     	movq	%rbx, %r14
    d3bf: 44 8b 44 24 20               	movl	32(%rsp), %r8d
    d3c4: 48 8b 6c 24 18               	movq	24(%rsp), %rbp
    d3c9: 48 89 c3                     	movq	%rax, %rbx
    d3cc: 44 8b 54 24 10               	movl	16(%rsp), %r10d
    d3d1: 4d 39 e5                     	cmpq	%r12, %r13
    d3d4: 75 10                        	jne	0xd3e6 <bpf_object_load_prog+0x666>
    d3d6: e9 91 01 00 00               	jmp	0xd56c <bpf_object_load_prog+0x7ec>
    d3db: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	while (p - 1 >= buf && *(p - 1) != '\n')
    d3e0: 41 80 3e 0a                  	cmpb	$10, (%r14)
    d3e4: 74 0c                        	je	0xd3f2 <bpf_object_load_prog+0x672>
    d3e6: 4d 89 f5                     	movq	%r14, %r13
    d3e9: 49 83 ee 01                  	subq	$1, %r14
    d3ed: 4d 39 e6                     	cmpq	%r12, %r14
    d3f0: 73 ee                        	jae	0xd3e0 <bpf_object_load_prog+0x660>
; 	if (sscanf(line1, "%d: (%*d) call unknown#195896080\n", &insn_idx) != 1)
    d3f2: 31 c0                        	xorl	%eax, %eax
    d3f4: 48 8d 54 24 4c               	leaq	76(%rsp), %rdx
    d3f9: 4c 89 ef                     	movq	%r13, %rdi
    d3fc: 4c 89 5c 24 10               	movq	%r11, 16(%rsp)
    d401: 48 8d 35 20 77 02 00         	leaq	161568(%rip), %rsi      # 0x34b28 <strs.2+0x1c98>
    d408: 44 89 54 24 08               	movl	%r10d, 8(%rsp)
    d40d: e8 ae 86 ff ff               	callq	0x5ac0 <.plt.sec+0x450>
    d412: 44 8b 54 24 08               	movl	8(%rsp), %r10d
    d417: 4c 8b 5c 24 10               	movq	16(%rsp), %r11
    d41c: 83 f8 01                     	cmpl	$1, %eax
    d41f: 75 77                        	jne	0xd498 <bpf_object_load_prog+0x718>
; 	relo = find_relo_core(prog, insn_idx);
    d421: 8b 53 50                     	movl	80(%rbx), %edx
    d424: 8b 4c 24 4c                  	movl	76(%rsp), %ecx
; 	for (i = 0; i < prog->nr_reloc; i++) {
    d428: 48 8b 43 48                  	movq	72(%rbx), %rax
    d42c: 85 d2                        	testl	%edx, %edx
    d42e: 7e 68                        	jle	0xd498 <bpf_object_load_prog+0x718>
    d430: 83 ea 01                     	subl	$1, %edx
    d433: 48 c1 e2 04                  	shlq	$4, %rdx
    d437: 48 8d 54 10 10               	leaq	16(%rax,%rdx), %rdx
; 		if (relo->type != RELO_CORE || relo->insn_idx != insn_idx)
    d43c: 83 38 06                     	cmpl	$6, (%rax)
    d43f: 0f 85 9b 01 00 00            	jne	0xd5e0 <bpf_object_load_prog+0x860>
    d445: 3b 48 04                     	cmpl	4(%rax), %ecx
    d448: 0f 85 92 01 00 00            	jne	0xd5e0 <bpf_object_load_prog+0x860>
; 		return relo->core_relo;
    d44e: 48 8b 50 08                  	movq	8(%rax), %rdx
; 	if (!relo)
    d452: 48 85 d2                     	testq	%rdx, %rdx
    d455: 74 41                        	je	0xd498 <bpf_object_load_prog+0x718>
; 	err = bpf_core_parse_spec(prog->name, prog->obj->btf, relo, &spec);
    d457: 48 8b 43 70                  	movq	112(%rbx), %rax
    d45b: 48 8b 3b                     	movq	(%rbx), %rdi
    d45e: 44 89 54 24 10               	movl	%r10d, 16(%rsp)
    d463: 4c 8d b4 24 c0 00 00 00      	leaq	192(%rsp), %r14
    d46b: 4c 89 f1                     	movq	%r14, %rcx
    d46e: 4c 89 5c 24 08               	movq	%r11, 8(%rsp)
    d473: 48 8b b0 10 01 00 00         	movq	272(%rax), %rsi
    d47a: e8 d1 47 01 00               	callq	0x21c50 <bpf_core_parse_spec>
; 	if (err)
    d47f: 4c 8b 5c 24 08               	movq	8(%rsp), %r11
    d484: 44 8b 54 24 10               	movl	16(%rsp), %r10d
    d489: 85 c0                        	testl	%eax, %eax
    d48b: 0f 84 cc 01 00 00            	je	0xd65d <bpf_object_load_prog+0x8dd>
    d491: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    d498: 45 8b 03                     	movl	(%r11), %r8d
    d49b: 4c 8d b4 24 e0 06 00 00      	leaq	1760(%rsp), %r14
    d4a3: e9 cc 00 00 00               	jmp	0xd574 <bpf_object_load_prog+0x7f4>
; 		if (obj->has_rodata && kernel_supports(obj, FEAT_PROG_BIND_MAP)) {
    d4a8: 4c 8b 74 24 18               	movq	24(%rsp), %r14
    d4ad: be 09 00 00 00               	movl	$9, %esi
    d4b2: 44 89 4c 24 10               	movl	%r9d, 16(%rsp)
    d4b7: 4c 89 5c 24 08               	movq	%r11, 8(%rsp)
    d4bc: 4c 89 f7                     	movq	%r14, %rdi
    d4bf: e8 4c ef ff ff               	callq	0xc410 <kernel_supports>
    d4c4: 4c 8b 5c 24 08               	movq	8(%rsp), %r11
    d4c9: 44 8b 4c 24 10               	movl	16(%rsp), %r9d
    d4ce: 84 c0                        	testb	%al, %al
    d4d0: 0f 84 9f fd ff ff            	je	0xd275 <bpf_object_load_prog+0x4f5>
; 			for (i = 0; i < obj->nr_maps; i++) {
    d4d6: 49 83 7e 70 00               	cmpq	$0, 112(%r14)
    d4db: 0f 84 94 fd ff ff            	je	0xd275 <bpf_object_load_prog+0x4f5>
    d4e1: 45 31 ed                     	xorl	%r13d, %r13d
; 					pr_warn("prog '%s': failed to bind map '%s': %s\n",
    d4e4: 48 8d 2d ed 75 02 00         	leaq	161261(%rip), %rbp      # 0x34ad8 <strs.2+0x1c48>
    d4eb: 45 89 cf                     	movl	%r9d, %r15d
    d4ee: eb 0e                        	jmp	0xd4fe <bpf_object_load_prog+0x77e>
; 			for (i = 0; i < obj->nr_maps; i++) {
    d4f0: 49 83 c5 01                  	addq	$1, %r13
    d4f4: 4d 39 6e 70                  	cmpq	%r13, 112(%r14)
    d4f8: 0f 86 01 02 00 00            	jbe	0xd6ff <bpf_object_load_prog+0x97f>
; 				map = &prog->obj->maps[i];
    d4fe: 48 8b 43 70                  	movq	112(%rbx), %rax
    d502: 4f 8d 64 ad 00               	leaq	(%r13,%r13,4), %r12
    d507: 49 c1 e4 05                  	shlq	$5, %r12
    d50b: 4c 03 60 68                  	addq	104(%rax), %r12
; 				if (map->libbpf_type != LIBBPF_MAP_RODATA)
    d50f: 41 83 7c 24 58 03            	cmpl	$3, 88(%r12)
    d515: 75 d9                        	jne	0xd4f0 <bpf_object_load_prog+0x770>
; 				if (bpf_prog_bind_map(ret, bpf_map__fd(map), NULL)) {
    d517: 41 8b 74 24 18               	movl	24(%r12), %esi
    d51c: 31 d2                        	xorl	%edx, %edx
    d51e: 44 89 ff                     	movl	%r15d, %edi
    d521: e8 1a b3 01 00               	callq	0x28840 <bpf_prog_bind_map>
    d526: 85 c0                        	testl	%eax, %eax
    d528: 74 c6                        	je	0xd4f0 <bpf_object_load_prog+0x770>
; 					cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    d52a: e8 c1 81 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    d52f: 48 8d b4 24 e0 06 00 00      	leaq	1760(%rsp), %rsi
    d537: ba 80 00 00 00               	movl	$128, %edx
    d53c: 8b 38                        	movl	(%rax), %edi
    d53e: e8 8d 04 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 					pr_warn("prog '%s': failed to bind map '%s': %s\n",
    d543: 49 8b 4c 24 10               	movq	16(%r12), %rcx
    d548: 48 8b 13                     	movq	(%rbx), %rdx
    d54b: 48 89 ee                     	movq	%rbp, %rsi
; 					cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    d54e: 49 89 c0                     	movq	%rax, %r8
; 					pr_warn("prog '%s': failed to bind map '%s': %s\n",
    d551: 31 ff                        	xorl	%edi, %edi
    d553: 31 c0                        	xorl	%eax, %eax
    d555: e8 76 ab ff ff               	callq	0x80d0 <libbpf_print>
    d55a: eb 94                        	jmp	0xd4f0 <bpf_object_load_prog+0x770>
    d55c: 44 8b 44 24 20               	movl	32(%rsp), %r8d
    d561: 44 8b 54 24 10               	movl	16(%rsp), %r10d
    d566: 4c 89 e3                     	movq	%r12, %rbx
    d569: 4d 89 f4                     	movq	%r14, %r12
    d56c: 4c 8d b4 24 e0 06 00 00      	leaq	1760(%rsp), %r14
; 	cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    d574: 44 89 c7                     	movl	%r8d, %edi
    d577: ba 80 00 00 00               	movl	$128, %edx
    d57c: 4c 89 f6                     	movq	%r14, %rsi
    d57f: 44 89 54 24 08               	movl	%r10d, 8(%rsp)
    d584: e8 47 04 01 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 	pr_warn("prog '%s': BPF program load failed: %s\n", prog->name, cp);
    d589: 48 8b 13                     	movq	(%rbx), %rdx
    d58c: 31 ff                        	xorl	%edi, %edi
    d58e: 48 8d 35 53 76 02 00         	leaq	161363(%rip), %rsi      # 0x34be8 <strs.2+0x1d58>
; 	cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    d595: 48 89 c1                     	movq	%rax, %rcx
; 	pr_warn("prog '%s': BPF program load failed: %s\n", prog->name, cp);
    d598: 31 c0                        	xorl	%eax, %eax
    d59a: e8 31 ab ff ff               	callq	0x80d0 <libbpf_print>
; 	pr_perm_msg(ret);
    d59f: 8b 7c 24 08                  	movl	8(%rsp), %edi
    d5a3: e8 d8 c4 ff ff               	callq	0x9a80 <pr_perm_msg>
; 	if (own_log_buf && log_buf && log_buf[0] != '\0') {
    d5a8: 80 7c 24 37 00               	cmpb	$0, 55(%rsp)
    d5ad: 44 8b 54 24 08               	movl	8(%rsp), %r10d
    d5b2: 0f 84 d3 fc ff ff            	je	0xd28b <bpf_object_load_prog+0x50b>
    d5b8: 41 80 3c 24 00               	cmpb	$0, (%r12)
    d5bd: 75 7e                        	jne	0xd63d <bpf_object_load_prog+0x8bd>
; 		free(log_buf);
    d5bf: 4c 89 e7                     	movq	%r12, %rdi
    d5c2: 44 89 54 24 08               	movl	%r10d, 8(%rsp)
    d5c7: e8 f4 80 ff ff               	callq	0x56c0 <.plt.sec+0x50>
    d5cc: 44 8b 54 24 08               	movl	8(%rsp), %r10d
    d5d1: e9 b5 fc ff ff               	jmp	0xd28b <bpf_object_load_prog+0x50b>
    d5d6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	for (i = 0; i < prog->nr_reloc; i++) {
    d5e0: 48 83 c0 10                  	addq	$16, %rax
    d5e4: 48 39 d0                     	cmpq	%rdx, %rax
    d5e7: 0f 85 4f fe ff ff            	jne	0xd43c <bpf_object_load_prog+0x6bc>
    d5ed: e9 a6 fe ff ff               	jmp	0xd498 <bpf_object_load_prog+0x718>
    d5f2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	for (i = 0; i < max_last_line_cnt; i++, next_line = cur_line) {
    d5f8: 83 44 24 08 01               	addl	$1, 8(%rsp)
    d5fd: 8b 74 24 08                  	movl	8(%rsp), %esi
; 	if (cur == buf) /* end of a log buf */
    d601: 83 fe 0a                     	cmpl	$10, %esi
    d604: 0f 84 52 ff ff ff            	je	0xd55c <bpf_object_load_prog+0x7dc>
    d60a: 84 c0                        	testb	%al, %al
    d60c: 0f 85 4a ff ff ff            	jne	0xd55c <bpf_object_load_prog+0x7dc>
    d612: 49 89 ef                     	movq	%rbp, %r15
    d615: e9 ad fa ff ff               	jmp	0xd0c7 <bpf_object_load_prog+0x347>
; 			pr_warn("prog '%s': failed to prepare load attributes: %d\n",
    d61a: 48 8b 13                     	movq	(%rbx), %rdx
    d61d: 89 44 24 08                  	movl	%eax, 8(%rsp)
    d621: 89 c1                        	movl	%eax, %ecx
    d623: 48 8d 35 26 74 02 00         	leaq	160806(%rip), %rsi      # 0x34a50 <strs.2+0x1bc0>
    d62a: 31 ff                        	xorl	%edi, %edi
    d62c: 31 c0                        	xorl	%eax, %eax
    d62e: e8 9d aa ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
    d633: 44 8b 54 24 08               	movl	8(%rsp), %r10d
    d638: e9 4e fc ff ff               	jmp	0xd28b <bpf_object_load_prog+0x50b>
; 		pr_warn("prog '%s': -- BEGIN PROG LOAD LOG --\n%s-- END PROG LOAD LOG --\n",
    d63d: 48 8b 13                     	movq	(%rbx), %rdx
    d640: 4c 89 e1                     	movq	%r12, %rcx
    d643: 48 8d 35 46 74 02 00         	leaq	160838(%rip), %rsi      # 0x34a90 <strs.2+0x1c00>
    d64a: 31 ff                        	xorl	%edi, %edi
    d64c: 31 c0                        	xorl	%eax, %eax
    d64e: e8 7d aa ff ff               	callq	0x80d0 <libbpf_print>
; 	if (own_log_buf)
    d653: 44 8b 54 24 08               	movl	8(%rsp), %r10d
    d658: e9 62 ff ff ff               	jmp	0xd5bf <bpf_object_load_prog+0x83f>
; 	spec_len = bpf_core_format_spec(spec_buf, sizeof(spec_buf), &spec);
    d65d: 48 8d 8c 24 e0 05 00 00      	leaq	1504(%rsp), %rcx
    d665: 4c 89 f2                     	movq	%r14, %rdx
    d668: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
    d66d: 44 89 54 24 18               	movl	%r10d, 24(%rsp)
    d672: 48 89 cf                     	movq	%rcx, %rdi
    d675: 4c 89 5c 24 10               	movq	%r11, 16(%rsp)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    d67a: 4c 8d b4 24 e0 06 00 00      	leaq	1760(%rsp), %r14
; 	spec_len = bpf_core_format_spec(spec_buf, sizeof(spec_buf), &spec);
    d682: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
    d687: e8 54 4e 01 00               	callq	0x224e0 <bpf_core_format_spec>
; 	snprintf(patch, sizeof(patch),
    d68c: 48 8d 15 ca 47 02 00         	leaq	149450(%rip), %rdx      # 0x31e5d <_IO_stdin_used+0x1e5d>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    d693: be 00 02 00 00               	movl	$512, %esi              # imm = 0x200
    d698: 4c 89 f7                     	movq	%r14, %rdi
; 	snprintf(patch, sizeof(patch),
    d69b: 3d ff 00 00 00               	cmpl	$255, %eax
    d6a0: 48 8d 05 a1 48 02 00         	leaq	149665(%rip), %rax      # 0x31f48 <_IO_stdin_used+0x1f48>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    d6a7: 4c 8d 05 a2 74 02 00         	leaq	160930(%rip), %r8       # 0x34b50 <strs.2+0x1cc0>
; 	snprintf(patch, sizeof(patch),
    d6ae: 48 0f 46 c2                  	cmovbeq	%rdx, %rax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    d6b2: ba 01 00 00 00               	movl	$1, %edx
; 	patch_log(buf, buf_sz, log_sz, line1, line3 - line1, patch);
    d6b7: 4d 29 ef                     	subq	%r13, %r15
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    d6ba: 50                           	pushq	%rax
    d6bb: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
    d6c0: 31 c0                        	xorl	%eax, %eax
    d6c2: 51                           	pushq	%rcx
    d6c3: 44 8b 4c 24 5c               	movl	92(%rsp), %r9d
    d6c8: b9 00 02 00 00               	movl	$512, %ecx              # imm = 0x200
    d6cd: e8 de 7f ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	patch_log(buf, buf_sz, log_sz, line1, line3 - line1, patch);
    d6d2: 48 8b 54 24 38               	movq	56(%rsp), %rdx
    d6d7: 4d 89 f8                     	movq	%r15, %r8
    d6da: 4c 89 e9                     	movq	%r13, %rcx
    d6dd: 48 89 ee                     	movq	%rbp, %rsi
    d6e0: 4d 89 f1                     	movq	%r14, %r9
    d6e3: 4c 89 e7                     	movq	%r12, %rdi
    d6e6: e8 75 99 ff ff               	callq	0x7060 <patch_log>
; 	cp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));
    d6eb: 4c 8b 5c 24 20               	movq	32(%rsp), %r11
    d6f0: 59                           	popq	%rcx
    d6f1: 5e                           	popq	%rsi
    d6f2: 44 8b 54 24 18               	movl	24(%rsp), %r10d
    d6f7: 45 8b 03                     	movl	(%r11), %r8d
    d6fa: e9 75 fe ff ff               	jmp	0xd574 <bpf_object_load_prog+0x7f4>
    d6ff: 4c 8b 5c 24 08               	movq	8(%rsp), %r11
    d704: 45 89 f9                     	movl	%r15d, %r9d
    d707: e9 69 fb ff ff               	jmp	0xd275 <bpf_object_load_prog+0x4f5>
    d70c: 4d 89 dc                     	movq	%r11, %r12
    d70f: 45 31 d2                     	xorl	%r10d, %r10d
    d712: e9 a8 fe ff ff               	jmp	0xd5bf <bpf_object_load_prog+0x83f>
; 		return -EINVAL;
    d717: 41 ba ea ff ff ff            	movl	$4294967274, %r10d      # imm = 0xFFFFFFEA
    d71d: e9 69 fb ff ff               	jmp	0xd28b <bpf_object_load_prog+0x50b>
; 		pr_warn("prog '%s': missing BPF prog type, check ELF section name '%s'\n",
    d722: 48 8b 4e 08                  	movq	8(%rsi), %rcx
    d726: 48 8b 16                     	movq	(%rsi), %rdx
    d729: 31 ff                        	xorl	%edi, %edi
    d72b: 48 8d 35 d6 72 02 00         	leaq	160470(%rip), %rsi      # 0x34a08 <strs.2+0x1b78>
    d732: 31 c0                        	xorl	%eax, %eax
    d734: e8 97 a9 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
    d739: 41 ba ea ff ff ff            	movl	$4294967274, %r10d      # imm = 0xFFFFFFEA
    d73f: e9 47 fb ff ff               	jmp	0xd28b <bpf_object_load_prog+0x50b>
; 				ret = -ENOMEM;
    d744: 41 ba f4 ff ff ff            	movl	$4294967284, %r10d      # imm = 0xFFFFFFF4
    d74a: e9 70 fe ff ff               	jmp	0xd5bf <bpf_object_load_prog+0x83f>
; 	if (ret >= 0) {
    d74f: 4d 89 e3                     	movq	%r12, %r11
    d752: e9 0c fb ff ff               	jmp	0xd263 <bpf_object_load_prog+0x4e3>
; }
    d757: e8 a4 80 ff ff               	callq	0x5800 <.plt.sec+0x190>
; 			pr_debug("prog '%s': -- BEGIN PROG LOAD LOG --\n%s-- END PROG LOAD LOG --\n",
    d75c: 48 8b 13                     	movq	(%rbx), %rdx
; 	if (ret >= 0) {
    d75f: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 			pr_debug("prog '%s': -- BEGIN PROG LOAD LOG --\n%s-- END PROG LOAD LOG --\n",
    d763: 4c 89 e9                     	movq	%r13, %rcx
    d766: bf 02 00 00 00               	movl	$2, %edi
    d76b: 48 8d 35 1e 73 02 00         	leaq	160542(%rip), %rsi      # 0x34a90 <strs.2+0x1c00>
    d772: 31 c0                        	xorl	%eax, %eax
; 			own_log_buf = true;
    d774: c6 44 24 37 01               	movb	$1, 55(%rsp)
; 			pr_debug("prog '%s': -- BEGIN PROG LOAD LOG --\n%s-- END PROG LOAD LOG --\n",
    d779: 4c 89 6c 24 08               	movq	%r13, 8(%rsp)
    d77e: e8 4d a9 ff ff               	callq	0x80d0 <libbpf_print>
    d783: 4c 8b 5c 24 08               	movq	8(%rsp), %r11
    d788: 44 8b 4c 24 10               	movl	16(%rsp), %r9d
    d78d: e9 d1 fa ff ff               	jmp	0xd263 <bpf_object_load_prog+0x4e3>
    d792: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    d79d: 0f 1f 00                     	nopl	(%rax)

000000000000d7a0 <load_module_btfs>:
; {
    d7a0: 41 57                        	pushq	%r15
    d7a2: 41 56                        	pushq	%r14
    d7a4: 41 55                        	pushq	%r13
    d7a6: 41 54                        	pushq	%r12
    d7a8: 55                           	pushq	%rbp
    d7a9: 53                           	pushq	%rbx
    d7aa: 48 81 ec 98 00 00 00         	subq	$152, %rsp
    d7b1: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    d7ba: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
    d7c2: 31 c0                        	xorl	%eax, %eax
; 	if (obj->btf_modules_loaded)
    d7c4: 80 bf 40 01 00 00 00         	cmpb	$0, 320(%rdi)
; 	__u32 id = 0, len;
    d7cb: c7 44 24 18 00 00 00 00      	movl	$0, 24(%rsp)
; 	if (obj->btf_modules_loaded)
    d7d3: 75 0d                        	jne	0xd7e2 <load_module_btfs+0x42>
; 	if (obj->gen_loader)
    d7d5: 48 83 bf a0 00 00 00 00      	cmpq	$0, 160(%rdi)
    d7dd: 48 89 fb                     	movq	%rdi, %rbx
    d7e0: 74 36                        	je	0xd818 <load_module_btfs+0x78>
; 		return 0;
    d7e2: 45 31 e4                     	xorl	%r12d, %r12d
; }
    d7e5: 48 8b 84 24 88 00 00 00      	movq	136(%rsp), %rax
    d7ed: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    d7f6: 0f 85 73 02 00 00            	jne	0xda6f <load_module_btfs+0x2cf>
    d7fc: 48 81 c4 98 00 00 00         	addq	$152, %rsp
    d803: 44 89 e0                     	movl	%r12d, %eax
    d806: 5b                           	popq	%rbx
    d807: 5d                           	popq	%rbp
    d808: 41 5c                        	popq	%r12
    d80a: 41 5d                        	popq	%r13
    d80c: 41 5e                        	popq	%r14
    d80e: 41 5f                        	popq	%r15
    d810: c3                           	retq
    d811: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	obj->btf_modules_loaded = true;
    d818: c6 87 40 01 00 00 01         	movb	$1, 320(%rdi)
; 	if (!kernel_supports(obj, FEAT_MODULE_BTF))
    d81f: be 0a 00 00 00               	movl	$10, %esi
    d824: e8 e7 eb ff ff               	callq	0xc410 <kernel_supports>
    d829: 84 c0                        	testb	%al, %al
    d82b: 74 b5                        	je	0xd7e2 <load_module_btfs+0x42>
    d82d: 8b 7c 24 18                  	movl	24(%rsp), %edi
    d831: 48 8d 6c 24 18               	leaq	24(%rsp), %rbp
; 		if (!info.kernel_btf || strcmp(name, "vmlinux") == 0) {
    d836: 49 bd 76 6d 6c 69 6e 75 78 00	movabsq	$33906114280844662, %r13 # imm = 0x78756E696C6D76
; 		err = bpf_btf_get_next_id(id, &id);
    d840: 48 89 ee                     	movq	%rbp, %rsi
    d843: e8 58 9f 01 00               	callq	0x277a0 <bpf_btf_get_next_id>
; 		if (err && errno == ENOENT)
    d848: 85 c0                        	testl	%eax, %eax
    d84a: 74 2c                        	je	0xd878 <load_module_btfs+0xd8>
    d84c: e8 9f 7e ff ff               	callq	0x56f0 <.plt.sec+0x80>
    d851: 44 8b 20                     	movl	(%rax), %r12d
    d854: 41 83 fc 02                  	cmpl	$2, %r12d
    d858: 74 88                        	je	0xd7e2 <load_module_btfs+0x42>
; 			err = -errno;
    d85a: 41 f7 dc                     	negl	%r12d
; 			pr_warn("failed to iterate BTF objects: %d\n", err);
    d85d: 48 8d 35 b4 73 02 00         	leaq	160692(%rip), %rsi      # 0x34c18 <strs.2+0x1d88>
    d864: 31 ff                        	xorl	%edi, %edi
    d866: 31 c0                        	xorl	%eax, %eax
    d868: 44 89 e2                     	movl	%r12d, %edx
    d86b: e8 60 a8 ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
    d870: e9 70 ff ff ff               	jmp	0xd7e5 <load_module_btfs+0x45>
    d875: 0f 1f 00                     	nopl	(%rax)
; 		fd = bpf_btf_get_fd_by_id(id);
    d878: 8b 7c 24 18                  	movl	24(%rsp), %edi
    d87c: e8 3f a1 01 00               	callq	0x279c0 <bpf_btf_get_fd_by_id>
    d881: 41 89 c7                     	movl	%eax, %r15d
; 		if (fd < 0) {
    d884: 85 c0                        	testl	%eax, %eax
    d886: 79 38                        	jns	0xd8c0 <load_module_btfs+0x120>
; 			if (errno == ENOENT)
    d888: e8 63 7e ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("failed to get BTF object #%d FD: %d\n", id, err);
    d88d: 8b 7c 24 18                  	movl	24(%rsp), %edi
; 			if (errno == ENOENT)
    d891: 44 8b 20                     	movl	(%rax), %r12d
    d894: 41 83 fc 02                  	cmpl	$2, %r12d
    d898: 74 a6                        	je	0xd840 <load_module_btfs+0xa0>
; 			err = -errno;
    d89a: 41 f7 dc                     	negl	%r12d
; 			pr_warn("failed to get BTF object #%d FD: %d\n", id, err);
    d89d: 89 fa                        	movl	%edi, %edx
    d89f: 48 8d 35 a2 73 02 00         	leaq	160674(%rip), %rsi      # 0x34c48 <strs.2+0x1db8>
    d8a6: 31 ff                        	xorl	%edi, %edi
    d8a8: 44 89 e1                     	movl	%r12d, %ecx
    d8ab: 31 c0                        	xorl	%eax, %eax
    d8ad: e8 1e a8 ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
    d8b2: e9 2e ff ff ff               	jmp	0xd7e5 <load_module_btfs+0x45>
    d8b7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
    d8c0: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	return (__u64) (unsigned long) ptr;
    d8c4: 4c 8d 74 24 40               	leaq	64(%rsp), %r14
;   return __builtin___memset_chk (__dest, __ch, __len,
    d8c9: 48 8d 74 24 20               	leaq	32(%rsp), %rsi
; 		err = bpf_obj_get_info_by_fd(fd, &info, &len);
    d8ce: 89 c7                        	movl	%eax, %edi
    d8d0: 48 8d 54 24 1c               	leaq	28(%rsp), %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
    d8d5: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 		len = sizeof(info);
    d8da: c7 44 24 1c 20 00 00 00      	movl	$32, 28(%rsp)
; 	return (__u64) (unsigned long) ptr;
    d8e2: 4c 89 74 24 30               	movq	%r14, 48(%rsp)
; 		info.name_len = sizeof(name);
    d8e7: c7 44 24 38 40 00 00 00      	movl	$64, 56(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
    d8ef: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
; 		err = bpf_obj_get_info_by_fd(fd, &info, &len);
    d8f4: e8 c7 a2 01 00               	callq	0x27bc0 <bpf_obj_get_info_by_fd>
; 		if (err) {
    d8f9: 85 c0                        	testl	%eax, %eax
    d8fb: 0f 85 4a 01 00 00            	jne	0xda4b <load_module_btfs+0x2ab>
; 		if (!info.kernel_btf || strcmp(name, "vmlinux") == 0) {
    d901: 8b 44 24 3c                  	movl	60(%rsp), %eax
    d905: 85 c0                        	testl	%eax, %eax
    d907: 0f 84 c3 00 00 00            	je	0xd9d0 <load_module_btfs+0x230>
    d90d: 4c 39 6c 24 40               	cmpq	%r13, 64(%rsp)
    d912: 0f 84 b8 00 00 00            	je	0xd9d0 <load_module_btfs+0x230>
; 		btf = btf_get_from_fd(fd, obj->btf_vmlinux);
    d918: 48 8b b3 20 01 00 00         	movq	288(%rbx), %rsi
    d91f: 44 89 ff                     	movl	%r15d, %edi
    d922: e8 d9 e1 01 00               	callq	0x2bb00 <btf_get_from_fd>
    d927: 49 89 c0                     	movq	%rax, %r8
; 	if (!IS_ERR_OR_NULL(ptr))
    d92a: 48 85 c0                     	testq	%rax, %rax
    d92d: 0f 84 b5 00 00 00            	je	0xd9e8 <load_module_btfs+0x248>
    d933: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
    d939: 0f 87 a9 00 00 00            	ja	0xd9e8 <load_module_btfs+0x248>
; 		err = libbpf_ensure_mem((void **)&obj->btf_modules, &obj->btf_module_cap,
    d93f: 48 8b 83 48 01 00 00         	movq	328(%rbx), %rax
    d946: ba 20 00 00 00               	movl	$32, %edx
    d94b: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
    d950: 48 8d b3 50 01 00 00         	leaq	336(%rbx), %rsi
    d957: 48 8d bb 38 01 00 00         	leaq	312(%rbx), %rdi
    d95e: 48 8d 48 01                  	leaq	1(%rax), %rcx
    d962: e8 29 c5 01 00               	callq	0x29e90 <libbpf_ensure_mem>
    d967: 41 89 c4                     	movl	%eax, %r12d
; 		if (err)
    d96a: 85 c0                        	testl	%eax, %eax
    d96c: 0f 85 b7 00 00 00            	jne	0xda29 <load_module_btfs+0x289>
; 		mod_btf = &obj->btf_modules[obj->btf_module_cnt++];
    d972: 4c 8b a3 48 01 00 00         	movq	328(%rbx), %r12
; 		mod_btf->btf = btf;
    d979: 4c 8b 44 24 08               	movq	8(%rsp), %r8
; 		mod_btf->name = strdup(name);
    d97e: 4c 89 f7                     	movq	%r14, %rdi
; 		mod_btf = &obj->btf_modules[obj->btf_module_cnt++];
    d981: 49 8d 44 24 01               	leaq	1(%r12), %rax
    d986: 49 c1 e4 05                  	shlq	$5, %r12
    d98a: 4c 03 a3 38 01 00 00         	addq	312(%rbx), %r12
    d991: 48 89 83 48 01 00 00         	movq	%rax, 328(%rbx)
; 		mod_btf->id = id;
    d998: 8b 44 24 18                  	movl	24(%rsp), %eax
; 		mod_btf->btf = btf;
    d99c: 4d 89 04 24                  	movq	%r8, (%r12)
; 		mod_btf->id = id;
    d9a0: 41 89 44 24 10               	movl	%eax, 16(%r12)
; 		mod_btf->fd = fd;
    d9a5: 45 89 7c 24 14               	movl	%r15d, 20(%r12)
; 		mod_btf->name = strdup(name);
    d9aa: e8 61 82 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
    d9af: 49 89 44 24 08               	movq	%rax, 8(%r12)
; 		if (!mod_btf->name) {
    d9b4: 48 85 c0                     	testq	%rax, %rax
    d9b7: 0f 84 b7 00 00 00            	je	0xda74 <load_module_btfs+0x2d4>
    d9bd: 8b 7c 24 18                  	movl	24(%rsp), %edi
    d9c1: e9 7a fe ff ff               	jmp	0xd840 <load_module_btfs+0xa0>
    d9c6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 			close(fd);
    d9d0: 44 89 ff                     	movl	%r15d, %edi
    d9d3: e8 28 7f ff ff               	callq	0x5900 <.plt.sec+0x290>
; 			continue;
    d9d8: 8b 7c 24 18                  	movl	24(%rsp), %edi
    d9dc: e9 5f fe ff ff               	jmp	0xd840 <load_module_btfs+0xa0>
    d9e1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    d9e8: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
; 		if (err && errno == ENOENT)
    d9ed: e8 fe 7c ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
    d9f2: 4c 8b 44 24 08               	movq	8(%rsp), %r8
    d9f7: 49 81 f8 00 f0 ff ff         	cmpq	$-4096, %r8             # imm = 0xF000
    d9fe: 77 40                        	ja	0xda40 <load_module_btfs+0x2a0>
; 	return -errno;
    da00: 44 8b 20                     	movl	(%rax), %r12d
; 		if (err) {
    da03: 45 85 e4                     	testl	%r12d, %r12d
    da06: 0f 84 33 ff ff ff            	je	0xd93f <load_module_btfs+0x19f>
; 	return -errno;
    da0c: 41 f7 dc                     	negl	%r12d
; 			pr_warn("failed to load module [%s]'s BTF object #%d: %d\n",
    da0f: 8b 4c 24 18                  	movl	24(%rsp), %ecx
    da13: 4c 89 f2                     	movq	%r14, %rdx
    da16: 31 ff                        	xorl	%edi, %edi
    da18: 45 89 e0                     	movl	%r12d, %r8d
    da1b: 48 8d 35 86 72 02 00         	leaq	160390(%rip), %rsi      # 0x34ca8 <strs.2+0x1e18>
    da22: 31 c0                        	xorl	%eax, %eax
    da24: e8 a7 a6 ff ff               	callq	0x80d0 <libbpf_print>
; 		close(fd);
    da29: 44 89 ff                     	movl	%r15d, %edi
    da2c: e8 cf 7e ff ff               	callq	0x5900 <.plt.sec+0x290>
; 		return err;
    da31: e9 af fd ff ff               	jmp	0xd7e5 <load_module_btfs+0x45>
    da36: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
    da40: 45 89 c4                     	movl	%r8d, %r12d
    da43: 41 f7 dc                     	negl	%r12d
    da46: 44 89 20                     	movl	%r12d, (%rax)
    da49: eb b8                        	jmp	0xda03 <load_module_btfs+0x263>
; 			err = -errno;
    da4b: e8 a0 7c ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("failed to get BTF object #%d info: %d\n", id, err);
    da50: 8b 54 24 18                  	movl	24(%rsp), %edx
    da54: 48 8d 35 1d 72 02 00         	leaq	160285(%rip), %rsi      # 0x34c78 <strs.2+0x1de8>
    da5b: 31 ff                        	xorl	%edi, %edi
; 			err = -errno;
    da5d: 44 8b 20                     	movl	(%rax), %r12d
; 			pr_warn("failed to get BTF object #%d info: %d\n", id, err);
    da60: 31 c0                        	xorl	%eax, %eax
; 			err = -errno;
    da62: 41 f7 dc                     	negl	%r12d
; 			pr_warn("failed to get BTF object #%d info: %d\n", id, err);
    da65: 44 89 e1                     	movl	%r12d, %ecx
    da68: e8 63 a6 ff ff               	callq	0x80d0 <libbpf_print>
; 			goto err_out;
    da6d: eb ba                        	jmp	0xda29 <load_module_btfs+0x289>
; }
    da6f: e8 8c 7d ff ff               	callq	0x5800 <.plt.sec+0x190>
; 			err = -ENOMEM;
    da74: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
    da7a: eb ad                        	jmp	0xda29 <load_module_btfs+0x289>
    da7c: 0f 1f 40 00                  	nopl	(%rax)

000000000000da80 <find_kernel_btf_id.part.0>:
; static int find_kernel_btf_id(struct bpf_object *obj, const char *attach_name,
    da80: 41 57                        	pushq	%r15
    da82: 41 56                        	pushq	%r14
    da84: 41 55                        	pushq	%r13
    da86: 41 54                        	pushq	%r12
    da88: 55                           	pushq	%rbp
    da89: 48 89 fd                     	movq	%rdi, %rbp
    da8c: 53                           	pushq	%rbx
    da8d: 89 d3                        	movl	%edx, %ebx
    da8f: 48 81 ec c8 00 00 00         	subq	$200, %rsp
    da96: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
    da9b: 48 89 4c 24 20               	movq	%rcx, 32(%rsp)
    daa0: 4c 89 44 24 28               	movq	%r8, 40(%rsp)
    daa5: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    daae: 48 89 84 24 b8 00 00 00      	movq	%rax, 184(%rsp)
    dab6: 31 c0                        	xorl	%eax, %eax
; 	ret = load_module_btfs(obj);
    dab8: e8 e3 fc ff ff               	callq	0xd7a0 <load_module_btfs>
; 	if (ret)
    dabd: 85 c0                        	testl	%eax, %eax
    dabf: 0f 85 c3 00 00 00            	jne	0xdb88 <find_kernel_btf_id.part.0+0x108>
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
    dac5: 48 83 bd 48 01 00 00 00      	cmpq	$0, 328(%rbp)
    dacd: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
    dad5: 4c 8d 64 24 30               	leaq	48(%rsp), %r12
; 	switch (attach_type) {
    dada: 4c 8d 3d 7c 43 02 00         	leaq	148348(%rip), %r15      # 0x31e5d <_IO_stdin_used+0x1e5d>
    dae1: 4c 8d 35 a6 44 02 00         	leaq	148646(%rip), %r14      # 0x31f8e <_IO_stdin_used+0x1f8e>
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
    dae8: 0f 84 32 01 00 00            	je	0xdc20 <find_kernel_btf_id.part.0+0x1a0>
    daee: 48 89 6c 24 10               	movq	%rbp, 16(%rsp)
; 		const struct module_btf *mod = &obj->btf_modules[i];
    daf3: 48 8b 2c 24                  	movq	(%rsp), %rbp
    daf7: 48 8b 44 24 10               	movq	16(%rsp), %rax
    dafc: 48 c1 e5 05                  	shlq	$5, %rbp
    db00: 48 03 a8 38 01 00 00         	addq	312(%rax), %rbp
; 		ret = find_attach_btf_id(mod->btf, attach_name, attach_type);
    db07: 4c 8b 5d 00                  	movq	(%rbp), %r11
; 	switch (attach_type) {
    db0b: 83 fb 1c                     	cmpl	$28, %ebx
    db0e: 0f 84 d4 00 00 00            	je	0xdbe8 <find_kernel_btf_id.part.0+0x168>
    db14: 0f 87 b6 00 00 00            	ja	0xdbd0 <find_kernel_btf_id.part.0+0x150>
    db1a: 41 bd 08 00 00 00            	movl	$8, %r13d
; 		*prefix = BTF_TRACE_PREFIX;
    db20: 4c 8d 0d 5c 44 02 00         	leaq	148572(%rip), %r9       # 0x31f83 <_IO_stdin_used+0x1f83>
; 	switch (attach_type) {
    db27: 83 fb 17                     	cmpl	$23, %ebx
    db2a: 0f 85 88 00 00 00            	jne	0xdbb8 <find_kernel_btf_id.part.0+0x138>
    db30: 4c 89 5c 24 18               	movq	%r11, 24(%rsp)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    db35: 48 83 ec 08                  	subq	$8, %rsp
    db39: b9 80 00 00 00               	movl	$128, %ecx
    db3e: 31 c0                        	xorl	%eax, %eax
    db40: ff 74 24 10                  	pushq	16(%rsp)
    db44: ba 01 00 00 00               	movl	$1, %edx
    db49: be 80 00 00 00               	movl	$128, %esi
    db4e: 4c 89 e7                     	movq	%r12, %rdi
    db51: 4c 8d 05 49 44 02 00         	leaq	148553(%rip), %r8       # 0x31fa1 <_IO_stdin_used+0x1fa1>
    db58: e8 53 7b ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (ret < 0 || ret >= sizeof(btf_type_name))
    db5d: 5a                           	popq	%rdx
    db5e: 59                           	popq	%rcx
    db5f: 83 f8 7f                     	cmpl	$127, %eax
    db62: 4c 8b 5c 24 18               	movq	24(%rsp), %r11
    db67: 0f 87 e3 00 00 00            	ja	0xdc50 <find_kernel_btf_id.part.0+0x1d0>
; 	return btf__find_by_name_kind(btf, btf_type_name, kind);
    db6d: 44 89 ea                     	movl	%r13d, %edx
    db70: 4c 89 e6                     	movq	%r12, %rsi
    db73: 4c 89 df                     	movq	%r11, %rdi
    db76: e8 55 df 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
; 		if (ret > 0) {
    db7b: 85 c0                        	testl	%eax, %eax
    db7d: 0f 8f ad 00 00 00            	jg	0xdc30 <find_kernel_btf_id.part.0+0x1b0>
; 		if (ret == -ENOENT)
    db83: 83 f8 fe                     	cmpl	$-2, %eax
    db86: 74 78                        	je	0xdc00 <find_kernel_btf_id.part.0+0x180>
; }
    db88: 48 8b 94 24 b8 00 00 00      	movq	184(%rsp), %rdx
    db90: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    db99: 0f 85 bb 00 00 00            	jne	0xdc5a <find_kernel_btf_id.part.0+0x1da>
    db9f: 48 81 c4 c8 00 00 00         	addq	$200, %rsp
    dba6: 5b                           	popq	%rbx
    dba7: 5d                           	popq	%rbp
    dba8: 41 5c                        	popq	%r12
    dbaa: 41 5d                        	popq	%r13
    dbac: 41 5e                        	popq	%r14
    dbae: 41 5f                        	popq	%r15
    dbb0: c3                           	retq
    dbb1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	switch (attach_type) {
    dbb8: 83 fb 1b                     	cmpl	$27, %ebx
    dbbb: 4d 89 f1                     	movq	%r14, %r9
    dbbe: 41 bd 0c 00 00 00            	movl	$12, %r13d
    dbc4: 4d 0f 45 cf                  	cmovneq	%r15, %r9
    dbc8: e9 63 ff ff ff               	jmp	0xdb30 <find_kernel_btf_id.part.0+0xb0>
    dbcd: 0f 1f 00                     	nopl	(%rax)
    dbd0: 83 fb 2b                     	cmpl	$43, %ebx
    dbd3: 4d 89 f1                     	movq	%r14, %r9
    dbd6: 41 bd 0c 00 00 00            	movl	$12, %r13d
    dbdc: 4d 0f 45 cf                  	cmovneq	%r15, %r9
    dbe0: e9 4b ff ff ff               	jmp	0xdb30 <find_kernel_btf_id.part.0+0xb0>
    dbe5: 0f 1f 00                     	nopl	(%rax)
    dbe8: 41 bd 0c 00 00 00            	movl	$12, %r13d
; 		*prefix = BTF_ITER_PREFIX;
    dbee: 4c 8d 0d a2 43 02 00         	leaq	148386(%rip), %r9       # 0x31f97 <_IO_stdin_used+0x1f97>
    dbf5: e9 36 ff ff ff               	jmp	0xdb30 <find_kernel_btf_id.part.0+0xb0>
    dbfa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
    dc00: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
    dc05: 48 83 04 24 01               	addq	$1, (%rsp)
    dc0a: 48 8b 04 24                  	movq	(%rsp), %rax
    dc0e: 48 3b 81 48 01 00 00         	cmpq	328(%rcx), %rax
    dc15: 0f 82 d8 fe ff ff            	jb	0xdaf3 <find_kernel_btf_id.part.0+0x73>
    dc1b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	return -ESRCH;
    dc20: b8 fd ff ff ff               	movl	$4294967293, %eax       # imm = 0xFFFFFFFD
    dc25: e9 5e ff ff ff               	jmp	0xdb88 <find_kernel_btf_id.part.0+0x108>
    dc2a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			*btf_obj_fd = mod->fd;
    dc30: 8b 55 14                     	movl	20(%rbp), %edx
    dc33: 48 8b 4c 24 20               	movq	32(%rsp), %rcx
    dc38: 89 11                        	movl	%edx, (%rcx)
; 			*btf_type_id = ret;
    dc3a: 48 8b 4c 24 28               	movq	40(%rsp), %rcx
    dc3f: 89 01                        	movl	%eax, (%rcx)
; 			return 0;
    dc41: 31 c0                        	xorl	%eax, %eax
    dc43: e9 40 ff ff ff               	jmp	0xdb88 <find_kernel_btf_id.part.0+0x108>
    dc48: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		return -ENAMETOOLONG;
    dc50: b8 dc ff ff ff               	movl	$4294967260, %eax       # imm = 0xFFFFFFDC
    dc55: e9 2e ff ff ff               	jmp	0xdb88 <find_kernel_btf_id.part.0+0x108>
; }
    dc5a: e8 a1 7b ff ff               	callq	0x5800 <.plt.sec+0x190>
    dc5f: 90                           	nop

000000000000dc60 <find_ksym_btf_id.constprop.0>:
; static int find_ksym_btf_id(struct bpf_object *obj, const char *ksym_name,
    dc60: 41 57                        	pushq	%r15
    dc62: 45 31 ff                     	xorl	%r15d, %r15d
    dc65: 41 56                        	pushq	%r14
    dc67: 49 89 fe                     	movq	%rdi, %r14
    dc6a: 41 55                        	pushq	%r13
    dc6c: 41 54                        	pushq	%r12
    dc6e: 55                           	pushq	%rbp
    dc6f: 48 89 f5                     	movq	%rsi, %rbp
    dc72: 53                           	pushq	%rbx
; 	id = btf__find_by_name_kind(btf, ksym_name, kind);
    dc73: 0f b7 da                     	movzwl	%dx, %ebx
    dc76: 89 da                        	movl	%ebx, %edx
; static int find_ksym_btf_id(struct bpf_object *obj, const char *ksym_name,
    dc78: 48 83 ec 18                  	subq	$24, %rsp
; 	btf = obj->btf_vmlinux;
    dc7c: 4c 8b a7 20 01 00 00         	movq	288(%rdi), %r12
; static int find_ksym_btf_id(struct bpf_object *obj, const char *ksym_name,
    dc83: 48 89 0c 24                  	movq	%rcx, (%rsp)
; 	id = btf__find_by_name_kind(btf, ksym_name, kind);
    dc87: 4c 89 e7                     	movq	%r12, %rdi
; static int find_ksym_btf_id(struct bpf_object *obj, const char *ksym_name,
    dc8a: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
; 	id = btf__find_by_name_kind(btf, ksym_name, kind);
    dc8f: e8 3c de 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
; 	if (id == -ENOENT) {
    dc94: 83 f8 fe                     	cmpl	$-2, %eax
    dc97: 74 27                        	je	0xdcc0 <find_ksym_btf_id.constprop.0+0x60>
; 	if (id <= 0)
    dc99: 85 c0                        	testl	%eax, %eax
    dc9b: 7e 73                        	jle	0xdd10 <find_ksym_btf_id.constprop.0+0xb0>
; 	*res_btf = btf;
    dc9d: 48 8b 0c 24                  	movq	(%rsp), %rcx
; 	*res_mod_btf = mod_btf;
    dca1: 48 8b 5c 24 08               	movq	8(%rsp), %rbx
; 	*res_btf = btf;
    dca6: 4c 89 21                     	movq	%r12, (%rcx)
; 	*res_mod_btf = mod_btf;
    dca9: 4c 89 3b                     	movq	%r15, (%rbx)
; }
    dcac: 48 83 c4 18                  	addq	$24, %rsp
    dcb0: 5b                           	popq	%rbx
    dcb1: 5d                           	popq	%rbp
    dcb2: 41 5c                        	popq	%r12
    dcb4: 41 5d                        	popq	%r13
    dcb6: 41 5e                        	popq	%r14
    dcb8: 41 5f                        	popq	%r15
    dcba: c3                           	retq
    dcbb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		err = load_module_btfs(obj);
    dcc0: 4c 89 f7                     	movq	%r14, %rdi
    dcc3: e8 d8 fa ff ff               	callq	0xd7a0 <load_module_btfs>
; 		if (err)
    dcc8: 85 c0                        	testl	%eax, %eax
    dcca: 75 e0                        	jne	0xdcac <find_ksym_btf_id.constprop.0+0x4c>
; 		for (i = 0; i < obj->btf_module_cnt; i++) {
    dccc: 45 31 ed                     	xorl	%r13d, %r13d
    dccf: 49 83 be 48 01 00 00 00      	cmpq	$0, 328(%r14)
    dcd7: 74 37                        	je	0xdd10 <find_ksym_btf_id.constprop.0+0xb0>
    dcd9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			mod_btf = &obj->btf_modules[i];
    dce0: 4d 89 ef                     	movq	%r13, %r15
; 			id = btf__find_by_name_kind_own(btf, ksym_name, kind);
    dce3: 89 da                        	movl	%ebx, %edx
    dce5: 48 89 ee                     	movq	%rbp, %rsi
; 			mod_btf = &obj->btf_modules[i];
    dce8: 49 c1 e7 05                  	shlq	$5, %r15
    dcec: 4d 03 be 38 01 00 00         	addq	312(%r14), %r15
; 			btf = mod_btf->btf;
    dcf3: 4d 8b 27                     	movq	(%r15), %r12
; 			id = btf__find_by_name_kind_own(btf, ksym_name, kind);
    dcf6: 4c 89 e7                     	movq	%r12, %rdi
    dcf9: e8 b2 dd 01 00               	callq	0x2bab0 <btf__find_by_name_kind_own>
; 			if (id != -ENOENT)
    dcfe: 83 f8 fe                     	cmpl	$-2, %eax
    dd01: 75 96                        	jne	0xdc99 <find_ksym_btf_id.constprop.0+0x39>
; 		for (i = 0; i < obj->btf_module_cnt; i++) {
    dd03: 49 83 c5 01                  	addq	$1, %r13
    dd07: 4d 39 ae 48 01 00 00         	cmpq	%r13, 328(%r14)
    dd0e: 77 d0                        	ja	0xdce0 <find_ksym_btf_id.constprop.0+0x80>
; 		return -ESRCH;
    dd10: b8 fd ff ff ff               	movl	$4294967293, %eax       # imm = 0xFFFFFFFD
    dd15: eb 95                        	jmp	0xdcac <find_ksym_btf_id.constprop.0+0x4c>
    dd17: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000000dd20 <libbpf_prepare_prog_load>:
; {
    dd20: f3 0f 1e fa                  	endbr64
    dd24: 41 57                        	pushq	%r15
    dd26: 41 56                        	pushq	%r14
    dd28: 41 55                        	pushq	%r13
    dd2a: 41 54                        	pushq	%r12
    dd2c: 49 89 f4                     	movq	%rsi, %r12
    dd2f: 55                           	pushq	%rbp
    dd30: 48 89 fd                     	movq	%rdi, %rbp
    dd33: 53                           	pushq	%rbx
    dd34: 48 89 d3                     	movq	%rdx, %rbx
    dd37: 48 81 ec c8 00 00 00         	subq	$200, %rsp
    dd3e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    dd47: 48 89 84 24 b8 00 00 00      	movq	%rax, 184(%rsp)
    dd4f: 31 c0                        	xorl	%eax, %eax
; 	if ((def & SEC_EXP_ATTACH_OPT) && !kernel_supports(prog->obj, FEAT_EXP_ATTACH_TYPE))
    dd51: 83 e2 01                     	andl	$1, %edx
    dd54: 0f 85 fe 00 00 00            	jne	0xde58 <libbpf_prepare_prog_load+0x138>
; 	if (def & SEC_SLEEPABLE)
    dd5a: f6 c3 08                     	testb	$8, %bl
    dd5d: 74 06                        	je	0xdd65 <libbpf_prepare_prog_load+0x45>
; 		opts->prog_flags |= BPF_F_SLEEPABLE;
    dd5f: 41 83 4c 24 14 10            	orl	$16, 20(%r12)
; 	if (prog->type == BPF_PROG_TYPE_XDP && (def & SEC_XDP_FRAGS))
    dd65: 83 bd 80 00 00 00 06         	cmpl	$6, 128(%rbp)
    dd6c: 0f 84 ce 00 00 00            	je	0xde40 <libbpf_prepare_prog_load+0x120>
; 	return 0;
    dd72: 45 31 ed                     	xorl	%r13d, %r13d
; 	if ((def & SEC_ATTACH_BTF) && !prog->attach_btf_id) {
    dd75: 83 e3 04                     	andl	$4, %ebx
    dd78: 0f 84 92 00 00 00            	je	0xde10 <libbpf_prepare_prog_load+0xf0>
    dd7e: 8b b5 90 00 00 00            	movl	144(%rbp), %esi
    dd84: 85 f6                        	testl	%esi, %esi
    dd86: 0f 85 84 00 00 00            	jne	0xde10 <libbpf_prepare_prog_load+0xf0>
; 		attach_name = strchr(prog->sec_name, '/');
    dd8c: 48 8b 7d 08                  	movq	8(%rbp), %rdi
    dd90: be 2f 00 00 00               	movl	$47, %esi
; 		int btf_obj_fd = 0, btf_type_id = 0, err;
    dd95: c7 44 24 28 00 00 00 00      	movl	$0, 40(%rsp)
    dd9d: c7 44 24 2c 00 00 00 00      	movl	$0, 44(%rsp)
; 		attach_name = strchr(prog->sec_name, '/');
    dda5: e8 76 7a ff ff               	callq	0x5820 <.plt.sec+0x1b0>
; 		if (!attach_name) {
    ddaa: 48 85 c0                     	testq	%rax, %rax
    ddad: 0f 84 ed 00 00 00            	je	0xdea0 <libbpf_prepare_prog_load+0x180>
; 		attach_name++; /* skip over / */
    ddb3: 44 8b bd 94 00 00 00         	movl	148(%rbp), %r15d
    ddba: 4c 8b 55 70                  	movq	112(%rbp), %r10
    ddbe: 4c 8d 70 01                  	leaq	1(%rax), %r14
; 	enum bpf_attach_type attach_type = prog->expected_attach_type;
    ddc2: 8b 9d 84 00 00 00            	movl	132(%rbp), %ebx
; 	if (attach_prog_fd) {
    ddc8: 45 85 ff                     	testl	%r15d, %r15d
    ddcb: 0f 85 af 00 00 00            	jne	0xde80 <libbpf_prepare_prog_load+0x160>
; 	if (prog->obj->gen_loader) {
    ddd1: 49 8b ba a0 00 00 00         	movq	160(%r10), %rdi
    ddd8: 48 85 ff                     	testq	%rdi, %rdi
    dddb: 0f 84 df 00 00 00            	je	0xdec0 <libbpf_prepare_prog_load+0x1a0>
; 		bpf_gen__record_attach_target(prog->obj->gen_loader, attach_name, attach_type);
    dde1: 89 da                        	movl	%ebx, %edx
    dde3: 4c 89 f6                     	movq	%r14, %rsi
    dde6: 41 bd 01 00 00 00            	movl	$1, %r13d
    ddec: e8 ff 1d 01 00               	callq	0x1fbf0 <bpf_gen__record_attach_target>
; 		prog->attach_btf_id = btf_type_id;
    ddf1: 44 89 ad 90 00 00 00         	movl	%r13d, 144(%rbp)
; 		prog->attach_btf_obj_fd = btf_obj_fd;
    ddf8: 44 89 bd 8c 00 00 00         	movl	%r15d, 140(%rbp)
; 		opts->attach_btf_obj_fd = btf_obj_fd;
    ddff: 45 89 7c 24 28               	movl	%r15d, 40(%r12)
; 		opts->attach_btf_id = btf_type_id;
    de04: 45 89 6c 24 20               	movl	%r13d, 32(%r12)
; 	return 0;
    de09: 45 31 ed                     	xorl	%r13d, %r13d
    de0c: 0f 1f 40 00                  	nopl	(%rax)
; }
    de10: 48 8b 84 24 b8 00 00 00      	movq	184(%rsp), %rax
    de18: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    de21: 0f 85 05 02 00 00            	jne	0xe02c <libbpf_prepare_prog_load+0x30c>
    de27: 48 81 c4 c8 00 00 00         	addq	$200, %rsp
    de2e: 44 89 e8                     	movl	%r13d, %eax
    de31: 5b                           	popq	%rbx
    de32: 5d                           	popq	%rbp
    de33: 41 5c                        	popq	%r12
    de35: 41 5d                        	popq	%r13
    de37: 41 5e                        	popq	%r14
    de39: 41 5f                        	popq	%r15
    de3b: c3                           	retq
    de3c: 0f 1f 40 00                  	nopl	(%rax)
; 	if (prog->type == BPF_PROG_TYPE_XDP && (def & SEC_XDP_FRAGS))
    de40: f6 c3 10                     	testb	$16, %bl
    de43: 0f 84 29 ff ff ff            	je	0xdd72 <libbpf_prepare_prog_load+0x52>
; 		opts->prog_flags |= BPF_F_XDP_HAS_FRAGS;
    de49: 41 83 4c 24 14 20            	orl	$32, 20(%r12)
    de4f: e9 1e ff ff ff               	jmp	0xdd72 <libbpf_prepare_prog_load+0x52>
    de54: 0f 1f 40 00                  	nopl	(%rax)
; 	if ((def & SEC_EXP_ATTACH_OPT) && !kernel_supports(prog->obj, FEAT_EXP_ATTACH_TYPE))
    de58: 48 8b 7f 70                  	movq	112(%rdi), %rdi
    de5c: be 07 00 00 00               	movl	$7, %esi
    de61: e8 aa e5 ff ff               	callq	0xc410 <kernel_supports>
    de66: 84 c0                        	testb	%al, %al
    de68: 0f 85 ec fe ff ff            	jne	0xdd5a <libbpf_prepare_prog_load+0x3a>
; 		opts->expected_attach_type = 0;
    de6e: 41 c7 44 24 0c 00 00 00 00   	movl	$0, 12(%r12)
    de77: e9 de fe ff ff               	jmp	0xdd5a <libbpf_prepare_prog_load+0x3a>
    de7c: 0f 1f 40 00                  	nopl	(%rax)
; 		err = libbpf_find_prog_btf_id(attach_name, attach_prog_fd);
    de80: 44 89 fe                     	movl	%r15d, %esi
    de83: 4c 89 f7                     	movq	%r14, %rdi
    de86: e8 45 cb ff ff               	callq	0xa9d0 <libbpf_find_prog_btf_id>
    de8b: 41 89 c5                     	movl	%eax, %r13d
; 		if (err < 0) {
    de8e: 85 c0                        	testl	%eax, %eax
    de90: 0f 88 4a 01 00 00            	js	0xdfe0 <libbpf_prepare_prog_load+0x2c0>
; 		prog->attach_btf_id = btf_type_id;
    de96: 45 31 ff                     	xorl	%r15d, %r15d
    de99: e9 53 ff ff ff               	jmp	0xddf1 <libbpf_prepare_prog_load+0xd1>
    de9e: 66 90                        	nop
; 			pr_warn("prog '%s': no BTF-based attach target is specified, use bpf_program__set_attach_target()\n",
    dea0: 48 8b 55 00                  	movq	(%rbp), %rdx
    dea4: 48 8d 35 3d 6e 02 00         	leaq	159293(%rip), %rsi      # 0x34ce8 <strs.2+0x1e58>
    deab: 31 ff                        	xorl	%edi, %edi
; 			return -EINVAL;
    dead: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
; 			pr_warn("prog '%s': no BTF-based attach target is specified, use bpf_program__set_attach_target()\n",
    deb3: e8 18 a2 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
    deb8: e9 53 ff ff ff               	jmp	0xde10 <libbpf_prepare_prog_load+0xf0>
    debd: 0f 1f 00                     	nopl	(%rax)
; 	ret = find_attach_btf_id(obj->btf_vmlinux, attach_name, attach_type);
    dec0: 49 8b 82 20 01 00 00         	movq	288(%r10), %rax
    dec7: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	switch (attach_type) {
    decc: 83 fb 1c                     	cmpl	$28, %ebx
    decf: 0f 84 2b 01 00 00            	je	0xe000 <libbpf_prepare_prog_load+0x2e0>
    ded5: 0f 87 e5 00 00 00            	ja	0xdfc0 <libbpf_prepare_prog_load+0x2a0>
    dedb: 41 bd 08 00 00 00            	movl	$8, %r13d
    dee1: 4c 8d 0d 9b 40 02 00         	leaq	147611(%rip), %r9       # 0x31f83 <_IO_stdin_used+0x1f83>
    dee8: 83 fb 17                     	cmpl	$23, %ebx
    deeb: 74 1b                        	je	0xdf08 <libbpf_prepare_prog_load+0x1e8>
    deed: 83 fb 1b                     	cmpl	$27, %ebx
    def0: 4c 8d 0d 97 40 02 00         	leaq	147607(%rip), %r9       # 0x31f8e <_IO_stdin_used+0x1f8e>
    def7: 48 8d 05 5f 3f 02 00         	leaq	147295(%rip), %rax      # 0x31e5d <_IO_stdin_used+0x1e5d>
    defe: 41 bd 0c 00 00 00            	movl	$12, %r13d
    df04: 4c 0f 45 c8                  	cmovneq	%rax, %r9
    df08: 4c 89 54 24 10               	movq	%r10, 16(%rsp)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    df0d: 4c 8d 5c 24 30               	leaq	48(%rsp), %r11
    df12: 48 83 ec 08                  	subq	$8, %rsp
    df16: b9 80 00 00 00               	movl	$128, %ecx
    df1b: 41 56                        	pushq	%r14
    df1d: ba 01 00 00 00               	movl	$1, %edx
    df22: 4c 89 df                     	movq	%r11, %rdi
    df25: 31 c0                        	xorl	%eax, %eax
    df27: 4c 8d 05 73 40 02 00         	leaq	147571(%rip), %r8       # 0x31fa1 <_IO_stdin_used+0x1fa1>
    df2e: be 80 00 00 00               	movl	$128, %esi
    df33: 4c 89 5c 24 18               	movq	%r11, 24(%rsp)
    df38: e8 73 77 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (ret < 0 || ret >= sizeof(btf_type_name))
    df3d: 5a                           	popq	%rdx
    df3e: 59                           	popq	%rcx
    df3f: 83 f8 7f                     	cmpl	$127, %eax
    df42: 4c 8b 5c 24 08               	movq	8(%rsp), %r11
    df47: 4c 8b 54 24 10               	movq	16(%rsp), %r10
    df4c: 0f 87 cf 00 00 00            	ja	0xe021 <libbpf_prepare_prog_load+0x301>
; 	return btf__find_by_name_kind(btf, btf_type_name, kind);
    df52: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
    df57: 44 89 ea                     	movl	%r13d, %edx
    df5a: 4c 89 de                     	movq	%r11, %rsi
    df5d: 4c 89 54 24 08               	movq	%r10, 8(%rsp)
    df62: e8 69 db 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
; 	if (ret > 0) {
    df67: 4c 8b 54 24 08               	movq	8(%rsp), %r10
    df6c: 85 c0                        	testl	%eax, %eax
; 	return btf__find_by_name_kind(btf, btf_type_name, kind);
    df6e: 41 89 c5                     	movl	%eax, %r13d
; 	if (ret > 0) {
    df71: 0f 8f 7a fe ff ff            	jg	0xddf1 <libbpf_prepare_prog_load+0xd1>
; 	if (ret != -ENOENT)
    df77: 83 f8 fe                     	cmpl	$-2, %eax
    df7a: 75 1a                        	jne	0xdf96 <libbpf_prepare_prog_load+0x276>
    df7c: 48 8d 4c 24 28               	leaq	40(%rsp), %rcx
    df81: 4c 8d 44 24 2c               	leaq	44(%rsp), %r8
    df86: 89 da                        	movl	%ebx, %edx
    df88: 4c 89 f6                     	movq	%r14, %rsi
    df8b: 4c 89 d7                     	movq	%r10, %rdi
    df8e: e8 ed fa ff ff               	callq	0xda80 <find_kernel_btf_id.part.0>
    df93: 41 89 c5                     	movl	%eax, %r13d
; 	if (err) {
    df96: 45 85 ed                     	testl	%r13d, %r13d
    df99: 74 77                        	je	0xe012 <libbpf_prepare_prog_load+0x2f2>
; 		pr_warn("failed to find kernel BTF type ID of '%s': %d\n", attach_name, err);
    df9b: 44 89 e9                     	movl	%r13d, %ecx
    df9e: 4c 89 f2                     	movq	%r14, %rdx
    dfa1: 48 8d 35 e8 6d 02 00         	leaq	159208(%rip), %rsi      # 0x34d90 <strs.2+0x1f00>
    dfa8: 31 ff                        	xorl	%edi, %edi
    dfaa: 31 c0                        	xorl	%eax, %eax
    dfac: e8 1f a1 ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
    dfb1: e9 5a fe ff ff               	jmp	0xde10 <libbpf_prepare_prog_load+0xf0>
    dfb6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	switch (attach_type) {
    dfc0: 83 fb 2b                     	cmpl	$43, %ebx
    dfc3: 4c 8d 0d c4 3f 02 00         	leaq	147396(%rip), %r9       # 0x31f8e <_IO_stdin_used+0x1f8e>
    dfca: 48 8d 05 8c 3e 02 00         	leaq	147084(%rip), %rax      # 0x31e5d <_IO_stdin_used+0x1e5d>
    dfd1: 41 bd 0c 00 00 00            	movl	$12, %r13d
    dfd7: 4c 0f 45 c8                  	cmovneq	%rax, %r9
    dfdb: e9 28 ff ff ff               	jmp	0xdf08 <libbpf_prepare_prog_load+0x1e8>
; 			pr_warn("failed to find BPF program (FD %d) BTF ID for '%s': %d\n",
    dfe0: 41 89 c0                     	movl	%eax, %r8d
    dfe3: 4c 89 f1                     	movq	%r14, %rcx
    dfe6: 44 89 fa                     	movl	%r15d, %edx
    dfe9: 31 ff                        	xorl	%edi, %edi
    dfeb: 48 8d 35 5e 6d 02 00         	leaq	159070(%rip), %rsi      # 0x34d50 <strs.2+0x1ec0>
    dff2: 31 c0                        	xorl	%eax, %eax
    dff4: e8 d7 a0 ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
    dff9: e9 12 fe ff ff               	jmp	0xde10 <libbpf_prepare_prog_load+0xf0>
    dffe: 66 90                        	nop
; 	switch (attach_type) {
    e000: 41 bd 0c 00 00 00            	movl	$12, %r13d
; 		*prefix = BTF_ITER_PREFIX;
    e006: 4c 8d 0d 8a 3f 02 00         	leaq	147338(%rip), %r9       # 0x31f97 <_IO_stdin_used+0x1f97>
    e00d: e9 f6 fe ff ff               	jmp	0xdf08 <libbpf_prepare_prog_load+0x1e8>
; 		prog->attach_btf_obj_fd = btf_obj_fd;
    e012: 44 8b 7c 24 28               	movl	40(%rsp), %r15d
; 		prog->attach_btf_id = btf_type_id;
    e017: 44 8b 6c 24 2c               	movl	44(%rsp), %r13d
    e01c: e9 d0 fd ff ff               	jmp	0xddf1 <libbpf_prepare_prog_load+0xd1>
; 		return -ENAMETOOLONG;
    e021: 41 bd dc ff ff ff            	movl	$4294967260, %r13d      # imm = 0xFFFFFFDC
    e027: e9 6f ff ff ff               	jmp	0xdf9b <libbpf_prepare_prog_load+0x27b>
; }
    e02c: e8 cf 77 ff ff               	callq	0x5800 <.plt.sec+0x190>
    e031: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    e03c: 0f 1f 40 00                  	nopl	(%rax)

000000000000e040 <bpf_core_essential_name_len>:
; {
    e040: f3 0f 1e fa                  	endbr64
    e044: 53                           	pushq	%rbx
    e045: 48 89 fb                     	movq	%rdi, %rbx
; 	size_t n = strlen(name);
    e048: e8 93 77 ff ff               	callq	0x57e0 <.plt.sec+0x170>
; 	for (i = n - 5; i >= 0; i--) {
    e04d: 89 c2                        	movl	%eax, %edx
    e04f: 83 ea 05                     	subl	$5, %edx
    e052: 78 3b                        	js	0xe08f <bpf_core_essential_name_len+0x4f>
    e054: 48 63 ca                     	movslq	%edx, %rcx
    e057: 48 8d 3c 0b                  	leaq	(%rbx,%rcx), %rdi
    e05b: eb 0f                        	jmp	0xe06c <bpf_core_essential_name_len+0x2c>
    e05d: 0f 1f 00                     	nopl	(%rax)
    e060: 83 ea 01                     	subl	$1, %edx
    e063: 48 83 ef 01                  	subq	$1, %rdi
    e067: 83 fa ff                     	cmpl	$-1, %edx
    e06a: 74 23                        	je	0xe08f <bpf_core_essential_name_len+0x4f>
; 	       s[1] == '_' && s[2] == '_' && s[3] == '_' &&   /* ___ */
    e06c: 80 3f 5f                     	cmpb	$95, (%rdi)
    e06f: 74 ef                        	je	0xe060 <bpf_core_essential_name_len+0x20>
; 	return s[0] != '_' &&				      /* X */
    e071: 80 7f 01 5f                  	cmpb	$95, 1(%rdi)
    e075: 75 e9                        	jne	0xe060 <bpf_core_essential_name_len+0x20>
; 	       s[1] == '_' && s[2] == '_' && s[3] == '_' &&   /* ___ */
    e077: 80 7f 02 5f                  	cmpb	$95, 2(%rdi)
    e07b: 75 e3                        	jne	0xe060 <bpf_core_essential_name_len+0x20>
    e07d: 80 7f 03 5f                  	cmpb	$95, 3(%rdi)
    e081: 75 dd                        	jne	0xe060 <bpf_core_essential_name_len+0x20>
    e083: 80 7f 04 5f                  	cmpb	$95, 4(%rdi)
    e087: 74 d7                        	je	0xe060 <bpf_core_essential_name_len+0x20>
; 			return i + 1;
    e089: 83 c2 01                     	addl	$1, %edx
    e08c: 48 63 c2                     	movslq	%edx, %rax
; }
    e08f: 5b                           	popq	%rbx
    e090: c3                           	retq
    e091: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    e09c: 0f 1f 40 00                  	nopl	(%rax)

000000000000e0a0 <bpf_core_free_cands>:
; {
    e0a0: f3 0f 1e fa                  	endbr64
; 	if (!cands)
    e0a4: 48 85 ff                     	testq	%rdi, %rdi
    e0a7: 74 17                        	je	0xe0c0 <bpf_core_free_cands+0x20>
; {
    e0a9: 55                           	pushq	%rbp
    e0aa: 48 89 fd                     	movq	%rdi, %rbp
; 	free(cands->cands);
    e0ad: 48 8b 3f                     	movq	(%rdi), %rdi
    e0b0: e8 0b 76 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(cands);
    e0b5: 48 89 ef                     	movq	%rbp, %rdi
; }
    e0b8: 5d                           	popq	%rbp
; 	free(cands);
    e0b9: e9 02 76 ff ff               	jmp	0x56c0 <.plt.sec+0x50>
    e0be: 66 90                        	nop
    e0c0: c3                           	retq
    e0c1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    e0cc: 0f 1f 40 00                  	nopl	(%rax)

000000000000e0d0 <bpf_core_add_cands>:
; {
    e0d0: f3 0f 1e fa                  	endbr64
    e0d4: 41 57                        	pushq	%r15
    e0d6: 49 89 ff                     	movq	%rdi, %r15
    e0d9: 41 56                        	pushq	%r14
    e0db: 41 55                        	pushq	%r13
    e0dd: 41 54                        	pushq	%r12
    e0df: 55                           	pushq	%rbp
    e0e0: 48 89 d5                     	movq	%rdx, %rbp
    e0e3: 53                           	pushq	%rbx
    e0e4: 44 89 c3                     	movl	%r8d, %ebx
    e0e7: 48 83 ec 38                  	subq	$56, %rsp
    e0eb: 48 89 7c 24 20               	movq	%rdi, 32(%rsp)
    e0f0: 48 89 34 24                  	movq	%rsi, (%rsp)
; 	local_t = btf__type_by_id(local_cand->btf, local_cand->id);
    e0f4: 8b 77 08                     	movl	8(%rdi), %esi
    e0f7: 48 8b 3f                     	movq	(%rdi), %rdi
; {
    e0fa: 48 89 4c 24 28               	movq	%rcx, 40(%rsp)
    e0ff: 4c 89 4c 24 10               	movq	%r9, 16(%rsp)
; 	local_t = btf__type_by_id(local_cand->btf, local_cand->id);
    e104: e8 97 be 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	local_name = btf__str_by_offset(local_cand->btf, local_t->name_off);
    e109: 49 8b 3f                     	movq	(%r15), %rdi
    e10c: 8b 30                        	movl	(%rax), %esi
; 	local_t = btf__type_by_id(local_cand->btf, local_cand->id);
    e10e: 49 89 c4                     	movq	%rax, %r12
; 	local_name = btf__str_by_offset(local_cand->btf, local_t->name_off);
    e111: e8 da d1 01 00               	callq	0x2b2f0 <btf__str_by_offset>
; 	n = btf__type_cnt(targ_btf);
    e116: 48 89 ef                     	movq	%rbp, %rdi
; 	local_name = btf__str_by_offset(local_cand->btf, local_t->name_off);
    e119: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	n = btf__type_cnt(targ_btf);
    e11e: e8 1d be 01 00               	callq	0x29f40 <btf__type_cnt>
; 	for (i = targ_start_id; i < n; i++) {
    e123: 39 d8                        	cmpl	%ebx, %eax
    e125: 0f 8e 41 01 00 00            	jle	0xe26c <bpf_core_add_cands+0x19c>
    e12b: 41 89 c5                     	movl	%eax, %r13d
    e12e: 66 90                        	nop
; 		t = btf__type_by_id(targ_btf, i);
    e130: 89 de                        	movl	%ebx, %esi
    e132: 48 89 ef                     	movq	%rbp, %rdi
    e135: e8 66 be 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	return BTF_INFO_KIND(t->info);
    e13a: 41 0f b6 54 24 07            	movzbl	7(%r12), %edx
; 		t = btf__type_by_id(targ_btf, i);
    e140: 49 89 c6                     	movq	%rax, %r14
; 	return BTF_INFO_KIND(t->info);
    e143: 0f b6 40 07                  	movzbl	7(%rax), %eax
    e147: 83 e2 1f                     	andl	$31, %edx
    e14a: 83 e0 1f                     	andl	$31, %eax
; 	return btf_kind(t1) == btf_kind(t2) ||
    e14d: 66 39 d0                     	cmpw	%dx, %ax
    e150: 74 1f                        	je	0xe171 <bpf_core_add_cands+0xa1>
; 	return btf_is_enum(t) || btf_is_enum64(t);
    e152: 0f b7 c0                     	movzwl	%ax, %eax
    e155: be 40 00 08 00               	movl	$524352, %esi           # imm = 0x80040
    e15a: 48 0f a3 c6                  	btq	%rax, %rsi
    e15e: 0f 83 fc 00 00 00            	jae	0xe260 <bpf_core_add_cands+0x190>
    e164: 0f b7 d2                     	movzwl	%dx, %edx
    e167: 48 0f a3 d6                  	btq	%rdx, %rsi
    e16b: 0f 83 ef 00 00 00            	jae	0xe260 <bpf_core_add_cands+0x190>
; 		targ_name = btf__name_by_offset(targ_btf, t->name_off);
    e171: 41 8b 36                     	movl	(%r14), %esi
    e174: 48 89 ef                     	movq	%rbp, %rdi
    e177: e8 74 d9 01 00               	callq	0x2baf0 <btf__name_by_offset>
    e17c: 49 89 c7                     	movq	%rax, %r15
; 	return !s || !s[0];
    e17f: 48 85 c0                     	testq	%rax, %rax
    e182: 0f 84 d8 00 00 00            	je	0xe260 <bpf_core_add_cands+0x190>
    e188: 41 80 3f 00                  	cmpb	$0, (%r15)
    e18c: 0f 84 ce 00 00 00            	je	0xe260 <bpf_core_add_cands+0x190>
; 		targ_essent_len = bpf_core_essential_name_len(targ_name);
    e192: 4c 89 ff                     	movq	%r15, %rdi
    e195: e8 a6 fe ff ff               	callq	0xe040 <bpf_core_essential_name_len>
; 		if (targ_essent_len != local_essent_len)
    e19a: 48 3b 04 24                  	cmpq	(%rsp), %rax
    e19e: 0f 85 bc 00 00 00            	jne	0xe260 <bpf_core_add_cands+0x190>
; 		if (strncmp(local_name, targ_name, local_essent_len) != 0)
    e1a4: 48 8b 14 24                  	movq	(%rsp), %rdx
    e1a8: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
    e1ad: 4c 89 fe                     	movq	%r15, %rsi
    e1b0: e8 6b 75 ff ff               	callq	0x5720 <.plt.sec+0xb0>
    e1b5: 85 c0                        	testl	%eax, %eax
    e1b7: 0f 85 a3 00 00 00            	jne	0xe260 <bpf_core_add_cands+0x190>
; 	return BTF_INFO_KIND(t->info);
    e1bd: 41 0f b6 7e 07               	movzbl	7(%r14), %edi
; 		pr_debug("CO-RE relocating [%d] %s %s: found target candidate [%d] %s %s in [%s]\n",
    e1c2: 48 8d 35 ff 6b 02 00         	leaq	158719(%rip), %rsi      # 0x34dc8 <strs.2+0x1f38>
    e1c9: 41 89 d9                     	movl	%ebx, %r9d
; 	return __btf_kind_str(btf_kind(t));
    e1cc: 83 e7 1f                     	andl	$31, %edi
    e1cf: e8 bc 81 ff ff               	callq	0x6390 <__btf_kind_str>
; 	return BTF_INFO_KIND(t->info);
    e1d4: 41 0f b6 7c 24 07            	movzbl	7(%r12), %edi
; 	return __btf_kind_str(btf_kind(t));
    e1da: 49 89 c0                     	movq	%rax, %r8
    e1dd: 83 e7 1f                     	andl	$31, %edi
    e1e0: e8 ab 81 ff ff               	callq	0x6390 <__btf_kind_str>
; 		pr_debug("CO-RE relocating [%d] %s %s: found target candidate [%d] %s %s in [%s]\n",
    e1e5: 48 83 ec 08                  	subq	$8, %rsp
    e1e9: bf 02 00 00 00               	movl	$2, %edi
; 	return __btf_kind_str(btf_kind(t));
    e1ee: 48 89 c1                     	movq	%rax, %rcx
; 		pr_debug("CO-RE relocating [%d] %s %s: found target candidate [%d] %s %s in [%s]\n",
    e1f1: 48 8b 44 24 28               	movq	40(%rsp), %rax
    e1f6: 8b 50 08                     	movl	8(%rax), %edx
    e1f9: ff 74 24 30                  	pushq	48(%rsp)
    e1fd: 31 c0                        	xorl	%eax, %eax
    e1ff: 41 57                        	pushq	%r15
    e201: 41 50                        	pushq	%r8
    e203: 4c 8b 44 24 28               	movq	40(%rsp), %r8
    e208: e8 c3 9e ff ff               	callq	0x80d0 <libbpf_print>
; 		new_cands = libbpf_reallocarray(cands->cands, cands->len + 1,
    e20d: 48 8b 44 24 30               	movq	48(%rsp), %rax
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    e212: 48 83 c4 20                  	addq	$32, %rsp
; 		new_cands = libbpf_reallocarray(cands->cands, cands->len + 1,
    e216: 48 8b 38                     	movq	(%rax), %rdi
    e219: 8b 40 08                     	movl	8(%rax), %eax
    e21c: 89 44 24 1c                  	movl	%eax, 28(%rsp)
    e220: 83 c0 01                     	addl	$1, %eax
    e223: 48 98                        	cltq
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    e225: 48 89 c6                     	movq	%rax, %rsi
    e228: 48 c1 e6 04                  	shlq	$4, %rsi
    e22c: 48 c1 e8 3c                  	shrq	$60, %rax
    e230: 75 4b                        	jne	0xe27d <bpf_core_add_cands+0x1ad>
; 	return realloc(ptr, total);
    e232: e8 e9 78 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 		if (!new_cands)
    e237: 48 85 c0                     	testq	%rax, %rax
    e23a: 74 41                        	je	0xe27d <bpf_core_add_cands+0x1ad>
; 		cand = &new_cands[cands->len];
    e23c: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
    e241: 48 63 57 08                  	movslq	8(%rdi), %rdx
    e245: 48 89 d1                     	movq	%rdx, %rcx
    e248: 48 c1 e2 04                  	shlq	$4, %rdx
    e24c: 48 01 c2                     	addq	%rax, %rdx
; 		cands->len++;
    e24f: 83 c1 01                     	addl	$1, %ecx
; 		cand->btf = targ_btf;
    e252: 48 89 2a                     	movq	%rbp, (%rdx)
; 		cand->id = i;
    e255: 89 5a 08                     	movl	%ebx, 8(%rdx)
; 		cands->cands = new_cands;
    e258: 48 89 07                     	movq	%rax, (%rdi)
; 		cands->len++;
    e25b: 89 4f 08                     	movl	%ecx, 8(%rdi)
    e25e: 66 90                        	nop
; 	for (i = targ_start_id; i < n; i++) {
    e260: 83 c3 01                     	addl	$1, %ebx
    e263: 41 39 dd                     	cmpl	%ebx, %r13d
    e266: 0f 85 c4 fe ff ff            	jne	0xe130 <bpf_core_add_cands+0x60>
; }
    e26c: 48 83 c4 38                  	addq	$56, %rsp
; 	return 0;
    e270: 31 c0                        	xorl	%eax, %eax
; }
    e272: 5b                           	popq	%rbx
    e273: 5d                           	popq	%rbp
    e274: 41 5c                        	popq	%r12
    e276: 41 5d                        	popq	%r13
    e278: 41 5e                        	popq	%r14
    e27a: 41 5f                        	popq	%r15
    e27c: c3                           	retq
    e27d: 48 83 c4 38                  	addq	$56, %rsp
; 			return -ENOMEM;
    e281: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
; }
    e286: 5b                           	popq	%rbx
    e287: 5d                           	popq	%rbp
    e288: 41 5c                        	popq	%r12
    e28a: 41 5d                        	popq	%r13
    e28c: 41 5e                        	popq	%r14
    e28e: 41 5f                        	popq	%r15
    e290: c3                           	retq
    e291: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    e29c: 0f 1f 40 00                  	nopl	(%rax)

000000000000e2a0 <bpf_core_resolve_relo>:
; {
    e2a0: 41 57                        	pushq	%r15
    e2a2: 41 56                        	pushq	%r14
    e2a4: 41 55                        	pushq	%r13
    e2a6: 49 89 fd                     	movq	%rdi, %r13
    e2a9: 41 54                        	pushq	%r12
    e2ab: 49 89 cc                     	movq	%rcx, %r12
; 	struct bpf_core_spec specs_scratch[3] = {};
    e2ae: b9 ec 01 00 00               	movl	$492, %ecx              # imm = 0x1EC
; {
    e2b3: 55                           	pushq	%rbp
    e2b4: 48 89 f5                     	movq	%rsi, %rbp
    e2b7: 53                           	pushq	%rbx
    e2b8: 48 81 ec f8 0f 00 00         	subq	$4088, %rsp             # imm = 0xFF8
; 	const void *type_key = u32_as_hash_key(relo->type_id);
    e2bf: 44 8b 7e 04                  	movl	4(%rsi), %r15d
; {
    e2c3: 89 54 24 14                  	movl	%edx, 20(%rsp)
; 	struct bpf_core_spec specs_scratch[3] = {};
    e2c7: 4c 8d b4 24 80 00 00 00      	leaq	128(%rsp), %r14
; {
    e2cf: 4c 89 44 24 20               	movq	%r8, 32(%rsp)
; 	struct bpf_core_spec specs_scratch[3] = {};
    e2d4: 4c 89 f7                     	movq	%r14, %rdi
; 	local_type = btf__type_by_id(local_btf, local_id);
    e2d7: 44 89 fe                     	movl	%r15d, %esi
; {
    e2da: 4c 89 4c 24 18               	movq	%r9, 24(%rsp)
    e2df: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    e2e8: 48 89 84 24 e8 0f 00 00      	movq	%rax, 4072(%rsp)
    e2f0: 31 c0                        	xorl	%eax, %eax
; 	struct bpf_core_cand_list *cands = NULL;
    e2f2: 48 c7 44 24 68 00 00 00 00   	movq	$0, 104(%rsp)
; 	struct bpf_core_spec specs_scratch[3] = {};
    e2fb: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	const char *prog_name = prog->name;
    e2fe: 49 8b 45 00                  	movq	(%r13), %rax
; 	local_type = btf__type_by_id(local_btf, local_id);
    e302: 4c 89 e7                     	movq	%r12, %rdi
; 	const char *prog_name = prog->name;
    e305: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	local_type = btf__type_by_id(local_btf, local_id);
    e30a: e8 91 bc 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	if (!local_type)
    e30f: 48 85 c0                     	testq	%rax, %rax
    e312: 0f 84 08 03 00 00            	je	0xe620 <bpf_core_resolve_relo+0x380>
; 	local_name = btf__name_by_offset(local_btf, local_type->name_off);
    e318: 8b 30                        	movl	(%rax), %esi
    e31a: 4c 89 e7                     	movq	%r12, %rdi
    e31d: 48 89 c3                     	movq	%rax, %rbx
    e320: e8 cb d7 01 00               	callq	0x2baf0 <btf__name_by_offset>
    e325: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	if (!local_name)
    e32a: 48 85 c0                     	testq	%rax, %rax
    e32d: 0f 84 ed 02 00 00            	je	0xe620 <bpf_core_resolve_relo+0x380>
; 	if (relo->kind != BPF_CORE_TYPE_ID_LOCAL &&
    e333: 83 7d 0c 06                  	cmpl	$6, 12(%rbp)
    e337: 74 1e                        	je	0xe357 <bpf_core_resolve_relo+0xb7>
; 	return (void *)(uintptr_t)x;
    e339: 44 89 f8                     	movl	%r15d, %eax
; 	    !hashmap__find(cand_cache, type_key, (void **)&cands)) {
    e33c: 48 8b 7c 24 20               	movq	32(%rsp), %rdi
    e341: 48 8d 54 24 68               	leaq	104(%rsp), %rdx
    e346: 48 89 c6                     	movq	%rax, %rsi
; 	return (void *)(uintptr_t)x;
    e349: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	    !hashmap__find(cand_cache, type_key, (void **)&cands)) {
    e34e: e8 ed 04 01 00               	callq	0x1e840 <hashmap__find>
; 	if (relo->kind != BPF_CORE_TYPE_ID_LOCAL &&
    e353: 84 c0                        	testb	%al, %al
    e355: 74 59                        	je	0xe3b0 <bpf_core_resolve_relo+0x110>
; 	return bpf_core_calc_relo_insn(prog_name, relo, relo_idx, local_btf, cands, specs_scratch,
    e357: 48 83 ec 08                  	subq	$8, %rsp
    e35b: 4c 89 e1                     	movq	%r12, %rcx
    e35e: 4d 89 f1                     	movq	%r14, %r9
    e361: 48 89 ee                     	movq	%rbp, %rsi
    e364: ff 74 24 20                  	pushq	32(%rsp)
    e368: 4c 8b 44 24 78               	movq	120(%rsp), %r8
    e36d: 8b 54 24 24                  	movl	36(%rsp), %edx
    e371: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
    e376: e8 e5 44 01 00               	callq	0x22860 <bpf_core_calc_relo_insn>
    e37b: 5a                           	popq	%rdx
    e37c: 59                           	popq	%rcx
; }
    e37d: 48 8b 94 24 e8 0f 00 00      	movq	4072(%rsp), %rdx
    e385: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    e38e: 0f 85 b2 02 00 00            	jne	0xe646 <bpf_core_resolve_relo+0x3a6>
    e394: 48 81 c4 f8 0f 00 00         	addq	$4088, %rsp             # imm = 0xFF8
    e39b: 5b                           	popq	%rbx
    e39c: 5d                           	popq	%rbp
    e39d: 41 5c                        	popq	%r12
    e39f: 41 5d                        	popq	%r13
    e3a1: 41 5e                        	popq	%r14
    e3a3: 41 5f                        	popq	%r15
    e3a5: c3                           	retq
    e3a6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	local_t = btf__type_by_id(local_btf, local_type_id);
    e3b0: 44 89 fe                     	movl	%r15d, %esi
    e3b3: 4c 89 e7                     	movq	%r12, %rdi
; 	local_cand.btf = local_btf;
    e3b6: 4c 89 64 24 70               	movq	%r12, 112(%rsp)
; 		cands = bpf_core_find_cands(prog->obj, local_btf, local_id);
    e3bb: 4d 8b 6d 70                  	movq	112(%r13), %r13
; 	struct bpf_core_cand local_cand = {};
    e3bf: c7 44 24 7c 00 00 00 00      	movl	$0, 124(%rsp)
; 	local_cand.id = local_type_id;
    e3c7: 44 89 7c 24 78               	movl	%r15d, 120(%rsp)
; 	local_t = btf__type_by_id(local_btf, local_type_id);
    e3cc: e8 cf bb 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	if (!local_t)
    e3d1: 48 85 c0                     	testq	%rax, %rax
    e3d4: 0f 84 06 01 00 00            	je	0xe4e0 <bpf_core_resolve_relo+0x240>
; 	local_name = btf__name_by_offset(local_btf, local_t->name_off);
    e3da: 8b 30                        	movl	(%rax), %esi
    e3dc: 4c 89 e7                     	movq	%r12, %rdi
    e3df: e8 0c d7 01 00               	callq	0x2baf0 <btf__name_by_offset>
    e3e4: 48 89 c7                     	movq	%rax, %rdi
; 	return !s || !s[0];
    e3e7: 48 85 c0                     	testq	%rax, %rax
    e3ea: 0f 84 f0 00 00 00            	je	0xe4e0 <bpf_core_resolve_relo+0x240>
    e3f0: 80 38 00                     	cmpb	$0, (%rax)
    e3f3: 0f 84 e7 00 00 00            	je	0xe4e0 <bpf_core_resolve_relo+0x240>
; 	local_essent_len = bpf_core_essential_name_len(local_name);
    e3f9: e8 42 fc ff ff               	callq	0xe040 <bpf_core_essential_name_len>
; 	cands = calloc(1, sizeof(*cands));
    e3fe: be 10 00 00 00               	movl	$16, %esi
    e403: bf 01 00 00 00               	movl	$1, %edi
; 	local_essent_len = bpf_core_essential_name_len(local_name);
    e408: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 	cands = calloc(1, sizeof(*cands));
    e40d: e8 7e 75 ff ff               	callq	0x5990 <.plt.sec+0x320>
    e412: 49 89 c2                     	movq	%rax, %r10
; 	if (!cands)
    e415: 48 85 c0                     	testq	%rax, %rax
    e418: 0f 84 2d 02 00 00            	je	0xe64b <bpf_core_resolve_relo+0x3ab>
; 	main_btf = obj->btf_vmlinux_override ?: obj->btf_vmlinux;
    e41e: 49 8b 95 30 01 00 00         	movq	304(%r13), %rdx
    e425: 48 85 d2                     	testq	%rdx, %rdx
    e428: 0f 84 e2 01 00 00            	je	0xe610 <bpf_core_resolve_relo+0x370>
; 	err = bpf_core_add_cands(&local_cand, local_essent_len, main_btf, "vmlinux", 1, cands);
    e42e: 48 8b 74 24 38               	movq	56(%rsp), %rsi
    e433: 48 8d 7c 24 70               	leaq	112(%rsp), %rdi
    e438: 4d 89 d1                     	movq	%r10, %r9
    e43b: 41 b8 01 00 00 00            	movl	$1, %r8d
    e441: 48 8d 0d a0 d7 02 00         	leaq	186272(%rip), %rcx      # 0x3bbe8 <CSWTCH.126+0x22e8>
    e448: 4c 89 54 24 40               	movq	%r10, 64(%rsp)
    e44d: 48 89 7c 24 48               	movq	%rdi, 72(%rsp)
    e452: e8 79 fc ff ff               	callq	0xe0d0 <bpf_core_add_cands>
; 	if (err)
    e457: 4c 8b 54 24 40               	movq	64(%rsp), %r10
    e45c: 85 c0                        	testl	%eax, %eax
    e45e: 0f 85 84 01 00 00            	jne	0xe5e8 <bpf_core_resolve_relo+0x348>
; 	if (cands->len)
    e464: 45 8b 42 08                  	movl	8(%r10), %r8d
    e468: 45 85 c0                     	testl	%r8d, %r8d
    e46b: 75 0e                        	jne	0xe47b <bpf_core_resolve_relo+0x1db>
; 	if (obj->btf_vmlinux_override)
    e46d: 49 83 bd 30 01 00 00 00      	cmpq	$0, 304(%r13)
    e475: 0f 84 b4 00 00 00            	je	0xe52f <bpf_core_resolve_relo+0x28f>
; 		cands = bpf_core_find_cands(prog->obj, local_btf, local_id);
    e47b: 4c 89 54 24 68               	movq	%r10, 104(%rsp)
; 		if (IS_ERR(cands)) {
    e480: 49 81 fa 00 f0 ff ff         	cmpq	$-4096, %r10            # imm = 0xF000
    e487: 77 6a                        	ja	0xe4f3 <bpf_core_resolve_relo+0x253>
; 	return hashmap__insert(map, key, value, HASHMAP_SET,
    e489: 48 8b 74 24 30               	movq	48(%rsp), %rsi
    e48e: 48 8b 7c 24 20               	movq	32(%rsp), %rdi
    e493: 45 31 c9                     	xorl	%r9d, %r9d
    e496: 45 31 c0                     	xorl	%r8d, %r8d
    e499: b9 01 00 00 00               	movl	$1, %ecx
    e49e: 4c 89 d2                     	movq	%r10, %rdx
    e4a1: e8 6a 00 01 00               	callq	0x1e510 <hashmap__insert>
; 		if (err) {
    e4a6: 85 c0                        	testl	%eax, %eax
    e4a8: 0f 84 a9 fe ff ff            	je	0xe357 <bpf_core_resolve_relo+0xb7>
; 			bpf_core_free_cands(cands);
    e4ae: 48 8b 6c 24 68               	movq	104(%rsp), %rbp
; 	if (!cands)
    e4b3: 48 85 ed                     	testq	%rbp, %rbp
    e4b6: 0f 84 c1 fe ff ff            	je	0xe37d <bpf_core_resolve_relo+0xdd>
; 	free(cands->cands);
    e4bc: 48 8b 7d 00                  	movq	(%rbp), %rdi
    e4c0: 89 44 24 08                  	movl	%eax, 8(%rsp)
    e4c4: e8 f7 71 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(cands);
    e4c9: 48 89 ef                     	movq	%rbp, %rdi
    e4cc: e8 ef 71 ff ff               	callq	0x56c0 <.plt.sec+0x50>
    e4d1: 8b 44 24 08                  	movl	8(%rsp), %eax
    e4d5: e9 a3 fe ff ff               	jmp	0xe37d <bpf_core_resolve_relo+0xdd>
    e4da: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return ERR_PTR(-ENOMEM);
    e4e0: 49 c7 c2 ea ff ff ff         	movq	$-22, %r10
; 		return ERR_PTR(-EINVAL);
    e4e7: 48 c7 c0 ea ff ff ff         	movq	$-22, %rax
; 		cands = bpf_core_find_cands(prog->obj, local_btf, local_id);
    e4ee: 48 89 44 24 68               	movq	%rax, 104(%rsp)
; 	return BTF_INFO_KIND(t->info);
    e4f3: 0f b6 7b 07                  	movzbl	7(%rbx), %edi
; 			pr_warn("prog '%s': relo #%d: target candidate search failed for [%d] %s %s: %ld\n",
    e4f7: 48 8d 35 1a 69 02 00         	leaq	157978(%rip), %rsi      # 0x34e18 <strs.2+0x1f88>
    e4fe: 45 89 f8                     	movl	%r15d, %r8d
; 	return __btf_kind_str(btf_kind(t));
    e501: 83 e7 1f                     	andl	$31, %edi
    e504: e8 87 7e ff ff               	callq	0x6390 <__btf_kind_str>
; 			pr_warn("prog '%s': relo #%d: target candidate search failed for [%d] %s %s: %ld\n",
    e509: 41 52                        	pushq	%r10
    e50b: 31 ff                        	xorl	%edi, %edi
    e50d: ff 74 24 30                  	pushq	48(%rsp)
    e511: 8b 4c 24 24                  	movl	36(%rsp), %ecx
; 	return __btf_kind_str(btf_kind(t));
    e515: 49 89 c1                     	movq	%rax, %r9
; 			pr_warn("prog '%s': relo #%d: target candidate search failed for [%d] %s %s: %ld\n",
    e518: 31 c0                        	xorl	%eax, %eax
    e51a: 48 8b 54 24 18               	movq	24(%rsp), %rdx
    e51f: e8 ac 9b ff ff               	callq	0x80d0 <libbpf_print>
; 			return PTR_ERR(cands);
    e524: 8b 44 24 78                  	movl	120(%rsp), %eax
    e528: 5e                           	popq	%rsi
    e529: 5f                           	popq	%rdi
    e52a: e9 4e fe ff ff               	jmp	0xe37d <bpf_core_resolve_relo+0xdd>
; 	err = load_module_btfs(obj);
    e52f: 4c 89 ef                     	movq	%r13, %rdi
    e532: e8 69 f2 ff ff               	callq	0xd7a0 <load_module_btfs>
; 	if (err)
    e537: 4c 8b 54 24 40               	movq	64(%rsp), %r10
    e53c: 85 c0                        	testl	%eax, %eax
    e53e: 0f 85 a4 00 00 00            	jne	0xe5e8 <bpf_core_resolve_relo+0x348>
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
    e544: 49 83 bd 48 01 00 00 00      	cmpq	$0, 328(%r13)
    e54c: 0f 84 29 ff ff ff            	je	0xe47b <bpf_core_resolve_relo+0x1db>
    e552: 31 c0                        	xorl	%eax, %eax
    e554: 44 89 7c 24 40               	movl	%r15d, 64(%rsp)
    e559: 4d 89 d7                     	movq	%r10, %r15
    e55c: 48 89 5c 24 50               	movq	%rbx, 80(%rsp)
    e561: 48 89 c3                     	movq	%rax, %rbx
    e564: 48 89 6c 24 58               	movq	%rbp, 88(%rsp)
    e569: 48 8b 6c 24 38               	movq	56(%rsp), %rbp
    e56e: 4c 89 64 24 38               	movq	%r12, 56(%rsp)
    e573: 4d 89 ec                     	movq	%r13, %r12
    e576: 4c 8b 6c 24 48               	movq	72(%rsp), %r13
    e57b: eb 15                        	jmp	0xe592 <bpf_core_resolve_relo+0x2f2>
    e57d: 0f 1f 00                     	nopl	(%rax)
    e580: 48 83 c3 01                  	addq	$1, %rbx
    e584: 49 3b 9c 24 48 01 00 00      	cmpq	328(%r12), %rbx
    e58c: 0f 83 98 00 00 00            	jae	0xe62a <bpf_core_resolve_relo+0x38a>
; 					 btf__type_cnt(obj->btf_vmlinux),
    e592: 49 8b bc 24 20 01 00 00      	movq	288(%r12), %rdi
    e59a: e8 a1 b9 01 00               	callq	0x29f40 <btf__type_cnt>
; 					 obj->btf_modules[i].name,
    e59f: 48 89 da                     	movq	%rbx, %rdx
; 		err = bpf_core_add_cands(&local_cand, local_essent_len,
    e5a2: 4d 89 f9                     	movq	%r15, %r9
    e5a5: 48 89 ee                     	movq	%rbp, %rsi
; 					 obj->btf_modules[i].name,
    e5a8: 48 c1 e2 05                  	shlq	$5, %rdx
    e5ac: 49 03 94 24 38 01 00 00      	addq	312(%r12), %rdx
; 					 btf__type_cnt(obj->btf_vmlinux),
    e5b4: 41 89 c0                     	movl	%eax, %r8d
; 		err = bpf_core_add_cands(&local_cand, local_essent_len,
    e5b7: 4c 89 ef                     	movq	%r13, %rdi
    e5ba: 48 8b 4a 08                  	movq	8(%rdx), %rcx
    e5be: 48 8b 12                     	movq	(%rdx), %rdx
    e5c1: e8 0a fb ff ff               	callq	0xe0d0 <bpf_core_add_cands>
; 		if (err)
    e5c6: 85 c0                        	testl	%eax, %eax
    e5c8: 74 b6                        	je	0xe580 <bpf_core_resolve_relo+0x2e0>
    e5ca: 4d 89 fa                     	movq	%r15, %r10
    e5cd: 48 8b 5c 24 50               	movq	80(%rsp), %rbx
    e5d2: 44 8b 7c 24 40               	movl	64(%rsp), %r15d
    e5d7: 48 8b 6c 24 58               	movq	88(%rsp), %rbp
    e5dc: 4c 8b 64 24 38               	movq	56(%rsp), %r12
    e5e1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	free(cands->cands);
    e5e8: 49 8b 3a                     	movq	(%r10), %rdi
    e5eb: 4c 89 54 24 38               	movq	%r10, 56(%rsp)
    e5f0: 89 44 24 40                  	movl	%eax, 64(%rsp)
    e5f4: e8 c7 70 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(cands);
    e5f9: 48 8b 7c 24 38               	movq	56(%rsp), %rdi
    e5fe: e8 bd 70 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return ERR_PTR(err);
    e603: 4c 63 54 24 40               	movslq	64(%rsp), %r10
    e608: e9 6e fe ff ff               	jmp	0xe47b <bpf_core_resolve_relo+0x1db>
    e60d: 0f 1f 00                     	nopl	(%rax)
; 	main_btf = obj->btf_vmlinux_override ?: obj->btf_vmlinux;
    e610: 49 8b 95 20 01 00 00         	movq	288(%r13), %rdx
    e617: e9 12 fe ff ff               	jmp	0xe42e <bpf_core_resolve_relo+0x18e>
    e61c: 0f 1f 40 00                  	nopl	(%rax)
; 		return -EINVAL;
    e620: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    e625: e9 53 fd ff ff               	jmp	0xe37d <bpf_core_resolve_relo+0xdd>
    e62a: 4d 89 fa                     	movq	%r15, %r10
    e62d: 48 8b 5c 24 50               	movq	80(%rsp), %rbx
    e632: 44 8b 7c 24 40               	movl	64(%rsp), %r15d
    e637: 48 8b 6c 24 58               	movq	88(%rsp), %rbp
    e63c: 4c 8b 64 24 38               	movq	56(%rsp), %r12
    e641: e9 35 fe ff ff               	jmp	0xe47b <bpf_core_resolve_relo+0x1db>
; }
    e646: e8 b5 71 ff ff               	callq	0x5800 <.plt.sec+0x190>
    e64b: 49 c7 c2 f4 ff ff ff         	movq	$-12, %r10
; 		return ERR_PTR(-ENOMEM);
    e652: 48 c7 c0 f4 ff ff ff         	movq	$-12, %rax
    e659: e9 90 fe ff ff               	jmp	0xe4ee <bpf_core_resolve_relo+0x24e>
    e65e: 66 90                        	nop

000000000000e660 <bpf_core_types_are_compat>:
; {
    e660: f3 0f 1e fa                  	endbr64
; 	return __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id, 32);
    e664: 41 b8 20 00 00 00            	movl	$32, %r8d
    e66a: e9 21 33 01 00               	jmp	0x21990 <__bpf_core_types_are_compat>
    e66f: 90                           	nop

000000000000e670 <bpf_core_types_match>:
; {
    e670: f3 0f 1e fa                  	endbr64
; 	return __bpf_core_types_match(local_btf, local_id, targ_btf, targ_id, false, 32);
    e674: 41 b9 20 00 00 00            	movl	$32, %r9d
    e67a: 45 31 c0                     	xorl	%r8d, %r8d
    e67d: e9 fe 4a 01 00               	jmp	0x23180 <__bpf_core_types_match>
    e682: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    e68d: 0f 1f 00                     	nopl	(%rax)

000000000000e690 <libbpf_kallsyms_parse>:
; {
    e690: f3 0f 1e fa                  	endbr64
    e694: 41 57                        	pushq	%r15
    e696: 41 56                        	pushq	%r14
    e698: 41 55                        	pushq	%r13
    e69a: 41 54                        	pushq	%r12
    e69c: 49 89 f4                     	movq	%rsi, %r12
; 	f = fopen("/proc/kallsyms", "r");
    e69f: 48 8d 35 63 35 02 00         	leaq	144739(%rip), %rsi      # 0x31c09 <_IO_stdin_used+0x1c09>
; {
    e6a6: 55                           	pushq	%rbp
    e6a7: 53                           	pushq	%rbx
    e6a8: 48 81 ec 28 02 00 00         	subq	$552, %rsp              # imm = 0x228
    e6af: 48 89 7c 24 08               	movq	%rdi, 8(%rsp)
; 	f = fopen("/proc/kallsyms", "r");
    e6b4: 48 8d 3d eb 38 02 00         	leaq	145643(%rip), %rdi      # 0x31fa6 <_IO_stdin_used+0x1fa6>
; {
    e6bb: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    e6c4: 48 89 84 24 18 02 00 00      	movq	%rax, 536(%rsp)
    e6cc: 31 c0                        	xorl	%eax, %eax
; 	f = fopen("/proc/kallsyms", "r");
    e6ce: e8 3d 73 ff ff               	callq	0x5a10 <.plt.sec+0x3a0>
; 	if (!f) {
    e6d3: 48 85 c0                     	testq	%rax, %rax
    e6d6: 0f 84 d2 00 00 00            	je	0xe7ae <libbpf_kallsyms_parse+0x11e>
    e6dc: 48 89 c5                     	movq	%rax, %rbp
    e6df: 48 8d 5c 24 20               	leaq	32(%rsp), %rbx
    e6e4: 4c 8d 7c 24 17               	leaq	23(%rsp), %r15
    e6e9: 4c 8d 74 24 18               	leaq	24(%rsp), %r14
    e6ee: 4c 8d 2d c0 38 02 00         	leaq	145600(%rip), %r13      # 0x31fb5 <_IO_stdin_used+0x1fb5>
    e6f5: eb 2c                        	jmp	0xe723 <libbpf_kallsyms_parse+0x93>
    e6f7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		if (ret != 3) {
    e700: 83 f8 03                     	cmpl	$3, %eax
    e703: 75 4f                        	jne	0xe754 <libbpf_kallsyms_parse+0xc4>
; 		err = cb(sym_addr, sym_type, sym_name, ctx);
    e705: 0f be 74 24 17               	movsbl	23(%rsp), %esi
    e70a: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
    e70f: 4c 89 e1                     	movq	%r12, %rcx
    e712: 48 89 da                     	movq	%rbx, %rdx
    e715: 48 8b 44 24 08               	movq	8(%rsp), %rax
    e71a: ff d0                        	callq	*%rax
    e71c: 41 89 c0                     	movl	%eax, %r8d
; 		if (err)
    e71f: 85 c0                        	testl	%eax, %eax
    e721: 75 47                        	jne	0xe76a <libbpf_kallsyms_parse+0xda>
; 		ret = fscanf(f, "%llx %c %499s%*[^\n]\n",
    e723: 4c 89 f2                     	movq	%r14, %rdx
    e726: 49 89 d8                     	movq	%rbx, %r8
    e729: 4c 89 f9                     	movq	%r15, %rcx
    e72c: 4c 89 ee                     	movq	%r13, %rsi
    e72f: 48 89 ef                     	movq	%rbp, %rdi
    e732: 31 c0                        	xorl	%eax, %eax
    e734: e8 a7 71 ff ff               	callq	0x58e0 <.plt.sec+0x270>
    e739: 89 c2                        	movl	%eax, %edx
; 		if (ret == EOF && feof(f))
    e73b: 83 f8 ff                     	cmpl	$-1, %eax
    e73e: 75 c0                        	jne	0xe700 <libbpf_kallsyms_parse+0x70>
    e740: 48 89 ef                     	movq	%rbp, %rdi
    e743: 89 44 24 08                  	movl	%eax, 8(%rsp)
    e747: e8 b4 72 ff ff               	callq	0x5a00 <.plt.sec+0x390>
    e74c: 8b 54 24 08                  	movl	8(%rsp), %edx
    e750: 85 c0                        	testl	%eax, %eax
    e752: 75 50                        	jne	0xe7a4 <libbpf_kallsyms_parse+0x114>
; 			pr_warn("failed to read kallsyms entry: %d\n", ret);
    e754: 48 8d 35 45 67 02 00         	leaq	157509(%rip), %rsi      # 0x34ea0 <strs.2+0x2010>
    e75b: 31 ff                        	xorl	%edi, %edi
    e75d: 31 c0                        	xorl	%eax, %eax
    e75f: e8 6c 99 ff ff               	callq	0x80d0 <libbpf_print>
; 			err = -EINVAL;
    e764: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
; 	fclose(f);
    e76a: 48 89 ef                     	movq	%rbp, %rdi
    e76d: 44 89 44 24 08               	movl	%r8d, 8(%rsp)
    e772: e8 49 70 ff ff               	callq	0x57c0 <.plt.sec+0x150>
    e777: 44 8b 44 24 08               	movl	8(%rsp), %r8d
; }
    e77c: 48 8b 84 24 18 02 00 00      	movq	536(%rsp), %rax
    e784: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    e78d: 75 1a                        	jne	0xe7a9 <libbpf_kallsyms_parse+0x119>
    e78f: 48 81 c4 28 02 00 00         	addq	$552, %rsp              # imm = 0x228
    e796: 44 89 c0                     	movl	%r8d, %eax
    e799: 5b                           	popq	%rbx
    e79a: 5d                           	popq	%rbp
    e79b: 41 5c                        	popq	%r12
    e79d: 41 5d                        	popq	%r13
    e79f: 41 5e                        	popq	%r14
    e7a1: 41 5f                        	popq	%r15
    e7a3: c3                           	retq
    e7a4: 45 31 c0                     	xorl	%r8d, %r8d
    e7a7: eb c1                        	jmp	0xe76a <libbpf_kallsyms_parse+0xda>
    e7a9: e8 52 70 ff ff               	callq	0x5800 <.plt.sec+0x190>
; 		err = -errno;
    e7ae: e8 3d 6f ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to open /proc/kallsyms: %d\n", err);
    e7b3: 48 8d 35 b6 66 02 00         	leaq	157366(%rip), %rsi      # 0x34e70 <strs.2+0x1fe0>
    e7ba: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
    e7bc: 44 8b 00                     	movl	(%rax), %r8d
; 		pr_warn("failed to open /proc/kallsyms: %d\n", err);
    e7bf: 31 c0                        	xorl	%eax, %eax
; 		err = -errno;
    e7c1: 41 f7 d8                     	negl	%r8d
; 		pr_warn("failed to open /proc/kallsyms: %d\n", err);
    e7c4: 44 89 c2                     	movl	%r8d, %edx
    e7c7: 44 89 44 24 08               	movl	%r8d, 8(%rsp)
    e7cc: e8 ff 98 ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
    e7d1: 44 8b 44 24 08               	movl	8(%rsp), %r8d
    e7d6: eb a4                        	jmp	0xe77c <libbpf_kallsyms_parse+0xec>
    e7d8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000000e7e0 <bpf_program__pin>:
; {
    e7e0: f3 0f 1e fa                  	endbr64
    e7e4: 41 56                        	pushq	%r14
    e7e6: 41 55                        	pushq	%r13
    e7e8: 41 54                        	pushq	%r12
    e7ea: 55                           	pushq	%rbp
    e7eb: 53                           	pushq	%rbx
    e7ec: 48 89 fb                     	movq	%rdi, %rbx
    e7ef: 48 81 ec 90 00 00 00         	subq	$144, %rsp
; 	if (prog->fd < 0) {
    e7f6: 8b 57 78                     	movl	120(%rdi), %edx
; {
    e7f9: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    e802: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
    e80a: 31 c0                        	xorl	%eax, %eax
; 	if (prog->fd < 0) {
    e80c: 85 d2                        	testl	%edx, %edx
    e80e: 0f 88 e8 00 00 00            	js	0xe8fc <bpf_program__pin+0x11c>
; 	err = make_parent_dir(path);
    e814: 48 89 f7                     	movq	%rsi, %rdi
    e817: 49 89 f5                     	movq	%rsi, %r13
    e81a: e8 b1 b3 ff ff               	callq	0x9bd0 <make_parent_dir>
    e81f: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
    e822: 85 c0                        	testl	%eax, %eax
    e824: 74 32                        	je	0xe858 <bpf_program__pin+0x78>
; 	if (ret < 0)
    e826: 78 70                        	js	0xe898 <bpf_program__pin+0xb8>
; }
    e828: 48 8b 84 24 88 00 00 00      	movq	136(%rsp), %rax
    e830: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    e839: 0f 85 e4 00 00 00            	jne	0xe923 <bpf_program__pin+0x143>
    e83f: 48 81 c4 90 00 00 00         	addq	$144, %rsp
    e846: 44 89 e0                     	movl	%r12d, %eax
    e849: 5b                           	popq	%rbx
    e84a: 5d                           	popq	%rbp
    e84b: 41 5c                        	popq	%r12
    e84d: 41 5d                        	popq	%r13
    e84f: 41 5e                        	popq	%r14
    e851: c3                           	retq
    e852: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	err = check_path(path);
    e858: 4c 89 ef                     	movq	%r13, %rdi
    e85b: e8 70 b4 ff ff               	callq	0x9cd0 <check_path>
    e860: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
    e863: 85 c0                        	testl	%eax, %eax
    e865: 75 bf                        	jne	0xe826 <bpf_program__pin+0x46>
; 	if (bpf_obj_pin(prog->fd, path)) {
    e867: 8b 7b 78                     	movl	120(%rbx), %edi
    e86a: 4c 89 ee                     	movq	%r13, %rsi
    e86d: e8 1e 81 01 00               	callq	0x26990 <bpf_obj_pin>
    e872: 41 89 c4                     	movl	%eax, %r12d
    e875: 85 c0                        	testl	%eax, %eax
    e877: 75 37                        	jne	0xe8b0 <bpf_program__pin+0xd0>
; 	pr_debug("prog '%s': pinned at '%s'\n", prog->name, path);
    e879: 48 8b 13                     	movq	(%rbx), %rdx
    e87c: 4c 89 e9                     	movq	%r13, %rcx
    e87f: 48 8d 35 ba 66 02 00         	leaq	157370(%rip), %rsi      # 0x34f40 <strs.2+0x20b0>
    e886: 31 c0                        	xorl	%eax, %eax
    e888: bf 02 00 00 00               	movl	$2, %edi
    e88d: e8 3e 98 ff ff               	callq	0x80d0 <libbpf_print>
; 	return 0;
    e892: eb 94                        	jmp	0xe828 <bpf_program__pin+0x48>
    e894: 0f 1f 40 00                  	nopl	(%rax)
; 		errno = -ret;
    e898: e8 53 6e ff ff               	callq	0x56f0 <.plt.sec+0x80>
    e89d: 44 89 e2                     	movl	%r12d, %edx
    e8a0: f7 da                        	negl	%edx
    e8a2: 89 10                        	movl	%edx, (%rax)
    e8a4: eb 82                        	jmp	0xe828 <bpf_program__pin+0x48>
    e8a6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		err = -errno;
    e8b0: e8 3b 6e ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
    e8b5: 48 89 e6                     	movq	%rsp, %rsi
    e8b8: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
    e8bd: 44 8b 30                     	movl	(%rax), %r14d
    e8c0: 48 89 c5                     	movq	%rax, %rbp
    e8c3: 45 89 f4                     	movl	%r14d, %r12d
    e8c6: 41 f7 dc                     	negl	%r12d
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
    e8c9: 44 89 e7                     	movl	%r12d, %edi
    e8cc: e8 ff f0 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("prog '%s': failed to pin at '%s': %s\n", prog->name, path, cp);
    e8d1: 48 8b 13                     	movq	(%rbx), %rdx
    e8d4: 31 ff                        	xorl	%edi, %edi
    e8d6: 4c 89 e9                     	movq	%r13, %rcx
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
    e8d9: 49 89 c0                     	movq	%rax, %r8
; 		pr_warn("prog '%s': failed to pin at '%s': %s\n", prog->name, path, cp);
    e8dc: 48 8d 35 2d 66 02 00         	leaq	157229(%rip), %rsi      # 0x34f10 <strs.2+0x2080>
    e8e3: 31 c0                        	xorl	%eax, %eax
    e8e5: e8 e6 97 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
    e8ea: 45 85 f6                     	testl	%r14d, %r14d
    e8ed: 0f 8e 35 ff ff ff            	jle	0xe828 <bpf_program__pin+0x48>
; 		errno = -ret;
    e8f3: 44 89 75 00                  	movl	%r14d, (%rbp)
    e8f7: e9 2c ff ff ff               	jmp	0xe828 <bpf_program__pin+0x48>
; 		pr_warn("prog '%s': can't pin program that wasn't loaded\n", prog->name);
    e8fc: 48 8b 17                     	movq	(%rdi), %rdx
    e8ff: 48 8d 35 ca 65 02 00         	leaq	157130(%rip), %rsi      # 0x34ed0 <strs.2+0x2040>
    e906: 31 ff                        	xorl	%edi, %edi
; 		return libbpf_err(-EINVAL);
    e908: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("prog '%s': can't pin program that wasn't loaded\n", prog->name);
    e90e: e8 bd 97 ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
    e913: e8 d8 6d ff ff               	callq	0x56f0 <.plt.sec+0x80>
    e918: c7 00 16 00 00 00            	movl	$22, (%rax)
    e91e: e9 05 ff ff ff               	jmp	0xe828 <bpf_program__pin+0x48>
; }
    e923: e8 d8 6e ff ff               	callq	0x5800 <.plt.sec+0x190>
    e928: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000000e930 <bpf_program__unpin>:
; {
    e930: f3 0f 1e fa                  	endbr64
    e934: 41 55                        	pushq	%r13
    e936: 41 54                        	pushq	%r12
    e938: 53                           	pushq	%rbx
; 	if (prog->fd < 0) {
    e939: 8b 47 78                     	movl	120(%rdi), %eax
; {
    e93c: 48 89 fb                     	movq	%rdi, %rbx
; 	if (prog->fd < 0) {
    e93f: 85 c0                        	testl	%eax, %eax
    e941: 78 7f                        	js	0xe9c2 <bpf_program__unpin+0x92>
; 	err = check_path(path);
    e943: 48 89 f7                     	movq	%rsi, %rdi
    e946: 49 89 f5                     	movq	%rsi, %r13
    e949: e8 82 b3 ff ff               	callq	0x9cd0 <check_path>
    e94e: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
    e951: 85 c0                        	testl	%eax, %eax
    e953: 74 23                        	je	0xe978 <bpf_program__unpin+0x48>
; 	if (ret < 0)
    e955: 78 09                        	js	0xe960 <bpf_program__unpin+0x30>
; }
    e957: 44 89 e0                     	movl	%r12d, %eax
    e95a: 5b                           	popq	%rbx
    e95b: 41 5c                        	popq	%r12
    e95d: 41 5d                        	popq	%r13
    e95f: c3                           	retq
; 		errno = -ret;
    e960: e8 8b 6d ff ff               	callq	0x56f0 <.plt.sec+0x80>
    e965: 44 89 e2                     	movl	%r12d, %edx
    e968: f7 da                        	negl	%edx
    e96a: 89 10                        	movl	%edx, (%rax)
; }
    e96c: 44 89 e0                     	movl	%r12d, %eax
    e96f: 5b                           	popq	%rbx
    e970: 41 5c                        	popq	%r12
    e972: 41 5d                        	popq	%r13
    e974: c3                           	retq
    e975: 0f 1f 00                     	nopl	(%rax)
; 	err = unlink(path);
    e978: 4c 89 ef                     	movq	%r13, %rdi
    e97b: e8 80 6d ff ff               	callq	0x5700 <.plt.sec+0x90>
    e980: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
    e983: 85 c0                        	testl	%eax, %eax
    e985: 74 19                        	je	0xe9a0 <bpf_program__unpin+0x70>
; 		return libbpf_err(-errno);
    e987: e8 64 6d ff ff               	callq	0x56f0 <.plt.sec+0x80>
; }
    e98c: 5b                           	popq	%rbx
; 		return libbpf_err(-errno);
    e98d: 44 8b 20                     	movl	(%rax), %r12d
    e990: 41 f7 dc                     	negl	%r12d
; }
    e993: 44 89 e0                     	movl	%r12d, %eax
    e996: 41 5c                        	popq	%r12
    e998: 41 5d                        	popq	%r13
    e99a: c3                           	retq
    e99b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	pr_debug("prog '%s': unpinned from '%s'\n", prog->name, path);
    e9a0: 48 8b 13                     	movq	(%rbx), %rdx
    e9a3: 4c 89 e9                     	movq	%r13, %rcx
    e9a6: 31 c0                        	xorl	%eax, %eax
    e9a8: 48 8d 35 f9 65 02 00         	leaq	157177(%rip), %rsi      # 0x34fa8 <strs.2+0x2118>
    e9af: bf 02 00 00 00               	movl	$2, %edi
    e9b4: e8 17 97 ff ff               	callq	0x80d0 <libbpf_print>
; }
    e9b9: 44 89 e0                     	movl	%r12d, %eax
    e9bc: 5b                           	popq	%rbx
    e9bd: 41 5c                        	popq	%r12
    e9bf: 41 5d                        	popq	%r13
    e9c1: c3                           	retq
; 		pr_warn("prog '%s': can't unpin program that wasn't loaded\n", prog->name);
    e9c2: 48 8b 17                     	movq	(%rdi), %rdx
    e9c5: 31 c0                        	xorl	%eax, %eax
    e9c7: 31 ff                        	xorl	%edi, %edi
; 		return libbpf_err(-EINVAL);
    e9c9: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("prog '%s': can't unpin program that wasn't loaded\n", prog->name);
    e9cf: 48 8d 35 92 65 02 00         	leaq	157074(%rip), %rsi      # 0x34f68 <strs.2+0x20d8>
    e9d6: e8 f5 96 ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
    e9db: e8 10 6d ff ff               	callq	0x56f0 <.plt.sec+0x80>
    e9e0: c7 00 16 00 00 00            	movl	$22, (%rax)
    e9e6: e9 6c ff ff ff               	jmp	0xe957 <bpf_program__unpin+0x27>
    e9eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000e9f0 <bpf_map__set_pin_path>:
; {
    e9f0: f3 0f 1e fa                  	endbr64
    e9f4: 55                           	pushq	%rbp
    e9f5: 48 89 f5                     	movq	%rsi, %rbp
    e9f8: 53                           	pushq	%rbx
    e9f9: 48 89 fb                     	movq	%rdi, %rbx
    e9fc: 48 83 ec 08                  	subq	$8, %rsp
; 	if (path) {
    ea00: 48 85 f6                     	testq	%rsi, %rsi
    ea03: 74 10                        	je	0xea15 <bpf_map__set_pin_path+0x25>
; 		new = strdup(path);
    ea05: 48 89 f7                     	movq	%rsi, %rdi
    ea08: e8 03 72 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
    ea0d: 48 89 c5                     	movq	%rax, %rbp
; 		if (!new)
    ea10: 48 85 c0                     	testq	%rax, %rax
    ea13: 74 1c                        	je	0xea31 <bpf_map__set_pin_path+0x41>
; 	free(map->pin_path);
    ea15: 48 8b bb 88 00 00 00         	movq	136(%rbx), %rdi
    ea1c: e8 9f 6c ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	map->pin_path = new;
    ea21: 48 89 ab 88 00 00 00         	movq	%rbp, 136(%rbx)
; }
    ea28: 48 83 c4 08                  	addq	$8, %rsp
    ea2c: 31 c0                        	xorl	%eax, %eax
    ea2e: 5b                           	popq	%rbx
    ea2f: 5d                           	popq	%rbp
    ea30: c3                           	retq
    ea31: 58                           	popq	%rax
    ea32: 5b                           	popq	%rbx
    ea33: 5d                           	popq	%rbp
    ea34: e9 c7 91 ff ff               	jmp	0x7c00 <bpf_map__set_pin_path.part.0>
    ea39: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000ea40 <bpf_map__pin_path>:
; {
    ea40: f3 0f 1e fa                  	endbr64
; 	return map->pin_path;
    ea44: 48 8b 87 88 00 00 00         	movq	136(%rdi), %rax
; }
    ea4b: c3                           	retq
    ea4c: 0f 1f 40 00                  	nopl	(%rax)

000000000000ea50 <bpf_map__is_pinned>:
; {
    ea50: f3 0f 1e fa                  	endbr64
; 	return map->pinned;
    ea54: 0f b6 87 90 00 00 00         	movzbl	144(%rdi), %eax
; }
    ea5b: c3                           	retq
    ea5c: 0f 1f 40 00                  	nopl	(%rax)

000000000000ea60 <bpf_object__close>:
; {
    ea60: f3 0f 1e fa                  	endbr64
; 	if (IS_ERR_OR_NULL(obj))
    ea64: 48 85 ff                     	testq	%rdi, %rdi
    ea67: 74 17                        	je	0xea80 <bpf_object__close+0x20>
    ea69: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
    ea70: 77 0e                        	ja	0xea80 <bpf_object__close+0x20>
    ea72: e9 d9 93 ff ff               	jmp	0x7e50 <bpf_object__close.part.0>
    ea77: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; }
    ea80: c3                           	retq
    ea81: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    ea8c: 0f 1f 40 00                  	nopl	(%rax)

000000000000ea90 <bpf_object__name>:
; {
    ea90: f3 0f 1e fa                  	endbr64
; 	return obj ? obj->name : libbpf_err_ptr(-EINVAL);
    ea94: 48 85 ff                     	testq	%rdi, %rdi
    ea97: 74 07                        	je	0xeaa0 <bpf_object__name+0x10>
    ea99: 48 89 f8                     	movq	%rdi, %rax
; }
    ea9c: c3                           	retq
    ea9d: 0f 1f 00                     	nopl	(%rax)
; {
    eaa0: 48 83 ec 08                  	subq	$8, %rsp
; 	errno = -err;
    eaa4: e8 47 6c ff ff               	callq	0x56f0 <.plt.sec+0x80>
    eaa9: c7 00 16 00 00 00            	movl	$22, (%rax)
    eaaf: 31 c0                        	xorl	%eax, %eax
; }
    eab1: 48 83 c4 08                  	addq	$8, %rsp
    eab5: c3                           	retq
    eab6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000000eac0 <bpf_object__kversion>:
; {
    eac0: f3 0f 1e fa                  	endbr64
; 	return obj ? obj->kern_version : 0;
    eac4: 31 c0                        	xorl	%eax, %eax
    eac6: 48 85 ff                     	testq	%rdi, %rdi
    eac9: 74 03                        	je	0xeace <bpf_object__kversion+0xe>
    eacb: 8b 47 50                     	movl	80(%rdi), %eax
; }
    eace: c3                           	retq
    eacf: 90                           	nop

000000000000ead0 <bpf_object__btf>:
; {
    ead0: f3 0f 1e fa                  	endbr64
; 	return obj ? obj->btf : NULL;
    ead4: 48 85 ff                     	testq	%rdi, %rdi
    ead7: 74 0f                        	je	0xeae8 <bpf_object__btf+0x18>
    ead9: 48 8b 87 10 01 00 00         	movq	272(%rdi), %rax
    eae0: c3                           	retq
    eae1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    eae8: 31 c0                        	xorl	%eax, %eax
; }
    eaea: c3                           	retq
    eaeb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000eaf0 <bpf_object__btf_fd>:
; {
    eaf0: f3 0f 1e fa                  	endbr64
; 	return obj->btf ? btf__fd(obj->btf) : -1;
    eaf4: 48 8b bf 10 01 00 00         	movq	272(%rdi), %rdi
    eafb: 48 85 ff                     	testq	%rdi, %rdi
    eafe: 74 08                        	je	0xeb08 <bpf_object__btf_fd+0x18>
    eb00: e9 2b c7 01 00               	jmp	0x2b230 <btf__fd>
    eb05: 0f 1f 00                     	nopl	(%rax)
; }
    eb08: b8 ff ff ff ff               	movl	$4294967295, %eax       # imm = 0xFFFFFFFF
    eb0d: c3                           	retq
    eb0e: 66 90                        	nop

000000000000eb10 <bpf_object__set_kversion>:
; {
    eb10: f3 0f 1e fa                  	endbr64
; 	if (obj->loaded)
    eb14: 80 bf 98 00 00 00 00         	cmpb	$0, 152(%rdi)
    eb1b: 75 06                        	jne	0xeb23 <bpf_object__set_kversion+0x13>
; 	obj->kern_version = kern_version;
    eb1d: 89 77 50                     	movl	%esi, 80(%rdi)
; 	return 0;
    eb20: 31 c0                        	xorl	%eax, %eax
; }
    eb22: c3                           	retq
; {
    eb23: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
    eb27: e8 c4 6b ff ff               	callq	0x56f0 <.plt.sec+0x80>
    eb2c: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
    eb32: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
    eb37: 48 83 c4 08                  	addq	$8, %rsp
    eb3b: c3                           	retq
    eb3c: 0f 1f 40 00                  	nopl	(%rax)

000000000000eb40 <bpf_object__gen_loader>:
; {
    eb40: f3 0f 1e fa                  	endbr64
; 	if (!opts)
    eb44: 48 85 f6                     	testq	%rsi, %rsi
    eb47: 0f 84 b6 00 00 00            	je	0xec03 <bpf_object__gen_loader+0xc3>
; {
    eb4d: 55                           	pushq	%rbp
    eb4e: 53                           	pushq	%rbx
    eb4f: 48 89 f3                     	movq	%rsi, %rbx
    eb52: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!OPTS_VALID(opts, gen_loader_opts))
    eb56: 48 8b 0e                     	movq	(%rsi), %rcx
; 	if (user_sz < sizeof(size_t)) {
    eb59: 48 83 f9 07                  	cmpq	$7, %rcx
    eb5d: 0f 86 7d 00 00 00            	jbe	0xebe0 <bpf_object__gen_loader+0xa0>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
    eb63: 48 8d 51 e0                  	leaq	-32(%rcx), %rdx
    eb67: 48 89 fd                     	movq	%rdi, %rbp
    eb6a: 48 8d 46 20                  	leaq	32(%rsi), %rax
; 	while (len > 0) {
    eb6e: 48 85 d2                     	testq	%rdx, %rdx
    eb71: 7e 45                        	jle	0xebb8 <bpf_object__gen_loader+0x78>
    eb73: 48 01 f1                     	addq	%rsi, %rcx
    eb76: eb 11                        	jmp	0xeb89 <bpf_object__gen_loader+0x49>
    eb78: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		p++;
    eb80: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
    eb84: 48 39 c8                     	cmpq	%rcx, %rax
    eb87: 74 2f                        	je	0xebb8 <bpf_object__gen_loader+0x78>
; 		if (*p)
    eb89: 80 38 00                     	cmpb	$0, (%rax)
    eb8c: 74 f2                        	je	0xeb80 <bpf_object__gen_loader+0x40>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
    eb8e: 31 c0                        	xorl	%eax, %eax
    eb90: 48 8d 15 33 34 02 00         	leaq	144435(%rip), %rdx      # 0x31fca <_IO_stdin_used+0x1fca>
    eb97: 48 8d 35 72 54 02 00         	leaq	152690(%rip), %rsi      # 0x34010 <strs.2+0x1180>
    eb9e: 31 ff                        	xorl	%edi, %edi
    eba0: e8 2b 95 ff ff               	callq	0x80d0 <libbpf_print>
; }
    eba5: 48 83 c4 08                  	addq	$8, %rsp
; 		return -EINVAL;
    eba9: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
    ebae: 5b                           	popq	%rbx
    ebaf: 5d                           	popq	%rbp
    ebb0: c3                           	retq
    ebb1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	gen = calloc(sizeof(*gen), 1);
    ebb8: be 01 00 00 00               	movl	$1, %esi
    ebbd: bf f8 00 00 00               	movl	$248, %edi
    ebc2: e8 c9 6d ff ff               	callq	0x5990 <.plt.sec+0x320>
; 	if (!gen)
    ebc7: 48 85 c0                     	testq	%rax, %rax
    ebca: 74 3d                        	je	0xec09 <bpf_object__gen_loader+0xc9>
; 	gen->opts = opts;
    ebcc: 48 89 18                     	movq	%rbx, (%rax)
; 	obj->gen_loader = gen;
    ebcf: 48 89 85 a0 00 00 00         	movq	%rax, 160(%rbp)
; 	return 0;
    ebd6: 31 c0                        	xorl	%eax, %eax
; }
    ebd8: 48 83 c4 08                  	addq	$8, %rsp
    ebdc: 5b                           	popq	%rbx
    ebdd: 5d                           	popq	%rbp
    ebde: c3                           	retq
    ebdf: 90                           	nop
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
    ebe0: 31 c0                        	xorl	%eax, %eax
    ebe2: 48 8d 15 e1 33 02 00         	leaq	144353(%rip), %rdx      # 0x31fca <_IO_stdin_used+0x1fca>
    ebe9: 48 8d 35 c8 53 02 00         	leaq	152520(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
    ebf0: 31 ff                        	xorl	%edi, %edi
    ebf2: e8 d9 94 ff ff               	callq	0x80d0 <libbpf_print>
; }
    ebf7: 48 83 c4 08                  	addq	$8, %rsp
; 		return -EINVAL;
    ebfb: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
    ec00: 5b                           	popq	%rbx
    ec01: 5d                           	popq	%rbp
    ec02: c3                           	retq
; 		return -EFAULT;
    ec03: b8 f2 ff ff ff               	movl	$4294967282, %eax       # imm = 0xFFFFFFF2
; }
    ec08: c3                           	retq
; 		return -ENOMEM;
    ec09: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
    ec0e: eb c8                        	jmp	0xebd8 <bpf_object__gen_loader+0x98>

000000000000ec10 <bpf_object__next_program>:
; {
    ec10: f3 0f 1e fa                  	endbr64
; 	size_t nr_programs = obj->nr_programs;
    ec14: 48 8b 4f 60                  	movq	96(%rdi), %rcx
; {
    ec18: 48 89 f0                     	movq	%rsi, %rax
; 	idx = (p - obj->programs) + (forward ? 1 : -1);
    ec1b: 49 b8 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %r8 # imm = 0xAAAAAAAAAAAAAAAB
; 	if (!nr_programs)
    ec25: 48 85 c9                     	testq	%rcx, %rcx
    ec28: 74 56                        	je	0xec80 <bpf_object__next_program+0x70>
; 	if (!p)
    ec2a: 48 85 c0                     	testq	%rax, %rax
    ec2d: 74 59                        	je	0xec88 <bpf_object__next_program+0x78>
; 	if (p->obj != obj) {
    ec2f: 48 3b 78 70                  	cmpq	112(%rax), %rdi
    ec33: 75 5b                        	jne	0xec90 <bpf_object__next_program+0x80>
; 	idx = (p - obj->programs) + (forward ? 1 : -1);
    ec35: 48 8b 77 58                  	movq	88(%rdi), %rsi
    ec39: 48 29 f0                     	subq	%rsi, %rax
    ec3c: 48 89 c2                     	movq	%rax, %rdx
    ec3f: 48 c1 fa 06                  	sarq	$6, %rdx
    ec43: 49 0f af d0                  	imulq	%r8, %rdx
; 	if (idx >= obj->nr_programs || idx < 0)
    ec47: 48 83 c2 01                  	addq	$1, %rdx
    ec4b: 78 33                        	js	0xec80 <bpf_object__next_program+0x70>
    ec4d: 48 39 d1                     	cmpq	%rdx, %rcx
    ec50: 76 2e                        	jbe	0xec80 <bpf_object__next_program+0x70>
; 	return &obj->programs[idx];
    ec52: 48 8d 84 06 c0 00 00 00      	leaq	192(%rsi,%rax), %rax
; 	} while (prog && prog_is_subprog(obj, prog));
    ec5a: 48 85 c0                     	testq	%rax, %rax
    ec5d: 74 0d                        	je	0xec6c <bpf_object__next_program+0x5c>
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
    ec5f: 48 63 97 04 01 00 00         	movslq	260(%rdi), %rdx
    ec66: 48 39 50 10                  	cmpq	%rdx, 16(%rax)
    ec6a: 74 04                        	je	0xec70 <bpf_object__next_program+0x60>
; }
    ec6c: c3                           	retq
    ec6d: 0f 1f 00                     	nopl	(%rax)
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
    ec70: 48 83 f9 01                  	cmpq	$1, %rcx
    ec74: 75 af                        	jne	0xec25 <bpf_object__next_program+0x15>
    ec76: c3                           	retq
    ec77: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		prog = __bpf_program__iter(prog, obj, true);
    ec80: 31 c0                        	xorl	%eax, %eax
    ec82: c3                           	retq
    ec83: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		return forward ? &obj->programs[0] :
    ec88: 48 8b 47 58                  	movq	88(%rdi), %rax
    ec8c: eb cc                        	jmp	0xec5a <bpf_object__next_program+0x4a>
    ec8e: 66 90                        	nop
; {
    ec90: 48 83 ec 08                  	subq	$8, %rsp
; 		pr_warn("error: program handler doesn't match object\n");
    ec94: 48 8d 35 35 63 02 00         	leaq	156469(%rip), %rsi      # 0x34fd0 <strs.2+0x2140>
    ec9b: 31 ff                        	xorl	%edi, %edi
    ec9d: 31 c0                        	xorl	%eax, %eax
    ec9f: e8 2c 94 ff ff               	callq	0x80d0 <libbpf_print>
; 		return errno = EINVAL, NULL;
    eca4: e8 47 6a ff ff               	callq	0x56f0 <.plt.sec+0x80>
    eca9: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		prog = __bpf_program__iter(prog, obj, true);
    ecaf: 31 c0                        	xorl	%eax, %eax
; }
    ecb1: 48 83 c4 08                  	addq	$8, %rsp
    ecb5: c3                           	retq
    ecb6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000000ecc0 <bpf_object__find_program_by_name>:
; {
    ecc0: f3 0f 1e fa                  	endbr64
    ecc4: 41 54                        	pushq	%r12
    ecc6: 49 89 f4                     	movq	%rsi, %r12
; 	bpf_object__for_each_program(prog, obj) {
    ecc9: 31 f6                        	xorl	%esi, %esi
; {
    eccb: 55                           	pushq	%rbp
    eccc: 53                           	pushq	%rbx
    eccd: 48 89 fb                     	movq	%rdi, %rbx
; 	bpf_object__for_each_program(prog, obj) {
    ecd0: e8 3b ff ff ff               	callq	0xec10 <bpf_object__next_program>
    ecd5: 48 85 c0                     	testq	%rax, %rax
    ecd8: 74 46                        	je	0xed20 <bpf_object__find_program_by_name+0x60>
    ecda: 48 89 c5                     	movq	%rax, %rbp
    ecdd: eb 24                        	jmp	0xed03 <bpf_object__find_program_by_name+0x43>
    ecdf: 90                           	nop
; 		if (!strcmp(prog->name, name))
    ece0: 48 8b 7d 00                  	movq	(%rbp), %rdi
    ece4: 4c 89 e6                     	movq	%r12, %rsi
    ece7: e8 c4 6c ff ff               	callq	0x59b0 <.plt.sec+0x340>
    ecec: 85 c0                        	testl	%eax, %eax
    ecee: 74 3d                        	je	0xed2d <bpf_object__find_program_by_name+0x6d>
; 	bpf_object__for_each_program(prog, obj) {
    ecf0: 48 89 ee                     	movq	%rbp, %rsi
    ecf3: 48 89 df                     	movq	%rbx, %rdi
    ecf6: e8 15 ff ff ff               	callq	0xec10 <bpf_object__next_program>
    ecfb: 48 89 c5                     	movq	%rax, %rbp
    ecfe: 48 85 c0                     	testq	%rax, %rax
    ed01: 74 1d                        	je	0xed20 <bpf_object__find_program_by_name+0x60>
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
    ed03: 48 63 83 04 01 00 00         	movslq	260(%rbx), %rax
    ed0a: 48 39 45 10                  	cmpq	%rax, 16(%rbp)
    ed0e: 75 d0                        	jne	0xece0 <bpf_object__find_program_by_name+0x20>
    ed10: 48 83 7b 60 01               	cmpq	$1, 96(%rbx)
    ed15: 77 d9                        	ja	0xecf0 <bpf_object__find_program_by_name+0x30>
    ed17: eb c7                        	jmp	0xece0 <bpf_object__find_program_by_name+0x20>
    ed19: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return errno = ENOENT, NULL;
    ed20: e8 cb 69 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    ed25: 31 ed                        	xorl	%ebp, %ebp
    ed27: c7 00 02 00 00 00            	movl	$2, (%rax)
; }
    ed2d: 48 89 e8                     	movq	%rbp, %rax
    ed30: 5b                           	popq	%rbx
    ed31: 5d                           	popq	%rbp
    ed32: 41 5c                        	popq	%r12
    ed34: c3                           	retq
    ed35: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

000000000000ed40 <obj_needs_vmlinux_btf>:
; {
    ed40: 53                           	pushq	%rbx
; 	if (obj->btf_ext && obj->btf_ext->core_relo_info.len && !obj->btf_custom_path)
    ed41: 48 8b 87 18 01 00 00         	movq	280(%rdi), %rax
; {
    ed48: 48 89 fb                     	movq	%rdi, %rbx
; 	if (obj->btf_ext && obj->btf_ext->core_relo_info.len && !obj->btf_custom_path)
    ed4b: 48 85 c0                     	testq	%rax, %rax
    ed4e: 74 0b                        	je	0xed5b <obj_needs_vmlinux_btf+0x1b>
    ed50: 8b 70 54                     	movl	84(%rax), %esi
    ed53: 85 f6                        	testl	%esi, %esi
    ed55: 0f 85 a5 00 00 00            	jne	0xee00 <obj_needs_vmlinux_btf+0xc0>
; 	for (i = 0; i < obj->nr_extern; i++) {
    ed5b: 8b 93 90 00 00 00            	movl	144(%rbx), %edx
    ed61: 85 d2                        	testl	%edx, %edx
    ed63: 7e 43                        	jle	0xeda8 <obj_needs_vmlinux_btf+0x68>
    ed65: 8d 4a ff                     	leal	-1(%rdx), %ecx
    ed68: 48 8b 83 88 00 00 00         	movq	136(%rbx), %rax
    ed6f: 48 8d 14 cd 00 00 00 00      	leaq	(,%rcx,8), %rdx
    ed77: 48 29 ca                     	subq	%rcx, %rdx
    ed7a: 48 8d 54 d0 38               	leaq	56(%rax,%rdx,8), %rdx
    ed7f: eb 10                        	jmp	0xed91 <obj_needs_vmlinux_btf+0x51>
    ed81: 0f 1f 80 00 00 00 00         	nopl	(%rax)
    ed88: 48 83 c0 38                  	addq	$56, %rax
    ed8c: 48 39 c2                     	cmpq	%rax, %rdx
    ed8f: 74 17                        	je	0xeda8 <obj_needs_vmlinux_btf+0x68>
; 		if (ext->type == EXT_KSYM && ext->ksym.type_id)
    ed91: 83 38 02                     	cmpl	$2, (%rax)
    ed94: 75 f2                        	jne	0xed88 <obj_needs_vmlinux_btf+0x48>
    ed96: 8b 48 30                     	movl	48(%rax), %ecx
    ed99: 85 c9                        	testl	%ecx, %ecx
    ed9b: 74 eb                        	je	0xed88 <obj_needs_vmlinux_btf+0x48>
; 		return true;
    ed9d: b8 01 00 00 00               	movl	$1, %eax
; }
    eda2: 5b                           	popq	%rbx
    eda3: c3                           	retq
    eda4: 0f 1f 40 00                  	nopl	(%rax)
; 	bpf_object__for_each_program(prog, obj) {
    eda8: 31 f6                        	xorl	%esi, %esi
    edaa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
    edb0: 48 89 df                     	movq	%rbx, %rdi
    edb3: e8 58 fe ff ff               	callq	0xec10 <bpf_object__next_program>
    edb8: 48 89 c6                     	movq	%rax, %rsi
    edbb: 48 85 c0                     	testq	%rax, %rax
    edbe: 74 33                        	je	0xedf3 <obj_needs_vmlinux_btf+0xb3>
; 		if (!prog->autoload)
    edc0: 80 78 7c 00                  	cmpb	$0, 124(%rax)
    edc4: 74 ea                        	je	0xedb0 <obj_needs_vmlinux_btf+0x70>
; 	if (prog->type == BPF_PROG_TYPE_STRUCT_OPS ||
    edc6: 8b 80 80 00 00 00            	movl	128(%rax), %eax
    edcc: 8d 50 e5                     	leal	-27(%rax), %edx
    edcf: 83 e2 fd                     	andl	$-3, %edx
    edd2: 74 c9                        	je	0xed9d <obj_needs_vmlinux_btf+0x5d>
; 	if (prog->type == BPF_PROG_TYPE_TRACING && !prog->attach_prog_fd)
    edd4: 83 f8 1a                     	cmpl	$26, %eax
    edd7: 75 d7                        	jne	0xedb0 <obj_needs_vmlinux_btf+0x70>
    edd9: 8b 86 94 00 00 00            	movl	148(%rsi), %eax
    eddf: 85 c0                        	testl	%eax, %eax
    ede1: 74 ba                        	je	0xed9d <obj_needs_vmlinux_btf+0x5d>
; 	bpf_object__for_each_program(prog, obj) {
    ede3: 48 89 df                     	movq	%rbx, %rdi
    ede6: e8 25 fe ff ff               	callq	0xec10 <bpf_object__next_program>
    edeb: 48 89 c6                     	movq	%rax, %rsi
    edee: 48 85 c0                     	testq	%rax, %rax
    edf1: 75 cd                        	jne	0xedc0 <obj_needs_vmlinux_btf+0x80>
; 	return false;
    edf3: 31 c0                        	xorl	%eax, %eax
; }
    edf5: 5b                           	popq	%rbx
    edf6: c3                           	retq
    edf7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	if (obj->btf_ext && obj->btf_ext->core_relo_info.len && !obj->btf_custom_path)
    ee00: 48 83 bf 28 01 00 00 00      	cmpq	$0, 296(%rdi)
    ee08: 0f 85 4d ff ff ff            	jne	0xed5b <obj_needs_vmlinux_btf+0x1b>
    ee0e: eb 8d                        	jmp	0xed9d <obj_needs_vmlinux_btf+0x5d>

000000000000ee10 <bpf_object__unpin_programs>:
; {
    ee10: f3 0f 1e fa                  	endbr64
    ee14: 41 57                        	pushq	%r15
    ee16: 41 56                        	pushq	%r14
    ee18: 41 55                        	pushq	%r13
    ee1a: 41 54                        	pushq	%r12
    ee1c: 55                           	pushq	%rbp
    ee1d: 53                           	pushq	%rbx
    ee1e: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
    ee25: 48 83 0c 24 00               	orq	$0, (%rsp)
    ee2a: 48 83 ec 18                  	subq	$24, %rsp
    ee2e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    ee37: 48 89 84 24 08 10 00 00      	movq	%rax, 4104(%rsp)
    ee3f: 31 c0                        	xorl	%eax, %eax
; 	if (!obj)
    ee41: 48 85 ff                     	testq	%rdi, %rdi
    ee44: 0f 84 f6 00 00 00            	je	0xef40 <bpf_object__unpin_programs+0x130>
    ee4a: 49 89 f5                     	movq	%rsi, %r13
; 	bpf_object__for_each_program(prog, obj) {
    ee4d: 31 f6                        	xorl	%esi, %esi
    ee4f: 49 89 fc                     	movq	%rdi, %r12
    ee52: 48 89 e3                     	movq	%rsp, %rbx
    ee55: e8 b6 fd ff ff               	callq	0xec10 <bpf_object__next_program>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    ee5a: 4c 8d 35 2f 2e 02 00         	leaq	142895(%rip), %r14      # 0x31c90 <_IO_stdin_used+0x1c90>
; 	bpf_object__for_each_program(prog, obj) {
    ee61: 48 89 c5                     	movq	%rax, %rbp
    ee64: 48 85 c0                     	testq	%rax, %rax
    ee67: 75 3b                        	jne	0xeea4 <bpf_object__unpin_programs+0x94>
    ee69: e9 a2 00 00 00               	jmp	0xef10 <bpf_object__unpin_programs+0x100>
    ee6e: 66 90                        	nop
; 		else if (len >= PATH_MAX)
    ee70: 3d ff 0f 00 00               	cmpl	$4095, %eax             # imm = 0xFFF
    ee75: 0f 8f 9d 00 00 00            	jg	0xef18 <bpf_object__unpin_programs+0x108>
; 		err = bpf_program__unpin(prog, buf);
    ee7b: 48 89 de                     	movq	%rbx, %rsi
    ee7e: 48 89 ef                     	movq	%rbp, %rdi
    ee81: e8 aa fa ff ff               	callq	0xe930 <bpf_program__unpin>
    ee86: 41 89 c7                     	movl	%eax, %r15d
; 		if (err)
    ee89: 85 c0                        	testl	%eax, %eax
    ee8b: 0f 85 9f 00 00 00            	jne	0xef30 <bpf_object__unpin_programs+0x120>
; 	bpf_object__for_each_program(prog, obj) {
    ee91: 48 89 ee                     	movq	%rbp, %rsi
    ee94: 4c 89 e7                     	movq	%r12, %rdi
    ee97: e8 74 fd ff ff               	callq	0xec10 <bpf_object__next_program>
    ee9c: 48 89 c5                     	movq	%rax, %rbp
    ee9f: 48 85 c0                     	testq	%rax, %rax
    eea2: 74 6c                        	je	0xef10 <bpf_object__unpin_programs+0x100>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    eea4: 48 83 ec 08                  	subq	$8, %rsp
    eea8: ff 75 00                     	pushq	(%rbp)
    eeab: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
    eeb0: 4d 89 e9                     	movq	%r13, %r9
    eeb3: ba 01 00 00 00               	movl	$1, %edx
    eeb8: 4d 89 f0                     	movq	%r14, %r8
    eebb: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
    eec0: 48 89 df                     	movq	%rbx, %rdi
    eec3: 31 c0                        	xorl	%eax, %eax
    eec5: e8 e6 67 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 		if (len < 0)
    eeca: 5a                           	popq	%rdx
    eecb: 59                           	popq	%rcx
    eecc: 85 c0                        	testl	%eax, %eax
    eece: 79 a0                        	jns	0xee70 <bpf_object__unpin_programs+0x60>
; 		errno = -ret;
    eed0: e8 1b 68 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 			return libbpf_err(-EINVAL);
    eed5: 41 bf ea ff ff ff            	movl	$4294967274, %r15d      # imm = 0xFFFFFFEA
; 		errno = -ret;
    eedb: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
    eee1: 48 8b 84 24 08 10 00 00      	movq	4104(%rsp), %rax
    eee9: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    eef2: 75 5f                        	jne	0xef53 <bpf_object__unpin_programs+0x143>
    eef4: 48 81 c4 18 10 00 00         	addq	$4120, %rsp             # imm = 0x1018
    eefb: 44 89 f8                     	movl	%r15d, %eax
    eefe: 5b                           	popq	%rbx
    eeff: 5d                           	popq	%rbp
    ef00: 41 5c                        	popq	%r12
    ef02: 41 5d                        	popq	%r13
    ef04: 41 5e                        	popq	%r14
    ef06: 41 5f                        	popq	%r15
    ef08: c3                           	retq
    ef09: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return 0;
    ef10: 45 31 ff                     	xorl	%r15d, %r15d
    ef13: eb cc                        	jmp	0xeee1 <bpf_object__unpin_programs+0xd1>
    ef15: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
    ef18: e8 d3 67 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 			return libbpf_err(-ENAMETOOLONG);
    ef1d: 41 bf dc ff ff ff            	movl	$4294967260, %r15d      # imm = 0xFFFFFFDC
; 		errno = -ret;
    ef23: c7 00 24 00 00 00            	movl	$36, (%rax)
    ef29: eb b6                        	jmp	0xeee1 <bpf_object__unpin_programs+0xd1>
    ef2b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	if (ret < 0)
    ef30: 79 af                        	jns	0xeee1 <bpf_object__unpin_programs+0xd1>
; 		errno = -ret;
    ef32: e8 b9 67 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    ef37: 44 89 fa                     	movl	%r15d, %edx
    ef3a: f7 da                        	negl	%edx
    ef3c: 89 10                        	movl	%edx, (%rax)
    ef3e: eb a1                        	jmp	0xeee1 <bpf_object__unpin_programs+0xd1>
    ef40: e8 ab 67 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOENT);
    ef45: 41 bf fe ff ff ff            	movl	$4294967294, %r15d      # imm = 0xFFFFFFFE
; 		errno = -ret;
    ef4b: c7 00 02 00 00 00            	movl	$2, (%rax)
    ef51: eb 8e                        	jmp	0xeee1 <bpf_object__unpin_programs+0xd1>
; }
    ef53: e8 a8 68 ff ff               	callq	0x5800 <.plt.sec+0x190>
    ef58: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000000ef60 <bpf_object__prev_program>:
; {
    ef60: f3 0f 1e fa                  	endbr64
; 	size_t nr_programs = obj->nr_programs;
    ef64: 48 8b 4f 60                  	movq	96(%rdi), %rcx
; {
    ef68: 48 89 f0                     	movq	%rsi, %rax
; 	idx = (p - obj->programs) + (forward ? 1 : -1);
    ef6b: 49 b9 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %r9 # imm = 0xAAAAAAAAAAAAAAAB
; 			&obj->programs[nr_programs - 1];
    ef75: 4c 8d 04 49                  	leaq	(%rcx,%rcx,2), %r8
    ef79: 49 c1 e0 06                  	shlq	$6, %r8
    ef7d: 49 81 e8 c0 00 00 00         	subq	$192, %r8
; 	if (!nr_programs)
    ef84: 48 85 c9                     	testq	%rcx, %rcx
    ef87: 74 57                        	je	0xefe0 <bpf_object__prev_program+0x80>
; 	if (!p)
    ef89: 48 85 c0                     	testq	%rax, %rax
    ef8c: 74 5a                        	je	0xefe8 <bpf_object__prev_program+0x88>
; 	if (p->obj != obj) {
    ef8e: 48 3b 78 70                  	cmpq	112(%rax), %rdi
    ef92: 75 64                        	jne	0xeff8 <bpf_object__prev_program+0x98>
; 	idx = (p - obj->programs) + (forward ? 1 : -1);
    ef94: 48 8b 77 58                  	movq	88(%rdi), %rsi
    ef98: 48 29 f0                     	subq	%rsi, %rax
    ef9b: 48 89 c2                     	movq	%rax, %rdx
    ef9e: 48 c1 fa 06                  	sarq	$6, %rdx
    efa2: 49 0f af d1                  	imulq	%r9, %rdx
; 	if (idx >= obj->nr_programs || idx < 0)
    efa6: 48 83 ea 01                  	subq	$1, %rdx
    efaa: 78 34                        	js	0xefe0 <bpf_object__prev_program+0x80>
    efac: 48 39 d1                     	cmpq	%rdx, %rcx
    efaf: 76 2f                        	jbe	0xefe0 <bpf_object__prev_program+0x80>
; 	return &obj->programs[idx];
    efb1: 48 8d 84 06 40 ff ff ff      	leaq	-192(%rsi,%rax), %rax
; 	} while (prog && prog_is_subprog(obj, prog));
    efb9: 48 85 c0                     	testq	%rax, %rax
    efbc: 74 0d                        	je	0xefcb <bpf_object__prev_program+0x6b>
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
    efbe: 48 63 97 04 01 00 00         	movslq	260(%rdi), %rdx
    efc5: 48 39 50 10                  	cmpq	%rdx, 16(%rax)
    efc9: 74 05                        	je	0xefd0 <bpf_object__prev_program+0x70>
; }
    efcb: c3                           	retq
    efcc: 0f 1f 40 00                  	nopl	(%rax)
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
    efd0: 48 83 f9 01                  	cmpq	$1, %rcx
    efd4: 75 ae                        	jne	0xef84 <bpf_object__prev_program+0x24>
    efd6: c3                           	retq
    efd7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		prog = __bpf_program__iter(prog, obj, false);
    efe0: 31 c0                        	xorl	%eax, %eax
    efe2: c3                           	retq
    efe3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		return forward ? &obj->programs[0] :
    efe8: 48 8b 47 58                  	movq	88(%rdi), %rax
    efec: 4c 01 c0                     	addq	%r8, %rax
    efef: eb c8                        	jmp	0xefb9 <bpf_object__prev_program+0x59>
    eff1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; {
    eff8: 48 83 ec 08                  	subq	$8, %rsp
; 		pr_warn("error: program handler doesn't match object\n");
    effc: 48 8d 35 cd 5f 02 00         	leaq	155597(%rip), %rsi      # 0x34fd0 <strs.2+0x2140>
    f003: 31 ff                        	xorl	%edi, %edi
    f005: 31 c0                        	xorl	%eax, %eax
    f007: e8 c4 90 ff ff               	callq	0x80d0 <libbpf_print>
; 		return errno = EINVAL, NULL;
    f00c: e8 df 66 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f011: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		prog = __bpf_program__iter(prog, obj, false);
    f017: 31 c0                        	xorl	%eax, %eax
; }
    f019: 48 83 c4 08                  	addq	$8, %rsp
    f01d: c3                           	retq
    f01e: 66 90                        	nop

000000000000f020 <bpf_object__pin_programs>:
; {
    f020: f3 0f 1e fa                  	endbr64
    f024: 41 57                        	pushq	%r15
    f026: 41 56                        	pushq	%r14
    f028: 41 55                        	pushq	%r13
    f02a: 41 54                        	pushq	%r12
    f02c: 55                           	pushq	%rbp
    f02d: 53                           	pushq	%rbx
    f02e: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
    f035: 48 83 0c 24 00               	orq	$0, (%rsp)
    f03a: 48 83 ec 18                  	subq	$24, %rsp
    f03e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    f047: 48 89 84 24 08 10 00 00      	movq	%rax, 4104(%rsp)
    f04f: 31 c0                        	xorl	%eax, %eax
; 	if (!obj)
    f051: 48 85 ff                     	testq	%rdi, %rdi
    f054: 0f 84 59 01 00 00            	je	0xf1b3 <bpf_object__pin_programs+0x193>
; 	if (!obj->loaded) {
    f05a: 80 bf 98 00 00 00 00         	cmpb	$0, 152(%rdi)
    f061: 49 89 fc                     	movq	%rdi, %r12
    f064: 0f 84 39 01 00 00            	je	0xf1a3 <bpf_object__pin_programs+0x183>
    f06a: 49 89 f5                     	movq	%rsi, %r13
; 	bpf_object__for_each_program(prog, obj) {
    f06d: 31 f6                        	xorl	%esi, %esi
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    f06f: 4c 8d 35 1a 2c 02 00         	leaq	142362(%rip), %r14      # 0x31c90 <_IO_stdin_used+0x1c90>
    f076: 48 89 e3                     	movq	%rsp, %rbx
; 	bpf_object__for_each_program(prog, obj) {
    f079: e8 92 fb ff ff               	callq	0xec10 <bpf_object__next_program>
    f07e: 48 89 c5                     	movq	%rax, %rbp
    f081: 48 85 c0                     	testq	%rax, %rax
    f084: 75 3e                        	jne	0xf0c4 <bpf_object__pin_programs+0xa4>
    f086: e9 05 01 00 00               	jmp	0xf190 <bpf_object__pin_programs+0x170>
    f08b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		} else if (len >= PATH_MAX) {
    f090: 3d ff 0f 00 00               	cmpl	$4095, %eax             # imm = 0xFFF
    f095: 0f 8f fd 00 00 00            	jg	0xf198 <bpf_object__pin_programs+0x178>
; 		err = bpf_program__pin(prog, buf);
    f09b: 48 89 de                     	movq	%rbx, %rsi
    f09e: 48 89 ef                     	movq	%rbp, %rdi
    f0a1: e8 3a f7 ff ff               	callq	0xe7e0 <bpf_program__pin>
    f0a6: 41 89 c7                     	movl	%eax, %r15d
; 		if (err)
    f0a9: 85 c0                        	testl	%eax, %eax
    f0ab: 75 49                        	jne	0xf0f6 <bpf_object__pin_programs+0xd6>
; 	bpf_object__for_each_program(prog, obj) {
    f0ad: 48 89 ee                     	movq	%rbp, %rsi
    f0b0: 4c 89 e7                     	movq	%r12, %rdi
    f0b3: e8 58 fb ff ff               	callq	0xec10 <bpf_object__next_program>
    f0b8: 48 89 c5                     	movq	%rax, %rbp
    f0bb: 48 85 c0                     	testq	%rax, %rax
    f0be: 0f 84 cc 00 00 00            	je	0xf190 <bpf_object__pin_programs+0x170>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    f0c4: 48 83 ec 08                  	subq	$8, %rsp
    f0c8: ff 75 00                     	pushq	(%rbp)
    f0cb: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
    f0d0: 48 89 df                     	movq	%rbx, %rdi
    f0d3: 4d 89 e9                     	movq	%r13, %r9
    f0d6: 4d 89 f0                     	movq	%r14, %r8
    f0d9: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
    f0de: ba 01 00 00 00               	movl	$1, %edx
    f0e3: 31 c0                        	xorl	%eax, %eax
    f0e5: e8 c6 65 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 		if (len < 0) {
    f0ea: 5e                           	popq	%rsi
    f0eb: 5f                           	popq	%rdi
    f0ec: 85 c0                        	testl	%eax, %eax
    f0ee: 79 a0                        	jns	0xf090 <bpf_object__pin_programs+0x70>
; 			err = -EINVAL;
    f0f0: 41 bf ea ff ff ff            	movl	$4294967274, %r15d      # imm = 0xFFFFFFEA
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    f0f6: 4c 8d 35 93 2b 02 00         	leaq	142227(%rip), %r14      # 0x31c90 <_IO_stdin_used+0x1c90>
    f0fd: 0f 1f 00                     	nopl	(%rax)
; 	while ((prog = bpf_object__prev_program(obj, prog))) {
    f100: 48 89 ee                     	movq	%rbp, %rsi
    f103: 4c 89 e7                     	movq	%r12, %rdi
    f106: e8 55 fe ff ff               	callq	0xef60 <bpf_object__prev_program>
    f10b: 48 89 c5                     	movq	%rax, %rbp
    f10e: 48 85 c0                     	testq	%rax, %rax
    f111: 74 3d                        	je	0xf150 <bpf_object__pin_programs+0x130>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    f113: 48 83 ec 08                  	subq	$8, %rsp
    f117: ff 75 00                     	pushq	(%rbp)
    f11a: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
    f11f: 4d 89 e9                     	movq	%r13, %r9
    f122: ba 01 00 00 00               	movl	$1, %edx
    f127: 4d 89 f0                     	movq	%r14, %r8
    f12a: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
    f12f: 48 89 df                     	movq	%rbx, %rdi
    f132: 31 c0                        	xorl	%eax, %eax
    f134: e8 77 65 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 		else if (len >= PATH_MAX)
    f139: 5a                           	popq	%rdx
    f13a: 59                           	popq	%rcx
    f13b: 3d ff 0f 00 00               	cmpl	$4095, %eax             # imm = 0xFFF
    f140: 77 be                        	ja	0xf100 <bpf_object__pin_programs+0xe0>
; 		bpf_program__unpin(prog, buf);
    f142: 48 89 de                     	movq	%rbx, %rsi
    f145: 48 89 ef                     	movq	%rbp, %rdi
    f148: e8 e3 f7 ff ff               	callq	0xe930 <bpf_program__unpin>
    f14d: eb b1                        	jmp	0xf100 <bpf_object__pin_programs+0xe0>
    f14f: 90                           	nop
; 	if (ret < 0)
    f150: 45 85 ff                     	testl	%r15d, %r15d
    f153: 78 2b                        	js	0xf180 <bpf_object__pin_programs+0x160>
; }
    f155: 48 8b 84 24 08 10 00 00      	movq	4104(%rsp), %rax
    f15d: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    f166: 75 5e                        	jne	0xf1c6 <bpf_object__pin_programs+0x1a6>
    f168: 48 81 c4 18 10 00 00         	addq	$4120, %rsp             # imm = 0x1018
    f16f: 44 89 f8                     	movl	%r15d, %eax
    f172: 5b                           	popq	%rbx
    f173: 5d                           	popq	%rbp
    f174: 41 5c                        	popq	%r12
    f176: 41 5d                        	popq	%r13
    f178: 41 5e                        	popq	%r14
    f17a: 41 5f                        	popq	%r15
    f17c: c3                           	retq
    f17d: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
    f180: e8 6b 65 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f185: 44 89 fa                     	movl	%r15d, %edx
    f188: f7 da                        	negl	%edx
    f18a: 89 10                        	movl	%edx, (%rax)
    f18c: eb c7                        	jmp	0xf155 <bpf_object__pin_programs+0x135>
    f18e: 66 90                        	nop
; 	return 0;
    f190: 45 31 ff                     	xorl	%r15d, %r15d
    f193: eb c0                        	jmp	0xf155 <bpf_object__pin_programs+0x135>
    f195: 0f 1f 00                     	nopl	(%rax)
; 			err = -ENAMETOOLONG;
    f198: 41 bf dc ff ff ff            	movl	$4294967260, %r15d      # imm = 0xFFFFFFDC
    f19e: e9 53 ff ff ff               	jmp	0xf0f6 <bpf_object__pin_programs+0xd6>
; 		pr_warn("object not yet loaded; load it first\n");
    f1a3: 48 8d 35 5e 5e 02 00         	leaq	155230(%rip), %rsi      # 0x35008 <strs.2+0x2178>
    f1aa: 31 ff                        	xorl	%edi, %edi
    f1ac: 31 c0                        	xorl	%eax, %eax
    f1ae: e8 1d 8f ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
    f1b3: e8 38 65 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOENT);
    f1b8: 41 bf fe ff ff ff            	movl	$4294967294, %r15d      # imm = 0xFFFFFFFE
; 		errno = -ret;
    f1be: c7 00 02 00 00 00            	movl	$2, (%rax)
    f1c4: eb 8f                        	jmp	0xf155 <bpf_object__pin_programs+0x135>
; }
    f1c6: e8 35 66 ff ff               	callq	0x5800 <.plt.sec+0x190>
    f1cb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000f1d0 <bpf_program__set_ifindex>:
; {
    f1d0: f3 0f 1e fa                  	endbr64
; 	prog->prog_ifindex = ifindex;
    f1d4: 89 b7 88 00 00 00            	movl	%esi, 136(%rdi)
; }
    f1da: c3                           	retq
    f1db: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000f1e0 <bpf_program__name>:
; {
    f1e0: f3 0f 1e fa                  	endbr64
; 	return prog->name;
    f1e4: 48 8b 07                     	movq	(%rdi), %rax
; }
    f1e7: c3                           	retq
    f1e8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000000f1f0 <bpf_program__section_name>:
; {
    f1f0: f3 0f 1e fa                  	endbr64
; 	return prog->sec_name;
    f1f4: 48 8b 47 08                  	movq	8(%rdi), %rax
; }
    f1f8: c3                           	retq
    f1f9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000f200 <bpf_program__autoload>:
; {
    f200: f3 0f 1e fa                  	endbr64
; 	return prog->autoload;
    f204: 0f b6 47 7c                  	movzbl	124(%rdi), %eax
; }
    f208: c3                           	retq
    f209: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000f210 <bpf_program__set_autoload>:
; {
    f210: f3 0f 1e fa                  	endbr64
; 	if (prog->obj->loaded)
    f214: 48 8b 47 70                  	movq	112(%rdi), %rax
    f218: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    f21f: 75 07                        	jne	0xf228 <bpf_program__set_autoload+0x18>
; 	prog->autoload = autoload;
    f221: 40 88 77 7c                  	movb	%sil, 124(%rdi)
; 	return 0;
    f225: 31 c0                        	xorl	%eax, %eax
; }
    f227: c3                           	retq
; {
    f228: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
    f22c: e8 bf 64 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f231: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
    f237: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
    f23c: 48 83 c4 08                  	addq	$8, %rsp
    f240: c3                           	retq
    f241: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f24c: 0f 1f 40 00                  	nopl	(%rax)

000000000000f250 <bpf_program__autoattach>:
; {
    f250: f3 0f 1e fa                  	endbr64
; 	return prog->autoattach;
    f254: 0f b6 47 7d                  	movzbl	125(%rdi), %eax
; }
    f258: c3                           	retq
    f259: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000f260 <bpf_program__set_autoattach>:
; {
    f260: f3 0f 1e fa                  	endbr64
; 	prog->autoattach = autoattach;
    f264: 40 88 77 7d                  	movb	%sil, 125(%rdi)
; }
    f268: c3                           	retq
    f269: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000f270 <bpf_program__insns>:
; {
    f270: f3 0f 1e fa                  	endbr64
; 	return prog->insns;
    f274: 48 8b 47 38                  	movq	56(%rdi), %rax
; }
    f278: c3                           	retq
    f279: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000f280 <bpf_program__insn_cnt>:
; {
    f280: f3 0f 1e fa                  	endbr64
; 	return prog->insns_cnt;
    f284: 48 8b 47 40                  	movq	64(%rdi), %rax
; }
    f288: c3                           	retq
    f289: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000f290 <bpf_program__set_insns>:
; {
    f290: f3 0f 1e fa                  	endbr64
; 	if (prog->obj->loaded)
    f294: 48 8b 47 70                  	movq	112(%rdi), %rax
    f298: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    f29f: 75 77                        	jne	0xf318 <bpf_program__set_insns+0x88>
; {
    f2a1: 41 55                        	pushq	%r13
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    f2a3: 48 89 d0                     	movq	%rdx, %rax
    f2a6: 4c 8d 2c d5 00 00 00 00      	leaq	(,%rdx,8), %r13
; {
    f2ae: 41 54                        	pushq	%r12
    f2b0: 55                           	pushq	%rbp
    f2b1: 48 89 d5                     	movq	%rdx, %rbp
    f2b4: 53                           	pushq	%rbx
    f2b5: 48 89 fb                     	movq	%rdi, %rbx
    f2b8: 48 83 ec 08                  	subq	$8, %rsp
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    f2bc: 48 c1 e8 3d                  	shrq	$61, %rax
; 	insns = libbpf_reallocarray(prog->insns, new_insn_cnt, sizeof(*insns));
    f2c0: 48 8b 7f 38                  	movq	56(%rdi), %rdi
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    f2c4: 75 33                        	jne	0xf2f9 <bpf_program__set_insns+0x69>
    f2c6: 49 89 f4                     	movq	%rsi, %r12
; 	return realloc(ptr, total);
    f2c9: 4c 89 ee                     	movq	%r13, %rsi
    f2cc: e8 4f 68 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 	if (!insns) {
    f2d1: 48 85 c0                     	testq	%rax, %rax
    f2d4: 74 23                        	je	0xf2f9 <bpf_program__set_insns+0x69>
;   return __builtin___memcpy_chk (__dest, __src, __len,
    f2d6: 4c 89 ea                     	movq	%r13, %rdx
    f2d9: 4c 89 e6                     	movq	%r12, %rsi
    f2dc: 48 89 c7                     	movq	%rax, %rdi
    f2df: e8 5c 67 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	prog->insns_cnt = new_insn_cnt;
    f2e4: 48 89 6b 40                  	movq	%rbp, 64(%rbx)
; 	prog->insns = insns;
    f2e8: 48 89 43 38                  	movq	%rax, 56(%rbx)
; 	return 0;
    f2ec: 31 c0                        	xorl	%eax, %eax
; }
    f2ee: 48 83 c4 08                  	addq	$8, %rsp
    f2f2: 5b                           	popq	%rbx
    f2f3: 5d                           	popq	%rbp
    f2f4: 41 5c                        	popq	%r12
    f2f6: 41 5d                        	popq	%r13
    f2f8: c3                           	retq
; 		pr_warn("prog '%s': failed to realloc prog code\n", prog->name);
    f2f9: 48 8b 13                     	movq	(%rbx), %rdx
    f2fc: 31 c0                        	xorl	%eax, %eax
    f2fe: 48 8d 35 73 55 02 00         	leaq	152947(%rip), %rsi      # 0x34878 <strs.2+0x19e8>
    f305: 31 ff                        	xorl	%edi, %edi
    f307: e8 c4 8d ff ff               	callq	0x80d0 <libbpf_print>
; 		return -ENOMEM;
    f30c: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
    f311: eb db                        	jmp	0xf2ee <bpf_program__set_insns+0x5e>
    f313: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		return -EBUSY;
    f318: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
    f31d: c3                           	retq
    f31e: 66 90                        	nop

000000000000f320 <bpf_program__fd>:
; {
    f320: f3 0f 1e fa                  	endbr64
    f324: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!prog)
    f328: 48 85 ff                     	testq	%rdi, %rdi
    f32b: 74 1e                        	je	0xf34b <bpf_program__fd+0x2b>
; 	if (prog->fd < 0)
    f32d: 8b 47 78                     	movl	120(%rdi), %eax
    f330: 85 c0                        	testl	%eax, %eax
    f332: 78 05                        	js	0xf339 <bpf_program__fd+0x19>
; }
    f334: 48 83 c4 08                  	addq	$8, %rsp
    f338: c3                           	retq
; 		errno = -ret;
    f339: e8 b2 63 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f33e: c7 00 02 00 00 00            	movl	$2, (%rax)
; 		return libbpf_err(-ENOENT);
    f344: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
    f349: eb e9                        	jmp	0xf334 <bpf_program__fd+0x14>
; 		errno = -ret;
    f34b: e8 a0 63 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f350: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
    f356: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    f35b: eb d7                        	jmp	0xf334 <bpf_program__fd+0x14>
    f35d: 0f 1f 00                     	nopl	(%rax)

000000000000f360 <bpf_program__type>:
; {
    f360: f3 0f 1e fa                  	endbr64
; 	return prog->type;
    f364: 8b 87 80 00 00 00            	movl	128(%rdi), %eax
; }
    f36a: c3                           	retq
    f36b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000f370 <bpf_program__set_type>:
; {
    f370: f3 0f 1e fa                  	endbr64
; 	if (prog->obj->loaded)
    f374: 48 8b 47 70                  	movq	112(%rdi), %rax
    f378: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    f37f: 75 09                        	jne	0xf38a <bpf_program__set_type+0x1a>
; 	prog->type = type;
    f381: 89 b7 80 00 00 00            	movl	%esi, 128(%rdi)
; 	return 0;
    f387: 31 c0                        	xorl	%eax, %eax
; }
    f389: c3                           	retq
; {
    f38a: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
    f38e: e8 5d 63 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f393: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
    f399: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
    f39e: 48 83 c4 08                  	addq	$8, %rsp
    f3a2: c3                           	retq
    f3a3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f3ae: 66 90                        	nop

000000000000f3b0 <bpf_program__get_expected_attach_type>:
; {
    f3b0: f3 0f 1e fa                  	endbr64
; 	return prog->expected_attach_type;
    f3b4: 8b 87 84 00 00 00            	movl	132(%rdi), %eax
; }
    f3ba: c3                           	retq
    f3bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000f3c0 <bpf_program__set_expected_attach_type>:
; {
    f3c0: f3 0f 1e fa                  	endbr64
; 	if (prog->obj->loaded)
    f3c4: 48 8b 47 70                  	movq	112(%rdi), %rax
    f3c8: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    f3cf: 75 09                        	jne	0xf3da <bpf_program__set_expected_attach_type+0x1a>
; 	prog->expected_attach_type = type;
    f3d1: 89 b7 84 00 00 00            	movl	%esi, 132(%rdi)
; 	return 0;
    f3d7: 31 c0                        	xorl	%eax, %eax
; }
    f3d9: c3                           	retq
; {
    f3da: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
    f3de: e8 0d 63 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f3e3: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
    f3e9: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
    f3ee: 48 83 c4 08                  	addq	$8, %rsp
    f3f2: c3                           	retq
    f3f3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f3fe: 66 90                        	nop

000000000000f400 <bpf_program__flags>:
; {
    f400: f3 0f 1e fa                  	endbr64
; 	return prog->prog_flags;
    f404: 8b 87 b8 00 00 00            	movl	184(%rdi), %eax
; }
    f40a: c3                           	retq
    f40b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000000f410 <bpf_program__set_flags>:
; {
    f410: f3 0f 1e fa                  	endbr64
; 	if (prog->obj->loaded)
    f414: 48 8b 47 70                  	movq	112(%rdi), %rax
    f418: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    f41f: 75 09                        	jne	0xf42a <bpf_program__set_flags+0x1a>
; 	prog->prog_flags = flags;
    f421: 89 b7 b8 00 00 00            	movl	%esi, 184(%rdi)
; 	return 0;
    f427: 31 c0                        	xorl	%eax, %eax
; }
    f429: c3                           	retq
; {
    f42a: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
    f42e: e8 bd 62 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f433: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
    f439: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
    f43e: 48 83 c4 08                  	addq	$8, %rsp
    f442: c3                           	retq
    f443: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f44e: 66 90                        	nop

000000000000f450 <bpf_program__log_level>:
; {
    f450: f3 0f 1e fa                  	endbr64
; 	return prog->log_level;
    f454: 8b 47 68                     	movl	104(%rdi), %eax
; }
    f457: c3                           	retq
    f458: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000000f460 <bpf_program__set_log_level>:
; {
    f460: f3 0f 1e fa                  	endbr64
; 	if (prog->obj->loaded)
    f464: 48 8b 47 70                  	movq	112(%rdi), %rax
    f468: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    f46f: 75 06                        	jne	0xf477 <bpf_program__set_log_level+0x17>
; 	prog->log_level = log_level;
    f471: 89 77 68                     	movl	%esi, 104(%rdi)
; 	return 0;
    f474: 31 c0                        	xorl	%eax, %eax
; }
    f476: c3                           	retq
; {
    f477: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
    f47b: e8 70 62 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f480: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
    f486: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
    f48b: 48 83 c4 08                  	addq	$8, %rsp
    f48f: c3                           	retq

000000000000f490 <bpf_program__log_buf>:
; {
    f490: f3 0f 1e fa                  	endbr64
; 	*log_size = prog->log_size;
    f494: 48 8b 47 60                  	movq	96(%rdi), %rax
    f498: 48 89 06                     	movq	%rax, (%rsi)
; 	return prog->log_buf;
    f49b: 48 8b 47 58                  	movq	88(%rdi), %rax
; }
    f49f: c3                           	retq

000000000000f4a0 <bpf_program__set_log_buf>:
; {
    f4a0: f3 0f 1e fa                  	endbr64
; 	if (log_size && !log_buf)
    f4a4: 48 85 d2                     	testq	%rdx, %rdx
    f4a7: 74 05                        	je	0xf4ae <bpf_program__set_log_buf+0xe>
    f4a9: 48 85 f6                     	testq	%rsi, %rsi
    f4ac: 74 2a                        	je	0xf4d8 <bpf_program__set_log_buf+0x38>
; 	if (prog->log_size > UINT_MAX)
    f4ae: b8 ff ff ff ff               	movl	$4294967295, %eax       # imm = 0xFFFFFFFF
    f4b3: 48 39 47 60                  	cmpq	%rax, 96(%rdi)
    f4b7: 77 1f                        	ja	0xf4d8 <bpf_program__set_log_buf+0x38>
; 	if (prog->obj->loaded)
    f4b9: 48 8b 47 70                  	movq	112(%rdi), %rax
    f4bd: 80 b8 98 00 00 00 00         	cmpb	$0, 152(%rax)
    f4c4: 75 1a                        	jne	0xf4e0 <bpf_program__set_log_buf+0x40>
; 	prog->log_buf = log_buf;
    f4c6: 48 89 77 58                  	movq	%rsi, 88(%rdi)
; 	return 0;
    f4ca: 31 c0                        	xorl	%eax, %eax
; 	prog->log_size = log_size;
    f4cc: 48 89 57 60                  	movq	%rdx, 96(%rdi)
; 	return 0;
    f4d0: c3                           	retq
    f4d1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return -EINVAL;
    f4d8: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    f4dd: c3                           	retq
    f4de: 66 90                        	nop
; 		return -EBUSY;
    f4e0: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
    f4e5: c3                           	retq
    f4e6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000000f4f0 <libbpf_register_prog_handler>:
; {
    f4f0: f3 0f 1e fa                  	endbr64
    f4f4: 41 57                        	pushq	%r15
    f4f6: 49 89 ff                     	movq	%rdi, %r15
    f4f9: 41 56                        	pushq	%r14
    f4fb: 41 89 d6                     	movl	%edx, %r14d
    f4fe: 41 55                        	pushq	%r13
    f500: 41 89 f5                     	movl	%esi, %r13d
    f503: 41 54                        	pushq	%r12
    f505: 55                           	pushq	%rbp
    f506: 53                           	pushq	%rbx
    f507: 48 89 cb                     	movq	%rcx, %rbx
    f50a: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!OPTS_VALID(opts, libbpf_prog_handler_opts))
    f50e: 48 85 c9                     	testq	%rcx, %rcx
    f511: 74 65                        	je	0xf578 <libbpf_register_prog_handler+0x88>
    f513: 48 8b 09                     	movq	(%rcx), %rcx
; 	if (user_sz < sizeof(size_t)) {
    f516: 48 83 f9 07                  	cmpq	$7, %rcx
    f51a: 0f 86 b0 01 00 00            	jbe	0xf6d0 <libbpf_register_prog_handler+0x1e0>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
    f520: 48 8d 51 d8                  	leaq	-40(%rcx), %rdx
    f524: 48 8d 43 28                  	leaq	40(%rbx), %rax
; 	while (len > 0) {
    f528: 48 85 d2                     	testq	%rdx, %rdx
    f52b: 7e 4b                        	jle	0xf578 <libbpf_register_prog_handler+0x88>
    f52d: 48 01 d9                     	addq	%rbx, %rcx
    f530: eb 0f                        	jmp	0xf541 <libbpf_register_prog_handler+0x51>
    f532: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		p++;
    f538: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
    f53c: 48 39 c1                     	cmpq	%rax, %rcx
    f53f: 74 37                        	je	0xf578 <libbpf_register_prog_handler+0x88>
; 		if (*p)
    f541: 80 38 00                     	cmpb	$0, (%rax)
    f544: 74 f2                        	je	0xf538 <libbpf_register_prog_handler+0x48>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
    f546: 48 8d 15 8d 2a 02 00         	leaq	141965(%rip), %rdx      # 0x31fda <_IO_stdin_used+0x1fda>
    f54d: 48 8d 35 bc 4a 02 00         	leaq	150204(%rip), %rsi      # 0x34010 <strs.2+0x1180>
    f554: 31 ff                        	xorl	%edi, %edi
    f556: 31 c0                        	xorl	%eax, %eax
    f558: e8 73 8b ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
    f55d: e8 8e 61 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f562: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
    f568: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    f56d: e9 d1 00 00 00               	jmp	0xf643 <libbpf_register_prog_handler+0x153>
    f572: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (last_custom_sec_def_handler_id == INT_MAX) /* prevent overflow */
    f578: 44 8b 25 a9 7c 03 00         	movl	228521(%rip), %r12d     # 0x47228 <last_custom_sec_def_handler_id>
    f57f: 41 81 fc ff ff ff 7f         	cmpl	$2147483647, %r12d      # imm = 0x7FFFFFFF
    f586: 0f 84 75 01 00 00            	je	0xf701 <libbpf_register_prog_handler+0x211>
; 	if (sec) {
    f58c: 4d 85 ff                     	testq	%r15, %r15
    f58f: 0f 84 fb 00 00 00            	je	0xf690 <libbpf_register_prog_handler+0x1a0>
; 		sec_def = libbpf_reallocarray(custom_sec_defs, custom_sec_def_cnt + 1,
    f595: 48 8b 2d e4 7c 03 00         	movq	228580(%rip), %rbp      # 0x47280 <custom_sec_def_cnt>
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    f59c: ba 38 00 00 00               	movl	$56, %edx
; 		sec_def = libbpf_reallocarray(custom_sec_defs, custom_sec_def_cnt + 1,
    f5a1: 48 8b 3d d0 7c 03 00         	movq	228560(%rip), %rdi      # 0x47278 <custom_sec_defs>
    f5a8: 48 8d 75 01                  	leaq	1(%rbp), %rsi
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    f5ac: 48 89 f0                     	movq	%rsi, %rax
    f5af: 48 f7 e2                     	mulq	%rdx
    f5b2: 48 89 c6                     	movq	%rax, %rsi
    f5b5: 0f 80 31 01 00 00            	jo	0xf6ec <libbpf_register_prog_handler+0x1fc>
; 	return realloc(ptr, total);
    f5bb: e8 60 65 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 		if (!sec_def)
    f5c0: 48 85 c0                     	testq	%rax, %rax
    f5c3: 0f 84 23 01 00 00            	je	0xf6ec <libbpf_register_prog_handler+0x1fc>
; 		sec_def = &custom_sec_defs[custom_sec_def_cnt];
    f5c9: 48 8d 14 ed 00 00 00 00      	leaq	(,%rbp,8), %rdx
; 	sec_def->sec = sec ? strdup(sec) : NULL;
    f5d1: 4c 89 ff                     	movq	%r15, %rdi
; 		custom_sec_defs = sec_def;
    f5d4: 48 89 05 9d 7c 03 00         	movq	%rax, 228509(%rip)      # 0x47278 <custom_sec_defs>
; 		sec_def = &custom_sec_defs[custom_sec_def_cnt];
    f5db: 48 29 ea                     	subq	%rbp, %rdx
    f5de: 48 8d 2c d0                  	leaq	(%rax,%rdx,8), %rbp
; 	sec_def->sec = sec ? strdup(sec) : NULL;
    f5e2: e8 29 66 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
    f5e7: 48 89 45 00                  	movq	%rax, (%rbp)
; 	if (sec && !sec_def->sec)
    f5eb: 48 85 c0                     	testq	%rax, %rax
    f5ee: 0f 84 f8 00 00 00            	je	0xf6ec <libbpf_register_prog_handler+0x1fc>
; 	sec_def->prog_type = prog_type;
    f5f4: 44 89 6d 08                  	movl	%r13d, 8(%rbp)
; 	sec_def->expected_attach_type = exp_attach_type;
    f5f8: 44 89 75 0c                  	movl	%r14d, 12(%rbp)
; 	sec_def->cookie = OPTS_GET(opts, cookie, 0);
    f5fc: 48 85 db                     	testq	%rbx, %rbx
    f5ff: 74 09                        	je	0xf60a <libbpf_register_prog_handler+0x11a>
    f601: 48 8b 03                     	movq	(%rbx), %rax
    f604: 48 83 f8 0f                  	cmpq	$15, %rax
    f608: 77 4e                        	ja	0xf658 <libbpf_register_prog_handler+0x168>
    f60a: 48 c7 45 10 00 00 00 00      	movq	$0, 16(%rbp)
; 	sec_def->prog_setup_fn = OPTS_GET(opts, prog_setup_fn, NULL);
    f612: 48 c7 45 20 00 00 00 00      	movq	$0, 32(%rbp)
; 	sec_def->prog_prepare_load_fn = OPTS_GET(opts, prog_prepare_load_fn, NULL);
    f61a: 48 c7 45 28 00 00 00 00      	movq	$0, 40(%rbp)
; 	sec_def->prog_attach_fn = OPTS_GET(opts, prog_attach_fn, NULL);
    f622: 31 c0                        	xorl	%eax, %eax
    f624: 48 89 45 30                  	movq	%rax, 48(%rbp)
; 	sec_def->handler_id = ++last_custom_sec_def_handler_id;
    f628: 41 8d 44 24 01               	leal	1(%r12), %eax
    f62d: 89 05 f5 7b 03 00            	movl	%eax, 228341(%rip)      # 0x47228 <last_custom_sec_def_handler_id>
    f633: 89 45 18                     	movl	%eax, 24(%rbp)
; 	if (sec)
    f636: 4d 85 ff                     	testq	%r15, %r15
    f639: 74 75                        	je	0xf6b0 <libbpf_register_prog_handler+0x1c0>
; 		custom_sec_def_cnt++;
    f63b: 48 83 05 3d 7c 03 00 01      	addq	$1, 228413(%rip)        # 0x47280 <custom_sec_def_cnt>
; }
    f643: 48 83 c4 08                  	addq	$8, %rsp
    f647: 5b                           	popq	%rbx
    f648: 5d                           	popq	%rbp
    f649: 41 5c                        	popq	%r12
    f64b: 41 5d                        	popq	%r13
    f64d: 41 5e                        	popq	%r14
    f64f: 41 5f                        	popq	%r15
    f651: c3                           	retq
    f652: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	sec_def->cookie = OPTS_GET(opts, cookie, 0);
    f658: 48 8b 53 08                  	movq	8(%rbx), %rdx
    f65c: 48 89 55 10                  	movq	%rdx, 16(%rbp)
; 	sec_def->prog_setup_fn = OPTS_GET(opts, prog_setup_fn, NULL);
    f660: 48 83 f8 17                  	cmpq	$23, %rax
    f664: 76 ac                        	jbe	0xf612 <libbpf_register_prog_handler+0x122>
    f666: 48 8b 53 10                  	movq	16(%rbx), %rdx
    f66a: 48 89 55 20                  	movq	%rdx, 32(%rbp)
; 	sec_def->prog_prepare_load_fn = OPTS_GET(opts, prog_prepare_load_fn, NULL);
    f66e: 48 83 f8 1f                  	cmpq	$31, %rax
    f672: 76 a6                        	jbe	0xf61a <libbpf_register_prog_handler+0x12a>
    f674: 48 8b 53 18                  	movq	24(%rbx), %rdx
    f678: 48 89 55 28                  	movq	%rdx, 40(%rbp)
; 	sec_def->prog_attach_fn = OPTS_GET(opts, prog_attach_fn, NULL);
    f67c: 48 83 f8 27                  	cmpq	$39, %rax
    f680: 0f 86 a5 00 00 00            	jbe	0xf72b <libbpf_register_prog_handler+0x23b>
    f686: 48 8b 43 20                  	movq	32(%rbx), %rax
    f68a: eb 98                        	jmp	0xf624 <libbpf_register_prog_handler+0x134>
    f68c: 0f 1f 40 00                  	nopl	(%rax)
; 		if (has_custom_fallback_def)
    f690: 80 3d 95 7b 03 00 00         	cmpb	$0, 228245(%rip)        # 0x4722c <has_custom_fallback_def>
    f697: 75 7d                        	jne	0xf716 <libbpf_register_prog_handler+0x226>
; 	sec_def->sec = sec ? strdup(sec) : NULL;
    f699: 48 c7 05 9c 7b 03 00 00 00 00 00     	movq	$0, 228252(%rip) # 0x47240 <custom_fallback_def>
; 		sec_def = &custom_fallback_def;
    f6a4: 48 8d 2d 95 7b 03 00         	leaq	228245(%rip), %rbp      # 0x47240 <custom_fallback_def>
    f6ab: e9 44 ff ff ff               	jmp	0xf5f4 <libbpf_register_prog_handler+0x104>
; 		has_custom_fallback_def = true;
    f6b0: c6 05 75 7b 03 00 01         	movb	$1, 228213(%rip)        # 0x4722c <has_custom_fallback_def>
; }
    f6b7: 48 83 c4 08                  	addq	$8, %rsp
    f6bb: 5b                           	popq	%rbx
    f6bc: 5d                           	popq	%rbp
    f6bd: 41 5c                        	popq	%r12
    f6bf: 41 5d                        	popq	%r13
    f6c1: 41 5e                        	popq	%r14
    f6c3: 41 5f                        	popq	%r15
    f6c5: c3                           	retq
    f6c6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
    f6d0: 48 8d 15 03 29 02 00         	leaq	141571(%rip), %rdx      # 0x31fda <_IO_stdin_used+0x1fda>
    f6d7: 48 8d 35 da 48 02 00         	leaq	149722(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
    f6de: 31 ff                        	xorl	%edi, %edi
    f6e0: 31 c0                        	xorl	%eax, %eax
    f6e2: e8 e9 89 ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
    f6e7: e9 71 fe ff ff               	jmp	0xf55d <libbpf_register_prog_handler+0x6d>
; 		errno = -ret;
    f6ec: e8 ff 5f ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f6f1: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
    f6f7: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
    f6fc: e9 42 ff ff ff               	jmp	0xf643 <libbpf_register_prog_handler+0x153>
; 		errno = -ret;
    f701: e8 ea 5f ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f706: c7 00 07 00 00 00            	movl	$7, (%rax)
; 		return libbpf_err(-E2BIG);
    f70c: b8 f9 ff ff ff               	movl	$4294967289, %eax       # imm = 0xFFFFFFF9
    f711: e9 2d ff ff ff               	jmp	0xf643 <libbpf_register_prog_handler+0x153>
; 		errno = -ret;
    f716: e8 d5 5f ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f71b: c7 00 10 00 00 00            	movl	$16, (%rax)
; 			return libbpf_err(-EBUSY);
    f721: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
    f726: e9 18 ff ff ff               	jmp	0xf643 <libbpf_register_prog_handler+0x153>
; 	sec_def->prog_attach_fn = OPTS_GET(opts, prog_attach_fn, NULL);
    f72b: 31 c0                        	xorl	%eax, %eax
    f72d: e9 f2 fe ff ff               	jmp	0xf624 <libbpf_register_prog_handler+0x134>
    f732: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f73d: 0f 1f 00                     	nopl	(%rax)

000000000000f740 <libbpf_unregister_prog_handler>:
; {
    f740: f3 0f 1e fa                  	endbr64
    f744: 41 54                        	pushq	%r12
    f746: 55                           	pushq	%rbp
    f747: 53                           	pushq	%rbx
; 	if (handler_id <= 0)
    f748: 85 ff                        	testl	%edi, %edi
    f74a: 0f 8e 1a 01 00 00            	jle	0xf86a <libbpf_unregister_prog_handler+0x12a>
; 	if (has_custom_fallback_def && custom_fallback_def.handler_id == handler_id) {
    f750: 80 3d d5 7a 03 00 00         	cmpb	$0, 228053(%rip)        # 0x4722c <has_custom_fallback_def>
    f757: 0f 85 bb 00 00 00            	jne	0xf818 <libbpf_unregister_prog_handler+0xd8>
; 	for (i = 0; i < custom_sec_def_cnt; i++) {
    f75d: 48 8b 1d 1c 7b 03 00         	movq	228124(%rip), %rbx      # 0x47280 <custom_sec_def_cnt>
    f764: 48 85 db                     	testq	%rbx, %rbx
    f767: 0f 84 eb 00 00 00            	je	0xf858 <libbpf_unregister_prog_handler+0x118>
; 		if (custom_sec_defs[i].handler_id == handler_id)
    f76d: 4c 8b 25 04 7b 03 00         	movq	228100(%rip), %r12      # 0x47278 <custom_sec_defs>
; 	for (i = 0; i < custom_sec_def_cnt; i++) {
    f774: 31 c0                        	xorl	%eax, %eax
    f776: 4c 89 e2                     	movq	%r12, %rdx
    f779: eb 12                        	jmp	0xf78d <libbpf_unregister_prog_handler+0x4d>
    f77b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
    f780: 48 83 c2 38                  	addq	$56, %rdx
    f784: 48 39 d8                     	cmpq	%rbx, %rax
    f787: 0f 84 cb 00 00 00            	je	0xf858 <libbpf_unregister_prog_handler+0x118>
    f78d: 89 c5                        	movl	%eax, %ebp
; 		if (custom_sec_defs[i].handler_id == handler_id)
    f78f: 48 83 c0 01                  	addq	$1, %rax
    f793: 39 7a 18                     	cmpl	%edi, 24(%rdx)
    f796: 75 e8                        	jne	0xf780 <libbpf_unregister_prog_handler+0x40>
; 	free(custom_sec_defs[i].sec);
    f798: 48 8b 3a                     	movq	(%rdx), %rdi
; 	for (i = i + 1; i < custom_sec_def_cnt; i++)
    f79b: 83 c5 01                     	addl	$1, %ebp
    f79e: 48 63 ed                     	movslq	%ebp, %rbp
; 	free(custom_sec_defs[i].sec);
    f7a1: e8 1a 5f ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	for (i = i + 1; i < custom_sec_def_cnt; i++)
    f7a6: 48 39 dd                     	cmpq	%rbx, %rbp
    f7a9: 73 32                        	jae	0xf7dd <libbpf_unregister_prog_handler+0x9d>
; 		custom_sec_defs[i - 1] = custom_sec_defs[i];
    f7ab: 48 89 d9                     	movq	%rbx, %rcx
    f7ae: 48 8d 04 ed 00 00 00 00      	leaq	(,%rbp,8), %rax
    f7b6: 48 29 e9                     	subq	%rbp, %rcx
    f7b9: 48 29 e8                     	subq	%rbp, %rax
    f7bc: 48 8d 14 cd 00 00 00 00      	leaq	(,%rcx,8), %rdx
    f7c4: 48 c1 e0 03                  	shlq	$3, %rax
    f7c8: 48 29 ca                     	subq	%rcx, %rdx
    f7cb: 49 8d 34 04                  	leaq	(%r12,%rax), %rsi
    f7cf: 49 8d 7c 04 c8               	leaq	-56(%r12,%rax), %rdi
    f7d4: 48 c1 e2 03                  	shlq	$3, %rdx
    f7d8: e8 a3 63 ff ff               	callq	0x5b80 <.plt.sec+0x510>
; 	custom_sec_def_cnt--;
    f7dd: 48 83 eb 01                  	subq	$1, %rbx
; 	return realloc(ptr, total);
    f7e1: 4c 89 e7                     	movq	%r12, %rdi
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    f7e4: 48 8d 34 dd 00 00 00 00      	leaq	(,%rbx,8), %rsi
; 	custom_sec_def_cnt--;
    f7ec: 48 89 1d 8d 7a 03 00         	movq	%rbx, 227981(%rip)      # 0x47280 <custom_sec_def_cnt>
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
    f7f3: 48 29 de                     	subq	%rbx, %rsi
    f7f6: 48 c1 e6 03                  	shlq	$3, %rsi
; 	return realloc(ptr, total);
    f7fa: e8 21 63 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 	if (sec_defs)
    f7ff: 48 85 c0                     	testq	%rax, %rax
    f802: 74 09                        	je	0xf80d <libbpf_unregister_prog_handler+0xcd>
; 		custom_sec_defs = sec_defs;
    f804: 48 89 05 6d 7a 03 00         	movq	%rax, 227949(%rip)      # 0x47278 <custom_sec_defs>
; 	return 0;
    f80b: 31 c0                        	xorl	%eax, %eax
; }
    f80d: 5b                           	popq	%rbx
    f80e: 5d                           	popq	%rbp
    f80f: 41 5c                        	popq	%r12
    f811: c3                           	retq
    f812: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (has_custom_fallback_def && custom_fallback_def.handler_id == handler_id) {
    f818: 39 3d 3a 7a 03 00            	cmpl	%edi, 227898(%rip)      # 0x47258 <custom_fallback_def+0x18>
    f81e: 0f 85 39 ff ff ff            	jne	0xf75d <libbpf_unregister_prog_handler+0x1d>
;   return __builtin___memset_chk (__dest, __ch, __len,
    f824: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 		has_custom_fallback_def = false;
    f828: c6 05 fd 79 03 00 00         	movb	$0, 227837(%rip)        # 0x4722c <has_custom_fallback_def>
; 		return 0;
    f82f: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
    f831: 48 c7 05 34 7a 03 00 00 00 00 00     	movq	$0, 227892(%rip) # 0x47270 <custom_fallback_def+0x30>
    f83c: 0f 29 05 fd 79 03 00         	movaps	%xmm0, 227837(%rip)     # 0x47240 <custom_fallback_def>
    f843: 0f 29 05 06 7a 03 00         	movaps	%xmm0, 227846(%rip)     # 0x47250 <custom_fallback_def+0x10>
    f84a: 0f 29 05 0f 7a 03 00         	movaps	%xmm0, 227855(%rip)     # 0x47260 <custom_fallback_def+0x20>
; 		return 0;
    f851: eb ba                        	jmp	0xf80d <libbpf_unregister_prog_handler+0xcd>
    f853: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		errno = -ret;
    f858: e8 93 5e ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f85d: c7 00 02 00 00 00            	movl	$2, (%rax)
; 		return libbpf_err(-ENOENT);
    f863: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
    f868: eb a3                        	jmp	0xf80d <libbpf_unregister_prog_handler+0xcd>
; 		errno = -ret;
    f86a: e8 81 5e ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f86f: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
    f875: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    f87a: eb 91                        	jmp	0xf80d <libbpf_unregister_prog_handler+0xcd>
    f87c: 0f 1f 40 00                  	nopl	(%rax)

000000000000f880 <libbpf_prog_type_by_name>:
; {
    f880: f3 0f 1e fa                  	endbr64
    f884: 41 54                        	pushq	%r12
    f886: 55                           	pushq	%rbp
    f887: 53                           	pushq	%rbx
; 	if (!name)
    f888: 48 85 ff                     	testq	%rdi, %rdi
    f88b: 74 7a                        	je	0xf907 <libbpf_prog_type_by_name+0x87>
    f88d: 49 89 fc                     	movq	%rdi, %r12
    f890: 48 89 f5                     	movq	%rsi, %rbp
    f893: 48 89 d3                     	movq	%rdx, %rbx
; 	sec_def = find_sec_def(name);
    f896: e8 45 7f ff ff               	callq	0x77e0 <find_sec_def>
; 	if (sec_def) {
    f89b: 48 85 c0                     	testq	%rax, %rax
    f89e: 74 12                        	je	0xf8b2 <libbpf_prog_type_by_name+0x32>
; 		*prog_type = sec_def->prog_type;
    f8a0: 8b 50 08                     	movl	8(%rax), %edx
    f8a3: 89 55 00                     	movl	%edx, (%rbp)
; 		*expected_attach_type = sec_def->expected_attach_type;
    f8a6: 8b 40 0c                     	movl	12(%rax), %eax
    f8a9: 89 03                        	movl	%eax, (%rbx)
; 		return 0;
    f8ab: 31 c0                        	xorl	%eax, %eax
; }
    f8ad: 5b                           	popq	%rbx
    f8ae: 5d                           	popq	%rbp
    f8af: 41 5c                        	popq	%r12
    f8b1: c3                           	retq
; 	pr_debug("failed to guess program type from ELF section '%s'\n", name);
    f8b2: 4c 89 e2                     	movq	%r12, %rdx
    f8b5: 48 8d 35 7c 57 02 00         	leaq	153468(%rip), %rsi      # 0x35038 <strs.2+0x21a8>
    f8bc: bf 02 00 00 00               	movl	$2, %edi
    f8c1: 31 c0                        	xorl	%eax, %eax
    f8c3: e8 08 88 ff ff               	callq	0x80d0 <libbpf_print>
; 	type_names = libbpf_get_type_names(false);
    f8c8: 31 ff                        	xorl	%edi, %edi
    f8ca: e8 41 78 ff ff               	callq	0x7110 <libbpf_get_type_names>
    f8cf: 48 89 c5                     	movq	%rax, %rbp
; 	if (type_names != NULL) {
    f8d2: 48 85 c0                     	testq	%rax, %rax
    f8d5: 74 1e                        	je	0xf8f5 <libbpf_prog_type_by_name+0x75>
; 		pr_debug("supported section(type) names are:%s\n", type_names);
    f8d7: 48 89 c2                     	movq	%rax, %rdx
    f8da: bf 02 00 00 00               	movl	$2, %edi
    f8df: 48 8d 35 92 57 02 00         	leaq	153490(%rip), %rsi      # 0x35078 <strs.2+0x21e8>
    f8e6: 31 c0                        	xorl	%eax, %eax
    f8e8: e8 e3 87 ff ff               	callq	0x80d0 <libbpf_print>
; 		free(type_names);
    f8ed: 48 89 ef                     	movq	%rbp, %rdi
    f8f0: e8 cb 5d ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 		errno = -ret;
    f8f5: e8 f6 5d ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f8fa: c7 00 03 00 00 00            	movl	$3, (%rax)
; 	return libbpf_err(-ESRCH);
    f900: b8 fd ff ff ff               	movl	$4294967293, %eax       # imm = 0xFFFFFFFD
    f905: eb a6                        	jmp	0xf8ad <libbpf_prog_type_by_name+0x2d>
; 		errno = -ret;
    f907: e8 e4 5d ff ff               	callq	0x56f0 <.plt.sec+0x80>
    f90c: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
    f912: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    f917: eb 94                        	jmp	0xf8ad <libbpf_prog_type_by_name+0x2d>
    f919: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000000f920 <libbpf_bpf_attach_type_str>:
; {
    f920: f3 0f 1e fa                  	endbr64
; 	if (t < 0 || t >= ARRAY_SIZE(attach_type_name))
    f924: 83 ff 2b                     	cmpl	$43, %edi
    f927: 77 17                        	ja	0xf940 <libbpf_bpf_attach_type_str+0x20>
; 	return attach_type_name[t];
    f929: 89 ff                        	movl	%edi, %edi
    f92b: 48 8d 05 ee 6c 03 00         	leaq	224494(%rip), %rax      # 0x46620 <attach_type_name>
    f932: 48 8b 04 f8                  	movq	(%rax,%rdi,8), %rax
    f936: c3                           	retq
    f937: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		return NULL;
    f940: 31 c0                        	xorl	%eax, %eax
; }
    f942: c3                           	retq
    f943: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f94e: 66 90                        	nop

000000000000f950 <libbpf_bpf_link_type_str>:
; {
    f950: f3 0f 1e fa                  	endbr64
; 	if (t < 0 || t >= ARRAY_SIZE(link_type_name))
    f954: 83 ff 09                     	cmpl	$9, %edi
    f957: 77 17                        	ja	0xf970 <libbpf_bpf_link_type_str+0x20>
; 	return link_type_name[t];
    f959: 89 ff                        	movl	%edi, %edi
    f95b: 48 8d 05 5e 6c 03 00         	leaq	224350(%rip), %rax      # 0x465c0 <link_type_name>
    f962: 48 8b 04 f8                  	movq	(%rax,%rdi,8), %rax
    f966: c3                           	retq
    f967: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		return NULL;
    f970: 31 c0                        	xorl	%eax, %eax
; }
    f972: c3                           	retq
    f973: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f97e: 66 90                        	nop

000000000000f980 <libbpf_bpf_map_type_str>:
; {
    f980: f3 0f 1e fa                  	endbr64
; 	if (t < 0 || t >= ARRAY_SIZE(map_type_name))
    f984: 83 ff 1e                     	cmpl	$30, %edi
    f987: 77 17                        	ja	0xf9a0 <libbpf_bpf_map_type_str+0x20>
; 	return map_type_name[t];
    f989: 89 ff                        	movl	%edi, %edi
    f98b: 48 8d 05 2e 6b 03 00         	leaq	224046(%rip), %rax      # 0x464c0 <map_type_name>
    f992: 48 8b 04 f8                  	movq	(%rax,%rdi,8), %rax
    f996: c3                           	retq
    f997: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		return NULL;
    f9a0: 31 c0                        	xorl	%eax, %eax
; }
    f9a2: c3                           	retq
    f9a3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f9ae: 66 90                        	nop

000000000000f9b0 <libbpf_bpf_prog_type_str>:
; {
    f9b0: f3 0f 1e fa                  	endbr64
; 	if (t < 0 || t >= ARRAY_SIZE(prog_type_name))
    f9b4: 83 ff 1f                     	cmpl	$31, %edi
    f9b7: 77 17                        	ja	0xf9d0 <libbpf_bpf_prog_type_str+0x20>
; 	return prog_type_name[t];
    f9b9: 89 ff                        	movl	%edi, %edi
    f9bb: 48 8d 05 fe 69 03 00         	leaq	223742(%rip), %rax      # 0x463c0 <prog_type_name>
    f9c2: 48 8b 04 f8                  	movq	(%rax,%rdi,8), %rax
    f9c6: c3                           	retq
    f9c7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		return NULL;
    f9d0: 31 c0                        	xorl	%eax, %eax
; }
    f9d2: c3                           	retq
    f9d3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    f9de: 66 90                        	nop

000000000000f9e0 <btf_get_kernel_prefix_kind>:
; {
    f9e0: f3 0f 1e fa                  	endbr64
; 	switch (attach_type) {
    f9e4: 83 ff 1c                     	cmpl	$28, %edi
    f9e7: 74 57                        	je	0xfa40 <btf_get_kernel_prefix_kind+0x60>
    f9e9: 77 35                        	ja	0xfa20 <btf_get_kernel_prefix_kind+0x40>
    f9eb: 48 8d 05 91 25 02 00         	leaq	140689(%rip), %rax      # 0x31f83 <_IO_stdin_used+0x1f83>
    f9f2: b9 08 00 00 00               	movl	$8, %ecx
    f9f7: 83 ff 17                     	cmpl	$23, %edi
    f9fa: 74 1a                        	je	0xfa16 <btf_get_kernel_prefix_kind+0x36>
    f9fc: 48 8d 0d 8b 25 02 00         	leaq	140683(%rip), %rcx      # 0x31f8e <_IO_stdin_used+0x1f8e>
    fa03: 83 ff 1b                     	cmpl	$27, %edi
    fa06: 48 8d 05 50 24 02 00         	leaq	140368(%rip), %rax      # 0x31e5d <_IO_stdin_used+0x1e5d>
    fa0d: 48 0f 44 c1                  	cmoveq	%rcx, %rax
    fa11: b9 0c 00 00 00               	movl	$12, %ecx
; 		*prefix = BTF_TRACE_PREFIX;
    fa16: 48 89 06                     	movq	%rax, (%rsi)
; 		*kind = BTF_KIND_TYPEDEF;
    fa19: 89 0a                        	movl	%ecx, (%rdx)
; }
    fa1b: c3                           	retq
    fa1c: 0f 1f 40 00                  	nopl	(%rax)
; 	switch (attach_type) {
    fa20: 48 8d 0d 67 25 02 00         	leaq	140647(%rip), %rcx      # 0x31f8e <_IO_stdin_used+0x1f8e>
    fa27: 83 ff 2b                     	cmpl	$43, %edi
    fa2a: 48 8d 05 2c 24 02 00         	leaq	140332(%rip), %rax      # 0x31e5d <_IO_stdin_used+0x1e5d>
    fa31: 48 0f 44 c1                  	cmoveq	%rcx, %rax
    fa35: b9 0c 00 00 00               	movl	$12, %ecx
; 		*prefix = BTF_TRACE_PREFIX;
    fa3a: 48 89 06                     	movq	%rax, (%rsi)
; 		*kind = BTF_KIND_TYPEDEF;
    fa3d: 89 0a                        	movl	%ecx, (%rdx)
; }
    fa3f: c3                           	retq
; 	switch (attach_type) {
    fa40: 48 8d 05 50 25 02 00         	leaq	140624(%rip), %rax      # 0x31f97 <_IO_stdin_used+0x1f97>
    fa47: b9 0c 00 00 00               	movl	$12, %ecx
    fa4c: eb c8                        	jmp	0xfa16 <btf_get_kernel_prefix_kind+0x36>
    fa4e: 66 90                        	nop

000000000000fa50 <libbpf_find_vmlinux_btf_id>:
; {
    fa50: f3 0f 1e fa                  	endbr64
    fa54: 41 57                        	pushq	%r15
    fa56: 41 56                        	pushq	%r14
    fa58: 41 55                        	pushq	%r13
    fa5a: 41 54                        	pushq	%r12
    fa5c: 49 89 fc                     	movq	%rdi, %r12
    fa5f: 55                           	pushq	%rbp
    fa60: 53                           	pushq	%rbx
    fa61: 89 f3                        	movl	%esi, %ebx
    fa63: 48 81 ec 98 00 00 00         	subq	$152, %rsp
    fa6a: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    fa73: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
    fa7b: 31 c0                        	xorl	%eax, %eax
; 	btf = btf__load_vmlinux_btf();
    fa7d: e8 ee e1 01 00               	callq	0x2dc70 <libbpf_find_kernel_btf>
    fa82: 48 89 c5                     	movq	%rax, %rbp
; 	if (!IS_ERR_OR_NULL(ptr))
    fa85: 48 85 c0                     	testq	%rax, %rax
    fa88: 0f 84 e2 00 00 00            	je	0xfb70 <libbpf_find_vmlinux_btf_id+0x120>
    fa8e: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
    fa94: 0f 87 d6 00 00 00            	ja	0xfb70 <libbpf_find_vmlinux_btf_id+0x120>
; 	switch (attach_type) {
    fa9a: 83 fb 1c                     	cmpl	$28, %ebx
    fa9d: 0f 84 85 01 00 00            	je	0xfc28 <libbpf_find_vmlinux_btf_id+0x1d8>
    faa3: 0f 87 0f 01 00 00            	ja	0xfbb8 <libbpf_find_vmlinux_btf_id+0x168>
    faa9: 41 bd 08 00 00 00            	movl	$8, %r13d
; 		*prefix = BTF_TRACE_PREFIX;
    faaf: 4c 8d 0d cd 24 02 00         	leaq	140493(%rip), %r9       # 0x31f83 <_IO_stdin_used+0x1f83>
; 	switch (attach_type) {
    fab6: 83 fb 17                     	cmpl	$23, %ebx
    fab9: 0f 85 89 00 00 00            	jne	0xfb48 <libbpf_find_vmlinux_btf_id+0xf8>
    fabf: 90                           	nop
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    fac0: 49 89 e6                     	movq	%rsp, %r14
    fac3: 48 83 ec 08                  	subq	$8, %rsp
    fac7: 4c 8d 05 d3 24 02 00         	leaq	140499(%rip), %r8       # 0x31fa1 <_IO_stdin_used+0x1fa1>
    face: 31 c0                        	xorl	%eax, %eax
    fad0: 41 54                        	pushq	%r12
    fad2: b9 80 00 00 00               	movl	$128, %ecx
    fad7: ba 01 00 00 00               	movl	$1, %edx
    fadc: 4c 89 f7                     	movq	%r14, %rdi
    fadf: be 80 00 00 00               	movl	$128, %esi
    fae4: e8 c7 5b ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (ret < 0 || ret >= sizeof(btf_type_name))
    fae9: 4c 89 f4                     	movq	%r14, %rsp
    faec: 83 f8 7f                     	cmpl	$127, %eax
    faef: 0f 87 4b 01 00 00            	ja	0xfc40 <libbpf_find_vmlinux_btf_id+0x1f0>
; 	return btf__find_by_name_kind(btf, btf_type_name, kind);
    faf5: 44 89 ea                     	movl	%r13d, %edx
    faf8: 4c 89 f6                     	movq	%r14, %rsi
    fafb: 48 89 ef                     	movq	%rbp, %rdi
    fafe: e8 cd bf 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
    fb03: 41 89 c5                     	movl	%eax, %r13d
; 	if (err <= 0)
    fb06: 85 c0                        	testl	%eax, %eax
    fb08: 0f 8e e2 00 00 00            	jle	0xfbf0 <libbpf_find_vmlinux_btf_id+0x1a0>
; 	btf__free(btf);
    fb0e: 48 89 ef                     	movq	%rbp, %rdi
    fb11: e8 da ac 01 00               	callq	0x2a7f0 <btf__free>
; }
    fb16: 48 8b 84 24 88 00 00 00      	movq	136(%rsp), %rax
    fb1e: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
    fb27: 0f 85 3b 01 00 00            	jne	0xfc68 <libbpf_find_vmlinux_btf_id+0x218>
    fb2d: 48 81 c4 98 00 00 00         	addq	$152, %rsp
    fb34: 44 89 e8                     	movl	%r13d, %eax
    fb37: 5b                           	popq	%rbx
    fb38: 5d                           	popq	%rbp
    fb39: 41 5c                        	popq	%r12
    fb3b: 41 5d                        	popq	%r13
    fb3d: 41 5e                        	popq	%r14
    fb3f: 41 5f                        	popq	%r15
    fb41: c3                           	retq
    fb42: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	switch (attach_type) {
    fb48: 83 fb 1b                     	cmpl	$27, %ebx
    fb4b: 4c 8d 0d 0b 23 02 00         	leaq	140043(%rip), %r9       # 0x31e5d <_IO_stdin_used+0x1e5d>
    fb52: 48 8d 05 35 24 02 00         	leaq	140341(%rip), %rax      # 0x31f8e <_IO_stdin_used+0x1f8e>
    fb59: 41 bd 0c 00 00 00            	movl	$12, %r13d
    fb5f: 4c 0f 44 c8                  	cmoveq	%rax, %r9
    fb63: e9 58 ff ff ff               	jmp	0xfac0 <libbpf_find_vmlinux_btf_id+0x70>
    fb68: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
    fb70: e8 7b 5b ff ff               	callq	0x56f0 <.plt.sec+0x80>
    fb75: 49 89 c7                     	movq	%rax, %r15
; 	if (IS_ERR(ptr))
    fb78: 48 81 fd 00 f0 ff ff         	cmpq	$-4096, %rbp            # imm = 0xF000
    fb7f: 77 5f                        	ja	0xfbe0 <libbpf_find_vmlinux_btf_id+0x190>
; 	return -errno;
    fb81: 44 8b 30                     	movl	(%rax), %r14d
    fb84: 45 89 f5                     	movl	%r14d, %r13d
    fb87: 41 f7 dd                     	negl	%r13d
; 	if (err) {
    fb8a: 45 85 f6                     	testl	%r14d, %r14d
    fb8d: 0f 84 07 ff ff ff            	je	0xfa9a <libbpf_find_vmlinux_btf_id+0x4a>
; 		pr_warn("vmlinux BTF is not found\n");
    fb93: 31 ff                        	xorl	%edi, %edi
    fb95: 31 c0                        	xorl	%eax, %eax
    fb97: 48 8d 35 0a 55 02 00         	leaq	152842(%rip), %rsi      # 0x350a8 <strs.2+0x2218>
    fb9e: e8 2d 85 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
    fba3: 45 85 f6                     	testl	%r14d, %r14d
    fba6: 0f 8e 6a ff ff ff            	jle	0xfb16 <libbpf_find_vmlinux_btf_id+0xc6>
; 		errno = -ret;
    fbac: 45 89 37                     	movl	%r14d, (%r15)
    fbaf: e9 62 ff ff ff               	jmp	0xfb16 <libbpf_find_vmlinux_btf_id+0xc6>
    fbb4: 0f 1f 40 00                  	nopl	(%rax)
; 	switch (attach_type) {
    fbb8: 83 fb 2b                     	cmpl	$43, %ebx
    fbbb: 4c 8d 0d 9b 22 02 00         	leaq	139931(%rip), %r9       # 0x31e5d <_IO_stdin_used+0x1e5d>
    fbc2: 48 8d 05 c5 23 02 00         	leaq	140229(%rip), %rax      # 0x31f8e <_IO_stdin_used+0x1f8e>
    fbc9: 41 bd 0c 00 00 00            	movl	$12, %r13d
    fbcf: 4c 0f 44 c8                  	cmoveq	%rax, %r9
    fbd3: e9 e8 fe ff ff               	jmp	0xfac0 <libbpf_find_vmlinux_btf_id+0x70>
    fbd8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
    fbe0: 41 89 ee                     	movl	%ebp, %r14d
    fbe3: 41 f7 de                     	negl	%r14d
    fbe6: 44 89 30                     	movl	%r14d, (%rax)
    fbe9: eb 99                        	jmp	0xfb84 <libbpf_find_vmlinux_btf_id+0x134>
    fbeb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("%s is not found in vmlinux BTF\n", name);
    fbf0: 31 ff                        	xorl	%edi, %edi
    fbf2: 31 c0                        	xorl	%eax, %eax
    fbf4: 48 8d 35 d5 54 02 00         	leaq	152789(%rip), %rsi      # 0x350d0 <strs.2+0x2240>
    fbfb: 4c 89 e2                     	movq	%r12, %rdx
    fbfe: e8 cd 84 ff ff               	callq	0x80d0 <libbpf_print>
; 	btf__free(btf);
    fc03: 48 89 ef                     	movq	%rbp, %rdi
    fc06: e8 e5 ab 01 00               	callq	0x2a7f0 <btf__free>
; 	if (ret < 0)
    fc0b: 45 85 ed                     	testl	%r13d, %r13d
    fc0e: 0f 84 02 ff ff ff            	je	0xfb16 <libbpf_find_vmlinux_btf_id+0xc6>
; 		errno = -ret;
    fc14: 44 89 eb                     	movl	%r13d, %ebx
    fc17: f7 db                        	negl	%ebx
    fc19: e8 d2 5a ff ff               	callq	0x56f0 <.plt.sec+0x80>
    fc1e: 89 18                        	movl	%ebx, (%rax)
    fc20: e9 f1 fe ff ff               	jmp	0xfb16 <libbpf_find_vmlinux_btf_id+0xc6>
    fc25: 0f 1f 00                     	nopl	(%rax)
; 	switch (attach_type) {
    fc28: 41 bd 0c 00 00 00            	movl	$12, %r13d
; 		*prefix = BTF_ITER_PREFIX;
    fc2e: 4c 8d 0d 62 23 02 00         	leaq	140130(%rip), %r9       # 0x31f97 <_IO_stdin_used+0x1f97>
    fc35: e9 86 fe ff ff               	jmp	0xfac0 <libbpf_find_vmlinux_btf_id+0x70>
    fc3a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("%s is not found in vmlinux BTF\n", name);
    fc40: 4c 89 e2                     	movq	%r12, %rdx
    fc43: 48 8d 35 86 54 02 00         	leaq	152710(%rip), %rsi      # 0x350d0 <strs.2+0x2240>
    fc4a: 31 ff                        	xorl	%edi, %edi
    fc4c: 31 c0                        	xorl	%eax, %eax
    fc4e: e8 7d 84 ff ff               	callq	0x80d0 <libbpf_print>
; 	btf__free(btf);
    fc53: 48 89 ef                     	movq	%rbp, %rdi
    fc56: bb 24 00 00 00               	movl	$36, %ebx
; 		return -ENAMETOOLONG;
    fc5b: 41 bd dc ff ff ff            	movl	$4294967260, %r13d      # imm = 0xFFFFFFDC
; 	btf__free(btf);
    fc61: e8 8a ab 01 00               	callq	0x2a7f0 <btf__free>
; 	if (ret < 0)
    fc66: eb b1                        	jmp	0xfc19 <libbpf_find_vmlinux_btf_id+0x1c9>
; }
    fc68: e8 93 5b ff ff               	callq	0x5800 <.plt.sec+0x190>
    fc6d: 0f 1f 00                     	nopl	(%rax)

000000000000fc70 <libbpf_attach_type_by_name>:
; {
    fc70: f3 0f 1e fa                  	endbr64
    fc74: 41 54                        	pushq	%r12
    fc76: 53                           	pushq	%rbx
    fc77: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!name)
    fc7b: 48 85 ff                     	testq	%rdi, %rdi
    fc7e: 0f 84 7c 00 00 00            	je	0xfd00 <libbpf_attach_type_by_name+0x90>
    fc84: 49 89 fc                     	movq	%rdi, %r12
    fc87: 48 89 f3                     	movq	%rsi, %rbx
; 	sec_def = find_sec_def(name);
    fc8a: e8 51 7b ff ff               	callq	0x77e0 <find_sec_def>
; 	if (!sec_def) {
    fc8f: 48 85 c0                     	testq	%rax, %rax
    fc92: 74 22                        	je	0xfcb6 <libbpf_attach_type_by_name+0x46>
; 	if (sec_def->prog_prepare_load_fn != libbpf_prepare_prog_load)
    fc94: 48 8d 15 85 e0 ff ff         	leaq	-8059(%rip), %rdx       # 0xdd20 <libbpf_prepare_prog_load>
    fc9b: 48 39 50 28                  	cmpq	%rdx, 40(%rax)
    fc9f: 75 5f                        	jne	0xfd00 <libbpf_attach_type_by_name+0x90>
; 	if (!(sec_def->cookie & SEC_ATTACHABLE))
    fca1: f6 40 10 02                  	testb	$2, 16(%rax)
    fca5: 74 59                        	je	0xfd00 <libbpf_attach_type_by_name+0x90>
; 	*attach_type = sec_def->expected_attach_type;
    fca7: 8b 40 0c                     	movl	12(%rax), %eax
    fcaa: 89 03                        	movl	%eax, (%rbx)
; 	return 0;
    fcac: 31 c0                        	xorl	%eax, %eax
; }
    fcae: 48 83 c4 08                  	addq	$8, %rsp
    fcb2: 5b                           	popq	%rbx
    fcb3: 41 5c                        	popq	%r12
    fcb5: c3                           	retq
; 		pr_debug("failed to guess attach type based on ELF section name '%s'\n", name);
    fcb6: 4c 89 e2                     	movq	%r12, %rdx
    fcb9: 48 8d 35 38 54 02 00         	leaq	152632(%rip), %rsi      # 0x350f8 <strs.2+0x2268>
    fcc0: bf 02 00 00 00               	movl	$2, %edi
    fcc5: e8 06 84 ff ff               	callq	0x80d0 <libbpf_print>
; 		type_names = libbpf_get_type_names(true);
    fcca: bf 01 00 00 00               	movl	$1, %edi
    fccf: e8 3c 74 ff ff               	callq	0x7110 <libbpf_get_type_names>
    fcd4: 49 89 c4                     	movq	%rax, %r12
; 		if (type_names != NULL) {
    fcd7: 48 85 c0                     	testq	%rax, %rax
    fcda: 74 24                        	je	0xfd00 <libbpf_attach_type_by_name+0x90>
; 			pr_debug("attachable section(type) names are:%s\n", type_names);
    fcdc: 48 89 c2                     	movq	%rax, %rdx
    fcdf: bf 02 00 00 00               	movl	$2, %edi
    fce4: 48 8d 35 55 54 02 00         	leaq	152661(%rip), %rsi      # 0x35140 <strs.2+0x22b0>
    fceb: 31 c0                        	xorl	%eax, %eax
    fced: e8 de 83 ff ff               	callq	0x80d0 <libbpf_print>
; 			free(type_names);
    fcf2: 4c 89 e7                     	movq	%r12, %rdi
    fcf5: e8 c6 59 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 		errno = -ret;
    fcfa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
    fd00: e8 eb 59 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    fd05: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
    fd0b: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    fd10: eb 9c                        	jmp	0xfcae <libbpf_attach_type_by_name+0x3e>
    fd12: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
    fd1d: 0f 1f 00                     	nopl	(%rax)

000000000000fd20 <bpf_map__fd>:
; {
    fd20: f3 0f 1e fa                  	endbr64
; 	return map ? map->fd : libbpf_err(-EINVAL);
    fd24: 48 85 ff                     	testq	%rdi, %rdi
    fd27: 74 04                        	je	0xfd2d <bpf_map__fd+0xd>
    fd29: 8b 47 18                     	movl	24(%rdi), %eax
; }
    fd2c: c3                           	retq
; {
    fd2d: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
    fd31: e8 ba 59 ff ff               	callq	0x56f0 <.plt.sec+0x80>
    fd36: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return map ? map->fd : libbpf_err(-EINVAL);
    fd3c: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
    fd41: 48 83 c4 08                  	addq	$8, %rsp
    fd45: c3                           	retq
    fd46: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000000fd50 <bpf_map__name>:
; {
    fd50: f3 0f 1e fa                  	endbr64
    fd54: 41 54                        	pushq	%r12
    fd56: 53                           	pushq	%rbx
    fd57: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!map)
    fd5b: 48 85 ff                     	testq	%rdi, %rdi
    fd5e: 74 60                        	je	0xfdc0 <bpf_map__name+0x70>
    fd60: 8b 47 58                     	movl	88(%rdi), %eax
    fd63: 4c 8b 67 10                  	movq	16(%rdi), %r12
    fd67: 48 89 fb                     	movq	%rdi, %rbx
; 	if (map->libbpf_type == LIBBPF_MAP_DATA && strcmp(map->real_name, DATA_SEC) != 0)
    fd6a: 83 f8 01                     	cmpl	$1, %eax
    fd6d: 74 31                        	je	0xfda0 <bpf_map__name+0x50>
; 	if (map->libbpf_type == LIBBPF_MAP_RODATA && strcmp(map->real_name, RODATA_SEC) != 0)
    fd6f: 83 f8 03                     	cmpl	$3, %eax
    fd72: 74 14                        	je	0xfd88 <bpf_map__name+0x38>
; 	return map->name;
    fd74: 4c 8b 63 08                  	movq	8(%rbx), %r12
; }
    fd78: 48 83 c4 08                  	addq	$8, %rsp
    fd7c: 4c 89 e0                     	movq	%r12, %rax
    fd7f: 5b                           	popq	%rbx
    fd80: 41 5c                        	popq	%r12
    fd82: c3                           	retq
    fd83: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	if (map->libbpf_type == LIBBPF_MAP_RODATA && strcmp(map->real_name, RODATA_SEC) != 0)
    fd88: 48 8d 35 6a 22 02 00         	leaq	139882(%rip), %rsi      # 0x31ff9 <_IO_stdin_used+0x1ff9>
    fd8f: 4c 89 e7                     	movq	%r12, %rdi
    fd92: e8 19 5c ff ff               	callq	0x59b0 <.plt.sec+0x340>
    fd97: 85 c0                        	testl	%eax, %eax
    fd99: 74 d9                        	je	0xfd74 <bpf_map__name+0x24>
    fd9b: eb db                        	jmp	0xfd78 <bpf_map__name+0x28>
    fd9d: 0f 1f 00                     	nopl	(%rax)
; 	if (map->libbpf_type == LIBBPF_MAP_DATA && strcmp(map->real_name, DATA_SEC) != 0)
    fda0: 48 8d 35 4c 22 02 00         	leaq	139852(%rip), %rsi      # 0x31ff3 <_IO_stdin_used+0x1ff3>
    fda7: 4c 89 e7                     	movq	%r12, %rdi
    fdaa: e8 01 5c ff ff               	callq	0x59b0 <.plt.sec+0x340>
    fdaf: 85 c0                        	testl	%eax, %eax
    fdb1: 74 c1                        	je	0xfd74 <bpf_map__name+0x24>
; }
    fdb3: 48 83 c4 08                  	addq	$8, %rsp
    fdb7: 4c 89 e0                     	movq	%r12, %rax
    fdba: 5b                           	popq	%rbx
    fdbb: 41 5c                        	popq	%r12
    fdbd: c3                           	retq
    fdbe: 66 90                        	nop
; 		return NULL;
    fdc0: 45 31 e4                     	xorl	%r12d, %r12d
    fdc3: eb b3                        	jmp	0xfd78 <bpf_map__name+0x28>
    fdc5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

000000000000fdd0 <build_map_pin_path>:
; {
    fdd0: 41 54                        	pushq	%r12
    fdd2: 55                           	pushq	%rbp
    fdd3: 53                           	pushq	%rbx
    fdd4: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
    fddb: 48 83 0c 24 00               	orq	$0, (%rsp)
    fde0: 48 83 ec 10                  	subq	$16, %rsp
    fde4: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    fded: 48 89 84 24 08 10 00 00      	movq	%rax, 4104(%rsp)
    fdf5: 31 c0                        	xorl	%eax, %eax
    fdf7: 48 89 f3                     	movq	%rsi, %rbx
; 		path = "/sys/fs/bpf";
    fdfa: 48 85 f6                     	testq	%rsi, %rsi
    fdfd: 48 8d 05 fd 21 02 00         	leaq	139773(%rip), %rax      # 0x32001 <_IO_stdin_used+0x2001>
    fe04: 48 0f 44 d8                  	cmoveq	%rax, %rbx
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    fe08: 49 89 e4                     	movq	%rsp, %r12
; {
    fe0b: 48 89 fd                     	movq	%rdi, %rbp
; 	len = snprintf(buf, PATH_MAX, "%s/%s", path, bpf_map__name(map));
    fe0e: e8 3d ff ff ff               	callq	0xfd50 <bpf_map__name>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    fe13: 48 83 ec 08                  	subq	$8, %rsp
    fe17: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
    fe1c: 4c 89 e7                     	movq	%r12, %rdi
    fe1f: 50                           	pushq	%rax
    fe20: 49 89 d9                     	movq	%rbx, %r9
    fe23: 4c 8d 05 66 1e 02 00         	leaq	138854(%rip), %r8       # 0x31c90 <_IO_stdin_used+0x1c90>
    fe2a: ba 01 00 00 00               	movl	$1, %edx
    fe2f: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
    fe34: 31 c0                        	xorl	%eax, %eax
    fe36: e8 75 58 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (len < 0)
    fe3b: 4c 89 e4                     	movq	%r12, %rsp
    fe3e: 85 c0                        	testl	%eax, %eax
    fe40: 78 55                        	js	0xfe97 <build_map_pin_path+0xc7>
; 	else if (len >= PATH_MAX)
    fe42: 3d ff 0f 00 00               	cmpl	$4095, %eax             # imm = 0xFFF
    fe47: 7f 47                        	jg	0xfe90 <build_map_pin_path+0xc0>
; 		new = strdup(path);
    fe49: 4c 89 e7                     	movq	%r12, %rdi
    fe4c: e8 bf 5d ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
    fe51: 48 89 c3                     	movq	%rax, %rbx
; 		if (!new)
    fe54: 48 85 c0                     	testq	%rax, %rax
    fe57: 74 4a                        	je	0xfea3 <build_map_pin_path+0xd3>
; 	free(map->pin_path);
    fe59: 48 8b bd 88 00 00 00         	movq	136(%rbp), %rdi
    fe60: e8 5b 58 ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	map->pin_path = new;
    fe65: 48 89 9d 88 00 00 00         	movq	%rbx, 136(%rbp)
; 	return 0;
    fe6c: 31 c0                        	xorl	%eax, %eax
; }
    fe6e: 48 8b 94 24 08 10 00 00      	movq	4104(%rsp), %rdx
    fe76: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
    fe7f: 75 1d                        	jne	0xfe9e <build_map_pin_path+0xce>
    fe81: 48 81 c4 10 10 00 00         	addq	$4112, %rsp             # imm = 0x1010
    fe88: 5b                           	popq	%rbx
    fe89: 5d                           	popq	%rbp
    fe8a: 41 5c                        	popq	%r12
    fe8c: c3                           	retq
    fe8d: 0f 1f 00                     	nopl	(%rax)
; 		return -ENAMETOOLONG;
    fe90: b8 dc ff ff ff               	movl	$4294967260, %eax       # imm = 0xFFFFFFDC
    fe95: eb d7                        	jmp	0xfe6e <build_map_pin_path+0x9e>
; 		return -EINVAL;
    fe97: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
    fe9c: eb d0                        	jmp	0xfe6e <build_map_pin_path+0x9e>
; }
    fe9e: e8 5d 59 ff ff               	callq	0x5800 <.plt.sec+0x190>
    fea3: e8 58 7d ff ff               	callq	0x7c00 <bpf_map__set_pin_path.part.0>
    fea8: eb c4                        	jmp	0xfe6e <build_map_pin_path+0x9e>
    feaa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000000feb0 <bpf_object__init_maps>:
; {
    feb0: 41 57                        	pushq	%r15
    feb2: 41 56                        	pushq	%r14
    feb4: 41 55                        	pushq	%r13
    feb6: 41 54                        	pushq	%r12
    feb8: 55                           	pushq	%rbp
    feb9: 48 89 fd                     	movq	%rdi, %rbp
    febc: 53                           	pushq	%rbx
    febd: 48 81 ec c8 00 00 00         	subq	$200, %rsp
    fec4: 48 89 74 24 30               	movq	%rsi, 48(%rsp)
    fec9: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
    fed2: 48 89 84 24 b8 00 00 00      	movq	%rax, 184(%rsp)
    feda: 31 c0                        	xorl	%eax, %eax
; 	strict = !OPTS_GET(opts, relaxed_maps, false);
    fedc: c7 44 24 20 01 00 00 00      	movl	$1, 32(%rsp)
    fee4: 48 85 f6                     	testq	%rsi, %rsi
    fee7: 74 33                        	je	0xff1c <bpf_object__init_maps+0x6c>
    fee9: 48 8b 06                     	movq	(%rsi), %rax
    feec: 48 83 f8 10                  	cmpq	$16, %rax
    fef0: 0f 86 aa 04 00 00            	jbe	0x103a0 <bpf_object__init_maps+0x4f0>
    fef6: 0f b6 5e 10                  	movzbl	16(%rsi), %ebx
    fefa: 89 da                        	movl	%ebx, %edx
    fefc: 88 1c 24                     	movb	%bl, (%rsp)
    feff: 83 f2 01                     	xorl	$1, %edx
; 	err = err ?: bpf_object__init_user_btf_maps(obj, strict, pin_root_path);
    ff02: 0f b6 da                     	movzbl	%dl, %ebx
    ff05: 89 5c 24 20                  	movl	%ebx, 32(%rsp)
; 	pin_root_path = OPTS_GET(opts, pin_root_path, NULL);
    ff09: 48 83 f8 1f                  	cmpq	$31, %rax
    ff0d: 0f 86 8d 04 00 00            	jbe	0x103a0 <bpf_object__init_maps+0x4f0>
    ff13: 48 8b 46 18                  	movq	24(%rsi), %rax
    ff17: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	if (obj->efile.btf_maps_shndx < 0)
    ff1c: 8b 95 fc 00 00 00            	movl	252(%rbp), %edx
    ff22: 85 d2                        	testl	%edx, %edx
    ff24: 0f 88 d6 02 00 00            	js	0x10200 <bpf_object__init_maps+0x350>
; 	scn = elf_sec_by_idx(obj, obj->efile.btf_maps_shndx);
    ff2a: 4c 63 e2                     	movslq	%edx, %r12
; 	scn = elf_getscn(obj->efile.elf, idx);
    ff2d: 48 8b bd c0 00 00 00         	movq	192(%rbp), %rdi
    ff34: 4c 89 e6                     	movq	%r12, %rsi
    ff37: e8 c4 5c ff ff               	callq	0x5c00 <.plt.sec+0x590>
    ff3c: 48 89 c6                     	movq	%rax, %rsi
; 	if (!scn) {
    ff3f: 48 85 c0                     	testq	%rax, %rax
    ff42: 0f 84 b0 09 00 00            	je	0x108f8 <bpf_object__init_maps+0xa48>
; 	data = elf_sec_data(obj, scn);
    ff48: 48 89 ef                     	movq	%rbp, %rdi
    ff4b: e8 60 b0 ff ff               	callq	0xafb0 <elf_sec_data>
    ff50: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	if (!scn || !data) {
    ff55: 48 85 c0                     	testq	%rax, %rax
    ff58: 0f 84 d7 0a 00 00            	je	0x10a35 <bpf_object__init_maps+0xb85>
; 	nr_types = btf__type_cnt(obj->btf);
    ff5e: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
    ff65: 4c 8d 2d 8d 21 02 00         	leaq	139661(%rip), %r13      # 0x320f9 <_IO_stdin_used+0x20f9>
    ff6c: e8 cf 9f 01 00               	callq	0x29f40 <btf__type_cnt>
    ff71: 41 89 c4                     	movl	%eax, %r12d
; 	for (i = 1; i < nr_types; i++) {
    ff74: 83 f8 01                     	cmpl	$1, %eax
    ff77: 0f 8e d3 04 00 00            	jle	0x10450 <bpf_object__init_maps+0x5a0>
    ff7d: 41 be 01 00 00 00            	movl	$1, %r14d
    ff83: 4c 8d 2d 6f 21 02 00         	leaq	139631(%rip), %r13      # 0x320f9 <_IO_stdin_used+0x20f9>
    ff8a: eb 11                        	jmp	0xff9d <bpf_object__init_maps+0xed>
    ff8c: 0f 1f 40 00                  	nopl	(%rax)
    ff90: 41 83 c6 01                  	addl	$1, %r14d
    ff94: 45 39 f4                     	cmpl	%r14d, %r12d
    ff97: 0f 84 b3 04 00 00            	je	0x10450 <bpf_object__init_maps+0x5a0>
; 		t = btf__type_by_id(obj->btf, i);
    ff9d: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
    ffa4: 44 89 f6                     	movl	%r14d, %esi
    ffa7: e8 f4 9f 01 00               	callq	0x29fa0 <btf__type_by_id>
    ffac: 48 89 c3                     	movq	%rax, %rbx
; 	return BTF_INFO_KIND(t->info);
    ffaf: 0f b6 40 07                  	movzbl	7(%rax), %eax
    ffb3: 83 e0 1f                     	andl	$31, %eax
; 		if (!btf_is_datasec(t))
    ffb6: 66 83 f8 0f                  	cmpw	$15, %ax
    ffba: 75 d4                        	jne	0xff90 <bpf_object__init_maps+0xe0>
; 		name = btf__name_by_offset(obj->btf, t->name_off);
    ffbc: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
    ffc3: 8b 33                        	movl	(%rbx), %esi
    ffc5: e8 26 bb 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 		if (strcmp(name, MAPS_ELF_SEC) == 0) {
    ffca: 4c 89 ee                     	movq	%r13, %rsi
; 		name = btf__name_by_offset(obj->btf, t->name_off);
    ffcd: 48 89 c7                     	movq	%rax, %rdi
; 		if (strcmp(name, MAPS_ELF_SEC) == 0) {
    ffd0: e8 db 59 ff ff               	callq	0x59b0 <.plt.sec+0x340>
    ffd5: 85 c0                        	testl	%eax, %eax
    ffd7: 75 b7                        	jne	0xff90 <bpf_object__init_maps+0xe0>
; 			obj->efile.btf_maps_sec_btf_id = i;
    ffd9: 0f b7 43 04                  	movzwl	4(%rbx), %eax
; 	err = parse_btf_map_def(map->name, obj->btf, def, strict, &map_def, &inner_def);
    ffdd: 48 8d 8c 24 80 00 00 00      	leaq	128(%rsp), %rcx
; 			obj->efile.btf_maps_sec_btf_id = i;
    ffe5: 44 89 b5 00 01 00 00         	movl	%r14d, 256(%rbp)
; 	return BTF_INFO_VLEN(t->info);
    ffec: 48 83 c3 0c                  	addq	$12, %rbx
; 	err = parse_btf_map_def(map->name, obj->btf, def, strict, &map_def, &inner_def);
    fff0: 48 89 4c 24 28               	movq	%rcx, 40(%rsp)
    fff5: 48 8d 4c 24 50               	leaq	80(%rsp), %rcx
; 	for (i = 0; i < vlen; i++) {
    fffa: 45 31 f6                     	xorl	%r14d, %r14d
    fffd: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 	err = parse_btf_map_def(map->name, obj->btf, def, strict, &map_def, &inner_def);
   10001: 48 89 4c 24 18               	movq	%rcx, 24(%rsp)
; 	for (i = 0; i < vlen; i++) {
   10006: 85 c0                        	testl	%eax, %eax
   10008: 0f 84 f2 01 00 00            	je	0x10200 <bpf_object__init_maps+0x350>
   1000e: 66 90                        	nop
; 	struct btf_map_def map_def = {}, inner_def = {};
   10010: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 		err = bpf_object__init_user_btf_map(obj, sec, i,
   10014: 8b 85 fc 00 00 00            	movl	252(%rbp), %eax
; 	var = btf__type_by_id(obj->btf, vi->type);
   1001a: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
; 	struct btf_map_def map_def = {}, inner_def = {};
   10021: 0f 29 84 24 80 00 00 00      	movaps	%xmm0, 128(%rsp)
   10029: 0f 29 84 24 90 00 00 00      	movaps	%xmm0, 144(%rsp)
   10031: 0f 29 84 24 a0 00 00 00      	movaps	%xmm0, 160(%rsp)
; 	var = btf__type_by_id(obj->btf, vi->type);
   10039: 8b 33                        	movl	(%rbx), %esi
; 	struct btf_map_def map_def = {}, inner_def = {};
   1003b: 0f 29 44 24 50               	movaps	%xmm0, 80(%rsp)
   10040: 0f 29 44 24 60               	movaps	%xmm0, 96(%rsp)
   10045: 0f 29 44 24 70               	movaps	%xmm0, 112(%rsp)
; 		err = bpf_object__init_user_btf_map(obj, sec, i,
   1004a: 89 04 24                     	movl	%eax, (%rsp)
; 	var = btf__type_by_id(obj->btf, vi->type);
   1004d: e8 4e 9f 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	map_name = btf__name_by_offset(obj->btf, var->name_off);
   10052: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   10059: 8b 30                        	movl	(%rax), %esi
; 	var = btf__type_by_id(obj->btf, vi->type);
   1005b: 49 89 c7                     	movq	%rax, %r15
; 	map_name = btf__name_by_offset(obj->btf, var->name_off);
   1005e: e8 8d ba 01 00               	callq	0x2baf0 <btf__name_by_offset>
   10063: 49 89 c4                     	movq	%rax, %r12
; 	if (map_name == NULL || map_name[0] == '\0') {
   10066: 48 85 c0                     	testq	%rax, %rax
   10069: 0f 84 8f 07 00 00            	je	0x107fe <bpf_object__init_maps+0x94e>
   1006f: 80 38 00                     	cmpb	$0, (%rax)
   10072: 0f 84 86 07 00 00            	je	0x107fe <bpf_object__init_maps+0x94e>
; 	if ((__u64)vi->offset + vi->size > data->d_size) {
   10078: 8b 43 04                     	movl	4(%rbx), %eax
   1007b: 8b 53 08                     	movl	8(%rbx), %edx
   1007e: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   10083: 48 01 d0                     	addq	%rdx, %rax
   10086: 48 3b 41 10                  	cmpq	16(%rcx), %rax
   1008a: 0f 87 c1 08 00 00            	ja	0x10951 <bpf_object__init_maps+0xaa1>
; 	return BTF_INFO_KIND(t->info);
   10090: 41 0f b6 47 07               	movzbl	7(%r15), %eax
   10095: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_var(var)) {
   10098: 66 83 f8 0e                  	cmpw	$14, %ax
   1009c: 0f 85 7a 07 00 00            	jne	0x1081c <bpf_object__init_maps+0x96c>
; 	if (var_extra->linkage != BTF_VAR_GLOBAL_ALLOCATED) {
   100a2: 41 8b 47 0c                  	movl	12(%r15), %eax
   100a6: 83 f8 01                     	cmpl	$1, %eax
   100a9: 0f 85 11 07 00 00            	jne	0x107c0 <bpf_object__init_maps+0x910>
; 	def = skip_mods_and_typedefs(obj->btf, var->type, NULL);
   100af: 41 8b 77 08                  	movl	8(%r15), %esi
   100b3: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   100ba: 31 d2                        	xorl	%edx, %edx
   100bc: e8 af b4 ff ff               	callq	0xb570 <skip_mods_and_typedefs>
   100c1: 49 89 c5                     	movq	%rax, %r13
; 	return BTF_INFO_KIND(t->info);
   100c4: 0f b6 40 07                  	movzbl	7(%rax), %eax
   100c8: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_struct(def)) {
   100cb: 66 83 f8 04                  	cmpw	$4, %ax
   100cf: 0f 85 8e 07 00 00            	jne	0x10863 <bpf_object__init_maps+0x9b3>
; 	if (def->size > vi->size) {
   100d5: 8b 43 08                     	movl	8(%rbx), %eax
   100d8: 41 39 45 08                  	cmpl	%eax, 8(%r13)
   100dc: 0f 87 63 07 00 00            	ja	0x10845 <bpf_object__init_maps+0x995>
; 	map = bpf_object__add_map(obj);
   100e2: 48 89 ef                     	movq	%rbp, %rdi
   100e5: e8 a6 73 ff ff               	callq	0x7490 <bpf_object__add_map>
   100ea: 49 89 c7                     	movq	%rax, %r15
; 	if (IS_ERR(map))
   100ed: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   100f3: 0f 87 ff 01 00 00            	ja	0x102f8 <bpf_object__init_maps+0x448>
; 	map->name = strdup(map_name);
   100f9: 4c 89 e7                     	movq	%r12, %rdi
   100fc: e8 0f 5b ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   10101: 49 89 47 08                  	movq	%rax, 8(%r15)
; 	if (!map->name) {
   10105: 48 85 c0                     	testq	%rax, %rax
   10108: 0f 84 06 09 00 00            	je	0x10a14 <bpf_object__init_maps+0xb64>
; 	map->sec_idx = sec_idx;
   1010e: 8b 0c 24                     	movl	(%rsp), %ecx
; 	map->libbpf_type = LIBBPF_MAP_UNSPEC;
   10111: 41 c7 47 58 00 00 00 00      	movl	$0, 88(%r15)
; 	pr_debug("map '%s': at sec_idx %d, offset %zu.\n",
   10119: 4c 89 e2                     	movq	%r12, %rdx
   1011c: 31 c0                        	xorl	%eax, %eax
; 	map->def.type = BPF_MAP_TYPE_UNSPEC;
   1011e: 41 c7 47 30 00 00 00 00      	movl	$0, 48(%r15)
; 	pr_debug("map '%s': at sec_idx %d, offset %zu.\n",
   10126: 48 8d 35 cb 51 02 00         	leaq	152011(%rip), %rsi      # 0x352f8 <strs.2+0x2468>
   1012d: bf 02 00 00 00               	movl	$2, %edi
; 	map->sec_idx = sec_idx;
   10132: 41 89 4f 1c                  	movl	%ecx, 28(%r15)
; 	map->sec_offset = vi->offset;
   10136: 44 8b 43 04                  	movl	4(%rbx), %r8d
; 	map->btf_var_idx = var_idx;
   1013a: 45 89 77 48                  	movl	%r14d, 72(%r15)
; 	map->sec_offset = vi->offset;
   1013e: 4d 89 47 20                  	movq	%r8, 32(%r15)
; 	pr_debug("map '%s': at sec_idx %d, offset %zu.\n",
   10142: e8 89 7f ff ff               	callq	0x80d0 <libbpf_print>
; 	err = parse_btf_map_def(map->name, obj->btf, def, strict, &map_def, &inner_def);
   10147: 49 8b 7f 08                  	movq	8(%r15), %rdi
   1014b: 8b 4c 24 20                  	movl	32(%rsp), %ecx
   1014f: 4c 89 ea                     	movq	%r13, %rdx
   10152: 48 8b b5 10 01 00 00         	movq	272(%rbp), %rsi
   10159: 4c 8b 4c 24 28               	movq	40(%rsp), %r9
   1015e: 4c 8b 44 24 18               	movq	24(%rsp), %r8
   10163: e8 a8 b6 ff ff               	callq	0xb810 <parse_btf_map_def>
   10168: 41 89 c5                     	movl	%eax, %r13d
; 	if (err)
   1016b: 85 c0                        	testl	%eax, %eax
   1016d: 0f 85 55 01 00 00            	jne	0x102c8 <bpf_object__init_maps+0x418>
; 	fill_map_from_def(map, &map_def);
   10173: 48 8b 74 24 18               	movq	24(%rsp), %rsi
   10178: 4c 89 ff                     	movq	%r15, %rdi
   1017b: e8 f0 8d ff ff               	callq	0x8f70 <fill_map_from_def>
; 	if (map_def.pinning == LIBBPF_PIN_BY_NAME) {
   10180: 83 7c 24 74 01               	cmpl	$1, 116(%rsp)
   10185: 0f 84 f5 05 00 00            	je	0x10780 <bpf_object__init_maps+0x8d0>
; 	if (map_def.parts & MAP_DEF_INNER_MAP) {
   1018b: f6 44 24 51 02               	testb	$2, 81(%rsp)
   10190: 0f 85 8a 01 00 00            	jne	0x10320 <bpf_object__init_maps+0x470>
; 	if (!obj->btf)
   10196: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   1019d: 48 85 ff                     	testq	%rdi, %rdi
   101a0: 0f 84 bd 02 00 00            	je	0x10463 <bpf_object__init_maps+0x5b3>
; 	if (map->sec_idx == obj->efile.btf_maps_shndx || bpf_map__is_struct_ops(map))
   101a6: 8b 85 fc 00 00 00            	movl	252(%rbp), %eax
   101ac: 41 39 47 1c                  	cmpl	%eax, 28(%r15)
   101b0: 74 33                        	je	0x101e5 <bpf_object__init_maps+0x335>
   101b2: 41 83 7f 30 1a               	cmpl	$26, 48(%r15)
   101b7: 74 2c                        	je	0x101e5 <bpf_object__init_maps+0x335>
; 	if (!bpf_map__is_internal(map))
   101b9: 41 8b 47 58                  	movl	88(%r15), %eax
   101bd: 85 c0                        	testl	%eax, %eax
   101bf: 0f 84 9e 02 00 00            	je	0x10463 <bpf_object__init_maps+0x5b3>
; 	id = btf__find_by_name(obj->btf, map->real_name);
   101c5: 49 8b 77 10                  	movq	16(%r15), %rsi
   101c9: e8 f2 b6 01 00               	callq	0x2b8c0 <btf__find_by_name>
   101ce: 41 89 c5                     	movl	%eax, %r13d
; 	if (id < 0)
   101d1: 85 c0                        	testl	%eax, %eax
   101d3: 0f 88 ef 00 00 00            	js	0x102c8 <bpf_object__init_maps+0x418>
; 	map->btf_key_type_id = 0;
   101d9: 41 c7 47 4c 00 00 00 00      	movl	$0, 76(%r15)
; 	map->btf_value_type_id = id;
   101e1: 41 89 47 50                  	movl	%eax, 80(%r15)
; 	for (i = 0; i < vlen; i++) {
   101e5: 41 83 c6 01                  	addl	$1, %r14d
   101e9: 48 83 c3 0c                  	addq	$12, %rbx
   101ed: 44 39 74 24 10               	cmpl	%r14d, 16(%rsp)
   101f2: 0f 85 18 fe ff ff            	jne	0x10010 <bpf_object__init_maps+0x160>
   101f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	for (sec_idx = 1; sec_idx < obj->efile.sec_cnt; sec_idx++) {
   10200: 83 bd f8 00 00 00 01         	cmpl	$1, 248(%rbp)
   10207: bb 01 00 00 00               	movl	$1, %ebx
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   1020c: 4c 8d 25 5d 4f 02 00         	leaq	151389(%rip), %r12      # 0x35170 <strs.2+0x22e0>
; 	for (sec_idx = 1; sec_idx < obj->efile.sec_cnt; sec_idx++) {
   10213: 7f 24                        	jg	0x10239 <bpf_object__init_maps+0x389>
   10215: e9 56 02 00 00               	jmp	0x10470 <bpf_object__init_maps+0x5c0>
   1021a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		switch (sec_desc->sec_type) {
   10220: 83 f8 02                     	cmpl	$2, %eax
   10223: 0f 84 d7 01 00 00            	je	0x10400 <bpf_object__init_maps+0x550>
; 	for (sec_idx = 1; sec_idx < obj->efile.sec_cnt; sec_idx++) {
   10229: 48 83 c3 01                  	addq	$1, %rbx
   1022d: 39 9d f8 00 00 00            	cmpl	%ebx, 248(%rbp)
   10233: 0f 8e 37 02 00 00            	jle	0x10470 <bpf_object__init_maps+0x5c0>
; 		sec_desc = &obj->efile.secs[sec_idx];
   10239: 48 8b 95 f0 00 00 00         	movq	240(%rbp), %rdx
   10240: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
   10244: 41 89 de                     	movl	%ebx, %r14d
   10247: 4c 8d 2c c2                  	leaq	(%rdx,%rax,8), %r13
; 		if (!sec_desc->data || sec_desc->data->d_size == 0)
   1024b: 49 8b 45 10                  	movq	16(%r13), %rax
   1024f: 48 85 c0                     	testq	%rax, %rax
   10252: 74 d5                        	je	0x10229 <bpf_object__init_maps+0x379>
   10254: 48 83 78 10 00               	cmpq	$0, 16(%rax)
   10259: 74 ce                        	je	0x10229 <bpf_object__init_maps+0x379>
; 		switch (sec_desc->sec_type) {
   1025b: 41 8b 45 00                  	movl	(%r13), %eax
   1025f: 83 f8 03                     	cmpl	$3, %eax
   10262: 0f 84 48 01 00 00            	je	0x103b0 <bpf_object__init_maps+0x500>
   10268: 83 f8 04                     	cmpl	$4, %eax
   1026b: 75 b3                        	jne	0x10220 <bpf_object__init_maps+0x370>
; 			obj->has_rodata = true;
   1026d: c6 85 9a 00 00 00 01         	movb	$1, 154(%rbp)
; 	scn = elf_getscn(obj->efile.elf, idx);
   10274: 48 8b bd c0 00 00 00         	movq	192(%rbp), %rdi
   1027b: 48 89 de                     	movq	%rbx, %rsi
   1027e: e8 7d 59 ff ff               	callq	0x5c00 <.plt.sec+0x590>
   10283: 49 89 c7                     	movq	%rax, %r15
; 	if (!scn) {
   10286: 48 85 c0                     	testq	%rax, %rax
   10289: 0f 84 08 07 00 00            	je	0x10997 <bpf_object__init_maps+0xae7>
; 			sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, sec_idx));
   1028f: 4c 89 fe                     	movq	%r15, %rsi
   10292: 48 89 ef                     	movq	%rbp, %rdi
   10295: e8 a6 a8 ff ff               	callq	0xab40 <elf_sec_name>
; 			err = bpf_object__init_internal_map(obj, LIBBPF_MAP_RODATA,
   1029a: 44 89 f1                     	movl	%r14d, %ecx
   1029d: be 03 00 00 00               	movl	$3, %esi
   102a2: 48 89 ef                     	movq	%rbp, %rdi
; 			sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, sec_idx));
   102a5: 48 89 c2                     	movq	%rax, %rdx
; 							    sec_desc->data->d_size);
   102a8: 49 8b 45 10                  	movq	16(%r13), %rax
; 			err = bpf_object__init_internal_map(obj, LIBBPF_MAP_RODATA,
   102ac: 4c 8b 48 10                  	movq	16(%rax), %r9
   102b0: 4c 8b 00                     	movq	(%rax), %r8
   102b3: e8 b8 a3 ff ff               	callq	0xa670 <bpf_object__init_internal_map>
; 		if (err)
   102b8: 85 c0                        	testl	%eax, %eax
   102ba: 0f 84 69 ff ff ff            	je	0x10229 <bpf_object__init_maps+0x379>
   102c0: 41 89 c5                     	movl	%eax, %r13d
   102c3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; }
   102c8: 48 8b 84 24 b8 00 00 00      	movq	184(%rsp), %rax
   102d0: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   102d9: 0f 85 51 07 00 00            	jne	0x10a30 <bpf_object__init_maps+0xb80>
   102df: 48 81 c4 c8 00 00 00         	addq	$200, %rsp
   102e6: 44 89 e8                     	movl	%r13d, %eax
   102e9: 5b                           	popq	%rbx
   102ea: 5d                           	popq	%rbp
   102eb: 41 5c                        	popq	%r12
   102ed: 41 5d                        	popq	%r13
   102ef: 41 5e                        	popq	%r14
   102f1: 41 5f                        	popq	%r15
   102f3: c3                           	retq
   102f4: 0f 1f 40 00                  	nopl	(%rax)
; 		return PTR_ERR(map);
   102f8: 41 89 c5                     	movl	%eax, %r13d
; 		if (err)
   102fb: 85 c0                        	testl	%eax, %eax
   102fd: 75 c9                        	jne	0x102c8 <bpf_object__init_maps+0x418>
; 	for (i = 0; i < vlen; i++) {
   102ff: 41 83 c6 01                  	addl	$1, %r14d
   10303: 48 83 c3 0c                  	addq	$12, %rbx
   10307: 44 39 74 24 10               	cmpl	%r14d, 16(%rsp)
   1030c: 0f 85 fe fc ff ff            	jne	0x10010 <bpf_object__init_maps+0x160>
   10312: e9 e9 fe ff ff               	jmp	0x10200 <bpf_object__init_maps+0x350>
   10317: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		map->inner_map = calloc(1, sizeof(*map->inner_map));
   10320: be a0 00 00 00               	movl	$160, %esi
   10325: bf 01 00 00 00               	movl	$1, %edi
   1032a: e8 61 56 ff ff               	callq	0x5990 <.plt.sec+0x320>
   1032f: 49 89 47 70                  	movq	%rax, 112(%r15)
   10333: 49 89 c5                     	movq	%rax, %r13
; 		if (!map->inner_map)
   10336: 48 85 c0                     	testq	%rax, %rax
   10339: 0f 84 a8 06 00 00            	je	0x109e7 <bpf_object__init_maps+0xb37>
; 		map->inner_map->fd = -1;
   1033f: c7 40 18 ff ff ff ff         	movl	$4294967295, 24(%rax)   # imm = 0xFFFFFFFF
; 		map->inner_map->sec_idx = sec_idx;
   10346: 8b 04 24                     	movl	(%rsp), %eax
; 		map->inner_map->name = malloc(strlen(map_name) + sizeof(".inner") + 1);
   10349: 4c 89 e7                     	movq	%r12, %rdi
; 		map->inner_map->sec_idx = sec_idx;
   1034c: 41 89 45 1c                  	movl	%eax, 28(%r13)
; 		map->inner_map->name = malloc(strlen(map_name) + sizeof(".inner") + 1);
   10350: e8 8b 54 ff ff               	callq	0x57e0 <.plt.sec+0x170>
   10355: 48 8d 78 08                  	leaq	8(%rax), %rdi
   10359: e8 32 57 ff ff               	callq	0x5a90 <.plt.sec+0x420>
   1035e: 49 89 45 08                  	movq	%rax, 8(%r13)
   10362: 48 89 c7                     	movq	%rax, %rdi
; 		if (!map->inner_map->name)
   10365: 48 85 c0                     	testq	%rax, %rax
   10368: 0f 84 79 06 00 00            	je	0x109e7 <bpf_object__init_maps+0xb37>
;   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
   1036e: 4d 89 e0                     	movq	%r12, %r8
   10371: 48 8d 0d b5 1b 02 00         	leaq	138165(%rip), %rcx      # 0x31f2d <_IO_stdin_used+0x1f2d>
   10378: 48 c7 c2 ff ff ff ff         	movq	$-1, %rdx
   1037f: 31 c0                        	xorl	%eax, %eax
   10381: be 01 00 00 00               	movl	$1, %esi
   10386: e8 05 59 ff ff               	callq	0x5c90 <.plt.sec+0x620>
; 		fill_map_from_def(map->inner_map, &inner_def);
   1038b: 49 8b 7f 70                  	movq	112(%r15), %rdi
   1038f: 48 8b 74 24 28               	movq	40(%rsp), %rsi
   10394: e8 d7 8b ff ff               	callq	0x8f70 <fill_map_from_def>
   10399: e9 f8 fd ff ff               	jmp	0x10196 <bpf_object__init_maps+0x2e6>
   1039e: 66 90                        	nop
; 	pin_root_path = OPTS_GET(opts, pin_root_path, NULL);
   103a0: 48 c7 44 24 30 00 00 00 00   	movq	$0, 48(%rsp)
   103a9: e9 6e fb ff ff               	jmp	0xff1c <bpf_object__init_maps+0x6c>
   103ae: 66 90                        	nop
; 	scn = elf_getscn(obj->efile.elf, idx);
   103b0: 48 8b bd c0 00 00 00         	movq	192(%rbp), %rdi
   103b7: 48 89 de                     	movq	%rbx, %rsi
   103ba: e8 41 58 ff ff               	callq	0x5c00 <.plt.sec+0x590>
   103bf: 49 89 c7                     	movq	%rax, %r15
; 	if (!scn) {
   103c2: 48 85 c0                     	testq	%rax, %rax
   103c5: 0f 84 f4 05 00 00            	je	0x109bf <bpf_object__init_maps+0xb0f>
; 			sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, sec_idx));
   103cb: 4c 89 fe                     	movq	%r15, %rsi
   103ce: 48 89 ef                     	movq	%rbp, %rdi
   103d1: e8 6a a7 ff ff               	callq	0xab40 <elf_sec_name>
; 			err = bpf_object__init_internal_map(obj, LIBBPF_MAP_DATA,
   103d6: 44 89 f1                     	movl	%r14d, %ecx
   103d9: be 01 00 00 00               	movl	$1, %esi
   103de: 48 89 ef                     	movq	%rbp, %rdi
; 			sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, sec_idx));
   103e1: 48 89 c2                     	movq	%rax, %rdx
; 							    sec_desc->data->d_size);
   103e4: 49 8b 45 10                  	movq	16(%r13), %rax
; 			err = bpf_object__init_internal_map(obj, LIBBPF_MAP_DATA,
   103e8: 4c 8b 48 10                  	movq	16(%rax), %r9
   103ec: 4c 8b 00                     	movq	(%rax), %r8
   103ef: e8 7c a2 ff ff               	callq	0xa670 <bpf_object__init_internal_map>
; 			break;
   103f4: e9 bf fe ff ff               	jmp	0x102b8 <bpf_object__init_maps+0x408>
   103f9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	scn = elf_getscn(obj->efile.elf, idx);
   10400: 48 8b bd c0 00 00 00         	movq	192(%rbp), %rdi
   10407: 48 89 de                     	movq	%rbx, %rsi
   1040a: e8 f1 57 ff ff               	callq	0x5c00 <.plt.sec+0x590>
   1040f: 49 89 c7                     	movq	%rax, %r15
; 	if (!scn) {
   10412: 48 85 c0                     	testq	%rax, %rax
   10415: 0f 84 54 05 00 00            	je	0x1096f <bpf_object__init_maps+0xabf>
; 			sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, sec_idx));
   1041b: 4c 89 fe                     	movq	%r15, %rsi
   1041e: 48 89 ef                     	movq	%rbp, %rdi
   10421: e8 1a a7 ff ff               	callq	0xab40 <elf_sec_name>
; 			err = bpf_object__init_internal_map(obj, LIBBPF_MAP_BSS,
   10426: 45 31 c0                     	xorl	%r8d, %r8d
   10429: 44 89 f1                     	movl	%r14d, %ecx
   1042c: be 02 00 00 00               	movl	$2, %esi
; 			sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, sec_idx));
   10431: 48 89 c2                     	movq	%rax, %rdx
; 			err = bpf_object__init_internal_map(obj, LIBBPF_MAP_BSS,
   10434: 49 8b 45 10                  	movq	16(%r13), %rax
   10438: 48 89 ef                     	movq	%rbp, %rdi
   1043b: 4c 8b 48 10                  	movq	16(%rax), %r9
   1043f: e8 2c a2 ff ff               	callq	0xa670 <bpf_object__init_internal_map>
; 			break;
   10444: e9 6f fe ff ff               	jmp	0x102b8 <bpf_object__init_maps+0x408>
   10449: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("DATASEC '%s' not found.\n", MAPS_ELF_SEC);
   10450: 4c 89 ea                     	movq	%r13, %rdx
   10453: 48 8d 35 76 50 02 00         	leaq	151670(%rip), %rsi      # 0x354d0 <strs.2+0x2640>
   1045a: 31 ff                        	xorl	%edi, %edi
   1045c: 31 c0                        	xorl	%eax, %eax
   1045e: e8 6d 7c ff ff               	callq	0x80d0 <libbpf_print>
; 		return -ENOENT;
   10463: 41 bd fe ff ff ff            	movl	$4294967294, %r13d      # imm = 0xFFFFFFFE
   10469: e9 5a fe ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
   1046e: 66 90                        	nop
; 	for (i = 0; i < obj->nr_extern; i++) {
   10470: 8b 85 90 00 00 00            	movl	144(%rbp), %eax
   10476: 85 c0                        	testl	%eax, %eax
   10478: 7e 7d                        	jle	0x104f7 <bpf_object__init_maps+0x647>
   1047a: 83 e8 01                     	subl	$1, %eax
   1047d: 48 8b 95 88 00 00 00         	movq	136(%rbp), %rdx
   10484: 48 8d 0c c5 00 00 00 00      	leaq	(,%rax,8), %rcx
   1048c: 48 29 c1                     	subq	%rax, %rcx
   1048f: 48 8d 42 38                  	leaq	56(%rdx), %rax
   10493: 48 8d 34 c8                  	leaq	(%rax,%rcx,8), %rsi
; 	struct extern_desc *last_ext = NULL, *ext;
   10497: 31 c9                        	xorl	%ecx, %ecx
   10499: eb 09                        	jmp	0x104a4 <bpf_object__init_maps+0x5f4>
   1049b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   104a0: 48 83 c0 38                  	addq	$56, %rax
; 		if (ext->type == EXT_KCFG)
   104a4: 83 3a 01                     	cmpl	$1, (%rdx)
   104a7: 48 0f 44 ca                  	cmoveq	%rdx, %rcx
; 	for (i = 0; i < obj->nr_extern; i++) {
   104ab: 48 89 c2                     	movq	%rax, %rdx
   104ae: 48 39 f0                     	cmpq	%rsi, %rax
   104b1: 75 ed                        	jne	0x104a0 <bpf_object__init_maps+0x5f0>
; 	if (!last_ext)
   104b3: 48 85 c9                     	testq	%rcx, %rcx
   104b6: 74 3f                        	je	0x104f7 <bpf_object__init_maps+0x647>
; 	map_sz = last_ext->kcfg.data_off + last_ext->kcfg.sz;
   104b8: 44 8b 49 24                  	movl	36(%rcx), %r9d
   104bc: 44 03 49 2c                  	addl	44(%rcx), %r9d
; 	err = bpf_object__init_internal_map(obj, LIBBPF_MAP_KCONFIG,
   104c0: 45 31 c0                     	xorl	%r8d, %r8d
   104c3: be 04 00 00 00               	movl	$4, %esi
   104c8: 8b 8d 08 01 00 00            	movl	264(%rbp), %ecx
   104ce: 4d 63 c9                     	movslq	%r9d, %r9
   104d1: 48 8d 15 61 1b 02 00         	leaq	138081(%rip), %rdx      # 0x32039 <_IO_stdin_used+0x2039>
   104d8: 48 89 ef                     	movq	%rbp, %rdi
   104db: e8 90 a1 ff ff               	callq	0xa670 <bpf_object__init_internal_map>
   104e0: 41 89 c5                     	movl	%eax, %r13d
; 	if (err)
   104e3: 85 c0                        	testl	%eax, %eax
   104e5: 0f 85 dd fd ff ff            	jne	0x102c8 <bpf_object__init_maps+0x418>
; 	obj->kconfig_map_idx = obj->nr_maps - 1;
   104eb: 8b 45 70                     	movl	112(%rbp), %eax
   104ee: 83 e8 01                     	subl	$1, %eax
   104f1: 89 85 94 00 00 00            	movl	%eax, 148(%rbp)
; 	if (obj->efile.st_ops_shndx == -1)
   104f7: 83 bd 0c 01 00 00 ff         	cmpl	$-1, 268(%rbp)
   104fe: 0f 84 b4 02 00 00            	je	0x107b8 <bpf_object__init_maps+0x908>
; 	btf = obj->btf;
   10504: 4c 8b a5 10 01 00 00         	movq	272(%rbp), %r12
; 	datasec_id = btf__find_by_name_kind(btf, STRUCT_OPS_SEC,
   1050b: 48 8d 35 d7 1b 02 00         	leaq	138199(%rip), %rsi      # 0x320e9 <_IO_stdin_used+0x20e9>
   10512: ba 0f 00 00 00               	movl	$15, %edx
   10517: 4c 89 e7                     	movq	%r12, %rdi
   1051a: e8 b1 b5 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
   1051f: 89 c6                        	movl	%eax, %esi
; 	if (datasec_id < 0) {
   10521: 85 c0                        	testl	%eax, %eax
   10523: 0f 88 c9 04 00 00            	js	0x109f2 <bpf_object__init_maps+0xb42>
; 	datasec = btf__type_by_id(btf, datasec_id);
   10529: 4c 89 e7                     	movq	%r12, %rdi
   1052c: e8 6f 9a 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	for (i = 0; i < btf_vlen(datasec); i++, vsi++) {
   10531: 66 83 78 04 00               	cmpw	$0, 4(%rax)
; 	datasec = btf__type_by_id(btf, datasec_id);
   10536: 48 89 44 24 48               	movq	%rax, 72(%rsp)
; 	return (struct btf_var_secinfo *)(t + 1);
   1053b: 4c 8d 78 0c                  	leaq	12(%rax), %r15
; 	for (i = 0; i < btf_vlen(datasec); i++, vsi++) {
   1053f: 0f 84 73 02 00 00            	je	0x107b8 <bpf_object__init_maps+0x908>
   10545: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
   1054d: e9 cd 01 00 00               	jmp	0x1071f <bpf_object__init_maps+0x86f>
   10552: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		type = btf__type_by_id(obj->btf, type_id);
   10558: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   1055f: 89 c6                        	movl	%eax, %esi
   10561: e8 3a 9a 01 00               	callq	0x29fa0 <btf__type_by_id>
; 		tname = btf__name_by_offset(obj->btf, type->name_off);
   10566: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   1056d: 8b 30                        	movl	(%rax), %esi
; 		type = btf__type_by_id(obj->btf, type_id);
   1056f: 48 89 c3                     	movq	%rax, %rbx
; 		tname = btf__name_by_offset(obj->btf, type->name_off);
   10572: e8 79 b5 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 		if (!tname[0]) {
   10577: 80 38 00                     	cmpb	$0, (%rax)
; 		tname = btf__name_by_offset(obj->btf, type->name_off);
   1057a: 49 89 c6                     	movq	%rax, %r14
; 		if (!tname[0]) {
   1057d: 0f 84 0e 03 00 00            	je	0x10891 <bpf_object__init_maps+0x9e1>
; 	return BTF_INFO_KIND(t->info);
   10583: 0f b6 43 07                  	movzbl	7(%rbx), %eax
   10587: 83 e0 1f                     	andl	$31, %eax
; 		if (!btf_is_struct(type)) {
   1058a: 66 83 f8 04                  	cmpw	$4, %ax
   1058e: 0f 85 18 03 00 00            	jne	0x108ac <bpf_object__init_maps+0x9fc>
; 		map = bpf_object__add_map(obj);
   10594: 48 89 ef                     	movq	%rbp, %rdi
   10597: e8 f4 6e ff ff               	callq	0x7490 <bpf_object__add_map>
   1059c: 48 89 c2                     	movq	%rax, %rdx
; 		if (IS_ERR(map))
   1059f: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   105a5: 0f 87 1f 03 00 00            	ja	0x108ca <bpf_object__init_maps+0xa1a>
; 		map->sec_idx = obj->efile.st_ops_shndx;
   105ab: 8b 85 0c 01 00 00            	movl	268(%rbp), %eax
; 		map->name = strdup(var_name);
   105b1: 48 8b 3c 24                  	movq	(%rsp), %rdi
; 		map->sec_offset = vsi->offset;
   105b5: 48 89 54 24 10               	movq	%rdx, 16(%rsp)
; 		map->sec_idx = obj->efile.st_ops_shndx;
   105ba: 89 42 1c                     	movl	%eax, 28(%rdx)
; 		map->sec_offset = vsi->offset;
   105bd: 41 8b 47 04                  	movl	4(%r15), %eax
   105c1: 48 89 42 20                  	movq	%rax, 32(%rdx)
   105c5: 89 44 24 18                  	movl	%eax, 24(%rsp)
   105c9: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 		map->name = strdup(var_name);
   105ce: e8 3d 56 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   105d3: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   105d8: 48 89 42 08                  	movq	%rax, 8(%rdx)
; 		if (!map->name)
   105dc: 48 85 c0                     	testq	%rax, %rax
   105df: 0f 84 02 04 00 00            	je	0x109e7 <bpf_object__init_maps+0xb37>
; 		map->st_ops = calloc(1, sizeof(*map->st_ops));
   105e5: be 38 00 00 00               	movl	$56, %esi
   105ea: bf 01 00 00 00               	movl	$1, %edi
; 		map->def.max_entries = 1;
   105ef: 48 89 54 24 20               	movq	%rdx, 32(%rsp)
; 		map->def.type = BPF_MAP_TYPE_STRUCT_OPS;
   105f4: 48 b8 1a 00 00 00 04 00 00 00	movabsq	$17179869210, %rax      # imm = 0x40000001A
   105fe: 48 89 42 30                  	movq	%rax, 48(%rdx)
; 		map->def.value_size = type->size;
   10602: 8b 43 08                     	movl	8(%rbx), %eax
; 		map->def.max_entries = 1;
   10605: c7 42 3c 01 00 00 00         	movl	$1, 60(%rdx)
; 		map->def.value_size = type->size;
   1060c: 89 42 38                     	movl	%eax, 56(%rdx)
   1060f: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 		map->st_ops = calloc(1, sizeof(*map->st_ops));
   10613: e8 78 53 ff ff               	callq	0x5990 <.plt.sec+0x320>
   10618: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   1061d: 49 89 c5                     	movq	%rax, %r13
   10620: 48 89 42 68                  	movq	%rax, 104(%rdx)
; 		if (!map->st_ops)
   10624: 48 85 c0                     	testq	%rax, %rax
   10627: 0f 84 ba 03 00 00            	je	0x109e7 <bpf_object__init_maps+0xb37>
; 		st_ops->data = malloc(type->size);
   1062d: 44 8b 4c 24 10               	movl	16(%rsp), %r9d
   10632: 4c 89 cf                     	movq	%r9, %rdi
   10635: 4c 89 4c 24 38               	movq	%r9, 56(%rsp)
   1063a: e8 51 54 ff ff               	callq	0x5a90 <.plt.sec+0x420>
; 		st_ops->progs = calloc(btf_vlen(type), sizeof(*st_ops->progs));
   1063f: 0f b7 7b 04                  	movzwl	4(%rbx), %edi
   10643: be 08 00 00 00               	movl	$8, %esi
; 		st_ops->data = malloc(type->size);
   10648: 49 89 45 20                  	movq	%rax, 32(%r13)
; 		st_ops->progs = calloc(btf_vlen(type), sizeof(*st_ops->progs));
   1064c: 48 89 7c 24 28               	movq	%rdi, 40(%rsp)
; 		st_ops->data = malloc(type->size);
   10651: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 		st_ops->progs = calloc(btf_vlen(type), sizeof(*st_ops->progs));
   10656: e8 35 53 ff ff               	callq	0x5990 <.plt.sec+0x320>
; 		st_ops->kern_func_off = malloc(btf_vlen(type) *
   1065b: 48 8b 7c 24 28               	movq	40(%rsp), %rdi
; 		st_ops->progs = calloc(btf_vlen(type), sizeof(*st_ops->progs));
   10660: 49 89 45 10                  	movq	%rax, 16(%r13)
; 		st_ops->kern_func_off = malloc(btf_vlen(type) *
   10664: 48 c1 e7 02                  	shlq	$2, %rdi
; 		st_ops->progs = calloc(btf_vlen(type), sizeof(*st_ops->progs));
   10668: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 		st_ops->kern_func_off = malloc(btf_vlen(type) *
   1066d: e8 1e 54 ff ff               	callq	0x5a90 <.plt.sec+0x420>
; 		if (!st_ops->data || !st_ops->progs || !st_ops->kern_func_off)
   10672: 4c 8b 44 24 30               	movq	48(%rsp), %r8
   10677: 48 8b 54 24 20               	movq	32(%rsp), %rdx
; 		st_ops->kern_func_off = malloc(btf_vlen(type) *
   1067c: 49 89 45 18                  	movq	%rax, 24(%r13)
; 		if (!st_ops->data || !st_ops->progs || !st_ops->kern_func_off)
   10680: 4d 85 c0                     	testq	%r8, %r8
   10683: 40 0f 94 c6                  	sete	%sil
   10687: 48 85 d2                     	testq	%rdx, %rdx
   1068a: 0f 94 c2                     	sete	%dl
   1068d: 40 08 d6                     	orb	%dl, %sil
   10690: 0f 85 51 03 00 00            	jne	0x109e7 <bpf_object__init_maps+0xb37>
   10696: 48 85 c0                     	testq	%rax, %rax
   10699: 0f 84 48 03 00 00            	je	0x109e7 <bpf_object__init_maps+0xb37>
; 		if (vsi->offset + type->size > obj->efile.st_ops_data->d_size) {
   1069f: 8b 54 24 18                  	movl	24(%rsp), %edx
   106a3: 8b 4c 24 10                  	movl	16(%rsp), %ecx
   106a7: 48 8b 85 d8 00 00 00         	movq	216(%rbp), %rax
   106ae: 4c 8b 4c 24 38               	movq	56(%rsp), %r9
   106b3: 01 ca                        	addl	%ecx, %edx
   106b5: 89 d2                        	movl	%edx, %edx
   106b7: 48 3b 50 10                  	cmpq	16(%rax), %rdx
   106bb: 0f 87 11 02 00 00            	ja	0x108d2 <bpf_object__init_maps+0xa22>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   106c1: 4c 89 ca                     	movq	%r9, %rdx
   106c4: 4c 89 c7                     	movq	%r8, %rdi
; 		       obj->efile.st_ops_data->d_buf + vsi->offset,
   106c7: 48 8b 74 24 40               	movq	64(%rsp), %rsi
   106cc: 48 03 30                     	addq	(%rax), %rsi
;   return __builtin___memcpy_chk (__dest, __src, __len,
   106cf: e8 6c 53 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 		st_ops->type_id = type_id;
   106d4: 45 89 65 30                  	movl	%r12d, 48(%r13)
; 		pr_debug("struct_ops init: struct %s(type_id=%u) %s found at offset %u\n",
   106d8: 4c 8b 04 24                  	movq	(%rsp), %r8
   106dc: 44 89 e1                     	movl	%r12d, %ecx
; 		st_ops->tname = tname;
   106df: 4d 89 75 00                  	movq	%r14, (%r13)
; 		pr_debug("struct_ops init: struct %s(type_id=%u) %s found at offset %u\n",
   106e3: 45 8b 4f 04                  	movl	4(%r15), %r9d
   106e7: 31 c0                        	xorl	%eax, %eax
   106e9: 4c 89 f2                     	movq	%r14, %rdx
; 		st_ops->type = type;
   106ec: 49 89 5d 08                  	movq	%rbx, 8(%r13)
; 		pr_debug("struct_ops init: struct %s(type_id=%u) %s found at offset %u\n",
   106f0: 48 8d 35 91 4d 02 00         	leaq	150929(%rip), %rsi      # 0x35488 <strs.2+0x25f8>
   106f7: bf 02 00 00 00               	movl	$2, %edi
; 	for (i = 0; i < btf_vlen(datasec); i++, vsi++) {
   106fc: 49 83 c7 0c                  	addq	$12, %r15
; 		pr_debug("struct_ops init: struct %s(type_id=%u) %s found at offset %u\n",
   10700: e8 cb 79 ff ff               	callq	0x80d0 <libbpf_print>
; 	for (i = 0; i < btf_vlen(datasec); i++, vsi++) {
   10705: 48 8b 44 24 48               	movq	72(%rsp), %rax
   1070a: 83 44 24 08 01               	addl	$1, 8(%rsp)
   1070f: 8b 4c 24 08                  	movl	8(%rsp), %ecx
   10713: 0f b7 40 04                  	movzwl	4(%rax), %eax
   10717: 39 c1                        	cmpl	%eax, %ecx
   10719: 0f 83 99 00 00 00            	jae	0x107b8 <bpf_object__init_maps+0x908>
; 		type = btf__type_by_id(obj->btf, vsi->type);
   1071f: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   10726: 41 8b 37                     	movl	(%r15), %esi
   10729: e8 72 98 01 00               	callq	0x29fa0 <btf__type_by_id>
; 		var_name = btf__name_by_offset(obj->btf, type->name_off);
   1072e: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   10735: 8b 30                        	movl	(%rax), %esi
   10737: e8 b4 b3 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 		type_id = btf__resolve_type(obj->btf, vsi->type);
   1073c: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   10743: 41 8b 37                     	movl	(%r15), %esi
; 		var_name = btf__name_by_offset(obj->btf, type->name_off);
   10746: 48 89 04 24                  	movq	%rax, (%rsp)
; 		type_id = btf__resolve_type(obj->btf, vsi->type);
   1074a: e8 a1 9f 01 00               	callq	0x2a6f0 <btf__resolve_type>
   1074f: 41 89 c4                     	movl	%eax, %r12d
; 		if (type_id < 0) {
   10752: 85 c0                        	testl	%eax, %eax
   10754: 0f 89 fe fd ff ff            	jns	0x10558 <bpf_object__init_maps+0x6a8>
; 			pr_warn("struct_ops init: Cannot resolve var type_id %u in DATASEC %s\n",
   1075a: 41 8b 17                     	movl	(%r15), %edx
   1075d: 48 8d 0d 85 19 02 00         	leaq	137605(%rip), %rcx      # 0x320e9 <_IO_stdin_used+0x20e9>
   10764: 31 ff                        	xorl	%edi, %edi
   10766: 31 c0                        	xorl	%eax, %eax
   10768: 48 8d 35 19 4c 02 00         	leaq	150553(%rip), %rsi      # 0x35388 <strs.2+0x24f8>
; 			return -EINVAL;
   1076f: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
; 			pr_warn("struct_ops init: Cannot resolve var type_id %u in DATASEC %s\n",
   10775: e8 56 79 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   1077a: e9 49 fb ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
   1077f: 90                           	nop
; 		err = build_map_pin_path(map, pin_root_path);
   10780: 48 8b 74 24 30               	movq	48(%rsp), %rsi
   10785: 4c 89 ff                     	movq	%r15, %rdi
   10788: e8 43 f6 ff ff               	callq	0xfdd0 <build_map_pin_path>
   1078d: 41 89 c5                     	movl	%eax, %r13d
; 		if (err) {
   10790: 85 c0                        	testl	%eax, %eax
   10792: 0f 84 f3 f9 ff ff            	je	0x1018b <bpf_object__init_maps+0x2db>
; 			pr_warn("map '%s': couldn't build pin path.\n", map->name);
   10798: 49 8b 57 08                  	movq	8(%r15), %rdx
   1079c: 48 8d 35 85 4b 02 00         	leaq	150405(%rip), %rsi      # 0x35328 <strs.2+0x2498>
   107a3: 31 ff                        	xorl	%edi, %edi
   107a5: 31 c0                        	xorl	%eax, %eax
   107a7: e8 24 79 ff ff               	callq	0x80d0 <libbpf_print>
; 			return err;
   107ac: e9 17 fb ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
   107b1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return 0;
   107b8: 45 31 ed                     	xorl	%r13d, %r13d
   107bb: e9 08 fb ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 	case BTF_VAR_STATIC: return "static";
   107c0: 48 8d 0d 46 18 02 00         	leaq	137286(%rip), %rcx      # 0x3200d <_IO_stdin_used+0x200d>
; 	switch (linkage) {
   107c7: 85 c0                        	testl	%eax, %eax
   107c9: 74 15                        	je	0x107e0 <bpf_object__init_maps+0x930>
   107cb: 83 f8 02                     	cmpl	$2, %eax
   107ce: 48 8d 0d 5d 14 02 00         	leaq	136285(%rip), %rcx      # 0x31c32 <_IO_stdin_used+0x1c32>
   107d5: 48 8d 05 38 18 02 00         	leaq	137272(%rip), %rax      # 0x32014 <_IO_stdin_used+0x2014>
   107dc: 48 0f 44 c8                  	cmoveq	%rax, %rcx
; 		pr_warn("map '%s': unsupported map linkage %s.\n",
   107e0: 4c 89 e2                     	movq	%r12, %rdx
   107e3: 48 8d 35 56 4a 02 00         	leaq	150102(%rip), %rsi      # 0x35240 <strs.2+0x23b0>
   107ea: 31 ff                        	xorl	%edi, %edi
   107ec: 31 c0                        	xorl	%eax, %eax
; 		return -EOPNOTSUPP;
   107ee: 41 bd a1 ff ff ff            	movl	$4294967201, %r13d      # imm = 0xFFFFFFA1
; 		pr_warn("map '%s': unsupported map linkage %s.\n",
   107f4: e8 d7 78 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   107f9: e9 ca fa ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 		pr_warn("map #%d: empty name.\n", var_idx);
   107fe: 44 89 f2                     	movl	%r14d, %edx
   10801: 48 8d 35 13 18 02 00         	leaq	137235(%rip), %rsi      # 0x3201b <_IO_stdin_used+0x201b>
   10808: 31 ff                        	xorl	%edi, %edi
   1080a: 31 c0                        	xorl	%eax, %eax
   1080c: e8 bf 78 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   10811: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
   10817: e9 ac fa ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 	return __btf_kind_str(btf_kind(t));
   1081c: 0f b7 f8                     	movzwl	%ax, %edi
; 		pr_warn("map '%s': unexpected var kind %s.\n",
   1081f: 48 8d 35 ea 49 02 00         	leaq	149994(%rip), %rsi      # 0x35210 <strs.2+0x2380>
; 		return -EINVAL;
   10826: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
; 	return __btf_kind_str(btf_kind(t));
   1082c: e8 5f 5b ff ff               	callq	0x6390 <__btf_kind_str>
; 		pr_warn("map '%s': unexpected var kind %s.\n",
   10831: 4c 89 e2                     	movq	%r12, %rdx
   10834: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
   10836: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("map '%s': unexpected var kind %s.\n",
   10839: 31 c0                        	xorl	%eax, %eax
   1083b: e8 90 78 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   10840: e9 83 fa ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 		pr_warn("map '%s': invalid def size.\n", map_name);
   10845: 4c 89 e2                     	movq	%r12, %rdx
   10848: 48 8d 35 51 4a 02 00         	leaq	150097(%rip), %rsi      # 0x352a0 <strs.2+0x2410>
   1084f: 31 ff                        	xorl	%edi, %edi
   10851: 31 c0                        	xorl	%eax, %eax
   10853: e8 78 78 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   10858: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
   1085e: e9 65 fa ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 	return BTF_INFO_KIND(t->info);
   10863: 41 0f b6 7f 07               	movzbl	7(%r15), %edi
; 		pr_warn("map '%s': unexpected def kind %s.\n",
   10868: 48 8d 35 01 4a 02 00         	leaq	150017(%rip), %rsi      # 0x35270 <strs.2+0x23e0>
; 		return -EINVAL;
   1086f: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
; 	return __btf_kind_str(btf_kind(t));
   10875: 83 e7 1f                     	andl	$31, %edi
   10878: e8 13 5b ff ff               	callq	0x6390 <__btf_kind_str>
; 		pr_warn("map '%s': unexpected def kind %s.\n",
   1087d: 4c 89 e2                     	movq	%r12, %rdx
   10880: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
   10882: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("map '%s': unexpected def kind %s.\n",
   10885: 31 c0                        	xorl	%eax, %eax
   10887: e8 44 78 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   1088c: e9 37 fa ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 			pr_warn("struct_ops init: anonymous type is not supported\n");
   10891: 48 8d 35 38 4b 02 00         	leaq	150328(%rip), %rsi      # 0x353d0 <strs.2+0x2540>
   10898: 31 ff                        	xorl	%edi, %edi
   1089a: 31 c0                        	xorl	%eax, %eax
; 			return -ENOTSUP;
   1089c: 41 bd a1 ff ff ff            	movl	$4294967201, %r13d      # imm = 0xFFFFFFA1
; 			pr_warn("struct_ops init: anonymous type is not supported\n");
   108a2: e8 29 78 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -ENOTSUP;
   108a7: e9 1c fa ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 			pr_warn("struct_ops init: %s is not a struct\n", tname);
   108ac: 4c 89 f2                     	movq	%r14, %rdx
   108af: 48 8d 35 5a 4b 02 00         	leaq	150362(%rip), %rsi      # 0x35410 <strs.2+0x2580>
   108b6: 31 ff                        	xorl	%edi, %edi
   108b8: 31 c0                        	xorl	%eax, %eax
   108ba: e8 11 78 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   108bf: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
   108c5: e9 fe f9 ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 			return PTR_ERR(map);
   108ca: 49 89 c5                     	movq	%rax, %r13
   108cd: e9 f6 f9 ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 			pr_warn("struct_ops init: var %s is beyond the end of DATASEC %s\n",
   108d2: 48 8b 14 24                  	movq	(%rsp), %rdx
   108d6: 48 8d 0d 0c 18 02 00         	leaq	137228(%rip), %rcx      # 0x320e9 <_IO_stdin_used+0x20e9>
   108dd: 31 ff                        	xorl	%edi, %edi
   108df: 31 c0                        	xorl	%eax, %eax
   108e1: 48 8d 35 58 4b 02 00         	leaq	150360(%rip), %rsi      # 0x35440 <strs.2+0x25b0>
; 			return -EINVAL;
   108e8: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
; 			pr_warn("struct_ops init: var %s is beyond the end of DATASEC %s\n",
   108ee: e8 dd 77 ff ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   108f3: e9 d0 f9 ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   108f8: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   108fd: 4c 8d ad 90 01 00 00         	leaq	400(%rbp), %r13
   10904: e8 57 51 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   10909: 31 ff                        	xorl	%edi, %edi
   1090b: 4c 89 e9                     	movq	%r13, %rcx
   1090e: 4c 89 e2                     	movq	%r12, %rdx
   10911: 49 89 c0                     	movq	%rax, %r8
   10914: 48 8d 35 55 48 02 00         	leaq	149589(%rip), %rsi      # 0x35170 <strs.2+0x22e0>
   1091b: 31 c0                        	xorl	%eax, %eax
   1091d: e8 ae 77 ff ff               	callq	0x80d0 <libbpf_print>
; 	data = elf_sec_data(obj, scn);
   10922: 31 f6                        	xorl	%esi, %esi
   10924: 48 89 ef                     	movq	%rbp, %rdi
   10927: e8 84 a6 ff ff               	callq	0xafb0 <elf_sec_data>
; 		pr_warn("elf: failed to get %s map definitions for %s\n",
   1092c: 4c 89 e9                     	movq	%r13, %rcx
   1092f: 48 8d 15 c3 17 02 00         	leaq	137155(%rip), %rdx      # 0x320f9 <_IO_stdin_used+0x20f9>
   10936: 31 ff                        	xorl	%edi, %edi
   10938: 31 c0                        	xorl	%eax, %eax
   1093a: 48 8d 35 67 48 02 00         	leaq	149607(%rip), %rsi      # 0x351a8 <strs.2+0x2318>
; 		return -EINVAL;
   10941: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
; 		pr_warn("elf: failed to get %s map definitions for %s\n",
   10947: e8 84 77 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ?: bpf_object__init_kconfig_map(obj);
   1094c: e9 77 f9 ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 		pr_warn("map '%s' BTF data is corrupted.\n", map_name);
   10951: 4c 89 e2                     	movq	%r12, %rdx
   10954: 48 8d 35 85 48 02 00         	leaq	149637(%rip), %rsi      # 0x351e0 <strs.2+0x2350>
   1095b: 31 ff                        	xorl	%edi, %edi
   1095d: 31 c0                        	xorl	%eax, %eax
   1095f: e8 6c 77 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   10964: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
   1096a: e9 59 f9 ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   1096f: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   10974: e8 e7 50 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   10979: 48 89 da                     	movq	%rbx, %rdx
   1097c: 4c 89 e6                     	movq	%r12, %rsi
   1097f: 31 ff                        	xorl	%edi, %edi
   10981: 49 89 c0                     	movq	%rax, %r8
   10984: 48 8d 8d 90 01 00 00         	leaq	400(%rbp), %rcx
   1098b: 31 c0                        	xorl	%eax, %eax
   1098d: e8 3e 77 ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
   10992: e9 84 fa ff ff               	jmp	0x1041b <bpf_object__init_maps+0x56b>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   10997: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   1099c: e8 bf 50 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   109a1: 48 89 da                     	movq	%rbx, %rdx
   109a4: 4c 89 e6                     	movq	%r12, %rsi
   109a7: 31 ff                        	xorl	%edi, %edi
   109a9: 49 89 c0                     	movq	%rax, %r8
   109ac: 48 8d 8d 90 01 00 00         	leaq	400(%rbp), %rcx
   109b3: 31 c0                        	xorl	%eax, %eax
   109b5: e8 16 77 ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
   109ba: e9 d0 f8 ff ff               	jmp	0x1028f <bpf_object__init_maps+0x3df>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   109bf: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   109c4: e8 97 50 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   109c9: 48 89 da                     	movq	%rbx, %rdx
   109cc: 4c 89 e6                     	movq	%r12, %rsi
   109cf: 31 ff                        	xorl	%edi, %edi
   109d1: 49 89 c0                     	movq	%rax, %r8
   109d4: 48 8d 8d 90 01 00 00         	leaq	400(%rbp), %rcx
   109db: 31 c0                        	xorl	%eax, %eax
   109dd: e8 ee 76 ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
   109e2: e9 e4 f9 ff ff               	jmp	0x103cb <bpf_object__init_maps+0x51b>
; 			return -ENOMEM;
   109e7: 41 bd f4 ff ff ff            	movl	$4294967284, %r13d      # imm = 0xFFFFFFF4
   109ed: e9 d6 f8 ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 		pr_warn("struct_ops init: DATASEC %s not found\n",
   109f2: 48 8d 15 f0 16 02 00         	leaq	136944(%rip), %rdx      # 0x320e9 <_IO_stdin_used+0x20e9>
   109f9: 48 8d 35 58 49 02 00         	leaq	149848(%rip), %rsi      # 0x35358 <strs.2+0x24c8>
   10a00: 31 ff                        	xorl	%edi, %edi
   10a02: 31 c0                        	xorl	%eax, %eax
   10a04: e8 c7 76 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   10a09: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
   10a0f: e9 b4 f8 ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; 		pr_warn("map '%s': failed to alloc map name.\n", map_name);
   10a14: 4c 89 e2                     	movq	%r12, %rdx
   10a17: 48 8d 35 aa 48 02 00         	leaq	149674(%rip), %rsi      # 0x352c8 <strs.2+0x2438>
   10a1e: 31 ff                        	xorl	%edi, %edi
; 		return -ENOMEM;
   10a20: 41 bd f4 ff ff ff            	movl	$4294967284, %r13d      # imm = 0xFFFFFFF4
; 		pr_warn("map '%s': failed to alloc map name.\n", map_name);
   10a26: e8 a5 76 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   10a2b: e9 98 f8 ff ff               	jmp	0x102c8 <bpf_object__init_maps+0x418>
; }
   10a30: e8 cb 4d ff ff               	callq	0x5800 <.plt.sec+0x190>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   10a35: 4c 8d ad 90 01 00 00         	leaq	400(%rbp), %r13
   10a3c: e9 eb fe ff ff               	jmp	0x1092c <bpf_object__init_maps+0xa7c>
   10a41: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   10a4c: 0f 1f 40 00                  	nopl	(%rax)

0000000000010a50 <bpf_map__pin>:
; {
   10a50: f3 0f 1e fa                  	endbr64
   10a54: 41 55                        	pushq	%r13
   10a56: 41 54                        	pushq	%r12
   10a58: 55                           	pushq	%rbp
   10a59: 48 81 ec 90 00 00 00         	subq	$144, %rsp
   10a60: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   10a69: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
   10a71: 31 c0                        	xorl	%eax, %eax
; 	if (map == NULL) {
   10a73: 48 85 ff                     	testq	%rdi, %rdi
   10a76: 0f 84 02 02 00 00            	je	0x10c7e <bpf_map__pin+0x22e>
; 	if (map->pin_path) {
   10a7c: 4c 8b a7 88 00 00 00         	movq	136(%rdi), %r12
   10a83: 49 89 fd                     	movq	%rdi, %r13
   10a86: 48 89 f5                     	movq	%rsi, %rbp
   10a89: 4d 85 e4                     	testq	%r12, %r12
   10a8c: 0f 84 f6 00 00 00            	je	0x10b88 <bpf_map__pin+0x138>
; 		if (path && strcmp(path, map->pin_path)) {
   10a92: 48 85 f6                     	testq	%rsi, %rsi
   10a95: 74 13                        	je	0x10aaa <bpf_map__pin+0x5a>
   10a97: 4c 89 e6                     	movq	%r12, %rsi
   10a9a: 48 89 ef                     	movq	%rbp, %rdi
   10a9d: e8 0e 4f ff ff               	callq	0x59b0 <.plt.sec+0x340>
   10aa2: 85 c0                        	testl	%eax, %eax
   10aa4: 0f 85 6f 01 00 00            	jne	0x10c19 <bpf_map__pin+0x1c9>
; 		} else if (map->pinned) {
   10aaa: 41 80 bd 90 00 00 00 00      	cmpb	$0, 144(%r13)
   10ab2: 0f 85 38 01 00 00            	jne	0x10bf0 <bpf_map__pin+0x1a0>
; 	err = make_parent_dir(map->pin_path);
   10ab8: 4c 89 e7                     	movq	%r12, %rdi
   10abb: e8 10 91 ff ff               	callq	0x9bd0 <make_parent_dir>
   10ac0: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
   10ac3: 85 c0                        	testl	%eax, %eax
   10ac5: 74 31                        	je	0x10af8 <bpf_map__pin+0xa8>
; 	if (ret < 0)
   10ac7: 0f 88 a3 00 00 00            	js	0x10b70 <bpf_map__pin+0x120>
; }
   10acd: 48 8b 84 24 88 00 00 00      	movq	136(%rsp), %rax
   10ad5: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   10ade: 0f 85 eb 01 00 00            	jne	0x10ccf <bpf_map__pin+0x27f>
   10ae4: 48 81 c4 90 00 00 00         	addq	$144, %rsp
   10aeb: 44 89 e0                     	movl	%r12d, %eax
   10aee: 5d                           	popq	%rbp
   10aef: 41 5c                        	popq	%r12
   10af1: 41 5d                        	popq	%r13
   10af3: c3                           	retq
   10af4: 0f 1f 40 00                  	nopl	(%rax)
; 	err = check_path(map->pin_path);
   10af8: 49 8b bd 88 00 00 00         	movq	136(%r13), %rdi
   10aff: e8 cc 91 ff ff               	callq	0x9cd0 <check_path>
   10b04: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
   10b07: 85 c0                        	testl	%eax, %eax
   10b09: 75 bc                        	jne	0x10ac7 <bpf_map__pin+0x77>
; 	if (bpf_obj_pin(map->fd, map->pin_path)) {
   10b0b: 49 8b b5 88 00 00 00         	movq	136(%r13), %rsi
   10b12: 41 8b 7d 18                  	movl	24(%r13), %edi
   10b16: e8 75 5e 01 00               	callq	0x26990 <bpf_obj_pin>
   10b1b: 41 89 c4                     	movl	%eax, %r12d
   10b1e: 85 c0                        	testl	%eax, %eax
   10b20: 0f 84 9a 00 00 00            	je	0x10bc0 <bpf_map__pin+0x170>
; 		err = -errno;
   10b26: e8 c5 4b ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	cp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));
   10b2b: 48 89 e6                     	movq	%rsp, %rsi
   10b2e: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   10b33: 8b 28                        	movl	(%rax), %ebp
; 	cp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));
   10b35: 89 ef                        	movl	%ebp, %edi
; 		err = -errno;
   10b37: 41 89 ec                     	movl	%ebp, %r12d
; 	cp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));
   10b3a: e8 91 ce 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		err = -errno;
   10b3f: 41 f7 dc                     	negl	%r12d
; 	pr_warn("failed to pin map: %s\n", cp);
   10b42: 31 ff                        	xorl	%edi, %edi
   10b44: 48 8d 35 85 4a 02 00         	leaq	150149(%rip), %rsi      # 0x355d0 <strs.2+0x2740>
; 	cp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));
   10b4b: 48 89 c2                     	movq	%rax, %rdx
; 	pr_warn("failed to pin map: %s\n", cp);
   10b4e: 31 c0                        	xorl	%eax, %eax
   10b50: e8 7b 75 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   10b55: 45 85 e4                     	testl	%r12d, %r12d
   10b58: 0f 89 6f ff ff ff            	jns	0x10acd <bpf_map__pin+0x7d>
; 		errno = -ret;
   10b5e: e8 8d 4b ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10b63: 89 28                        	movl	%ebp, (%rax)
   10b65: e9 63 ff ff ff               	jmp	0x10acd <bpf_map__pin+0x7d>
   10b6a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   10b70: e8 7b 4b ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10b75: 44 89 e2                     	movl	%r12d, %edx
   10b78: f7 da                        	negl	%edx
   10b7a: 89 10                        	movl	%edx, (%rax)
   10b7c: e9 4c ff ff ff               	jmp	0x10acd <bpf_map__pin+0x7d>
   10b81: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (!path) {
   10b88: 48 85 f6                     	testq	%rsi, %rsi
   10b8b: 0f 84 11 01 00 00            	je	0x10ca2 <bpf_map__pin+0x252>
; 		} else if (map->pinned) {
   10b91: 80 bf 90 00 00 00 00         	cmpb	$0, 144(%rdi)
   10b98: 0f 85 b2 00 00 00            	jne	0x10c50 <bpf_map__pin+0x200>
; 		map->pin_path = strdup(path);
   10b9e: 48 89 f7                     	movq	%rsi, %rdi
   10ba1: e8 6a 50 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   10ba6: 49 89 85 88 00 00 00         	movq	%rax, 136(%r13)
   10bad: 49 89 c4                     	movq	%rax, %r12
; 		if (!map->pin_path) {
   10bb0: 48 85 c0                     	testq	%rax, %rax
   10bb3: 0f 85 ff fe ff ff            	jne	0x10ab8 <bpf_map__pin+0x68>
   10bb9: e9 68 ff ff ff               	jmp	0x10b26 <bpf_map__pin+0xd6>
   10bbe: 66 90                        	nop
; 	map->pinned = true;
   10bc0: 41 c6 85 90 00 00 00 01      	movb	$1, 144(%r13)
; 	pr_debug("pinned map '%s'\n", map->pin_path);
   10bc8: 49 8b 95 88 00 00 00         	movq	136(%r13), %rdx
   10bcf: 48 8d 35 89 14 02 00         	leaq	136329(%rip), %rsi      # 0x3205f <_IO_stdin_used+0x205f>
   10bd6: 31 c0                        	xorl	%eax, %eax
   10bd8: bf 02 00 00 00               	movl	$2, %edi
   10bdd: e8 ee 74 ff ff               	callq	0x80d0 <libbpf_print>
; 	return 0;
   10be2: e9 e6 fe ff ff               	jmp	0x10acd <bpf_map__pin+0x7d>
   10be7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 			pr_debug("map '%s' already pinned at '%s'; not re-pinning\n",
   10bf0: 4c 89 ef                     	movq	%r13, %rdi
   10bf3: e8 58 f1 ff ff               	callq	0xfd50 <bpf_map__name>
   10bf8: 4c 89 e1                     	movq	%r12, %rcx
   10bfb: bf 02 00 00 00               	movl	$2, %edi
; 			return 0;
   10c00: 45 31 e4                     	xorl	%r12d, %r12d
; 			pr_debug("map '%s' already pinned at '%s'; not re-pinning\n",
   10c03: 48 89 c2                     	movq	%rax, %rdx
   10c06: 48 8d 35 2b 49 02 00         	leaq	149803(%rip), %rsi      # 0x35538 <strs.2+0x26a8>
   10c0d: 31 c0                        	xorl	%eax, %eax
   10c0f: e8 bc 74 ff ff               	callq	0x80d0 <libbpf_print>
; 			return 0;
   10c14: e9 b4 fe ff ff               	jmp	0x10acd <bpf_map__pin+0x7d>
; 			pr_warn("map '%s' already has pin path '%s' different from '%s'\n",
   10c19: 4c 89 ef                     	movq	%r13, %rdi
   10c1c: e8 2f f1 ff ff               	callq	0xfd50 <bpf_map__name>
   10c21: 4c 89 e1                     	movq	%r12, %rcx
   10c24: 49 89 e8                     	movq	%rbp, %r8
   10c27: 31 ff                        	xorl	%edi, %edi
   10c29: 48 89 c2                     	movq	%rax, %rdx
   10c2c: 48 8d 35 c5 48 02 00         	leaq	149701(%rip), %rsi      # 0x354f8 <strs.2+0x2668>
   10c33: 31 c0                        	xorl	%eax, %eax
; 			return libbpf_err(-EINVAL);
   10c35: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("map '%s' already has pin path '%s' different from '%s'\n",
   10c3b: e8 90 74 ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   10c40: e8 ab 4a ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10c45: c7 00 16 00 00 00            	movl	$22, (%rax)
   10c4b: e9 7d fe ff ff               	jmp	0x10acd <bpf_map__pin+0x7d>
; 			pr_warn("map '%s' already pinned\n", bpf_map__name(map));
   10c50: e8 fb f0 ff ff               	callq	0xfd50 <bpf_map__name>
   10c55: 48 8d 35 4c 49 02 00         	leaq	149836(%rip), %rsi      # 0x355a8 <strs.2+0x2718>
   10c5c: 31 ff                        	xorl	%edi, %edi
; 			return libbpf_err(-EEXIST);
   10c5e: 41 bc ef ff ff ff            	movl	$4294967279, %r12d      # imm = 0xFFFFFFEF
; 			pr_warn("map '%s' already pinned\n", bpf_map__name(map));
   10c64: 48 89 c2                     	movq	%rax, %rdx
   10c67: 31 c0                        	xorl	%eax, %eax
   10c69: e8 62 74 ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   10c6e: e8 7d 4a ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10c73: c7 00 11 00 00 00            	movl	$17, (%rax)
   10c79: e9 4f fe ff ff               	jmp	0x10acd <bpf_map__pin+0x7d>
; 		pr_warn("invalid map pointer\n");
   10c7e: 48 8d 35 bd 13 02 00         	leaq	136125(%rip), %rsi      # 0x32042 <_IO_stdin_used+0x2042>
   10c85: 31 ff                        	xorl	%edi, %edi
; 		return libbpf_err(-EINVAL);
   10c87: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("invalid map pointer\n");
   10c8d: e8 3e 74 ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   10c92: e8 59 4a ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10c97: c7 00 16 00 00 00            	movl	$22, (%rax)
   10c9d: e9 2b fe ff ff               	jmp	0x10acd <bpf_map__pin+0x7d>
; 			pr_warn("missing a path to pin map '%s' at\n",
   10ca2: e8 a9 f0 ff ff               	callq	0xfd50 <bpf_map__name>
   10ca7: 48 8d 35 ca 48 02 00         	leaq	149706(%rip), %rsi      # 0x35578 <strs.2+0x26e8>
   10cae: 31 ff                        	xorl	%edi, %edi
; 			return libbpf_err(-EINVAL);
   10cb0: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("missing a path to pin map '%s' at\n",
   10cb6: 48 89 c2                     	movq	%rax, %rdx
   10cb9: 31 c0                        	xorl	%eax, %eax
   10cbb: e8 10 74 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   10cc0: bf ea ff ff ff               	movl	$4294967274, %edi       # imm = 0xFFFFFFEA
   10cc5: e8 a6 65 ff ff               	callq	0x7270 <libbpf_err.part.0>
; 			return libbpf_err(-EINVAL);
   10cca: e9 fe fd ff ff               	jmp	0x10acd <bpf_map__pin+0x7d>
; }
   10ccf: e8 2c 4b ff ff               	callq	0x5800 <.plt.sec+0x190>
   10cd4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   10cdf: 90                           	nop

0000000000010ce0 <bpf_map__unpin>:
; {
   10ce0: f3 0f 1e fa                  	endbr64
   10ce4: 41 55                        	pushq	%r13
   10ce6: 41 54                        	pushq	%r12
   10ce8: 55                           	pushq	%rbp
; 	if (map == NULL) {
   10ce9: 48 85 ff                     	testq	%rdi, %rdi
   10cec: 0f 84 06 01 00 00            	je	0x10df8 <bpf_map__unpin+0x118>
; 	if (map->pin_path) {
   10cf2: 4c 8b af 88 00 00 00         	movq	136(%rdi), %r13
   10cf9: 48 89 fd                     	movq	%rdi, %rbp
   10cfc: 49 89 f4                     	movq	%rsi, %r12
   10cff: 4d 85 ed                     	testq	%r13, %r13
   10d02: 74 7c                        	je	0x10d80 <bpf_map__unpin+0xa0>
; 		if (path && strcmp(path, map->pin_path)) {
   10d04: 48 85 f6                     	testq	%rsi, %rsi
   10d07: 74 13                        	je	0x10d1c <bpf_map__unpin+0x3c>
   10d09: 4c 89 ee                     	movq	%r13, %rsi
   10d0c: 4c 89 e7                     	movq	%r12, %rdi
   10d0f: e8 9c 4c ff ff               	callq	0x59b0 <.plt.sec+0x340>
   10d14: 85 c0                        	testl	%eax, %eax
   10d16: 0f 85 a5 00 00 00            	jne	0x10dc1 <bpf_map__unpin+0xe1>
; 	err = check_path(path);
   10d1c: 4c 89 ef                     	movq	%r13, %rdi
   10d1f: e8 ac 8f ff ff               	callq	0x9cd0 <check_path>
   10d24: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
   10d27: 85 c0                        	testl	%eax, %eax
   10d29: 74 2d                        	je	0x10d58 <bpf_map__unpin+0x78>
; 	if (ret < 0)
   10d2b: 78 13                        	js	0x10d40 <bpf_map__unpin+0x60>
; }
   10d2d: 44 89 e0                     	movl	%r12d, %eax
   10d30: 5d                           	popq	%rbp
   10d31: 41 5c                        	popq	%r12
   10d33: 41 5d                        	popq	%r13
   10d35: c3                           	retq
   10d36: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		errno = -ret;
   10d40: e8 ab 49 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10d45: 44 89 e2                     	movl	%r12d, %edx
   10d48: f7 da                        	negl	%edx
   10d4a: 89 10                        	movl	%edx, (%rax)
; }
   10d4c: 44 89 e0                     	movl	%r12d, %eax
   10d4f: 5d                           	popq	%rbp
   10d50: 41 5c                        	popq	%r12
   10d52: 41 5d                        	popq	%r13
   10d54: c3                           	retq
   10d55: 0f 1f 00                     	nopl	(%rax)
; 	err = unlink(path);
   10d58: 4c 89 ef                     	movq	%r13, %rdi
   10d5b: e8 a0 49 ff ff               	callq	0x5700 <.plt.sec+0x90>
   10d60: 41 89 c4                     	movl	%eax, %r12d
; 	if (err != 0)
   10d63: 85 c0                        	testl	%eax, %eax
   10d65: 74 29                        	je	0x10d90 <bpf_map__unpin+0xb0>
; 		return libbpf_err(-errno);
   10d67: e8 84 49 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; }
   10d6c: 5d                           	popq	%rbp
; 		return libbpf_err(-errno);
   10d6d: 44 8b 20                     	movl	(%rax), %r12d
   10d70: 41 f7 dc                     	negl	%r12d
; }
   10d73: 44 89 e0                     	movl	%r12d, %eax
   10d76: 41 5c                        	popq	%r12
   10d78: 41 5d                        	popq	%r13
   10d7a: c3                           	retq
   10d7b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	} else if (!path) {
   10d80: 48 85 f6                     	testq	%rsi, %rsi
   10d83: 0f 84 95 00 00 00            	je	0x10e1e <bpf_map__unpin+0x13e>
   10d89: 49 89 f5                     	movq	%rsi, %r13
   10d8c: eb 8e                        	jmp	0x10d1c <bpf_map__unpin+0x3c>
   10d8e: 66 90                        	nop
; 	map->pinned = false;
   10d90: c6 85 90 00 00 00 00         	movb	$0, 144(%rbp)
; 	pr_debug("unpinned map '%s' from '%s'\n", bpf_map__name(map), path);
   10d97: 48 89 ef                     	movq	%rbp, %rdi
   10d9a: e8 b1 ef ff ff               	callq	0xfd50 <bpf_map__name>
   10d9f: 4c 89 e9                     	movq	%r13, %rcx
   10da2: bf 02 00 00 00               	movl	$2, %edi
   10da7: 48 8d 35 6a 48 02 00         	leaq	149610(%rip), %rsi      # 0x35618 <strs.2+0x2788>
   10dae: 48 89 c2                     	movq	%rax, %rdx
   10db1: 31 c0                        	xorl	%eax, %eax
   10db3: e8 18 73 ff ff               	callq	0x80d0 <libbpf_print>
; }
   10db8: 44 89 e0                     	movl	%r12d, %eax
   10dbb: 5d                           	popq	%rbp
   10dbc: 41 5c                        	popq	%r12
   10dbe: 41 5d                        	popq	%r13
   10dc0: c3                           	retq
; 			pr_warn("map '%s' already has pin path '%s' different from '%s'\n",
   10dc1: 48 89 ef                     	movq	%rbp, %rdi
   10dc4: e8 87 ef ff ff               	callq	0xfd50 <bpf_map__name>
   10dc9: 4d 89 e0                     	movq	%r12, %r8
   10dcc: 4c 89 e9                     	movq	%r13, %rcx
   10dcf: 31 ff                        	xorl	%edi, %edi
   10dd1: 48 89 c2                     	movq	%rax, %rdx
   10dd4: 48 8d 35 1d 47 02 00         	leaq	149277(%rip), %rsi      # 0x354f8 <strs.2+0x2668>
   10ddb: 31 c0                        	xorl	%eax, %eax
; 			return libbpf_err(-EINVAL);
   10ddd: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("map '%s' already has pin path '%s' different from '%s'\n",
   10de3: e8 e8 72 ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   10de8: e8 03 49 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10ded: c7 00 16 00 00 00            	movl	$22, (%rax)
   10df3: e9 35 ff ff ff               	jmp	0x10d2d <bpf_map__unpin+0x4d>
; 		pr_warn("invalid map pointer\n");
   10df8: 48 8d 35 43 12 02 00         	leaq	135747(%rip), %rsi      # 0x32042 <_IO_stdin_used+0x2042>
   10dff: 31 ff                        	xorl	%edi, %edi
   10e01: 31 c0                        	xorl	%eax, %eax
; 		return libbpf_err(-EINVAL);
   10e03: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("invalid map pointer\n");
   10e09: e8 c2 72 ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   10e0e: e8 dd 48 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10e13: c7 00 16 00 00 00            	movl	$22, (%rax)
   10e19: e9 0f ff ff ff               	jmp	0x10d2d <bpf_map__unpin+0x4d>
; 		pr_warn("no path to unpin map '%s' from\n",
   10e1e: e8 2d ef ff ff               	callq	0xfd50 <bpf_map__name>
   10e23: 48 8d 35 c6 47 02 00         	leaq	149446(%rip), %rsi      # 0x355f0 <strs.2+0x2760>
   10e2a: 31 ff                        	xorl	%edi, %edi
; 		return libbpf_err(-EINVAL);
   10e2c: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("no path to unpin map '%s' from\n",
   10e32: 48 89 c2                     	movq	%rax, %rdx
   10e35: 31 c0                        	xorl	%eax, %eax
   10e37: e8 94 72 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   10e3c: bf ea ff ff ff               	movl	$4294967274, %edi       # imm = 0xFFFFFFEA
   10e41: e8 2a 64 ff ff               	callq	0x7270 <libbpf_err.part.0>
; 		return libbpf_err(-EINVAL);
   10e46: e9 e2 fe ff ff               	jmp	0x10d2d <bpf_map__unpin+0x4d>
   10e4b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000010e50 <bpf_object__unpin_maps>:
; {
   10e50: f3 0f 1e fa                  	endbr64
   10e54: 41 57                        	pushq	%r15
   10e56: 41 56                        	pushq	%r14
   10e58: 41 55                        	pushq	%r13
   10e5a: 41 54                        	pushq	%r12
   10e5c: 55                           	pushq	%rbp
   10e5d: 53                           	pushq	%rbx
   10e5e: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   10e65: 48 83 0c 24 00               	orq	$0, (%rsp)
   10e6a: 48 83 ec 28                  	subq	$40, %rsp
   10e6e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   10e77: 48 89 84 24 18 10 00 00      	movq	%rax, 4120(%rsp)
   10e7f: 31 c0                        	xorl	%eax, %eax
; 	if (!obj)
   10e81: 48 85 ff                     	testq	%rdi, %rdi
   10e84: 0f 84 40 01 00 00            	je	0x10fca <bpf_object__unpin_maps+0x17a>
; 		return obj->maps;
   10e8a: 4c 8b 7f 68                  	movq	104(%rdi), %r15
   10e8e: 48 89 fd                     	movq	%rdi, %rbp
; 	bpf_object__for_each_map(map, obj) {
   10e91: 4d 85 ff                     	testq	%r15, %r15
   10e94: 0f 84 c6 00 00 00            	je	0x10f60 <bpf_object__unpin_maps+0x110>
   10e9a: 45 31 e4                     	xorl	%r12d, %r12d
   10e9d: 4c 8d 6c 24 10               	leaq	16(%rsp), %r13
   10ea2: 48 85 f6                     	testq	%rsi, %rsi
   10ea5: 48 89 f3                     	movq	%rsi, %rbx
   10ea8: 4d 0f 45 e5                  	cmovneq	%r13, %r12
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   10eac: 4c 8d 35 dd 0d 02 00         	leaq	134621(%rip), %r14      # 0x31c90 <_IO_stdin_used+0x1c90>
   10eb3: eb 3b                        	jmp	0x10ef0 <bpf_object__unpin_maps+0xa0>
   10eb5: 0f 1f 00                     	nopl	(%rax)
; 		} else if (!map->pin_path) {
   10eb8: 49 83 bf 88 00 00 00 00      	cmpq	$0, 136(%r15)
   10ec0: 74 16                        	je	0x10ed8 <bpf_object__unpin_maps+0x88>
; 		err = bpf_map__unpin(map, pin_path);
   10ec2: 4c 89 e6                     	movq	%r12, %rsi
   10ec5: 4c 89 ff                     	movq	%r15, %rdi
   10ec8: e8 13 fe ff ff               	callq	0x10ce0 <bpf_map__unpin>
   10ecd: 41 89 c0                     	movl	%eax, %r8d
; 		if (err)
   10ed0: 85 c0                        	testl	%eax, %eax
   10ed2: 0f 85 b3 00 00 00            	jne	0x10f8b <bpf_object__unpin_maps+0x13b>
; 	return __bpf_map__iter(prev, obj, 1);
   10ed8: 4c 89 ff                     	movq	%r15, %rdi
   10edb: ba 01 00 00 00               	movl	$1, %edx
   10ee0: 48 89 ee                     	movq	%rbp, %rsi
   10ee3: e8 08 8f ff ff               	callq	0x9df0 <__bpf_map__iter>
   10ee8: 49 89 c7                     	movq	%rax, %r15
; 	bpf_object__for_each_map(map, obj) {
   10eeb: 48 85 c0                     	testq	%rax, %rax
   10eee: 74 70                        	je	0x10f60 <bpf_object__unpin_maps+0x110>
; 		if (path) {
   10ef0: 48 85 db                     	testq	%rbx, %rbx
   10ef3: 74 c3                        	je	0x10eb8 <bpf_object__unpin_maps+0x68>
; 			len = snprintf(buf, PATH_MAX, "%s/%s", path,
   10ef5: 4c 89 ff                     	movq	%r15, %rdi
   10ef8: e8 53 ee ff ff               	callq	0xfd50 <bpf_map__name>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   10efd: 48 83 ec 08                  	subq	$8, %rsp
   10f01: 49 89 d9                     	movq	%rbx, %r9
   10f04: 4d 89 f0                     	movq	%r14, %r8
   10f07: 50                           	pushq	%rax
   10f08: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
   10f0d: ba 01 00 00 00               	movl	$1, %edx
   10f12: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
   10f17: 4c 89 ef                     	movq	%r13, %rdi
   10f1a: 31 c0                        	xorl	%eax, %eax
   10f1c: e8 8f 47 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 			if (len < 0)
   10f21: 5a                           	popq	%rdx
   10f22: 59                           	popq	%rcx
   10f23: 85 c0                        	testl	%eax, %eax
   10f25: 78 7d                        	js	0x10fa4 <bpf_object__unpin_maps+0x154>
; 			else if (len >= PATH_MAX)
   10f27: 3d ff 0f 00 00               	cmpl	$4095, %eax             # imm = 0xFFF
   10f2c: 0f 8f 85 00 00 00            	jg	0x10fb7 <bpf_object__unpin_maps+0x167>
; 	while (*s) {
   10f32: 0f b6 54 24 10               	movzbl	16(%rsp), %edx
   10f37: 4c 89 e8                     	movq	%r13, %rax
   10f3a: 84 d2                        	testb	%dl, %dl
   10f3c: 74 84                        	je	0x10ec2 <bpf_object__unpin_maps+0x72>
   10f3e: 66 90                        	nop
; 		if (*s == '.')
   10f40: 80 fa 2e                     	cmpb	$46, %dl
   10f43: 75 03                        	jne	0x10f48 <bpf_object__unpin_maps+0xf8>
; 			*s = '_';
   10f45: c6 00 5f                     	movb	$95, (%rax)
; 	while (*s) {
   10f48: 0f b6 50 01                  	movzbl	1(%rax), %edx
; 		s++;
   10f4c: 48 83 c0 01                  	addq	$1, %rax
; 	while (*s) {
   10f50: 84 d2                        	testb	%dl, %dl
   10f52: 75 ec                        	jne	0x10f40 <bpf_object__unpin_maps+0xf0>
   10f54: e9 69 ff ff ff               	jmp	0x10ec2 <bpf_object__unpin_maps+0x72>
   10f59: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return 0;
   10f60: 45 31 c0                     	xorl	%r8d, %r8d
; }
   10f63: 48 8b 84 24 18 10 00 00      	movq	4120(%rsp), %rax
   10f6b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   10f74: 75 67                        	jne	0x10fdd <bpf_object__unpin_maps+0x18d>
   10f76: 48 81 c4 28 10 00 00         	addq	$4136, %rsp             # imm = 0x1028
   10f7d: 44 89 c0                     	movl	%r8d, %eax
   10f80: 5b                           	popq	%rbx
   10f81: 5d                           	popq	%rbp
   10f82: 41 5c                        	popq	%r12
   10f84: 41 5d                        	popq	%r13
   10f86: 41 5e                        	popq	%r14
   10f88: 41 5f                        	popq	%r15
   10f8a: c3                           	retq
; 	if (ret < 0)
   10f8b: 79 d6                        	jns	0x10f63 <bpf_object__unpin_maps+0x113>
   10f8d: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 		errno = -ret;
   10f91: e8 5a 47 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   10f96: 44 8b 44 24 0c               	movl	12(%rsp), %r8d
   10f9b: 44 89 c2                     	movl	%r8d, %edx
   10f9e: f7 da                        	negl	%edx
   10fa0: 89 10                        	movl	%edx, (%rax)
   10fa2: eb bf                        	jmp	0x10f63 <bpf_object__unpin_maps+0x113>
   10fa4: e8 47 47 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 				return libbpf_err(-EINVAL);
   10fa9: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
; 		errno = -ret;
   10faf: c7 00 16 00 00 00            	movl	$22, (%rax)
   10fb5: eb ac                        	jmp	0x10f63 <bpf_object__unpin_maps+0x113>
   10fb7: e8 34 47 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 				return libbpf_err(-ENAMETOOLONG);
   10fbc: 41 b8 dc ff ff ff            	movl	$4294967260, %r8d       # imm = 0xFFFFFFDC
; 		errno = -ret;
   10fc2: c7 00 24 00 00 00            	movl	$36, (%rax)
   10fc8: eb 99                        	jmp	0x10f63 <bpf_object__unpin_maps+0x113>
   10fca: e8 21 47 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOENT);
   10fcf: 41 b8 fe ff ff ff            	movl	$4294967294, %r8d       # imm = 0xFFFFFFFE
; 		errno = -ret;
   10fd5: c7 00 02 00 00 00            	movl	$2, (%rax)
   10fdb: eb 86                        	jmp	0x10f63 <bpf_object__unpin_maps+0x113>
; }
   10fdd: e8 1e 48 ff ff               	callq	0x5800 <.plt.sec+0x190>
   10fe2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   10fed: 0f 1f 00                     	nopl	(%rax)

0000000000010ff0 <bpf_object__pin_maps>:
; {
   10ff0: f3 0f 1e fa                  	endbr64
   10ff4: 41 57                        	pushq	%r15
   10ff6: 41 56                        	pushq	%r14
   10ff8: 41 55                        	pushq	%r13
   10ffa: 41 54                        	pushq	%r12
   10ffc: 55                           	pushq	%rbp
   10ffd: 53                           	pushq	%rbx
   10ffe: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   11005: 48 83 0c 24 00               	orq	$0, (%rsp)
   1100a: 48 83 ec 18                  	subq	$24, %rsp
   1100e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   11017: 48 89 84 24 08 10 00 00      	movq	%rax, 4104(%rsp)
   1101f: 31 c0                        	xorl	%eax, %eax
; 	if (!obj)
   11021: 48 85 ff                     	testq	%rdi, %rdi
   11024: 0f 84 7c 01 00 00            	je	0x111a6 <bpf_object__pin_maps+0x1b6>
; 	if (!obj->loaded) {
   1102a: 80 bf 98 00 00 00 00         	cmpb	$0, 152(%rdi)
   11031: 48 89 fb                     	movq	%rdi, %rbx
   11034: 0f 84 5c 01 00 00            	je	0x11196 <bpf_object__pin_maps+0x1a6>
; 		return obj->maps;
   1103a: 48 8b 6f 68                  	movq	104(%rdi), %rbp
; 	bpf_object__for_each_map(map, obj) {
   1103e: 48 85 ed                     	testq	%rbp, %rbp
   11041: 0f 84 09 01 00 00            	je	0x11150 <bpf_object__pin_maps+0x160>
   11047: 45 31 ed                     	xorl	%r13d, %r13d
   1104a: 49 89 e6                     	movq	%rsp, %r14
   1104d: 48 85 f6                     	testq	%rsi, %rsi
   11050: 49 89 f4                     	movq	%rsi, %r12
   11053: 4d 0f 45 ee                  	cmovneq	%r14, %r13
   11057: eb 43                        	jmp	0x1109c <bpf_object__pin_maps+0xac>
   11059: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		} else if (!map->pin_path) {
   11060: 48 83 bd 88 00 00 00 00      	cmpq	$0, 136(%rbp)
   11068: 74 16                        	je	0x11080 <bpf_object__pin_maps+0x90>
; 		err = bpf_map__pin(map, pin_path);
   1106a: 4c 89 ee                     	movq	%r13, %rsi
   1106d: 48 89 ef                     	movq	%rbp, %rdi
   11070: e8 db f9 ff ff               	callq	0x10a50 <bpf_map__pin>
   11075: 41 89 c7                     	movl	%eax, %r15d
; 		if (err)
   11078: 85 c0                        	testl	%eax, %eax
   1107a: 0f 85 a0 00 00 00            	jne	0x11120 <bpf_object__pin_maps+0x130>
; 	return __bpf_map__iter(prev, obj, 1);
   11080: 48 89 ef                     	movq	%rbp, %rdi
   11083: ba 01 00 00 00               	movl	$1, %edx
   11088: 48 89 de                     	movq	%rbx, %rsi
   1108b: e8 60 8d ff ff               	callq	0x9df0 <__bpf_map__iter>
   11090: 48 89 c5                     	movq	%rax, %rbp
; 	bpf_object__for_each_map(map, obj) {
   11093: 48 85 c0                     	testq	%rax, %rax
   11096: 0f 84 b4 00 00 00            	je	0x11150 <bpf_object__pin_maps+0x160>
; 		if (!map->autocreate)
   1109c: 80 bd 92 00 00 00 00         	cmpb	$0, 146(%rbp)
   110a3: 74 db                        	je	0x11080 <bpf_object__pin_maps+0x90>
; 		if (path) {
   110a5: 4d 85 e4                     	testq	%r12, %r12
   110a8: 74 b6                        	je	0x11060 <bpf_object__pin_maps+0x70>
; 			len = snprintf(buf, PATH_MAX, "%s/%s", path,
   110aa: 48 89 ef                     	movq	%rbp, %rdi
   110ad: e8 9e ec ff ff               	callq	0xfd50 <bpf_map__name>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   110b2: 48 83 ec 08                  	subq	$8, %rsp
   110b6: 4d 89 e1                     	movq	%r12, %r9
   110b9: 4c 89 f7                     	movq	%r14, %rdi
   110bc: 50                           	pushq	%rax
   110bd: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
   110c2: ba 01 00 00 00               	movl	$1, %edx
   110c7: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
   110cc: 4c 8d 05 bd 0b 02 00         	leaq	134077(%rip), %r8       # 0x31c90 <_IO_stdin_used+0x1c90>
   110d3: 31 c0                        	xorl	%eax, %eax
   110d5: e8 d6 45 ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 			if (len < 0) {
   110da: 5a                           	popq	%rdx
   110db: 59                           	popq	%rcx
   110dc: 85 c0                        	testl	%eax, %eax
   110de: 78 39                        	js	0x11119 <bpf_object__pin_maps+0x129>
; 			} else if (len >= PATH_MAX) {
   110e0: 3d ff 0f 00 00               	cmpl	$4095, %eax             # imm = 0xFFF
   110e5: 0f 8f a3 00 00 00            	jg	0x1118e <bpf_object__pin_maps+0x19e>
; 	while (*s) {
   110eb: 0f b6 14 24                  	movzbl	(%rsp), %edx
   110ef: 4c 89 f0                     	movq	%r14, %rax
   110f2: 84 d2                        	testb	%dl, %dl
   110f4: 0f 84 70 ff ff ff            	je	0x1106a <bpf_object__pin_maps+0x7a>
   110fa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		if (*s == '.')
   11100: 80 fa 2e                     	cmpb	$46, %dl
   11103: 75 03                        	jne	0x11108 <bpf_object__pin_maps+0x118>
; 			*s = '_';
   11105: c6 00 5f                     	movb	$95, (%rax)
; 	while (*s) {
   11108: 0f b6 50 01                  	movzbl	1(%rax), %edx
; 		s++;
   1110c: 48 83 c0 01                  	addq	$1, %rax
; 	while (*s) {
   11110: 84 d2                        	testb	%dl, %dl
   11112: 75 ec                        	jne	0x11100 <bpf_object__pin_maps+0x110>
   11114: e9 51 ff ff ff               	jmp	0x1106a <bpf_object__pin_maps+0x7a>
; 				err = -EINVAL;
   11119: 41 bf ea ff ff ff            	movl	$4294967274, %r15d      # imm = 0xFFFFFFEA
   1111f: 90                           	nop
; 	return __bpf_map__iter(next, obj, -1);
   11120: 48 89 ef                     	movq	%rbp, %rdi
   11123: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
   11128: 48 89 de                     	movq	%rbx, %rsi
   1112b: e8 c0 8c ff ff               	callq	0x9df0 <__bpf_map__iter>
   11130: 48 89 c5                     	movq	%rax, %rbp
; 	while ((map = bpf_object__prev_map(obj, map))) {
   11133: 48 85 c0                     	testq	%rax, %rax
   11136: 74 43                        	je	0x1117b <bpf_object__pin_maps+0x18b>
; 		if (!map->pin_path)
   11138: 48 83 bd 88 00 00 00 00      	cmpq	$0, 136(%rbp)
   11140: 74 de                        	je	0x11120 <bpf_object__pin_maps+0x130>
; 		bpf_map__unpin(map, NULL);
   11142: 31 f6                        	xorl	%esi, %esi
   11144: 48 89 ef                     	movq	%rbp, %rdi
   11147: e8 94 fb ff ff               	callq	0x10ce0 <bpf_map__unpin>
   1114c: eb d2                        	jmp	0x11120 <bpf_object__pin_maps+0x130>
   1114e: 66 90                        	nop
; 	return 0;
   11150: 45 31 ff                     	xorl	%r15d, %r15d
; }
   11153: 48 8b 84 24 08 10 00 00      	movq	4104(%rsp), %rax
   1115b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   11164: 75 53                        	jne	0x111b9 <bpf_object__pin_maps+0x1c9>
   11166: 48 81 c4 18 10 00 00         	addq	$4120, %rsp             # imm = 0x1018
   1116d: 44 89 f8                     	movl	%r15d, %eax
   11170: 5b                           	popq	%rbx
   11171: 5d                           	popq	%rbp
   11172: 41 5c                        	popq	%r12
   11174: 41 5d                        	popq	%r13
   11176: 41 5e                        	popq	%r14
   11178: 41 5f                        	popq	%r15
   1117a: c3                           	retq
; 	if (ret < 0)
   1117b: 45 85 ff                     	testl	%r15d, %r15d
   1117e: 79 d3                        	jns	0x11153 <bpf_object__pin_maps+0x163>
; 		errno = -ret;
   11180: e8 6b 45 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   11185: 44 89 fa                     	movl	%r15d, %edx
   11188: f7 da                        	negl	%edx
   1118a: 89 10                        	movl	%edx, (%rax)
   1118c: eb c5                        	jmp	0x11153 <bpf_object__pin_maps+0x163>
; 				err = -ENAMETOOLONG;
   1118e: 41 bf dc ff ff ff            	movl	$4294967260, %r15d      # imm = 0xFFFFFFDC
; 	while ((map = bpf_object__prev_map(obj, map))) {
   11194: eb 8a                        	jmp	0x11120 <bpf_object__pin_maps+0x130>
; 		pr_warn("object not yet loaded; load it first\n");
   11196: 48 8d 35 6b 3e 02 00         	leaq	147051(%rip), %rsi      # 0x35008 <strs.2+0x2178>
   1119d: 31 ff                        	xorl	%edi, %edi
   1119f: 31 c0                        	xorl	%eax, %eax
   111a1: e8 2a 6f ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   111a6: e8 45 45 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOENT);
   111ab: 41 bf fe ff ff ff            	movl	$4294967294, %r15d      # imm = 0xFFFFFFFE
; 		errno = -ret;
   111b1: c7 00 02 00 00 00            	movl	$2, (%rax)
   111b7: eb 9a                        	jmp	0x11153 <bpf_object__pin_maps+0x163>
; }
   111b9: e8 42 46 ff ff               	callq	0x5800 <.plt.sec+0x190>
   111be: 66 90                        	nop

00000000000111c0 <bpf_object__pin>:
; {
   111c0: f3 0f 1e fa                  	endbr64
   111c4: 41 55                        	pushq	%r13
   111c6: 49 89 f5                     	movq	%rsi, %r13
   111c9: 41 54                        	pushq	%r12
   111cb: 55                           	pushq	%rbp
   111cc: 48 89 fd                     	movq	%rdi, %rbp
; 	err = bpf_object__pin_maps(obj, path);
   111cf: e8 1c fe ff ff               	callq	0x10ff0 <bpf_object__pin_maps>
; 	if (err)
   111d4: 85 c0                        	testl	%eax, %eax
   111d6: 74 18                        	je	0x111f0 <bpf_object__pin+0x30>
   111d8: 41 89 c4                     	movl	%eax, %r12d
; 	if (ret < 0)
   111db: 78 35                        	js	0x11212 <bpf_object__pin+0x52>
; }
   111dd: 44 89 e0                     	movl	%r12d, %eax
   111e0: 5d                           	popq	%rbp
   111e1: 41 5c                        	popq	%r12
   111e3: 41 5d                        	popq	%r13
   111e5: c3                           	retq
   111e6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	err = bpf_object__pin_programs(obj, path);
   111f0: 4c 89 ee                     	movq	%r13, %rsi
   111f3: 48 89 ef                     	movq	%rbp, %rdi
   111f6: e8 25 de ff ff               	callq	0xf020 <bpf_object__pin_programs>
   111fb: 41 89 c4                     	movl	%eax, %r12d
; 	if (err) {
   111fe: 85 c0                        	testl	%eax, %eax
   11200: 74 db                        	je	0x111dd <bpf_object__pin+0x1d>
; 		bpf_object__unpin_maps(obj, path);
   11202: 4c 89 ee                     	movq	%r13, %rsi
   11205: 48 89 ef                     	movq	%rbp, %rdi
   11208: e8 43 fc ff ff               	callq	0x10e50 <bpf_object__unpin_maps>
; 	if (ret < 0)
   1120d: 45 85 e4                     	testl	%r12d, %r12d
   11210: 79 cb                        	jns	0x111dd <bpf_object__pin+0x1d>
; 		errno = -ret;
   11212: e8 d9 44 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   11217: 44 89 e2                     	movl	%r12d, %edx
   1121a: f7 da                        	negl	%edx
   1121c: 89 10                        	movl	%edx, (%rax)
; }
   1121e: 44 89 e0                     	movl	%r12d, %eax
   11221: 5d                           	popq	%rbp
   11222: 41 5c                        	popq	%r12
   11224: 41 5d                        	popq	%r13
   11226: c3                           	retq
   11227: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000011230 <bpf_map__type>:
; {
   11230: f3 0f 1e fa                  	endbr64
; 	return map->def.type;
   11234: 8b 47 30                     	movl	48(%rdi), %eax
; }
   11237: c3                           	retq
   11238: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000011240 <bpf_map__set_type>:
; {
   11240: f3 0f 1e fa                  	endbr64
; 	if (map->fd >= 0)
   11244: 8b 47 18                     	movl	24(%rdi), %eax
   11247: 85 c0                        	testl	%eax, %eax
   11249: 79 06                        	jns	0x11251 <bpf_map__set_type+0x11>
; 	map->def.type = type;
   1124b: 89 77 30                     	movl	%esi, 48(%rdi)
; 	return 0;
   1124e: 31 c0                        	xorl	%eax, %eax
; }
   11250: c3                           	retq
; {
   11251: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   11255: e8 96 44 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   1125a: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
   11260: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
   11265: 48 83 c4 08                  	addq	$8, %rsp
   11269: c3                           	retq
   1126a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

0000000000011270 <bpf_map__map_flags>:
; {
   11270: f3 0f 1e fa                  	endbr64
; 	return map->def.map_flags;
   11274: 8b 47 40                     	movl	64(%rdi), %eax
; }
   11277: c3                           	retq
   11278: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000011280 <bpf_map__set_map_flags>:
; {
   11280: f3 0f 1e fa                  	endbr64
; 	if (map->fd >= 0)
   11284: 8b 47 18                     	movl	24(%rdi), %eax
   11287: 85 c0                        	testl	%eax, %eax
   11289: 79 06                        	jns	0x11291 <bpf_map__set_map_flags+0x11>
; 	map->def.map_flags = flags;
   1128b: 89 77 40                     	movl	%esi, 64(%rdi)
; 	return 0;
   1128e: 31 c0                        	xorl	%eax, %eax
; }
   11290: c3                           	retq
; {
   11291: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   11295: e8 56 44 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   1129a: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
   112a0: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
   112a5: 48 83 c4 08                  	addq	$8, %rsp
   112a9: c3                           	retq
   112aa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

00000000000112b0 <bpf_map__map_extra>:
; {
   112b0: f3 0f 1e fa                  	endbr64
; 	return map->map_extra;
   112b4: 48 8b 87 98 00 00 00         	movq	152(%rdi), %rax
; }
   112bb: c3                           	retq
   112bc: 0f 1f 40 00                  	nopl	(%rax)

00000000000112c0 <bpf_map__set_map_extra>:
; {
   112c0: f3 0f 1e fa                  	endbr64
; 	if (map->fd >= 0)
   112c4: 8b 47 18                     	movl	24(%rdi), %eax
   112c7: 85 c0                        	testl	%eax, %eax
   112c9: 79 0a                        	jns	0x112d5 <bpf_map__set_map_extra+0x15>
; 	map->map_extra = map_extra;
   112cb: 48 89 b7 98 00 00 00         	movq	%rsi, 152(%rdi)
; 	return 0;
   112d2: 31 c0                        	xorl	%eax, %eax
; }
   112d4: c3                           	retq
; {
   112d5: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   112d9: e8 12 44 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   112de: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
   112e4: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
   112e9: 48 83 c4 08                  	addq	$8, %rsp
   112ed: c3                           	retq
   112ee: 66 90                        	nop

00000000000112f0 <bpf_map__numa_node>:
; {
   112f0: f3 0f 1e fa                  	endbr64
; 	return map->numa_node;
   112f4: 8b 47 44                     	movl	68(%rdi), %eax
; }
   112f7: c3                           	retq
   112f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000011300 <bpf_map__set_numa_node>:
; {
   11300: f3 0f 1e fa                  	endbr64
; 	if (map->fd >= 0)
   11304: 8b 47 18                     	movl	24(%rdi), %eax
   11307: 85 c0                        	testl	%eax, %eax
   11309: 79 06                        	jns	0x11311 <bpf_map__set_numa_node+0x11>
; 	map->numa_node = numa_node;
   1130b: 89 77 44                     	movl	%esi, 68(%rdi)
; 	return 0;
   1130e: 31 c0                        	xorl	%eax, %eax
; }
   11310: c3                           	retq
; {
   11311: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   11315: e8 d6 43 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   1131a: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
   11320: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
   11325: 48 83 c4 08                  	addq	$8, %rsp
   11329: c3                           	retq
   1132a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

0000000000011330 <bpf_map__key_size>:
; {
   11330: f3 0f 1e fa                  	endbr64
; 	return map->def.key_size;
   11334: 8b 47 34                     	movl	52(%rdi), %eax
; }
   11337: c3                           	retq
   11338: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000011340 <bpf_map__set_key_size>:
; {
   11340: f3 0f 1e fa                  	endbr64
; 	if (map->fd >= 0)
   11344: 8b 47 18                     	movl	24(%rdi), %eax
   11347: 85 c0                        	testl	%eax, %eax
   11349: 79 06                        	jns	0x11351 <bpf_map__set_key_size+0x11>
; 	map->def.key_size = size;
   1134b: 89 77 34                     	movl	%esi, 52(%rdi)
; 	return 0;
   1134e: 31 c0                        	xorl	%eax, %eax
; }
   11350: c3                           	retq
; {
   11351: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   11355: e8 96 43 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   1135a: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
   11360: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
   11365: 48 83 c4 08                  	addq	$8, %rsp
   11369: c3                           	retq
   1136a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

0000000000011370 <bpf_map__value_size>:
; {
   11370: f3 0f 1e fa                  	endbr64
; 	return map->def.value_size;
   11374: 8b 47 38                     	movl	56(%rdi), %eax
; }
   11377: c3                           	retq
   11378: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000011380 <bpf_map__set_value_size>:
; {
   11380: f3 0f 1e fa                  	endbr64
; 	if (map->fd >= 0)
   11384: 8b 47 18                     	movl	24(%rdi), %eax
   11387: 85 c0                        	testl	%eax, %eax
   11389: 79 06                        	jns	0x11391 <bpf_map__set_value_size+0x11>
; 	map->def.value_size = size;
   1138b: 89 77 38                     	movl	%esi, 56(%rdi)
; 	return 0;
   1138e: 31 c0                        	xorl	%eax, %eax
; }
   11390: c3                           	retq
; {
   11391: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   11395: e8 56 43 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   1139a: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
   113a0: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
   113a5: 48 83 c4 08                  	addq	$8, %rsp
   113a9: c3                           	retq
   113aa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

00000000000113b0 <bpf_map__btf_key_type_id>:
; {
   113b0: f3 0f 1e fa                  	endbr64
; 	return map ? map->btf_key_type_id : 0;
   113b4: 31 c0                        	xorl	%eax, %eax
   113b6: 48 85 ff                     	testq	%rdi, %rdi
   113b9: 74 03                        	je	0x113be <bpf_map__btf_key_type_id+0xe>
   113bb: 8b 47 4c                     	movl	76(%rdi), %eax
; }
   113be: c3                           	retq
   113bf: 90                           	nop

00000000000113c0 <bpf_map__btf_value_type_id>:
; {
   113c0: f3 0f 1e fa                  	endbr64
; 	return map ? map->btf_value_type_id : 0;
   113c4: 31 c0                        	xorl	%eax, %eax
   113c6: 48 85 ff                     	testq	%rdi, %rdi
   113c9: 74 03                        	je	0x113ce <bpf_map__btf_value_type_id+0xe>
   113cb: 8b 47 50                     	movl	80(%rdi), %eax
; }
   113ce: c3                           	retq
   113cf: 90                           	nop

00000000000113d0 <bpf_map__set_initial_value>:
; {
   113d0: f3 0f 1e fa                  	endbr64
   113d4: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!map->mmaped || map->libbpf_type == LIBBPF_MAP_KCONFIG ||
   113d8: 4c 8b 47 60                  	movq	96(%rdi), %r8
   113dc: 4d 85 c0                     	testq	%r8, %r8
   113df: 74 2f                        	je	0x11410 <bpf_map__set_initial_value+0x40>
   113e1: 83 7f 58 04                  	cmpl	$4, 88(%rdi)
   113e5: 74 29                        	je	0x11410 <bpf_map__set_initial_value+0x40>
; 	    size != map->def.value_size || map->fd >= 0)
   113e7: 44 8b 4f 38                  	movl	56(%rdi), %r9d
; 	if (!map->mmaped || map->libbpf_type == LIBBPF_MAP_KCONFIG ||
   113eb: 49 39 d1                     	cmpq	%rdx, %r9
   113ee: 75 20                        	jne	0x11410 <bpf_map__set_initial_value+0x40>
; 	    size != map->def.value_size || map->fd >= 0)
   113f0: 8b 47 18                     	movl	24(%rdi), %eax
   113f3: 85 c0                        	testl	%eax, %eax
   113f5: 79 19                        	jns	0x11410 <bpf_map__set_initial_value+0x40>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   113f7: 4c 89 ca                     	movq	%r9, %rdx
   113fa: 4c 89 c7                     	movq	%r8, %rdi
   113fd: e8 3e 46 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	return 0;
   11402: 31 c0                        	xorl	%eax, %eax
; }
   11404: 48 83 c4 08                  	addq	$8, %rsp
   11408: c3                           	retq
   11409: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -ret;
   11410: e8 db 42 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   11415: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   1141b: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   11420: eb e2                        	jmp	0x11404 <bpf_map__set_initial_value+0x34>
   11422: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1142d: 0f 1f 00                     	nopl	(%rax)

0000000000011430 <bpf_map__initial_value>:
; {
   11430: f3 0f 1e fa                  	endbr64
; 	if (!map->mmaped)
   11434: 48 8b 47 60                  	movq	96(%rdi), %rax
   11438: 48 85 c0                     	testq	%rax, %rax
   1143b: 74 06                        	je	0x11443 <bpf_map__initial_value+0x13>
; 	*psize = map->def.value_size;
   1143d: 8b 57 38                     	movl	56(%rdi), %edx
   11440: 48 89 16                     	movq	%rdx, (%rsi)
; }
   11443: c3                           	retq
   11444: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1144f: 90                           	nop

0000000000011450 <bpf_map__is_internal>:
; {
   11450: f3 0f 1e fa                  	endbr64
; 	return map->libbpf_type != LIBBPF_MAP_UNSPEC;
   11454: 8b 47 58                     	movl	88(%rdi), %eax
   11457: 85 c0                        	testl	%eax, %eax
   11459: 0f 95 c0                     	setne	%al
; }
   1145c: c3                           	retq
   1145d: 0f 1f 00                     	nopl	(%rax)

0000000000011460 <bpf_map__ifindex>:
; {
   11460: f3 0f 1e fa                  	endbr64
; 	return map->map_ifindex;
   11464: 8b 47 28                     	movl	40(%rdi), %eax
; }
   11467: c3                           	retq
   11468: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000011470 <bpf_map__set_ifindex>:
; {
   11470: f3 0f 1e fa                  	endbr64
; 	if (map->fd >= 0)
   11474: 8b 47 18                     	movl	24(%rdi), %eax
   11477: 85 c0                        	testl	%eax, %eax
   11479: 79 06                        	jns	0x11481 <bpf_map__set_ifindex+0x11>
; 	map->map_ifindex = ifindex;
   1147b: 89 77 28                     	movl	%esi, 40(%rdi)
; 	return 0;
   1147e: 31 c0                        	xorl	%eax, %eax
; }
   11480: c3                           	retq
; {
   11481: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   11485: e8 66 42 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   1148a: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
   11490: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
   11495: 48 83 c4 08                  	addq	$8, %rsp
   11499: c3                           	retq
   1149a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

00000000000114a0 <bpf_map__set_inner_map_fd>:
; {
   114a0: f3 0f 1e fa                  	endbr64
   114a4: 53                           	pushq	%rbx
   114a5: 48 83 ec 10                  	subq	$16, %rsp
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
   114a9: 8b 47 30                     	movl	48(%rdi), %eax
   114ac: 83 e8 0c                     	subl	$12, %eax
   114af: 83 f8 01                     	cmpl	$1, %eax
   114b2: 76 2c                        	jbe	0x114e0 <bpf_map__set_inner_map_fd+0x40>
; 		pr_warn("error: unsupported map type\n");
   114b4: 48 8d 35 85 41 02 00         	leaq	147845(%rip), %rsi      # 0x35640 <strs.2+0x27b0>
; 		pr_warn("error: inner_map_fd already specified\n");
   114bb: 31 ff                        	xorl	%edi, %edi
   114bd: 31 c0                        	xorl	%eax, %eax
   114bf: e8 0c 6c ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   114c4: e8 27 42 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   114c9: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   114cf: 48 83 c4 10                  	addq	$16, %rsp
; 		return libbpf_err(-EINVAL);
   114d3: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   114d8: 5b                           	popq	%rbx
   114d9: c3                           	retq
   114da: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (map->inner_map_fd != -1) {
   114e0: 83 7f 2c ff                  	cmpl	$-1, 44(%rdi)
   114e4: 48 89 fb                     	movq	%rdi, %rbx
   114e7: 75 32                        	jne	0x1151b <bpf_map__set_inner_map_fd+0x7b>
; 	if (map->inner_map) {
   114e9: 48 8b 7f 70                  	movq	112(%rdi), %rdi
   114ed: 48 85 ff                     	testq	%rdi, %rdi
   114f0: 74 1e                        	je	0x11510 <bpf_map__set_inner_map_fd+0x70>
   114f2: 89 74 24 0c                  	movl	%esi, 12(%rsp)
; 		bpf_map__destroy(map->inner_map);
   114f6: e8 d5 65 ff ff               	callq	0x7ad0 <bpf_map__destroy>
; 		zfree(&map->inner_map);
   114fb: 48 8b 7b 70                  	movq	112(%rbx), %rdi
   114ff: e8 bc 41 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   11504: 48 c7 43 70 00 00 00 00      	movq	$0, 112(%rbx)
   1150c: 8b 74 24 0c                  	movl	12(%rsp), %esi
; 	map->inner_map_fd = fd;
   11510: 89 73 2c                     	movl	%esi, 44(%rbx)
; }
   11513: 48 83 c4 10                  	addq	$16, %rsp
; 	return 0;
   11517: 31 c0                        	xorl	%eax, %eax
; }
   11519: 5b                           	popq	%rbx
   1151a: c3                           	retq
; 		pr_warn("error: inner_map_fd already specified\n");
   1151b: 48 8d 35 46 41 02 00         	leaq	147782(%rip), %rsi      # 0x35668 <strs.2+0x27d8>
   11522: eb 97                        	jmp	0x114bb <bpf_map__set_inner_map_fd+0x1b>
   11524: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1152f: 90                           	nop

0000000000011530 <bpf_object__next_map>:
; {
   11530: f3 0f 1e fa                  	endbr64
; 	if (prev == NULL)
   11534: 48 85 f6                     	testq	%rsi, %rsi
   11537: 74 67                        	je	0x115a0 <bpf_object__next_map+0x70>
; {
   11539: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!obj || !obj->maps)
   1153d: 48 85 ff                     	testq	%rdi, %rdi
   11540: 0f 84 81 00 00 00            	je	0x115c7 <bpf_object__next_map+0x97>
   11546: 48 8b 57 68                  	movq	104(%rdi), %rdx
   1154a: 48 85 d2                     	testq	%rdx, %rdx
   1154d: 74 78                        	je	0x115c7 <bpf_object__next_map+0x97>
; 	e = obj->maps + obj->nr_maps;
   1154f: 48 8b 4f 70                  	movq	112(%rdi), %rcx
   11553: 48 8d 04 89                  	leaq	(%rcx,%rcx,4), %rax
   11557: 48 c1 e0 05                  	shlq	$5, %rax
   1155b: 48 01 d0                     	addq	%rdx, %rax
; 	if ((m < s) || (m >= e)) {
   1155e: 48 39 c6                     	cmpq	%rax, %rsi
   11561: 73 4d                        	jae	0x115b0 <bpf_object__next_map+0x80>
   11563: 48 39 d6                     	cmpq	%rdx, %rsi
   11566: 72 48                        	jb	0x115b0 <bpf_object__next_map+0x80>
; 	idx = (m - obj->maps) + i;
   11568: 48 bf cd cc cc cc cc cc cc cc	movabsq	$-3689348814741910323, %rdi # imm = 0xCCCCCCCCCCCCCCCD
   11572: 48 29 d6                     	subq	%rdx, %rsi
   11575: 48 89 f0                     	movq	%rsi, %rax
   11578: 48 c1 f8 05                  	sarq	$5, %rax
   1157c: 48 0f af c7                  	imulq	%rdi, %rax
; 	if (idx >= obj->nr_maps || idx < 0)
   11580: 48 83 c0 01                  	addq	$1, %rax
   11584: 78 22                        	js	0x115a8 <bpf_object__next_map+0x78>
   11586: 48 39 c1                     	cmpq	%rax, %rcx
   11589: 76 1d                        	jbe	0x115a8 <bpf_object__next_map+0x78>
; 	return &obj->maps[idx];
   1158b: 48 8d 84 32 a0 00 00 00      	leaq	160(%rdx,%rsi), %rax
; }
   11593: 48 83 c4 08                  	addq	$8, %rsp
   11597: c3                           	retq
   11598: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		return obj->maps;
   115a0: 48 8b 47 68                  	movq	104(%rdi), %rax
; }
   115a4: c3                           	retq
   115a5: 0f 1f 00                     	nopl	(%rax)
; 		return NULL;
   115a8: 31 c0                        	xorl	%eax, %eax
; }
   115aa: 48 83 c4 08                  	addq	$8, %rsp
   115ae: c3                           	retq
   115af: 90                           	nop
; 		pr_warn("error in %s: map handler doesn't belong to object\n",
   115b0: 48 8d 15 29 18 02 00         	leaq	137257(%rip), %rdx      # 0x32de0 <__func__.15>
   115b7: 48 8d 35 62 25 02 00         	leaq	140642(%rip), %rsi      # 0x33b20 <strs.2+0xc90>
   115be: 31 ff                        	xorl	%edi, %edi
   115c0: 31 c0                        	xorl	%eax, %eax
   115c2: e8 09 6b ff ff               	callq	0x80d0 <libbpf_print>
; 		return errno = EINVAL, NULL;
   115c7: e8 24 41 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   115cc: c7 00 16 00 00 00            	movl	$22, (%rax)
   115d2: 31 c0                        	xorl	%eax, %eax
; }
   115d4: 48 83 c4 08                  	addq	$8, %rsp
   115d8: c3                           	retq
   115d9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

00000000000115e0 <bpf_object__prev_map>:
; {
   115e0: f3 0f 1e fa                  	endbr64
; 	if (next == NULL) {
   115e4: 48 85 f6                     	testq	%rsi, %rsi
   115e7: 74 67                        	je	0x11650 <bpf_object__prev_map+0x70>
; {
   115e9: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!obj || !obj->maps)
   115ed: 48 85 ff                     	testq	%rdi, %rdi
   115f0: 0f 84 99 00 00 00            	je	0x1168f <bpf_object__prev_map+0xaf>
   115f6: 48 8b 57 68                  	movq	104(%rdi), %rdx
   115fa: 48 85 d2                     	testq	%rdx, %rdx
   115fd: 0f 84 8c 00 00 00            	je	0x1168f <bpf_object__prev_map+0xaf>
; 	e = obj->maps + obj->nr_maps;
   11603: 48 8b 4f 70                  	movq	112(%rdi), %rcx
   11607: 48 8d 04 89                  	leaq	(%rcx,%rcx,4), %rax
   1160b: 48 c1 e0 05                  	shlq	$5, %rax
   1160f: 48 01 d0                     	addq	%rdx, %rax
; 	if ((m < s) || (m >= e)) {
   11612: 48 39 c6                     	cmpq	%rax, %rsi
   11615: 73 61                        	jae	0x11678 <bpf_object__prev_map+0x98>
   11617: 48 39 d6                     	cmpq	%rdx, %rsi
   1161a: 72 5c                        	jb	0x11678 <bpf_object__prev_map+0x98>
; 	idx = (m - obj->maps) + i;
   1161c: 48 bf cd cc cc cc cc cc cc cc	movabsq	$-3689348814741910323, %rdi # imm = 0xCCCCCCCCCCCCCCCD
   11626: 48 29 d6                     	subq	%rdx, %rsi
   11629: 48 89 f0                     	movq	%rsi, %rax
   1162c: 48 c1 f8 05                  	sarq	$5, %rax
   11630: 48 0f af c7                  	imulq	%rdi, %rax
; 	if (idx >= obj->nr_maps || idx < 0)
   11634: 48 83 e8 01                  	subq	$1, %rax
   11638: 78 6e                        	js	0x116a8 <bpf_object__prev_map+0xc8>
   1163a: 48 39 c1                     	cmpq	%rax, %rcx
   1163d: 76 69                        	jbe	0x116a8 <bpf_object__prev_map+0xc8>
; 	return &obj->maps[idx];
   1163f: 48 8d 84 32 60 ff ff ff      	leaq	-160(%rdx,%rsi), %rax
; }
   11647: 48 83 c4 08                  	addq	$8, %rsp
   1164b: c3                           	retq
   1164c: 0f 1f 40 00                  	nopl	(%rax)
; 		if (!obj->nr_maps)
   11650: 48 8b 57 70                  	movq	112(%rdi), %rdx
; 			return NULL;
   11654: 31 c0                        	xorl	%eax, %eax
; 		if (!obj->nr_maps)
   11656: 48 85 d2                     	testq	%rdx, %rdx
   11659: 74 15                        	je	0x11670 <bpf_object__prev_map+0x90>
; 		return obj->maps + obj->nr_maps - 1;
   1165b: 48 8d 04 92                  	leaq	(%rdx,%rdx,4), %rax
   1165f: 48 8b 57 68                  	movq	104(%rdi), %rdx
   11663: 48 c1 e0 05                  	shlq	$5, %rax
   11667: 48 8d 84 02 60 ff ff ff      	leaq	-160(%rdx,%rax), %rax
   1166f: c3                           	retq
; }
   11670: c3                           	retq
   11671: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("error in %s: map handler doesn't belong to object\n",
   11678: 48 8d 15 61 17 02 00         	leaq	137057(%rip), %rdx      # 0x32de0 <__func__.15>
   1167f: 48 8d 35 9a 24 02 00         	leaq	140442(%rip), %rsi      # 0x33b20 <strs.2+0xc90>
   11686: 31 ff                        	xorl	%edi, %edi
   11688: 31 c0                        	xorl	%eax, %eax
   1168a: e8 41 6a ff ff               	callq	0x80d0 <libbpf_print>
; 		return errno = EINVAL, NULL;
   1168f: e8 5c 40 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   11694: c7 00 16 00 00 00            	movl	$22, (%rax)
   1169a: 31 c0                        	xorl	%eax, %eax
; }
   1169c: 48 83 c4 08                  	addq	$8, %rsp
   116a0: c3                           	retq
   116a1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			return NULL;
   116a8: 31 c0                        	xorl	%eax, %eax
; }
   116aa: 48 83 c4 08                  	addq	$8, %rsp
   116ae: c3                           	retq
   116af: 90                           	nop

00000000000116b0 <bpf_object__find_map_by_name>:
; {
   116b0: f3 0f 1e fa                  	endbr64
   116b4: 41 57                        	pushq	%r15
   116b6: 4c 8d 3d 3c 09 02 00         	leaq	133436(%rip), %r15      # 0x31ff9 <_IO_stdin_used+0x1ff9>
   116bd: 41 56                        	pushq	%r14
   116bf: 4c 8d 35 2d 09 02 00         	leaq	133421(%rip), %r14      # 0x31ff3 <_IO_stdin_used+0x1ff3>
   116c6: 41 55                        	pushq	%r13
   116c8: 49 89 fd                     	movq	%rdi, %r13
   116cb: 41 54                        	pushq	%r12
   116cd: 55                           	pushq	%rbp
   116ce: 53                           	pushq	%rbx
   116cf: 48 89 f3                     	movq	%rsi, %rbx
   116d2: 48 83 ec 08                  	subq	$8, %rsp
; 		return obj->maps;
   116d6: 48 8b 6f 68                  	movq	104(%rdi), %rbp
; 	bpf_object__for_each_map(pos, obj) {
   116da: 48 85 ed                     	testq	%rbp, %rbp
   116dd: 74 42                        	je	0x11721 <bpf_object__find_map_by_name+0x71>
; 		if (name[0] == '.') {
   116df: 80 3b 2e                     	cmpb	$46, (%rbx)
; 			if (pos->real_name && strcmp(pos->real_name, name) == 0)
   116e2: 4c 8b 65 10                  	movq	16(%rbp), %r12
; 		if (name[0] == '.') {
   116e6: 74 58                        	je	0x11740 <bpf_object__find_map_by_name+0x90>
; 		if (map_uses_real_name(pos)) {
   116e8: 8b 45 58                     	movl	88(%rbp), %eax
; 	if (map->libbpf_type == LIBBPF_MAP_DATA && strcmp(map->real_name, DATA_SEC) != 0)
   116eb: 83 f8 01                     	cmpl	$1, %eax
   116ee: 74 70                        	je	0x11760 <bpf_object__find_map_by_name+0xb0>
; 	if (map->libbpf_type == LIBBPF_MAP_RODATA && strcmp(map->real_name, RODATA_SEC) != 0)
   116f0: 83 f8 03                     	cmpl	$3, %eax
   116f3: 0f 84 7f 00 00 00            	je	0x11778 <bpf_object__find_map_by_name+0xc8>
; 		if (strcmp(pos->name, name) == 0)
   116f9: 48 8b 7d 08                  	movq	8(%rbp), %rdi
   116fd: 48 89 de                     	movq	%rbx, %rsi
   11700: e8 ab 42 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   11705: 85 c0                        	testl	%eax, %eax
   11707: 74 25                        	je	0x1172e <bpf_object__find_map_by_name+0x7e>
; 	return __bpf_map__iter(prev, obj, 1);
   11709: 48 89 ef                     	movq	%rbp, %rdi
   1170c: ba 01 00 00 00               	movl	$1, %edx
   11711: 4c 89 ee                     	movq	%r13, %rsi
   11714: e8 d7 86 ff ff               	callq	0x9df0 <__bpf_map__iter>
   11719: 48 89 c5                     	movq	%rax, %rbp
; 	bpf_object__for_each_map(pos, obj) {
   1171c: 48 85 c0                     	testq	%rax, %rax
   1171f: 75 be                        	jne	0x116df <bpf_object__find_map_by_name+0x2f>
; 	return errno = ENOENT, NULL;
   11721: e8 ca 3f ff ff               	callq	0x56f0 <.plt.sec+0x80>
   11726: 31 ed                        	xorl	%ebp, %ebp
   11728: c7 00 02 00 00 00            	movl	$2, (%rax)
; }
   1172e: 48 83 c4 08                  	addq	$8, %rsp
   11732: 48 89 e8                     	movq	%rbp, %rax
   11735: 5b                           	popq	%rbx
   11736: 5d                           	popq	%rbp
   11737: 41 5c                        	popq	%r12
   11739: 41 5d                        	popq	%r13
   1173b: 41 5e                        	popq	%r14
   1173d: 41 5f                        	popq	%r15
   1173f: c3                           	retq
; 			if (pos->real_name && strcmp(pos->real_name, name) == 0)
   11740: 4d 85 e4                     	testq	%r12, %r12
   11743: 74 c4                        	je	0x11709 <bpf_object__find_map_by_name+0x59>
; 			if (strcmp(pos->real_name, name) == 0)
   11745: 48 89 de                     	movq	%rbx, %rsi
   11748: 4c 89 e7                     	movq	%r12, %rdi
   1174b: e8 60 42 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   11750: 85 c0                        	testl	%eax, %eax
   11752: 74 da                        	je	0x1172e <bpf_object__find_map_by_name+0x7e>
   11754: eb b3                        	jmp	0x11709 <bpf_object__find_map_by_name+0x59>
   11756: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	if (map->libbpf_type == LIBBPF_MAP_DATA && strcmp(map->real_name, DATA_SEC) != 0)
   11760: 4c 89 f6                     	movq	%r14, %rsi
   11763: 4c 89 e7                     	movq	%r12, %rdi
   11766: e8 45 42 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   1176b: 85 c0                        	testl	%eax, %eax
   1176d: 74 8a                        	je	0x116f9 <bpf_object__find_map_by_name+0x49>
   1176f: eb d4                        	jmp	0x11745 <bpf_object__find_map_by_name+0x95>
   11771: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	if (map->libbpf_type == LIBBPF_MAP_RODATA && strcmp(map->real_name, RODATA_SEC) != 0)
   11778: 4c 89 fe                     	movq	%r15, %rsi
   1177b: 4c 89 e7                     	movq	%r12, %rdi
   1177e: e8 2d 42 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   11783: 85 c0                        	testl	%eax, %eax
   11785: 0f 84 6e ff ff ff            	je	0x116f9 <bpf_object__find_map_by_name+0x49>
   1178b: eb b8                        	jmp	0x11745 <bpf_object__find_map_by_name+0x95>
   1178d: 0f 1f 00                     	nopl	(%rax)

0000000000011790 <bpf_object_open.part.0>:
; static struct bpf_object *bpf_object_open(const char *path, const void *obj_buf, size_t obj_buf_sz,
   11790: 41 57                        	pushq	%r15
   11792: 49 89 f8                     	movq	%rdi, %r8
   11795: 41 56                        	pushq	%r14
   11797: 49 89 ce                     	movq	%rcx, %r14
   1179a: 41 55                        	pushq	%r13
   1179c: 41 54                        	pushq	%r12
   1179e: 49 89 f4                     	movq	%rsi, %r12
   117a1: 55                           	pushq	%rbp
   117a2: 53                           	pushq	%rbx
   117a3: 48 89 d3                     	movq	%rdx, %rbx
   117a6: 48 81 ec f8 00 00 00         	subq	$248, %rsp
   117ad: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   117b6: 48 89 84 24 e8 00 00 00      	movq	%rax, 232(%rsp)
   117be: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_object_open_opts))
   117c0: 48 85 c9                     	testq	%rcx, %rcx
   117c3: 0f 84 87 01 00 00            	je	0x11950 <bpf_object_open.part.0+0x1c0>
   117c9: 48 8b 09                     	movq	(%rcx), %rcx
; 	if (user_sz < sizeof(size_t)) {
   117cc: 48 83 f9 07                  	cmpq	$7, %rcx
   117d0: 0f 86 52 03 00 00            	jbe	0x11b28 <bpf_object_open.part.0+0x398>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   117d6: 48 8d 51 bc                  	leaq	-68(%rcx), %rdx
   117da: 49 8d 46 44                  	leaq	68(%r14), %rax
; 	while (len > 0) {
   117de: 48 85 d2                     	testq	%rdx, %rdx
   117e1: 7e 45                        	jle	0x11828 <bpf_object_open.part.0+0x98>
   117e3: 49 8d 14 0e                  	leaq	(%r14,%rcx), %rdx
   117e7: eb 10                        	jmp	0x117f9 <bpf_object_open.part.0+0x69>
   117e9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		p++;
   117f0: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   117f4: 48 39 d0                     	cmpq	%rdx, %rax
   117f7: 74 2f                        	je	0x11828 <bpf_object_open.part.0+0x98>
; 		if (*p)
   117f9: 80 38 00                     	cmpb	$0, (%rax)
   117fc: 74 f2                        	je	0x117f0 <bpf_object_open.part.0+0x60>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   117fe: 48 8d 15 7b 08 02 00         	leaq	133243(%rip), %rdx      # 0x32080 <_IO_stdin_used+0x2080>
   11805: 48 8d 35 04 28 02 00         	leaq	141316(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   1180c: 31 ff                        	xorl	%edi, %edi
   1180e: 31 c0                        	xorl	%eax, %eax
   11810: e8 bb 68 ff ff               	callq	0x80d0 <libbpf_print>
; 		return ERR_PTR(-EINVAL);
   11815: 49 c7 c7 ea ff ff ff         	movq	$-22, %r15
   1181c: e9 f9 00 00 00               	jmp	0x1191a <bpf_object_open.part.0+0x18a>
   11821: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	obj_name = OPTS_GET(opts, object_name, NULL);
   11828: 48 83 f9 0f                  	cmpq	$15, %rcx
   1182c: 76 52                        	jbe	0x11880 <bpf_object_open.part.0+0xf0>
   1182e: 4d 8b 6e 08                  	movq	8(%r14), %r13
; 	if (obj_buf) {
   11832: 4d 85 e4                     	testq	%r12, %r12
   11835: 0f 84 9c 00 00 00            	je	0x118d7 <bpf_object_open.part.0+0x147>
; 		if (!obj_name) {
   1183b: 4d 85 ed                     	testq	%r13, %r13
   1183e: 74 49                        	je	0x11889 <bpf_object_open.part.0+0xf9>
; 		pr_debug("loading object '%s' from buffer\n", obj_name);
   11840: 4c 89 ea                     	movq	%r13, %rdx
   11843: 48 8d 35 96 53 02 00         	leaq	152470(%rip), %rsi      # 0x36be0 <strs.2+0x3d50>
   1184a: bf 02 00 00 00               	movl	$2, %edi
   1184f: 31 c0                        	xorl	%eax, %eax
   11851: e8 7a 68 ff ff               	callq	0x80d0 <libbpf_print>
; 	log_buf = OPTS_GET(opts, kernel_log_buf, NULL);
   11856: 49 8b 0e                     	movq	(%r14), %rcx
   11859: 4d 89 e8                     	movq	%r13, %r8
   1185c: 48 83 f9 37                  	cmpq	$55, %rcx
   11860: 77 7b                        	ja	0x118dd <bpf_object_open.part.0+0x14d>
   11862: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 	log_size = OPTS_GET(opts, kernel_log_size, 0);
   1186b: 31 ed                        	xorl	%ebp, %ebp
; 	log_level = OPTS_GET(opts, kernel_log_level, 0);
   1186d: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
   11875: e9 3c 01 00 00               	jmp	0x119b6 <bpf_object_open.part.0+0x226>
   1187a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (obj_buf) {
   11880: 4d 85 e4                     	testq	%r12, %r12
   11883: 0f 84 c7 02 00 00            	je	0x11b50 <bpf_object_open.part.0+0x3c0>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   11889: b9 40 00 00 00               	movl	$64, %ecx
   1188e: 4d 89 e1                     	movq	%r12, %r9
   11891: ba 01 00 00 00               	movl	$1, %edx
   11896: 31 c0                        	xorl	%eax, %eax
   11898: 4c 8d ac 24 a0 00 00 00      	leaq	160(%rsp), %r13
   118a0: 48 83 ec 08                  	subq	$8, %rsp
   118a4: be 40 00 00 00               	movl	$64, %esi
   118a9: 53                           	pushq	%rbx
   118aa: 4c 8d 05 83 08 02 00         	leaq	133251(%rip), %r8       # 0x32134 <_IO_stdin_used+0x2134>
   118b1: 4c 89 ef                     	movq	%r13, %rdi
   118b4: e8 f7 3d ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 		pr_debug("loading object '%s' from buffer\n", obj_name);
   118b9: 4c 89 ea                     	movq	%r13, %rdx
   118bc: 31 c0                        	xorl	%eax, %eax
   118be: bf 02 00 00 00               	movl	$2, %edi
   118c3: 48 8d 35 16 53 02 00         	leaq	152342(%rip), %rsi      # 0x36be0 <strs.2+0x3d50>
   118ca: e8 01 68 ff ff               	callq	0x80d0 <libbpf_print>
; 	log_buf = OPTS_GET(opts, kernel_log_buf, NULL);
   118cf: 49 8b 0e                     	movq	(%r14), %rcx
   118d2: 58                           	popq	%rax
; 			obj_name = tmp_name;
   118d3: 4d 89 e8                     	movq	%r13, %r8
; 	log_buf = OPTS_GET(opts, kernel_log_buf, NULL);
   118d6: 5a                           	popq	%rdx
   118d7: 48 83 f9 37                  	cmpq	$55, %rcx
   118db: 76 85                        	jbe	0x11862 <bpf_object_open.part.0+0xd2>
   118dd: 49 8b 46 30                  	movq	48(%r14), %rax
   118e1: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	log_size = OPTS_GET(opts, kernel_log_size, 0);
   118e6: 48 83 f9 3f                  	cmpq	$63, %rcx
   118ea: 0f 86 bc 00 00 00            	jbe	0x119ac <bpf_object_open.part.0+0x21c>
; 	log_level = OPTS_GET(opts, kernel_log_level, 0);
   118f0: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	log_size = OPTS_GET(opts, kernel_log_size, 0);
   118f8: 49 8b 6e 38                  	movq	56(%r14), %rbp
; 	log_level = OPTS_GET(opts, kernel_log_level, 0);
   118fc: 48 83 f9 43                  	cmpq	$67, %rcx
   11900: 0f 87 12 02 00 00            	ja	0x11b18 <bpf_object_open.part.0+0x388>
; 	if (log_size > UINT_MAX)
   11906: 48 89 e8                     	movq	%rbp, %rax
; 		return ERR_PTR(-EINVAL);
   11909: 49 c7 c7 ea ff ff ff         	movq	$-22, %r15
; 	if (log_size > UINT_MAX)
   11910: 48 c1 e8 20                  	shrq	$32, %rax
   11914: 0f 84 ee 02 00 00            	je	0x11c08 <bpf_object_open.part.0+0x478>
; }
   1191a: 48 8b 84 24 e8 00 00 00      	movq	232(%rsp), %rax
   11922: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1192b: 0f 85 4f 32 00 00            	jne	0x14b80 <bpf_object_open.part.0+0x33f0>
   11931: 48 81 c4 f8 00 00 00         	addq	$248, %rsp
   11938: 4c 89 f8                     	movq	%r15, %rax
   1193b: 5b                           	popq	%rbx
   1193c: 5d                           	popq	%rbp
   1193d: 41 5c                        	popq	%r12
   1193f: 41 5d                        	popq	%r13
   11941: 41 5e                        	popq	%r14
   11943: 41 5f                        	popq	%r15
   11945: c3                           	retq
   11946: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	obj_name = OPTS_GET(opts, object_name, NULL);
   11950: 45 31 ed                     	xorl	%r13d, %r13d
; 	if (obj_buf) {
   11953: 48 85 f6                     	testq	%rsi, %rsi
   11956: 74 4b                        	je	0x119a3 <bpf_object_open.part.0+0x213>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   11958: 4c 8d ac 24 a0 00 00 00      	leaq	160(%rsp), %r13
   11960: 48 83 ec 08                  	subq	$8, %rsp
   11964: 49 89 f1                     	movq	%rsi, %r9
   11967: 31 c0                        	xorl	%eax, %eax
   11969: 52                           	pushq	%rdx
   1196a: 4c 8d 05 c3 07 02 00         	leaq	133059(%rip), %r8       # 0x32134 <_IO_stdin_used+0x2134>
   11971: b9 40 00 00 00               	movl	$64, %ecx
   11976: 4c 89 ef                     	movq	%r13, %rdi
   11979: ba 01 00 00 00               	movl	$1, %edx
   1197e: be 40 00 00 00               	movl	$64, %esi
   11983: e8 28 3d ff ff               	callq	0x56b0 <.plt.sec+0x40>
; 		pr_debug("loading object '%s' from buffer\n", obj_name);
   11988: 4c 89 ea                     	movq	%r13, %rdx
   1198b: bf 02 00 00 00               	movl	$2, %edi
   11990: 31 c0                        	xorl	%eax, %eax
   11992: 48 8d 35 47 52 02 00         	leaq	152135(%rip), %rsi      # 0x36be0 <strs.2+0x3d50>
   11999: e8 32 67 ff ff               	callq	0x80d0 <libbpf_print>
   1199e: 59                           	popq	%rcx
; 			obj_name = tmp_name;
   1199f: 4d 89 e8                     	movq	%r13, %r8
; 		pr_debug("loading object '%s' from buffer\n", obj_name);
   119a2: 5e                           	popq	%rsi
; 	log_level = OPTS_GET(opts, kernel_log_level, 0);
   119a3: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
   119ac: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
   119b4: 31 ed                        	xorl	%ebp, %ebp
; 	obj = calloc(1, sizeof(struct bpf_object) + strlen(path) + 1);
   119b6: 4c 89 c7                     	movq	%r8, %rdi
   119b9: 4c 89 44 24 20               	movq	%r8, 32(%rsp)
   119be: e8 1d 3e ff ff               	callq	0x57e0 <.plt.sec+0x170>
   119c3: bf 01 00 00 00               	movl	$1, %edi
   119c8: 48 8d b0 91 01 00 00         	leaq	401(%rax), %rsi
   119cf: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   119d4: e8 b7 3f ff ff               	callq	0x5990 <.plt.sec+0x320>
; 	if (!obj) {
   119d9: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   119de: 4c 8b 44 24 20               	movq	32(%rsp), %r8
   119e3: 48 85 c0                     	testq	%rax, %rax
; 	obj = calloc(1, sizeof(struct bpf_object) + strlen(path) + 1);
   119e6: 49 89 c7                     	movq	%rax, %r15
; 	if (!obj) {
   119e9: 0f 84 b4 32 00 00            	je	0x14ca3 <bpf_object_open.part.0+0x3513>
; 	strcpy(obj->path, path);
   119ef: 48 8d b8 90 01 00 00         	leaq	400(%rax), %rdi
;   return __builtin___strcpy_chk (__dest, __src, __glibc_objsize (__dest));
   119f6: 48 83 c2 01                  	addq	$1, %rdx
   119fa: 4c 89 c6                     	movq	%r8, %rsi
   119fd: 4c 89 44 24 18               	movq	%r8, 24(%rsp)
; 	strcpy(obj->path, path);
   11a02: 48 89 7c 24 30               	movq	%rdi, 48(%rsp)
;   return __builtin___strcpy_chk (__dest, __src, __glibc_objsize (__dest));
   11a07: e8 34 40 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	for (i = 0; i < sz && src[i]; i++)
   11a0c: 31 c0                        	xorl	%eax, %eax
; 	if (obj_name) {
   11a0e: 4d 85 ed                     	testq	%r13, %r13
   11a11: 4c 8b 44 24 18               	movq	24(%rsp), %r8
   11a16: 0f 84 4c 01 00 00            	je	0x11b68 <bpf_object_open.part.0+0x3d8>
   11a1c: 0f 1f 40 00                  	nopl	(%rax)
; 	for (i = 0; i < sz && src[i]; i++)
   11a20: 41 0f b6 54 05 00            	movzbl	(%r13,%rax), %edx
   11a26: 84 d2                        	testb	%dl, %dl
   11a28: 74 0e                        	je	0x11a38 <bpf_object_open.part.0+0x2a8>
; 		dst[i] = src[i];
   11a2a: 41 88 14 07                  	movb	%dl, (%r15,%rax)
; 	for (i = 0; i < sz && src[i]; i++)
   11a2e: 48 83 c0 01                  	addq	$1, %rax
   11a32: 48 83 f8 0f                  	cmpq	$15, %rax
   11a36: 75 e8                        	jne	0x11a20 <bpf_object_open.part.0+0x290>
; 	dst[i] = '\0';
   11a38: 41 c6 04 07 00               	movb	$0, (%r15,%rax)
; 	obj->efile.fd = -1;
   11a3d: 41 c7 87 a8 00 00 00 ff ff ff ff     	movl	$4294967295, 168(%r15) # imm = 0xFFFFFFFF
; 	obj->efile.obj_buf = obj_buf;
   11a48: 4d 89 a7 b0 00 00 00         	movq	%r12, 176(%r15)
; 	obj->efile.obj_buf_sz = obj_buf_sz;
   11a4f: 49 89 9f b8 00 00 00         	movq	%rbx, 184(%r15)
; 	obj->efile.btf_maps_shndx = -1;
   11a56: 41 c7 87 fc 00 00 00 ff ff ff ff     	movl	$4294967295, 252(%r15) # imm = 0xFFFFFFFF
; 	obj->efile.st_ops_shndx = -1;
   11a61: 41 c7 87 0c 01 00 00 ff ff ff ff     	movl	$4294967295, 268(%r15) # imm = 0xFFFFFFFF
; 	obj->kconfig_map_idx = -1;
   11a6c: 41 c7 87 94 00 00 00 ff ff ff ff     	movl	$4294967295, 148(%r15) # imm = 0xFFFFFFFF
; 	obj->kern_version = get_kernel_version();
   11a77: e8 b4 99 ff ff               	callq	0xb430 <get_kernel_version>
; 	obj->loaded = false;
   11a7c: 41 c6 87 98 00 00 00 00      	movb	$0, 152(%r15)
; 	obj->kern_version = get_kernel_version();
   11a84: 41 89 47 50                  	movl	%eax, 80(%r15)
; 	if (IS_ERR(obj))
   11a88: 49 81 ff 00 f0 ff ff         	cmpq	$-4096, %r15            # imm = 0xF000
   11a8f: 0f 87 85 fe ff ff            	ja	0x1191a <bpf_object_open.part.0+0x18a>
; 	obj->log_buf = log_buf;
   11a95: 48 8b 44 24 10               	movq	16(%rsp), %rax
; 	obj->log_size = log_size;
   11a9a: 49 89 af 60 01 00 00         	movq	%rbp, 352(%r15)
; 	obj->log_buf = log_buf;
   11aa1: 49 89 87 58 01 00 00         	movq	%rax, 344(%r15)
; 	obj->log_level = log_level;
   11aa8: 8b 44 24 08                  	movl	8(%rsp), %eax
   11aac: 41 89 87 68 01 00 00         	movl	%eax, 360(%r15)
; 	btf_tmp_path = OPTS_GET(opts, btf_custom_path, NULL);
   11ab3: 4d 85 f6                     	testq	%r14, %r14
   11ab6: 0f 84 24 01 00 00            	je	0x11be0 <bpf_object_open.part.0+0x450>
   11abc: 49 8b 06                     	movq	(%r14), %rax
   11abf: 48 83 f8 2f                  	cmpq	$47, %rax
   11ac3: 0f 86 ef 00 00 00            	jbe	0x11bb8 <bpf_object_open.part.0+0x428>
   11ac9: 49 8b 6e 28                  	movq	40(%r14), %rbp
; 	if (btf_tmp_path) {
   11acd: 48 85 ed                     	testq	%rbp, %rbp
   11ad0: 0f 84 e8 00 00 00            	je	0x11bbe <bpf_object_open.part.0+0x42e>
; 		if (strlen(btf_tmp_path) >= PATH_MAX) {
   11ad6: 48 89 ef                     	movq	%rbp, %rdi
   11ad9: 48 c7 c3 dc ff ff ff         	movq	$-36, %rbx
   11ae0: e8 fb 3c ff ff               	callq	0x57e0 <.plt.sec+0x170>
   11ae5: 48 3d ff 0f 00 00            	cmpq	$4095, %rax             # imm = 0xFFF
   11aeb: 0f 87 07 01 00 00            	ja	0x11bf8 <bpf_object_open.part.0+0x468>
; 		obj->btf_custom_path = strdup(btf_tmp_path);
   11af1: 48 89 ef                     	movq	%rbp, %rdi
   11af4: e8 17 41 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   11af9: 49 89 87 28 01 00 00         	movq	%rax, 296(%r15)
; 		if (!obj->btf_custom_path) {
   11b00: 48 85 c0                     	testq	%rax, %rax
   11b03: 0f 85 b5 00 00 00            	jne	0x11bbe <bpf_object_open.part.0+0x42e>
; 			pr_warn("sec '%s': failed to alloc memory for new program '%s'\n",
   11b09: 48 c7 c3 f4 ff ff ff         	movq	$-12, %rbx
   11b10: e9 e3 00 00 00               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   11b15: 0f 1f 00                     	nopl	(%rax)
; 	log_level = OPTS_GET(opts, kernel_log_level, 0);
   11b18: 41 8b 46 40                  	movl	64(%r14), %eax
   11b1c: 89 44 24 08                  	movl	%eax, 8(%rsp)
   11b20: e9 e1 fd ff ff               	jmp	0x11906 <bpf_object_open.part.0+0x176>
   11b25: 0f 1f 00                     	nopl	(%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   11b28: 48 8d 15 51 05 02 00         	leaq	132433(%rip), %rdx      # 0x32080 <_IO_stdin_used+0x2080>
   11b2f: 48 8d 35 82 24 02 00         	leaq	140418(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   11b36: 31 ff                        	xorl	%edi, %edi
; 		return ERR_PTR(-EINVAL);
   11b38: 49 c7 c7 ea ff ff ff         	movq	$-22, %r15
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   11b3f: e8 8c 65 ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   11b44: e9 d1 fd ff ff               	jmp	0x1191a <bpf_object_open.part.0+0x18a>
   11b49: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	log_buf = OPTS_GET(opts, kernel_log_buf, NULL);
   11b50: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 	obj_name = OPTS_GET(opts, object_name, NULL);
   11b59: 45 31 ed                     	xorl	%r13d, %r13d
   11b5c: e9 85 fd ff ff               	jmp	0x118e6 <bpf_object_open.part.0+0x156>
   11b61: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		libbpf_strlcpy(obj->name, basename((void *)path), sizeof(obj->name));
   11b68: 4c 89 c7                     	movq	%r8, %rdi
   11b6b: e8 e0 3e ff ff               	callq	0x5a50 <.plt.sec+0x3e0>
; 	for (i = 0; i < sz && src[i]; i++)
   11b70: 31 d2                        	xorl	%edx, %edx
   11b72: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   11b78: 0f b6 0c 10                  	movzbl	(%rax,%rdx), %ecx
   11b7c: 84 c9                        	testb	%cl, %cl
   11b7e: 74 0e                        	je	0x11b8e <bpf_object_open.part.0+0x3fe>
; 		dst[i] = src[i];
   11b80: 41 88 0c 17                  	movb	%cl, (%r15,%rdx)
; 	for (i = 0; i < sz && src[i]; i++)
   11b84: 48 83 c2 01                  	addq	$1, %rdx
   11b88: 48 83 fa 0f                  	cmpq	$15, %rdx
   11b8c: 75 ea                        	jne	0x11b78 <bpf_object_open.part.0+0x3e8>
; 	dst[i] = '\0';
   11b8e: 41 c6 04 17 00               	movb	$0, (%r15,%rdx)
; 		end = strchr(obj->name, '.');
   11b93: be 2e 00 00 00               	movl	$46, %esi
   11b98: 4c 89 ff                     	movq	%r15, %rdi
   11b9b: e8 80 3c ff ff               	callq	0x5820 <.plt.sec+0x1b0>
; 		if (end)
   11ba0: 48 85 c0                     	testq	%rax, %rax
   11ba3: 0f 84 94 fe ff ff            	je	0x11a3d <bpf_object_open.part.0+0x2ad>
; 			*end = 0;
   11ba9: c6 00 00                     	movb	$0, (%rax)
   11bac: e9 8c fe ff ff               	jmp	0x11a3d <bpf_object_open.part.0+0x2ad>
   11bb1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	kconfig = OPTS_GET(opts, kconfig, NULL);
   11bb8: 48 83 f8 27                  	cmpq	$39, %rax
   11bbc: 76 22                        	jbe	0x11be0 <bpf_object_open.part.0+0x450>
   11bbe: 49 8b 7e 20                  	movq	32(%r14), %rdi
; 	if (kconfig) {
   11bc2: 48 85 ff                     	testq	%rdi, %rdi
   11bc5: 74 19                        	je	0x11be0 <bpf_object_open.part.0+0x450>
; 		obj->kconfig = strdup(kconfig);
   11bc7: e8 44 40 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   11bcc: 49 89 87 80 00 00 00         	movq	%rax, 128(%r15)
; 		if (!obj->kconfig) {
   11bd3: 48 85 c0                     	testq	%rax, %rax
   11bd6: 0f 84 2d ff ff ff            	je	0x11b09 <bpf_object_open.part.0+0x379>
   11bdc: 0f 1f 40 00                  	nopl	(%rax)
; 	err = bpf_object__elf_init(obj);
   11be0: 4c 89 ff                     	movq	%r15, %rdi
   11be3: e8 78 6f ff ff               	callq	0x8b60 <bpf_object__elf_init>
   11be8: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	return ERR_PTR(err);
   11bec: 48 63 d8                     	movslq	%eax, %rbx
; 	err = err ? : bpf_object__check_endianness(obj);
   11bef: 85 c0                        	testl	%eax, %eax
   11bf1: 74 35                        	je	0x11c28 <bpf_object_open.part.0+0x498>
   11bf3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	if (IS_ERR_OR_NULL(obj))
   11bf8: 4c 89 ff                     	movq	%r15, %rdi
; 	return ERR_PTR(err);
   11bfb: 49 89 df                     	movq	%rbx, %r15
   11bfe: e8 4d 62 ff ff               	callq	0x7e50 <bpf_object__close.part.0>
   11c03: e9 12 fd ff ff               	jmp	0x1191a <bpf_object_open.part.0+0x18a>
; 	if (log_size && !log_buf)
   11c08: 48 85 ed                     	testq	%rbp, %rbp
   11c0b: 0f 84 a5 fd ff ff            	je	0x119b6 <bpf_object_open.part.0+0x226>
   11c11: 48 83 7c 24 10 00            	cmpq	$0, 16(%rsp)
   11c17: 0f 84 fd fc ff ff            	je	0x1191a <bpf_object_open.part.0+0x18a>
   11c1d: e9 94 fd ff ff               	jmp	0x119b6 <bpf_object_open.part.0+0x226>
   11c22: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (obj->efile.ehdr->e_ident[EI_DATA] == ELFDATA2LSB)
   11c28: 49 8b 87 c8 00 00 00         	movq	200(%r15), %rax
   11c2f: 80 78 05 01                  	cmpb	$1, 5(%rax)
   11c33: 0f 85 af 00 00 00            	jne	0x11ce8 <bpf_object_open.part.0+0x558>
; 	obj->efile.sec_cnt = obj->efile.ehdr->e_shnum;
   11c39: 0f b7 50 3c                  	movzwl	60(%rax), %edx
; 	obj->efile.secs = calloc(obj->efile.sec_cnt, sizeof(*obj->efile.secs));
   11c3d: be 18 00 00 00               	movl	$24, %esi
; 	Elf *elf = obj->efile.elf;
   11c42: 4d 8b af c0 00 00 00         	movq	192(%r15), %r13
; 	obj->efile.sec_cnt = obj->efile.ehdr->e_shnum;
   11c49: 41 89 97 f8 00 00 00         	movl	%edx, 248(%r15)
; 	obj->efile.secs = calloc(obj->efile.sec_cnt, sizeof(*obj->efile.secs));
   11c50: 0f b7 fa                     	movzwl	%dx, %edi
   11c53: e8 38 3d ff ff               	callq	0x5990 <.plt.sec+0x320>
   11c58: 49 89 87 f0 00 00 00         	movq	%rax, 240(%r15)
; 	if (!obj->efile.secs)
   11c5f: 48 85 c0                     	testq	%rax, %rax
   11c62: 0f 84 a1 fe ff ff            	je	0x11b09 <bpf_object_open.part.0+0x379>
; 	scn = NULL;
   11c68: 31 ed                        	xorl	%ebp, %ebp
   11c6a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	while ((scn = elf_nextscn(elf, scn)) != NULL) {
   11c70: 48 89 ee                     	movq	%rbp, %rsi
   11c73: 4c 89 ef                     	movq	%r13, %rdi
   11c76: e8 15 3f ff ff               	callq	0x5b90 <.plt.sec+0x520>
   11c7b: 48 89 c5                     	movq	%rax, %rbp
   11c7e: 48 85 c0                     	testq	%rax, %rax
   11c81: 0f 84 d3 00 00 00            	je	0x11d5a <bpf_object_open.part.0+0x5ca>
; 	shdr = elf64_getshdr(scn);
   11c87: 48 89 ef                     	movq	%rbp, %rdi
   11c8a: e8 91 3c ff ff               	callq	0x5920 <.plt.sec+0x2b0>
   11c8f: 48 89 c3                     	movq	%rax, %rbx
; 	if (!shdr) {
   11c92: 48 85 c0                     	testq	%rax, %rax
   11c95: 74 78                        	je	0x11d0f <bpf_object_open.part.0+0x57f>
; 		if (sh->sh_type == SHT_SYMTAB) {
   11c97: 83 78 04 02                  	cmpl	$2, 4(%rax)
   11c9b: 75 d3                        	jne	0x11c70 <bpf_object_open.part.0+0x4e0>
; 			if (obj->efile.symbols) {
   11c9d: 49 83 bf d0 00 00 00 00      	cmpq	$0, 208(%r15)
   11ca5: 0f 85 75 04 00 00            	jne	0x12120 <bpf_object_open.part.0+0x990>
; 			data = elf_sec_data(obj, scn);
   11cab: 48 89 ee                     	movq	%rbp, %rsi
   11cae: 4c 89 ff                     	movq	%r15, %rdi
   11cb1: e8 fa 92 ff ff               	callq	0xafb0 <elf_sec_data>
   11cb6: 49 89 c4                     	movq	%rax, %r12
; 			if (!data)
   11cb9: 48 85 c0                     	testq	%rax, %rax
   11cbc: 0f 84 8c 00 00 00            	je	0x11d4e <bpf_object_open.part.0+0x5be>
; 			idx = elf_ndxscn(scn);
   11cc2: 48 89 ef                     	movq	%rbp, %rdi
   11cc5: e8 16 3f ff ff               	callq	0x5be0 <.plt.sec+0x570>
; 			obj->efile.symbols = data;
   11cca: 4d 89 a7 d0 00 00 00         	movq	%r12, 208(%r15)
; 			idx = elf_ndxscn(scn);
   11cd1: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 			obj->efile.symbols_shndx = idx;
   11cd5: 41 89 87 08 01 00 00         	movl	%eax, 264(%r15)
; 			obj->efile.strtabidx = sh->sh_link;
   11cdc: 8b 43 28                     	movl	40(%rbx), %eax
   11cdf: 49 89 87 e8 00 00 00         	movq	%rax, 232(%r15)
   11ce6: eb 88                        	jmp	0x11c70 <bpf_object_open.part.0+0x4e0>
; 	pr_warn("elf: endianness mismatch in %s.\n", obj->path);
   11ce8: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   11ced: 48 8d 35 cc 39 02 00         	leaq	145868(%rip), %rsi      # 0x356c0 <strs.2+0x2830>
   11cf4: 31 ff                        	xorl	%edi, %edi
   11cf6: 31 c0                        	xorl	%eax, %eax
   11cf8: 48 c7 c3 5d f0 ff ff         	movq	$-4003, %rbx            # imm = 0xF05D
   11cff: e8 cc 63 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__elf_collect(obj);
   11d04: e9 ef fe ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("elf: failed to get section(%zu) header from %s: %s\n",
   11d09: 4c 89 f5                     	movq	%r14, %rbp
   11d0c: 4d 89 ef                     	movq	%r13, %r15
   11d0f: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   11d14: e8 47 3d ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   11d19: 48 89 ef                     	movq	%rbp, %rdi
   11d1c: 48 89 c3                     	movq	%rax, %rbx
   11d1f: e8 bc 3e ff ff               	callq	0x5be0 <.plt.sec+0x570>
   11d24: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   11d29: 49 89 d8                     	movq	%rbx, %r8
   11d2c: 31 ff                        	xorl	%edi, %edi
   11d2e: 48 89 c2                     	movq	%rax, %rdx
   11d31: 48 8d 35 e0 15 02 00         	leaq	136672(%rip), %rsi      # 0x33318 <strs.2+0x488>
   11d38: 31 c0                        	xorl	%eax, %eax
   11d3a: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   11d41: e8 8a 63 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (!sh)
   11d46: e9 ad fe ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   11d4b: 4d 89 ef                     	movq	%r13, %r15
; 	if (!sh || sh->sh_entsize != sizeof(Elf64_Sym))
   11d4e: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   11d55: e9 9e fe ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	if (!obj->efile.symbols) {
   11d5a: 49 83 bf d0 00 00 00 00      	cmpq	$0, 208(%r15)
   11d62: 0f 84 1a 2f 00 00            	je	0x14c82 <bpf_object_open.part.0+0x34f2>
; 	Elf_Data *btf_data = NULL;
   11d68: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
; 		pr_debug("sec '%s': found program '%s' at insn offset %zu (%zu bytes), code size %zu insns (%zu bytes)\n",
   11d71: 4c 89 f8                     	movq	%r15, %rax
   11d74: 4d 89 ef                     	movq	%r13, %r15
; 	Elf_Data *btf_ext_data = NULL;
   11d77: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 		pr_debug("sec '%s': found program '%s' at insn offset %zu (%zu bytes), code size %zu insns (%zu bytes)\n",
   11d80: 49 89 c5                     	movq	%rax, %r13
   11d83: 4c 89 74 24 48               	movq	%r14, 72(%rsp)
   11d88: 49 89 ee                     	movq	%rbp, %r14
   11d8b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	while ((scn = elf_nextscn(elf, scn)) != NULL) {
   11d90: 4c 89 f6                     	movq	%r14, %rsi
   11d93: 4c 89 ff                     	movq	%r15, %rdi
   11d96: e8 f5 3d ff ff               	callq	0x5b90 <.plt.sec+0x520>
   11d9b: 49 89 c6                     	movq	%rax, %r14
   11d9e: 48 85 c0                     	testq	%rax, %rax
   11da1: 0f 84 9a 03 00 00            	je	0x12141 <bpf_object_open.part.0+0x9b1>
; 		idx = elf_ndxscn(scn);
   11da7: 4c 89 f7                     	movq	%r14, %rdi
   11daa: e8 31 3e ff ff               	callq	0x5be0 <.plt.sec+0x570>
; 	shdr = elf64_getshdr(scn);
   11daf: 4c 89 f7                     	movq	%r14, %rdi
; 		idx = elf_ndxscn(scn);
   11db2: 48 89 44 24 10               	movq	%rax, 16(%rsp)
   11db7: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 		sec_desc = &obj->efile.secs[idx];
   11dbb: 49 8b 85 f0 00 00 00         	movq	240(%r13), %rax
   11dc2: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	shdr = elf64_getshdr(scn);
   11dc7: e8 54 3b ff ff               	callq	0x5920 <.plt.sec+0x2b0>
   11dcc: 48 89 c3                     	movq	%rax, %rbx
; 	if (!shdr) {
   11dcf: 48 85 c0                     	testq	%rax, %rax
   11dd2: 0f 84 31 ff ff ff            	je	0x11d09 <bpf_object_open.part.0+0x579>
; 		name = elf_sec_str(obj, sh->sh_name);
   11dd8: 8b 28                        	movl	(%rax), %ebp
; 	name = elf_strptr(obj->efile.elf, obj->efile.shstrndx, off);
   11dda: 49 8b b5 e0 00 00 00         	movq	224(%r13), %rsi
   11de1: 49 8b bd c0 00 00 00         	movq	192(%r13), %rdi
   11de8: 48 89 ea                     	movq	%rbp, %rdx
   11deb: e8 80 3a ff ff               	callq	0x5870 <.plt.sec+0x200>
   11df0: 49 89 c4                     	movq	%rax, %r12
; 	if (!name) {
   11df3: 48 85 c0                     	testq	%rax, %rax
   11df6: 0f 84 6f 02 00 00            	je	0x1206b <bpf_object_open.part.0+0x8db>
; 	if (hdr->sh_type == SHT_STRTAB)
   11dfc: 8b 43 04                     	movl	4(%rbx), %eax
; 	if (hdr->sh_type == SHT_LLVM_ADDRSIG)
   11dff: 3d 03 4c ff 6f               	cmpl	$1879002115, %eax       # imm = 0x6FFF4C03
   11e04: 74 8a                        	je	0x11d90 <bpf_object_open.part.0+0x600>
   11e06: 83 f8 03                     	cmpl	$3, %eax
   11e09: 74 85                        	je	0x11d90 <bpf_object_open.part.0+0x600>
; 	if (hdr->sh_type == SHT_PROGBITS && hdr->sh_size == 0 &&
   11e0b: 83 f8 01                     	cmpl	$1, %eax
   11e0e: 0f 84 2f 01 00 00            	je	0x11f43 <bpf_object_open.part.0+0x7b3>
; 	return str_has_pfx(name, ".debug_");
   11e14: ba 07 00 00 00               	movl	$7, %edx
   11e19: 48 8d 35 7b 02 02 00         	leaq	131707(%rip), %rsi      # 0x3209b <_IO_stdin_used+0x209b>
   11e20: 4c 89 e7                     	movq	%r12, %rdi
   11e23: e8 f8 38 ff ff               	callq	0x5720 <.plt.sec+0xb0>
; 	if (is_sec_name_dwarf(name))
   11e28: 85 c0                        	testl	%eax, %eax
   11e2a: 0f 84 60 ff ff ff            	je	0x11d90 <bpf_object_open.part.0+0x600>
; 	if (str_has_pfx(name, ".rel")) {
   11e30: ba 04 00 00 00               	movl	$4, %edx
   11e35: 48 8d 35 67 02 02 00         	leaq	131687(%rip), %rsi      # 0x320a3 <_IO_stdin_used+0x20a3>
   11e3c: 4c 89 e7                     	movq	%r12, %rdi
   11e3f: e8 dc 38 ff ff               	callq	0x5720 <.plt.sec+0xb0>
   11e44: 85 c0                        	testl	%eax, %eax
   11e46: 75 4f                        	jne	0x11e97 <bpf_object_open.part.0+0x707>
; 		name += sizeof(".rel") - 1;
   11e48: 49 8d 6c 24 04               	leaq	4(%r12), %rbp
; 	return str_has_pfx(name, ".debug_");
   11e4d: ba 07 00 00 00               	movl	$7, %edx
   11e52: 48 8d 35 42 02 02 00         	leaq	131650(%rip), %rsi      # 0x3209b <_IO_stdin_used+0x209b>
   11e59: 48 89 ef                     	movq	%rbp, %rdi
   11e5c: e8 bf 38 ff ff               	callq	0x5720 <.plt.sec+0xb0>
; 		if (is_sec_name_dwarf(name))
   11e61: 85 c0                        	testl	%eax, %eax
   11e63: 0f 84 27 ff ff ff            	je	0x11d90 <bpf_object_open.part.0+0x600>
; 		if (strcmp(name, BTF_ELF_SEC) == 0 ||
   11e69: 48 8d 35 ee ff 01 00         	leaq	131054(%rip), %rsi      # 0x31e5e <_IO_stdin_used+0x1e5e>
   11e70: 48 89 ef                     	movq	%rbp, %rdi
   11e73: e8 38 3b ff ff               	callq	0x59b0 <.plt.sec+0x340>
   11e78: 85 c0                        	testl	%eax, %eax
   11e7a: 0f 84 10 ff ff ff            	je	0x11d90 <bpf_object_open.part.0+0x600>
; 		    strcmp(name, BTF_EXT_ELF_SEC) == 0)
   11e80: 48 8d 35 dc ff 01 00         	leaq	131036(%rip), %rsi      # 0x31e63 <_IO_stdin_used+0x1e63>
   11e87: 48 89 ef                     	movq	%rbp, %rdi
   11e8a: e8 21 3b ff ff               	callq	0x59b0 <.plt.sec+0x340>
; 		if (strcmp(name, BTF_ELF_SEC) == 0 ||
   11e8f: 85 c0                        	testl	%eax, %eax
   11e91: 0f 84 f9 fe ff ff            	je	0x11d90 <bpf_object_open.part.0+0x600>
; 		data = elf_sec_data(obj, scn);
   11e97: 4c 89 f6                     	movq	%r14, %rsi
   11e9a: 4c 89 ef                     	movq	%r13, %rdi
   11e9d: e8 0e 91 ff ff               	callq	0xafb0 <elf_sec_data>
   11ea2: 48 89 c5                     	movq	%rax, %rbp
; 		if (!data)
   11ea5: 48 85 c0                     	testq	%rax, %rax
   11ea8: 0f 84 9d fe ff ff            	je	0x11d4b <bpf_object_open.part.0+0x5bb>
; 		pr_debug("elf: section(%d) %s, size %ld, link %d, flags %lx, type=%d\n",
   11eae: 4c 8b 40 10                  	movq	16(%rax), %r8
   11eb2: 8b 43 04                     	movl	4(%rbx), %eax
   11eb5: 4c 89 e1                     	movq	%r12, %rcx
   11eb8: bf 02 00 00 00               	movl	$2, %edi
   11ebd: 44 8b 4b 28                  	movl	40(%rbx), %r9d
   11ec1: 48 8d 35 a0 38 02 00         	leaq	145568(%rip), %rsi      # 0x35768 <strs.2+0x28d8>
   11ec8: 50                           	pushq	%rax
   11ec9: 31 c0                        	xorl	%eax, %eax
   11ecb: ff 73 08                     	pushq	8(%rbx)
   11ece: 8b 54 24 18                  	movl	24(%rsp), %edx
   11ed2: e8 f9 61 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (strcmp(name, "license") == 0) {
   11ed7: 48 8d 35 ca 01 02 00         	leaq	131530(%rip), %rsi      # 0x320a8 <_IO_stdin_used+0x20a8>
   11ede: 4c 89 e7                     	movq	%r12, %rdi
   11ee1: e8 ca 3a ff ff               	callq	0x59b0 <.plt.sec+0x340>
   11ee6: 41 5a                        	popq	%r10
   11ee8: 41 5b                        	popq	%r11
   11eea: 85 c0                        	testl	%eax, %eax
   11eec: 74 7c                        	je	0x11f6a <bpf_object_open.part.0+0x7da>
; 		} else if (strcmp(name, "version") == 0) {
   11eee: 48 8d 35 d8 01 02 00         	leaq	131544(%rip), %rsi      # 0x320cd <_IO_stdin_used+0x20cd>
   11ef5: 4c 89 e7                     	movq	%r12, %rdi
   11ef8: e8 b3 3a ff ff               	callq	0x59b0 <.plt.sec+0x340>
   11efd: 85 c0                        	testl	%eax, %eax
   11eff: 0f 84 dd 00 00 00            	je	0x11fe2 <bpf_object_open.part.0+0x852>
; 		} else if (strcmp(name, "maps") == 0) {
   11f05: 48 8d 35 ee 01 02 00         	leaq	131566(%rip), %rsi      # 0x320fa <_IO_stdin_used+0x20fa>
   11f0c: 4c 89 e7                     	movq	%r12, %rdi
   11f0f: e8 9c 3a ff ff               	callq	0x59b0 <.plt.sec+0x340>
   11f14: 85 c0                        	testl	%eax, %eax
   11f16: 0f 84 6e 29 00 00            	je	0x1488a <bpf_object_open.part.0+0x30fa>
; 		} else if (strcmp(name, MAPS_ELF_SEC) == 0) {
   11f1c: 48 8d 35 d6 01 02 00         	leaq	131542(%rip), %rsi      # 0x320f9 <_IO_stdin_used+0x20f9>
   11f23: 4c 89 e7                     	movq	%r12, %rdi
   11f26: e8 85 3a ff ff               	callq	0x59b0 <.plt.sec+0x340>
   11f2b: 85 c0                        	testl	%eax, %eax
   11f2d: 0f 85 e1 00 00 00            	jne	0x12014 <bpf_object_open.part.0+0x884>
; 			obj->efile.btf_maps_shndx = idx;
   11f33: 8b 44 24 10                  	movl	16(%rsp), %eax
   11f37: 41 89 85 fc 00 00 00         	movl	%eax, 252(%r13)
   11f3e: e9 4d fe ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 	if (hdr->sh_type == SHT_PROGBITS && hdr->sh_size == 0 &&
   11f43: 48 83 7b 20 00               	cmpq	$0, 32(%rbx)
   11f48: 0f 85 c6 fe ff ff            	jne	0x11e14 <bpf_object_open.part.0+0x684>
; 	    strcmp(name, ".text") == 0)
   11f4e: 48 8d 35 40 01 02 00         	leaq	131392(%rip), %rsi      # 0x32095 <_IO_stdin_used+0x2095>
   11f55: 4c 89 e7                     	movq	%r12, %rdi
   11f58: e8 53 3a ff ff               	callq	0x59b0 <.plt.sec+0x340>
; 	if (hdr->sh_type == SHT_PROGBITS && hdr->sh_size == 0 &&
   11f5d: 85 c0                        	testl	%eax, %eax
   11f5f: 0f 85 af fe ff ff            	jne	0x11e14 <bpf_object_open.part.0+0x684>
   11f65: e9 26 fe ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 			err = bpf_object__init_license(obj, data->d_buf, data->d_size);
   11f6a: 48 8b 7d 10                  	movq	16(%rbp), %rdi
; 	libbpf_strlcpy(obj->license, data, min(size + 1, sizeof(obj->license)));
   11f6e: 4d 8d 4d 10                  	leaq	16(%r13), %r9
; 	if (sz == 0)
   11f72: 48 83 ff ff                  	cmpq	$-1, %rdi
   11f76: 74 4a                        	je	0x11fc2 <bpf_object_open.part.0+0x832>
; 	libbpf_strlcpy(obj->license, data, min(size + 1, sizeof(obj->license)));
   11f78: 48 83 c7 01                  	addq	$1, %rdi
   11f7c: b8 40 00 00 00               	movl	$64, %eax
; 	for (i = 0; i < sz && src[i]; i++)
   11f81: 4c 89 ce                     	movq	%r9, %rsi
; 	libbpf_strlcpy(obj->license, data, min(size + 1, sizeof(obj->license)));
   11f84: 48 39 c7                     	cmpq	%rax, %rdi
   11f87: 48 0f 47 f8                  	cmovaq	%rax, %rdi
; 	for (i = 0; i < sz && src[i]; i++)
   11f8b: 48 83 ef 01                  	subq	$1, %rdi
   11f8f: 74 2e                        	je	0x11fbf <bpf_object_open.part.0+0x82f>
; 			err = bpf_object__init_license(obj, data->d_buf, data->d_size);
   11f91: 4c 8b 45 00                  	movq	(%rbp), %r8
   11f95: 4c 89 ca                     	movq	%r9, %rdx
; 	for (i = 0; i < sz && src[i]; i++)
   11f98: 31 c0                        	xorl	%eax, %eax
   11f9a: eb 17                        	jmp	0x11fb3 <bpf_object_open.part.0+0x823>
   11f9c: 0f 1f 40 00                  	nopl	(%rax)
   11fa0: 48 83 c0 01                  	addq	$1, %rax
; 		dst[i] = src[i];
   11fa4: 88 0a                        	movb	%cl, (%rdx)
; 	for (i = 0; i < sz && src[i]; i++)
   11fa6: 48 8d 56 01                  	leaq	1(%rsi), %rdx
   11faa: 48 39 c7                     	cmpq	%rax, %rdi
   11fad: 0f 84 af 00 00 00            	je	0x12062 <bpf_object_open.part.0+0x8d2>
   11fb3: 41 0f b6 0c 00               	movzbl	(%r8,%rax), %ecx
; 		dst[i] = src[i];
   11fb8: 48 89 d6                     	movq	%rdx, %rsi
; 	for (i = 0; i < sz && src[i]; i++)
   11fbb: 84 c9                        	testb	%cl, %cl
   11fbd: 75 e1                        	jne	0x11fa0 <bpf_object_open.part.0+0x810>
; 	dst[i] = '\0';
   11fbf: c6 06 00                     	movb	$0, (%rsi)
; 	pr_debug("license of %s is %s\n", obj->path, obj->license);
   11fc2: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   11fc7: 4c 89 c9                     	movq	%r9, %rcx
   11fca: bf 02 00 00 00               	movl	$2, %edi
   11fcf: 31 c0                        	xorl	%eax, %eax
   11fd1: 48 8d 35 d8 00 02 00         	leaq	131288(%rip), %rsi      # 0x320b0 <_IO_stdin_used+0x20b0>
   11fd8: e8 f3 60 ff ff               	callq	0x80d0 <libbpf_print>
; 			if (err)
   11fdd: e9 ae fd ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 	if (size != sizeof(kver)) {
   11fe2: 48 83 7d 10 04               	cmpq	$4, 16(%rbp)
; 			err = bpf_object__init_kversion(obj, data->d_buf, data->d_size);
   11fe7: 48 8b 45 00                  	movq	(%rbp), %rax
; 	if (size != sizeof(kver)) {
   11feb: 0f 85 09 29 00 00            	jne	0x148fa <bpf_object_open.part.0+0x316a>
; 	memcpy(&kver, data, sizeof(kver));
   11ff1: 8b 08                        	movl	(%rax), %ecx
; 	pr_debug("kernel version of %s is %x\n", obj->path, obj->kern_version);
   11ff3: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   11ff8: 48 8d 35 d9 37 02 00         	leaq	145369(%rip), %rsi      # 0x357d8 <strs.2+0x2948>
   11fff: 31 c0                        	xorl	%eax, %eax
   12001: bf 02 00 00 00               	movl	$2, %edi
; 	obj->kern_version = kver;
   12006: 41 89 4d 50                  	movl	%ecx, 80(%r13)
; 	pr_debug("kernel version of %s is %x\n", obj->path, obj->kern_version);
   1200a: e8 c1 60 ff ff               	callq	0x80d0 <libbpf_print>
; 			if (err)
   1200f: e9 7c fd ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 		} else if (strcmp(name, BTF_ELF_SEC) == 0) {
   12014: 48 8d 35 43 fe 01 00         	leaq	130627(%rip), %rsi      # 0x31e5e <_IO_stdin_used+0x1e5e>
   1201b: 4c 89 e7                     	movq	%r12, %rdi
   1201e: e8 8d 39 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   12023: 85 c0                        	testl	%eax, %eax
   12025: 75 14                        	jne	0x1203b <bpf_object_open.part.0+0x8ab>
; 			if (sh->sh_type != SHT_PROGBITS)
   12027: 83 7b 04 01                  	cmpl	$1, 4(%rbx)
   1202b: 0f 85 1a fd ff ff            	jne	0x11d4b <bpf_object_open.part.0+0x5bb>
   12031: 48 89 6c 24 20               	movq	%rbp, 32(%rsp)
   12036: e9 55 fd ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 		} else if (strcmp(name, BTF_EXT_ELF_SEC) == 0) {
   1203b: 48 8d 35 21 fe 01 00         	leaq	130593(%rip), %rsi      # 0x31e63 <_IO_stdin_used+0x1e63>
   12042: 4c 89 e7                     	movq	%r12, %rdi
   12045: e8 66 39 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   1204a: 85 c0                        	testl	%eax, %eax
   1204c: 75 58                        	jne	0x120a6 <bpf_object_open.part.0+0x916>
; 			if (sh->sh_type != SHT_PROGBITS)
   1204e: 83 7b 04 01                  	cmpl	$1, 4(%rbx)
   12052: 0f 85 f3 fc ff ff            	jne	0x11d4b <bpf_object_open.part.0+0x5bb>
   12058: 48 89 6c 24 28               	movq	%rbp, 40(%rsp)
   1205d: e9 2e fd ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 	dst[i] = '\0';
   12062: 49 8d 34 39                  	leaq	(%r9,%rdi), %rsi
   12066: e9 54 ff ff ff               	jmp	0x11fbf <bpf_object_open.part.0+0x82f>
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   1206b: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   12070: 48 89 6c 24 08               	movq	%rbp, 8(%rsp)
   12075: 4d 89 ef                     	movq	%r13, %r15
   12078: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   1207f: e8 dc 39 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   12084: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   12089: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   1208e: 31 ff                        	xorl	%edi, %edi
   12090: 49 89 c0                     	movq	%rax, %r8
   12093: 48 8d 35 46 1d 02 00         	leaq	138566(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
   1209a: 31 c0                        	xorl	%eax, %eax
   1209c: e8 2f 60 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (!name)
   120a1: e9 52 fb ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		} else if (sh->sh_type == SHT_SYMTAB) {
   120a6: 8b 43 04                     	movl	4(%rbx), %eax
   120a9: 83 f8 02                     	cmpl	$2, %eax
   120ac: 0f 84 de fc ff ff            	je	0x11d90 <bpf_object_open.part.0+0x600>
; 		sec_desc = &obj->efile.secs[idx];
   120b2: 48 63 4c 24 10               	movslq	16(%rsp), %rcx
   120b7: 48 8d 14 49                  	leaq	(%rcx,%rcx,2), %rdx
   120bb: 48 89 4c 24 50               	movq	%rcx, 80(%rsp)
   120c0: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   120c5: 48 8d 0c d1                  	leaq	(%rcx,%rdx,8), %rcx
   120c9: 48 89 4c 24 18               	movq	%rcx, 24(%rsp)
; 		} else if (sh->sh_type == SHT_PROGBITS && data->d_size > 0) {
   120ce: 83 f8 01                     	cmpl	$1, %eax
   120d1: 0f 84 bf 1f 00 00            	je	0x14096 <bpf_object_open.part.0+0x2906>
; 		} else if (sh->sh_type == SHT_REL) {
   120d7: 83 f8 09                     	cmpl	$9, %eax
   120da: 0f 84 10 23 00 00            	je	0x143f0 <bpf_object_open.part.0+0x2c60>
; 		} else if (sh->sh_type == SHT_NOBITS && strcmp(name, BSS_SEC) == 0) {
   120e0: 83 f8 08                     	cmpl	$8, %eax
   120e3: 0f 85 8a 1f 00 00            	jne	0x14073 <bpf_object_open.part.0+0x28e3>
   120e9: 48 8d 35 0f 00 02 00         	leaq	131087(%rip), %rsi      # 0x320ff <_IO_stdin_used+0x20ff>
   120f0: 4c 89 e7                     	movq	%r12, %rdi
   120f3: e8 b8 38 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   120f8: 85 c0                        	testl	%eax, %eax
   120fa: 0f 85 73 1f 00 00            	jne	0x14073 <bpf_object_open.part.0+0x28e3>
; 			sec_desc->sec_type = SEC_BSS;
   12100: 48 8b 44 24 18               	movq	24(%rsp), %rax
   12105: c7 00 02 00 00 00            	movl	$2, (%rax)
; 			sec_desc->shdr = sh;
   1210b: 48 89 58 08                  	movq	%rbx, 8(%rax)
; 			sec_desc->data = data;
   1210f: 48 89 68 10                  	movq	%rbp, 16(%rax)
   12113: e9 78 fc ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
   12118: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 				pr_warn("elf: multiple symbol tables in %s\n", obj->path);
   12120: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   12125: 48 8d 35 c4 35 02 00         	leaq	144836(%rip), %rsi      # 0x356f0 <strs.2+0x2860>
   1212c: 31 ff                        	xorl	%edi, %edi
   1212e: 31 c0                        	xorl	%eax, %eax
   12130: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   12137: e8 94 5f ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__init_maps(obj, opts);
   1213c: e9 b7 fa ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	if (!obj->efile.strtabidx || obj->efile.strtabidx > idx) {
   12141: 49 8b 95 e8 00 00 00         	movq	232(%r13), %rdx
   12148: 4c 8b 74 24 48               	movq	72(%rsp), %r14
   1214d: 4d 89 ef                     	movq	%r13, %r15
   12150: 48 85 d2                     	testq	%rdx, %rdx
   12153: 0f 84 ec 2c 00 00            	je	0x14e45 <bpf_object_open.part.0+0x36b5>
   12159: 48 63 44 24 08               	movslq	8(%rsp), %rax
   1215e: 48 39 c2                     	cmpq	%rax, %rdx
   12161: 0f 87 de 2c 00 00            	ja	0x14e45 <bpf_object_open.part.0+0x36b5>
; 	if (obj->nr_programs)
   12167: 49 8b 75 60                  	movq	96(%r13), %rsi
   1216b: 48 85 f6                     	testq	%rsi, %rsi
   1216e: 0f 85 10 22 00 00            	jne	0x14384 <bpf_object_open.part.0+0x2bf4>
; 	return bpf_object__init_btf(obj, btf_data, btf_ext_data);
   12174: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   12179: 48 8b 74 24 20               	movq	32(%rsp), %rsi
   1217e: 4c 89 ff                     	movq	%r15, %rdi
   12181: e8 2a 8b ff ff               	callq	0xacb0 <bpf_object__init_btf>
   12186: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 	err = err ? : bpf_object__collect_externs(obj);
   1218a: 85 c0                        	testl	%eax, %eax
   1218c: 0f 85 17 16 00 00            	jne	0x137a9 <bpf_object_open.part.0+0x2019>
; 	if (!obj->efile.symbols)
   12192: 49 83 bf d0 00 00 00 00      	cmpq	$0, 208(%r15)
   1219a: 0f 84 06 02 00 00            	je	0x123a6 <bpf_object_open.part.0+0xc16>
; 	scn = elf_sec_by_idx(obj, obj->efile.symbols_shndx);
   121a0: 4d 63 a7 08 01 00 00         	movslq	264(%r15), %r12
; 	scn = elf_getscn(obj->efile.elf, idx);
   121a7: 49 8b bf c0 00 00 00         	movq	192(%r15), %rdi
   121ae: 4c 89 e6                     	movq	%r12, %rsi
   121b1: e8 4a 3a ff ff               	callq	0x5c00 <.plt.sec+0x590>
   121b6: 48 89 c5                     	movq	%rax, %rbp
; 	if (!scn) {
   121b9: 48 85 c0                     	testq	%rax, %rax
   121bc: 0f 84 dc 21 00 00            	je	0x1439e <bpf_object_open.part.0+0x2c0e>
; 	sh = elf_sec_hdr(obj, scn);
   121c2: 48 89 ee                     	movq	%rbp, %rsi
   121c5: 4c 89 ff                     	movq	%r15, %rdi
   121c8: e8 13 6d ff ff               	callq	0x8ee0 <elf_sec_hdr>
   121cd: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	if (!sh || sh->sh_entsize != sizeof(Elf64_Sym))
   121d2: 48 85 c0                     	testq	%rax, %rax
   121d5: 0f 84 73 fb ff ff            	je	0x11d4e <bpf_object_open.part.0+0x5be>
   121db: 48 8b 6c 24 08               	movq	8(%rsp), %rbp
   121e0: 48 8b 4d 38                  	movq	56(%rbp), %rcx
   121e4: 48 83 f9 18                  	cmpq	$24, %rcx
   121e8: 0f 85 60 fb ff ff            	jne	0x11d4e <bpf_object_open.part.0+0x5be>
; 	dummy_var_btf_id = add_dummy_ksym_var(obj->btf);
   121ee: 49 8b 9f 10 01 00 00         	movq	272(%r15), %rbx
; 	if (!btf)
   121f5: 48 85 db                     	testq	%rbx, %rbx
   121f8: 0f 84 d2 18 00 00            	je	0x13ad0 <bpf_object_open.part.0+0x2340>
; 	sec_btf_id = btf__find_by_name_kind(btf, KSYMS_SEC,
   121fe: 48 8d 35 ff fe 01 00         	leaq	130815(%rip), %rsi      # 0x32104 <_IO_stdin_used+0x2104>
   12205: ba 0f 00 00 00               	movl	$15, %edx
   1220a: 48 89 df                     	movq	%rbx, %rdi
   1220d: e8 be 98 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
   12212: 89 c6                        	movl	%eax, %esi
; 	if (sec_btf_id < 0)
   12214: 85 c0                        	testl	%eax, %eax
   12216: 0f 88 c1 18 00 00            	js	0x13add <bpf_object_open.part.0+0x234d>
; 	sec = btf__type_by_id(btf, sec_btf_id);
   1221c: 48 89 df                     	movq	%rbx, %rdi
   1221f: e8 7c 7d 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	for (i = 0; i < btf_vlen(sec); i++, vs++) {
   12224: 66 83 78 04 00               	cmpw	$0, 4(%rax)
; 	sec = btf__type_by_id(btf, sec_btf_id);
   12229: 48 89 c5                     	movq	%rax, %rbp
; 	return (struct btf_var_secinfo *)(t + 1);
   1222c: 4c 8d 68 0c                  	leaq	12(%rax), %r13
; 	for (i = 0; i < btf_vlen(sec); i++, vs++) {
   12230: 0f 84 04 1d 00 00            	je	0x13f3a <bpf_object_open.part.0+0x27aa>
   12236: 45 31 e4                     	xorl	%r12d, %r12d
   12239: eb 16                        	jmp	0x12251 <bpf_object_open.part.0+0xac1>
   1223b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   12240: 0f b7 45 04                  	movzwl	4(%rbp), %eax
   12244: 41 83 c4 01                  	addl	$1, %r12d
   12248: 49 83 c5 0c                  	addq	$12, %r13
   1224c: 41 39 c4                     	cmpl	%eax, %r12d
   1224f: 7d 1d                        	jge	0x1226e <bpf_object_open.part.0+0xade>
; 		vt = btf__type_by_id(btf, vs->type);
   12251: 41 8b 75 00                  	movl	(%r13), %esi
   12255: 48 89 df                     	movq	%rbx, %rdi
   12258: e8 43 7d 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	return BTF_INFO_KIND(t->info);
   1225d: 0f b6 40 07                  	movzbl	7(%rax), %eax
   12261: 83 e0 1f                     	andl	$31, %eax
; 		if (btf_is_func(vt))
   12264: 66 83 f8 0c                  	cmpw	$12, %ax
   12268: 75 d6                        	jne	0x12240 <bpf_object_open.part.0+0xab0>
; 	for (i = 0; i < btf_vlen(sec); i++, vs++) {
   1226a: 0f b7 45 04                  	movzwl	4(%rbp), %eax
; 	if (i == btf_vlen(sec))
   1226e: 44 39 e0                     	cmpl	%r12d, %eax
   12271: 0f 84 c3 1c 00 00            	je	0x13f3a <bpf_object_open.part.0+0x27aa>
; 	int_btf_id = find_int_btf_id(btf);
   12277: 48 89 df                     	movq	%rbx, %rdi
   1227a: e8 81 4d ff ff               	callq	0x7000 <find_int_btf_id>
; 	dummy_var_btf_id = btf__add_var(btf,
   1227f: ba 01 00 00 00               	movl	$1, %edx
   12284: 48 8d 35 80 fe 01 00         	leaq	130688(%rip), %rsi      # 0x3210b <_IO_stdin_used+0x210b>
   1228b: 48 89 df                     	movq	%rbx, %rdi
; 	int_btf_id = find_int_btf_id(btf);
   1228e: 89 c1                        	movl	%eax, %ecx
; 	dummy_var_btf_id = btf__add_var(btf,
   12290: e8 2b ac 01 00               	callq	0x2cec0 <btf__add_var>
   12295: 89 44 24 48                  	movl	%eax, 72(%rsp)
; 	if (dummy_var_btf_id < 0)
   12299: 85 c0                        	testl	%eax, %eax
   1229b: 0f 88 af 1c 00 00            	js	0x13f50 <bpf_object_open.part.0+0x27c0>
; 	n = sh->sh_size / sh->sh_entsize;
   122a1: 48 8b 44 24 08               	movq	8(%rsp), %rax
   122a6: 48 8b 48 38                  	movq	56(%rax), %rcx
   122aa: 48 8b 44 24 08               	movq	8(%rsp), %rax
   122af: 31 d2                        	xorl	%edx, %edx
; 	pr_debug("looking for externs among %d symbols...\n", n);
   122b1: bf 02 00 00 00               	movl	$2, %edi
   122b6: 48 8d 35 6b 38 02 00         	leaq	145515(%rip), %rsi      # 0x35b28 <strs.2+0x2c98>
; 	n = sh->sh_size / sh->sh_entsize;
   122bd: 48 8b 40 20                  	movq	32(%rax), %rax
   122c1: 48 f7 f1                     	divq	%rcx
   122c4: 48 89 c3                     	movq	%rax, %rbx
   122c7: 89 c2                        	movl	%eax, %edx
; 	pr_debug("looking for externs among %d symbols...\n", n);
   122c9: 31 c0                        	xorl	%eax, %eax
   122cb: e8 00 5e ff ff               	callq	0x80d0 <libbpf_print>
; 	for (i = 0; i < n; i++) {
   122d0: 85 db                        	testl	%ebx, %ebx
   122d2: 0f 8e c3 27 00 00            	jle	0x14a9b <bpf_object_open.part.0+0x330b>
   122d8: 8d 43 ff                     	leal	-1(%rbx), %eax
   122db: 4c 89 74 24 28               	movq	%r14, 40(%rsp)
   122e0: 31 db                        	xorl	%ebx, %ebx
   122e2: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	struct btf_type *sec, *kcfg_sec = NULL, *ksym_sec = NULL;
   122e7: 48 c7 44 24 40 00 00 00 00   	movq	$0, 64(%rsp)
   122f0: 48 c7 44 24 50 00 00 00 00   	movq	$0, 80(%rsp)
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   122f9: 49 8b 8f d0 00 00 00         	movq	208(%r15), %rcx
   12300: 89 5c 24 10                  	movl	%ebx, 16(%rsp)
   12304: 48 b8 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rax # imm = 0xAAAAAAAAAAAAAAAB
   1230e: 48 f7 61 10                  	mulq	16(%rcx)
   12312: 48 c1 ea 04                  	shrq	$4, %rdx
   12316: 48 39 da                     	cmpq	%rbx, %rdx
   12319: 0f 86 2f fa ff ff            	jbe	0x11d4e <bpf_object_open.part.0+0x5be>
; 	return (Elf64_Sym *)obj->efile.symbols->d_buf + idx;
   1231f: 48 8b 11                     	movq	(%rcx), %rdx
   12322: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
   12326: 4c 8d 34 c2                  	leaq	(%rdx,%rax,8), %r14
; 		if (!sym)
   1232a: 4d 85 f6                     	testq	%r14, %r14
   1232d: 0f 84 1b fa ff ff            	je	0x11d4e <bpf_object_open.part.0+0x5be>
; 	       (bind == STB_GLOBAL || bind == STB_WEAK) &&
   12333: 66 41 83 7e 06 00            	cmpw	$0, 6(%r14)
   12339: 41 0f b6 56 04               	movzbl	4(%r14), %edx
   1233e: 75 14                        	jne	0x12354 <bpf_object_open.part.0+0xbc4>
; 	int bind = ELF64_ST_BIND(sym->st_info);
   12340: 89 d0                        	movl	%edx, %eax
   12342: c0 e8 04                     	shrb	$4, %al
; 	       (bind == STB_GLOBAL || bind == STB_WEAK) &&
   12345: 0f b6 c0                     	movzbl	%al, %eax
   12348: 83 e8 01                     	subl	$1, %eax
; 	return sym->st_shndx == SHN_UNDEF &&
   1234b: 83 f8 01                     	cmpl	$1, %eax
   1234e: 0f 86 5d 14 00 00            	jbe	0x137b1 <bpf_object_open.part.0+0x2021>
; 	for (i = 0; i < n; i++) {
   12354: 48 8d 43 01                  	leaq	1(%rbx), %rax
   12358: 48 3b 5c 24 18               	cmpq	24(%rsp), %rbx
   1235d: 0f 84 5c 21 00 00            	je	0x144bf <bpf_object_open.part.0+0x2d2f>
   12363: 48 89 c3                     	movq	%rax, %rbx
   12366: eb 91                        	jmp	0x122f9 <bpf_object_open.part.0+0xb69>
; 	for (i = 1; i < n; i++) {
   12368: 41 83 c4 01                  	addl	$1, %r12d
   1236c: 44 39 64 24 38               	cmpl	%r12d, 56(%rsp)
   12371: 0f 85 21 15 00 00            	jne	0x13898 <bpf_object_open.part.0+0x2108>
   12377: 4c 8b 74 24 28               	movq	40(%rsp), %r14
; 	return -ENOENT;
   1237c: b9 fe ff ff ff               	movl	$4294967294, %ecx       # imm = 0xFFFFFFFE
; 		ext->btf_id = find_extern_btf_id(obj->btf, ext_name);
   12381: 41 89 4d 08                  	movl	%ecx, 8(%r13)
; 			pr_warn("failed to find BTF for extern '%s': %d\n",
   12385: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   1238a: 31 ff                        	xorl	%edi, %edi
   1238c: 31 c0                        	xorl	%eax, %eax
   1238e: 48 8d 35 cb 37 02 00         	leaq	145355(%rip), %rsi      # 0x35b60 <strs.2+0x2cd0>
   12395: e8 36 5d ff ff               	callq	0x80d0 <libbpf_print>
; 			return ext->btf_id;
   1239a: 49 63 5d 08                  	movslq	8(%r13), %rbx
; 	err = err ? : bpf_object__finalize_btf(obj);
   1239e: 85 db                        	testl	%ebx, %ebx
   123a0: 0f 85 52 f8 ff ff            	jne	0x11bf8 <bpf_object_open.part.0+0x468>
; 	if (!obj->btf)
   123a6: 49 8b 87 10 01 00 00         	movq	272(%r15), %rax
   123ad: 48 89 c3                     	movq	%rax, %rbx
   123b0: 48 85 c0                     	testq	%rax, %rax
   123b3: 0f 84 b2 02 00 00            	je	0x1266b <bpf_object_open.part.0+0xedb>
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   123b9: 49 bd ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %r13 # imm = 0xAAAAAAAAAAAAAAAB
; 	__u32 i, n = btf__type_cnt(btf);
   123c3: 48 89 df                     	movq	%rbx, %rdi
   123c6: e8 75 7b 01 00               	callq	0x29f40 <btf__type_cnt>
; 	for (i = 1; i < n; i++) {
   123cb: c7 44 24 08 01 00 00 00      	movl	$1, 8(%rsp)
; 	__u32 i, n = btf__type_cnt(btf);
   123d3: 89 44 24 38                  	movl	%eax, 56(%rsp)
; 	for (i = 1; i < n; i++) {
   123d7: 83 f8 01                     	cmpl	$1, %eax
   123da: 0f 86 8b 02 00 00            	jbe	0x1266b <bpf_object_open.part.0+0xedb>
   123e0: 4c 89 74 24 58               	movq	%r14, 88(%rsp)
   123e5: 4d 89 fe                     	movq	%r15, %r14
   123e8: 49 89 df                     	movq	%rbx, %r15
   123eb: eb 16                        	jmp	0x12403 <bpf_object_open.part.0+0xc73>
   123ed: 0f 1f 00                     	nopl	(%rax)
   123f0: 83 44 24 08 01               	addl	$1, 8(%rsp)
   123f5: 8b 44 24 08                  	movl	8(%rsp), %eax
   123f9: 39 44 24 38                  	cmpl	%eax, 56(%rsp)
   123fd: 0f 84 60 02 00 00            	je	0x12663 <bpf_object_open.part.0+0xed3>
; 		struct btf_type *t = btf_type_by_id(btf, i);
   12403: 8b 74 24 08                  	movl	8(%rsp), %esi
   12407: 4c 89 ff                     	movq	%r15, %rdi
   1240a: e8 51 7b 01 00               	callq	0x29f60 <btf_type_by_id>
; 	return BTF_INFO_KIND(t->info);
   1240f: 8b 50 04                     	movl	4(%rax), %edx
; 		struct btf_type *t = btf_type_by_id(btf, i);
   12412: 48 89 c5                     	movq	%rax, %rbp
; 	return BTF_INFO_KIND(t->info);
   12415: 89 d0                        	movl	%edx, %eax
   12417: c1 e8 18                     	shrl	$24, %eax
   1241a: 83 e0 1f                     	andl	$31, %eax
; 		if (btf_is_datasec(t)) {
   1241d: 66 83 f8 0f                  	cmpw	$15, %ax
   12421: 75 cd                        	jne	0x123f0 <bpf_object_open.part.0+0xc60>
; 	const char *name = btf__name_by_offset(btf, t->name_off);
   12423: 8b 75 00                     	movl	(%rbp), %esi
   12426: 0f b7 c2                     	movzwl	%dx, %eax
   12429: 4c 89 ff                     	movq	%r15, %rdi
   1242c: 89 44 24 48                  	movl	%eax, 72(%rsp)
   12430: e8 bb 96 01 00               	callq	0x2baf0 <btf__name_by_offset>
   12435: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	if (!name) {
   1243a: 48 85 c0                     	testq	%rax, %rax
   1243d: 0f 84 43 2c 00 00            	je	0x15086 <bpf_object_open.part.0+0x38f6>
; 	return (struct btf_var_secinfo *)(t + 1);
   12443: 48 8d 45 0c                  	leaq	12(%rbp), %rax
   12447: 48 89 44 24 50               	movq	%rax, 80(%rsp)
; 	if (t->size)
   1244c: 8b 45 08                     	movl	8(%rbp), %eax
   1244f: 85 c0                        	testl	%eax, %eax
   12451: 0f 85 99 01 00 00            	jne	0x125f0 <bpf_object_open.part.0+0xe60>
; 	scn = elf_sec_by_name(obj, name);
   12457: 48 8b 74 24 20               	movq	32(%rsp), %rsi
   1245c: 4c 89 f7                     	movq	%r14, %rdi
   1245f: e8 dc 87 ff ff               	callq	0xac40 <elf_sec_by_name>
; 	data = elf_sec_data(obj, scn);
   12464: 4c 89 f7                     	movq	%r14, %rdi
; 	scn = elf_sec_by_name(obj, name);
   12467: 48 89 c6                     	movq	%rax, %rsi
; 	data = elf_sec_data(obj, scn);
   1246a: e8 41 8b ff ff               	callq	0xafb0 <elf_sec_data>
; 	if (data) {
   1246f: 48 85 c0                     	testq	%rax, %rax
   12472: 0f 84 ee 1f 00 00            	je	0x14466 <bpf_object_open.part.0+0x2cd6>
; 		*size = data->d_size;
   12478: 48 8b 40 10                  	movq	16(%rax), %rax
; 	if (ret || !size) {
   1247c: 85 c0                        	testl	%eax, %eax
   1247e: 0f 84 e2 1f 00 00            	je	0x14466 <bpf_object_open.part.0+0x2cd6>
; 	t->size = size;
   12484: 89 45 08                     	movl	%eax, 8(%rbp)
; 	for (i = 0, vsi = btf_var_secinfos(t); i < vars; i++, vsi++) {
   12487: 8b 44 24 48                  	movl	72(%rsp), %eax
   1248b: 85 c0                        	testl	%eax, %eax
   1248d: 0f 84 5d 01 00 00            	je	0x125f0 <bpf_object_open.part.0+0xe60>
   12493: 83 e8 01                     	subl	$1, %eax
   12496: 4c 89 7c 24 18               	movq	%r15, 24(%rsp)
   1249b: 48 8b 5c 24 50               	movq	80(%rsp), %rbx
   124a0: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   124a4: 48 8d 44 85 18               	leaq	24(%rbp,%rax,4), %rax
   124a9: 48 89 44 24 28               	movq	%rax, 40(%rsp)
   124ae: 66 90                        	nop
; 		t_var = btf__type_by_id(btf, vsi->type);
   124b0: 8b 33                        	movl	(%rbx), %esi
   124b2: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
   124b7: e8 e4 7a 01 00               	callq	0x29fa0 <btf__type_by_id>
; 		if (!t_var || !btf_is_var(t_var)) {
   124bc: 48 85 c0                     	testq	%rax, %rax
   124bf: 0f 84 17 12 00 00            	je	0x136dc <bpf_object_open.part.0+0x1f4c>
; 	return BTF_INFO_KIND(t->info);
   124c5: 0f b6 50 07                  	movzbl	7(%rax), %edx
   124c9: 83 e2 1f                     	andl	$31, %edx
; 		if (!t_var || !btf_is_var(t_var)) {
   124cc: 66 83 fa 0e                  	cmpw	$14, %dx
   124d0: 0f 85 06 12 00 00            	jne	0x136dc <bpf_object_open.part.0+0x1f4c>
; 		if (var->linkage == BTF_VAR_STATIC)
   124d6: 44 8b 78 0c                  	movl	12(%rax), %r15d
   124da: 45 85 ff                     	testl	%r15d, %r15d
   124dd: 0f 84 f3 00 00 00            	je	0x125d6 <bpf_object_open.part.0+0xe46>
; 		name = btf__name_by_offset(btf, t_var->name_off);
   124e3: 8b 30                        	movl	(%rax), %esi
   124e5: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
   124ea: e8 01 96 01 00               	callq	0x2baf0 <btf__name_by_offset>
   124ef: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 		if (!name) {
   124f4: 48 85 c0                     	testq	%rax, %rax
   124f7: 0f 84 28 18 00 00            	je	0x13d25 <bpf_object_open.part.0+0x2595>
; 	Elf_Data *symbols = obj->efile.symbols;
   124fd: 49 8b be d0 00 00 00         	movq	208(%r14), %rdi
; 	for (si = 0; si < symbols->d_size / sizeof(Elf64_Sym); si++) {
   12504: 48 8b 77 10                  	movq	16(%rdi), %rsi
; 	Elf_Data *symbols = obj->efile.symbols;
   12508: 48 89 7c 24 10               	movq	%rdi, 16(%rsp)
; 	for (si = 0; si < symbols->d_size / sizeof(Elf64_Sym); si++) {
   1250d: 48 89 f2                     	movq	%rsi, %rdx
   12510: 48 83 fe 17                  	cmpq	$23, %rsi
   12514: 0f 86 f6 00 00 00            	jbe	0x12610 <bpf_object_open.part.0+0xe80>
   1251a: 48 89 5c 24 40               	movq	%rbx, 64(%rsp)
   1251f: 48 8b 6c 24 20               	movq	32(%rsp), %rbp
   12524: 45 31 e4                     	xorl	%r12d, %r12d
   12527: eb 29                        	jmp	0x12552 <bpf_object_open.part.0+0xdc2>
   12529: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   12530: 48 89 f0                     	movq	%rsi, %rax
   12533: 49 83 c4 01                  	addq	$1, %r12
   12537: 49 f7 e5                     	mulq	%r13
   1253a: 48 c1 ea 04                  	shrq	$4, %rdx
   1253e: 49 39 d4                     	cmpq	%rdx, %r12
   12541: 0f 83 c9 00 00 00            	jae	0x12610 <bpf_object_open.part.0+0xe80>
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   12547: 49 8b be d0 00 00 00         	movq	208(%r14), %rdi
   1254e: 48 8b 57 10                  	movq	16(%rdi), %rdx
   12552: 48 89 d0                     	movq	%rdx, %rax
   12555: 49 f7 e5                     	mulq	%r13
   12558: 48 c1 ea 04                  	shrq	$4, %rdx
   1255c: 4c 39 e2                     	cmpq	%r12, %rdx
   1255f: 0f 86 45 37 ff ff            	jbe	0x5caa <bpf_object_open.part.0.cold+0xa>
; 	return (Elf64_Sym *)obj->efile.symbols->d_buf + idx;
   12565: 48 8b 17                     	movq	(%rdi), %rdx
   12568: 4b 8d 04 64                  	leaq	(%r12,%r12,2), %rax
   1256c: 48 8d 1c c2                  	leaq	(%rdx,%rax,8), %rbx
; 		if (ELF64_ST_TYPE(sym->st_info) != STT_OBJECT)
   12570: 0f b6 43 04                  	movzbl	4(%rbx), %eax
   12574: 89 c2                        	movl	%eax, %edx
   12576: 83 e2 0f                     	andl	$15, %edx
   12579: 80 fa 01                     	cmpb	$1, %dl
   1257c: 75 b2                        	jne	0x12530 <bpf_object_open.part.0+0xda0>
; 		if (ELF64_ST_BIND(sym->st_info) != STB_GLOBAL &&
   1257e: c0 e8 04                     	shrb	$4, %al
   12581: 83 e8 01                     	subl	$1, %eax
   12584: 3c 01                        	cmpb	$1, %al
   12586: 77 a8                        	ja	0x12530 <bpf_object_open.part.0+0xda0>
; 		sname = elf_sym_str(obj, sym->st_name);
   12588: 44 8b 3b                     	movl	(%rbx), %r15d
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   1258b: 49 8b b6 e8 00 00 00         	movq	232(%r14), %rsi
   12592: 49 8b be c0 00 00 00         	movq	192(%r14), %rdi
   12599: 4c 89 fa                     	movq	%r15, %rdx
   1259c: e8 cf 32 ff ff               	callq	0x5870 <.plt.sec+0x200>
   125a1: 48 89 c6                     	movq	%rax, %rsi
; 	if (!name) {
   125a4: 48 85 c0                     	testq	%rax, %rax
   125a7: 0f 84 5d 01 00 00            	je	0x1270a <bpf_object_open.part.0+0xf7a>
; 		if (strcmp(name, sname) == 0) {
   125ad: 48 89 ef                     	movq	%rbp, %rdi
   125b0: e8 fb 33 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   125b5: 85 c0                        	testl	%eax, %eax
   125b7: 74 0e                        	je	0x125c7 <bpf_object_open.part.0+0xe37>
   125b9: 48 8b 44 24 10               	movq	16(%rsp), %rax
   125be: 48 8b 70 10                  	movq	16(%rax), %rsi
   125c2: e9 69 ff ff ff               	jmp	0x12530 <bpf_object_open.part.0+0xda0>
; 			*off = sym->st_value;
   125c7: 48 89 dd                     	movq	%rbx, %rbp
   125ca: 48 8b 5c 24 40               	movq	64(%rsp), %rbx
   125cf: 48 8b 45 08                  	movq	8(%rbp), %rax
   125d3: 89 43 04                     	movl	%eax, 4(%rbx)
; 	for (i = 0, vsi = btf_var_secinfos(t); i < vars; i++, vsi++) {
   125d6: 48 83 c3 0c                  	addq	$12, %rbx
   125da: 48 3b 5c 24 28               	cmpq	40(%rsp), %rbx
   125df: 0f 85 cb fe ff ff            	jne	0x124b0 <bpf_object_open.part.0+0xd20>
   125e5: 4c 8b 7c 24 18               	movq	24(%rsp), %r15
   125ea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	qsort(btf_var_secinfos(t), vars, sizeof(*vsi), compare_vsi_off);
   125f0: 8b 74 24 48                  	movl	72(%rsp), %esi
   125f4: 48 8b 7c 24 50               	movq	80(%rsp), %rdi
   125f9: ba 0c 00 00 00               	movl	$12, %edx
   125fe: 48 8d 0d eb 3e ff ff         	leaq	-49429(%rip), %rcx      # 0x64f0 <compare_vsi_off>
   12605: e8 56 31 ff ff               	callq	0x5760 <.plt.sec+0xf0>
; 			if (err)
   1260a: e9 e1 fd ff ff               	jmp	0x123f0 <bpf_object_open.part.0+0xc60>
   1260f: 90                           	nop
   12610: 4d 89 f7                     	movq	%r14, %r15
; 			pr_debug("No offset found in symbol table for VAR %s\n",
   12613: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   12618: 48 8d 35 81 38 02 00         	leaq	145537(%rip), %rsi      # 0x35ea0 <strs.2+0x3010>
   1261f: bf 02 00 00 00               	movl	$2, %edi
   12624: 31 c0                        	xorl	%eax, %eax
   12626: 48 c7 c3 fe ff ff ff         	movq	$-2, %rbx
   1262d: bd 02 00 00 00               	movl	$2, %ebp
; 			return -ENOENT;
   12632: 41 bc fe ff ff ff            	movl	$4294967294, %r12d      # imm = 0xFFFFFFFE
; 			pr_debug("No offset found in symbol table for VAR %s\n",
   12638: e8 93 5a ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   1263d: e8 ae 30 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("Error finalizing %s: %d.\n", BTF_ELF_SEC, err);
   12642: 44 89 e1                     	movl	%r12d, %ecx
   12645: 48 8d 15 12 f8 01 00         	leaq	129042(%rip), %rdx      # 0x31e5e <_IO_stdin_used+0x1e5e>
   1264c: 31 ff                        	xorl	%edi, %edi
; 		errno = -ret;
   1264e: 89 28                        	movl	%ebp, (%rax)
; 		pr_warn("Error finalizing %s: %d.\n", BTF_ELF_SEC, err);
   12650: 48 8d 35 a1 44 02 00         	leaq	148641(%rip), %rsi      # 0x36af8 <strs.2+0x3c68>
   12657: 31 c0                        	xorl	%eax, %eax
   12659: e8 72 5a ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
   1265e: e9 95 f5 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   12663: 4d 89 f7                     	movq	%r14, %r15
   12666: 4c 8b 74 24 58               	movq	88(%rsp), %r14
; 	err = err ? : bpf_object__init_maps(obj, opts);
   1266b: 4c 89 f6                     	movq	%r14, %rsi
   1266e: 4c 89 ff                     	movq	%r15, %rdi
   12671: e8 3a d8 ff ff               	callq	0xfeb0 <bpf_object__init_maps>
; 	err = err ? : bpf_object_init_progs(obj, opts);
   12676: 85 c0                        	testl	%eax, %eax
   12678: 0f 85 2b 11 00 00            	jne	0x137a9 <bpf_object_open.part.0+0x2019>
; 	bpf_object__for_each_program(prog, obj) {
   1267e: 31 f6                        	xorl	%esi, %esi
   12680: 4c 89 ff                     	movq	%r15, %rdi
; 			pr_debug("prog '%s': unrecognized ELF section name '%s'\n",
   12683: 4c 8d 25 4e 38 02 00         	leaq	145486(%rip), %r12      # 0x35ed8 <strs.2+0x3048>
; 	bpf_object__for_each_program(prog, obj) {
   1268a: e8 81 c5 ff ff               	callq	0xec10 <bpf_object__next_program>
   1268f: 48 89 c5                     	movq	%rax, %rbp
   12692: 48 85 c0                     	testq	%rax, %rax
   12695: 75 48                        	jne	0x126df <bpf_object_open.part.0+0xf4f>
   12697: e9 b3 00 00 00               	jmp	0x1274f <bpf_object_open.part.0+0xfbf>
   1269c: 0f 1f 40 00                  	nopl	(%rax)
; 		prog->type = prog->sec_def->prog_type;
   126a0: 8b 50 08                     	movl	8(%rax), %edx
   126a3: 89 95 80 00 00 00            	movl	%edx, 128(%rbp)
; 		prog->expected_attach_type = prog->sec_def->expected_attach_type;
   126a9: 8b 50 0c                     	movl	12(%rax), %edx
   126ac: 89 95 84 00 00 00            	movl	%edx, 132(%rbp)
; 		if (prog->sec_def->prog_setup_fn) {
   126b2: 48 8b 50 20                  	movq	32(%rax), %rdx
   126b6: 48 85 d2                     	testq	%rdx, %rdx
   126b9: 74 11                        	je	0x126cc <bpf_object_open.part.0+0xf3c>
; 			err = prog->sec_def->prog_setup_fn(prog, prog->sec_def->cookie);
   126bb: 48 8b 70 10                  	movq	16(%rax), %rsi
   126bf: 48 89 ef                     	movq	%rbp, %rdi
   126c2: ff d2                        	callq	*%rdx
; 			if (err < 0) {
   126c4: 85 c0                        	testl	%eax, %eax
   126c6: 0f 88 bf 10 00 00            	js	0x1378b <bpf_object_open.part.0+0x1ffb>
; 	bpf_object__for_each_program(prog, obj) {
   126cc: 48 89 ee                     	movq	%rbp, %rsi
   126cf: 4c 89 ff                     	movq	%r15, %rdi
   126d2: e8 39 c5 ff ff               	callq	0xec10 <bpf_object__next_program>
   126d7: 48 89 c5                     	movq	%rax, %rbp
   126da: 48 85 c0                     	testq	%rax, %rax
   126dd: 74 70                        	je	0x1274f <bpf_object_open.part.0+0xfbf>
; 		prog->sec_def = find_sec_def(prog->sec_name);
   126df: 4c 8b 6d 08                  	movq	8(%rbp), %r13
   126e3: 4c 89 ef                     	movq	%r13, %rdi
   126e6: e8 f5 50 ff ff               	callq	0x77e0 <find_sec_def>
   126eb: 48 89 45 18                  	movq	%rax, 24(%rbp)
; 		if (!prog->sec_def) {
   126ef: 48 85 c0                     	testq	%rax, %rax
   126f2: 75 ac                        	jne	0x126a0 <bpf_object_open.part.0+0xf10>
; 			pr_debug("prog '%s': unrecognized ELF section name '%s'\n",
   126f4: 48 8b 55 00                  	movq	(%rbp), %rdx
   126f8: 4c 89 e9                     	movq	%r13, %rcx
   126fb: 4c 89 e6                     	movq	%r12, %rsi
   126fe: bf 02 00 00 00               	movl	$2, %edi
   12703: e8 c8 59 ff ff               	callq	0x80d0 <libbpf_print>
; 			continue;
   12708: eb c2                        	jmp	0x126cc <bpf_object_open.part.0+0xf3c>
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   1270a: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   1270f: 4c 89 fd                     	movq	%r15, %rbp
   12712: 4d 89 f7                     	movq	%r14, %r15
   12715: e8 46 33 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   1271a: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   1271f: 48 89 ea                     	movq	%rbp, %rdx
   12722: 31 ff                        	xorl	%edi, %edi
   12724: 49 89 c0                     	movq	%rax, %r8
   12727: 48 8d 35 b2 16 02 00         	leaq	136882(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
   1272e: 31 c0                        	xorl	%eax, %eax
   12730: e8 9b 59 ff ff               	callq	0x80d0 <libbpf_print>
; 			pr_warn("failed to get sym name string for var %s\n", name);
   12735: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   1273a: 31 ff                        	xorl	%edi, %edi
   1273c: 31 c0                        	xorl	%eax, %eax
   1273e: 48 8d 35 23 37 02 00         	leaq	145187(%rip), %rsi      # 0x35e68 <strs.2+0x2fd8>
   12745: e8 86 59 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (ret) {
   1274a: e9 c4 fe ff ff               	jmp	0x12613 <bpf_object_open.part.0+0xe83>
; 	for (i = 0; i < obj->efile.sec_cnt; i++) {
   1274f: 49 63 8f f8 00 00 00         	movslq	248(%r15), %rcx
   12756: 31 db                        	xorl	%ebx, %ebx
   12758: 85 c9                        	testl	%ecx, %ecx
   1275a: 0f 8e 2b 04 00 00            	jle	0x12b8b <bpf_object_open.part.0+0x13fb>
   12760: 48 89 5c 24 08               	movq	%rbx, 8(%rsp)
   12765: 0f 1f 00                     	nopl	(%rax)
; 		struct elf_sec_desc *sec_desc = &obj->efile.secs[i];
   12768: 48 8b 44 24 08               	movq	8(%rsp), %rax
   1276d: 49 8b 97 f0 00 00 00         	movq	240(%r15), %rdx
   12774: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   12778: 48 8d 04 c2                  	leaq	(%rdx,%rax,8), %rax
; 		if (sec_desc->sec_type != SEC_RELO)
   1277c: 83 38 01                     	cmpl	$1, (%rax)
   1277f: 0f 85 f3 03 00 00            	jne	0x12b78 <bpf_object_open.part.0+0x13e8>
; 		shdr = sec_desc->shdr;
   12785: 48 8b 68 08                  	movq	8(%rax), %rbp
; 		data = sec_desc->data;
   12789: 48 8b 40 10                  	movq	16(%rax), %rax
; 		if (shdr->sh_type != SHT_REL) {
   1278d: 83 7d 04 09                  	cmpl	$9, 4(%rbp)
; 		data = sec_desc->data;
   12791: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 		idx = shdr->sh_info;
   12796: 8b 45 2c                     	movl	44(%rbp), %eax
; 		if (shdr->sh_type != SHT_REL) {
   12799: 0f 85 08 13 00 00            	jne	0x13aa7 <bpf_object_open.part.0+0x2317>
; 		if (idx == obj->efile.st_ops_shndx)
   1279f: 41 3b 87 0c 01 00 00         	cmpl	268(%r15), %eax
   127a6: 0f 84 a4 08 00 00            	je	0x13050 <bpf_object_open.part.0+0x18c0>
; 		else if (idx == obj->efile.btf_maps_shndx)
   127ac: 41 3b 87 fc 00 00 00         	cmpl	252(%r15), %eax
   127b3: 0f 84 a7 04 00 00            	je	0x12c60 <bpf_object_open.part.0+0x14d0>
; 	size_t sec_idx = shdr->sh_info, sym_idx;
   127b9: 89 c6                        	movl	%eax, %esi
   127bb: 48 89 74 24 28               	movq	%rsi, 40(%rsp)
; 	if (sec_idx >= obj->efile.sec_cnt)
   127c0: 48 39 ce                     	cmpq	%rcx, %rsi
   127c3: 0f 83 9f 09 00 00            	jae	0x13168 <bpf_object_open.part.0+0x19d8>
; 	scn = elf_getscn(obj->efile.elf, idx);
   127c9: 49 8b bf c0 00 00 00         	movq	192(%r15), %rdi
   127d0: e8 2b 34 ff ff               	callq	0x5c00 <.plt.sec+0x590>
   127d5: 49 89 c5                     	movq	%rax, %r13
; 	if (!scn) {
   127d8: 48 85 c0                     	testq	%rax, %rax
   127db: 0f 84 18 15 00 00            	je	0x13cf9 <bpf_object_open.part.0+0x2569>
; 	scn_data = elf_sec_data(obj, scn);
   127e1: 4c 89 ee                     	movq	%r13, %rsi
   127e4: 4c 89 ff                     	movq	%r15, %rdi
   127e7: e8 c4 87 ff ff               	callq	0xafb0 <elf_sec_data>
; 	relo_sec_name = elf_sec_str(obj, shdr->sh_name);
   127ec: 44 8b 75 00                  	movl	(%rbp), %r14d
; 	name = elf_strptr(obj->efile.elf, obj->efile.shstrndx, off);
   127f0: 49 8b b7 e0 00 00 00         	movq	224(%r15), %rsi
   127f7: 49 8b bf c0 00 00 00         	movq	192(%r15), %rdi
; 	scn_data = elf_sec_data(obj, scn);
   127fe: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 	name = elf_strptr(obj->efile.elf, obj->efile.shstrndx, off);
   12803: 4c 89 f2                     	movq	%r14, %rdx
   12806: e8 65 30 ff ff               	callq	0x5870 <.plt.sec+0x200>
   1280b: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	if (!name) {
   12810: 48 85 c0                     	testq	%rax, %rax
   12813: 0f 84 a4 14 00 00            	je	0x13cbd <bpf_object_open.part.0+0x252d>
; 	sec_name = elf_sec_name(obj, scn);
   12819: 4c 89 ee                     	movq	%r13, %rsi
   1281c: 4c 89 ff                     	movq	%r15, %rdi
   1281f: e8 1c 83 ff ff               	callq	0xab40 <elf_sec_name>
   12824: 48 89 44 24 68               	movq	%rax, 104(%rsp)
; 	if (!relo_sec_name || !sec_name)
   12829: 48 85 c0                     	testq	%rax, %rax
   1282c: 0f 84 36 09 00 00            	je	0x13168 <bpf_object_open.part.0+0x19d8>
; 	pr_debug("sec '%s': collecting relocation for section(%zu) '%s'\n",
   12832: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   12837: 48 8b 4c 24 28               	movq	40(%rsp), %rcx
   1283c: 49 89 c0                     	movq	%rax, %r8
   1283f: 48 8d 35 ea 3b 02 00         	leaq	146410(%rip), %rsi      # 0x36430 <strs.2+0x35a0>
   12846: 31 c0                        	xorl	%eax, %eax
   12848: bf 02 00 00 00               	movl	$2, %edi
   1284d: e8 7e 58 ff ff               	callq	0x80d0 <libbpf_print>
; 	nrels = shdr->sh_size / shdr->sh_entsize;
   12852: 48 8b 45 20                  	movq	32(%rbp), %rax
   12856: 31 d2                        	xorl	%edx, %edx
   12858: 48 f7 75 38                  	divq	56(%rbp)
; 	for (i = 0; i < nrels; i++) {
   1285c: 85 c0                        	testl	%eax, %eax
   1285e: 0f 8e 06 03 00 00            	jle	0x12b6a <bpf_object_open.part.0+0x13da>
   12864: 83 e8 01                     	subl	$1, %eax
   12867: 45 31 e4                     	xorl	%r12d, %r12d
   1286a: 48 89 44 24 50               	movq	%rax, 80(%rsp)
; 	if (idx >= data->d_size / sizeof(Elf64_Rel))
   1286f: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   12874: 45 89 e5                     	movl	%r12d, %r13d
   12877: 48 8b 41 10                  	movq	16(%rcx), %rax
   1287b: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   12880: 48 c1 e8 04                  	shrq	$4, %rax
   12884: 4c 39 e0                     	cmpq	%r12, %rax
   12887: 0f 86 9b 07 00 00            	jbe	0x13028 <bpf_object_open.part.0+0x1898>
; 	return (Elf64_Rel *)data->d_buf + idx;
   1288d: 4c 89 e3                     	movq	%r12, %rbx
   12890: 48 c1 e3 04                  	shlq	$4, %rbx
; 		if (!rel) {
   12894: 48 03 19                     	addq	(%rcx), %rbx
   12897: 48 89 5c 24 18               	movq	%rbx, 24(%rsp)
   1289c: 0f 84 86 07 00 00            	je	0x13028 <bpf_object_open.part.0+0x1898>
; 		sym_idx = ELF64_R_SYM(rel->r_info);
   128a2: 48 8b 44 24 18               	movq	24(%rsp), %rax
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   128a7: 49 8b b7 d0 00 00 00         	movq	208(%r15), %rsi
; 		sym_idx = ELF64_R_SYM(rel->r_info);
   128ae: 8b 48 0c                     	movl	12(%rax), %ecx
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   128b1: 48 b8 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rax # imm = 0xAAAAAAAAAAAAAAAB
   128bb: 48 f7 66 10                  	mulq	16(%rsi)
   128bf: 48 c1 ea 04                  	shrq	$4, %rdx
   128c3: 48 39 d1                     	cmpq	%rdx, %rcx
   128c6: 0f 83 e4 0a 00 00            	jae	0x133b0 <bpf_object_open.part.0+0x1c20>
; 	return (Elf64_Sym *)obj->efile.symbols->d_buf + idx;
   128cc: 48 8b 16                     	movq	(%rsi), %rdx
   128cf: 48 8d 04 49                  	leaq	(%rcx,%rcx,2), %rax
   128d3: 48 8d 1c c2                  	leaq	(%rdx,%rax,8), %rbx
; 		if (!sym) {
   128d7: 48 85 db                     	testq	%rbx, %rbx
   128da: 0f 84 d0 0a 00 00            	je	0x133b0 <bpf_object_open.part.0+0x1c20>
; 		if (sym->st_shndx >= obj->efile.sec_cnt) {
   128e0: 0f b7 43 06                  	movzwl	6(%rbx), %eax
   128e4: 49 89 c0                     	movq	%rax, %r8
   128e7: 41 3b 87 f8 00 00 00         	cmpl	248(%r15), %eax
   128ee: 0f 8d 94 14 00 00            	jge	0x13d88 <bpf_object_open.part.0+0x25f8>
; 		if (rel->r_offset % BPF_INSN_SZ || rel->r_offset >= scn_data->d_size) {
   128f4: 48 8b 44 24 18               	movq	24(%rsp), %rax
   128f9: 48 8b 28                     	movq	(%rax), %rbp
   128fc: 40 f6 c5 07                  	testb	$7, %bpl
   12900: 0f 85 0d 13 00 00            	jne	0x13c13 <bpf_object_open.part.0+0x2483>
   12906: 48 8b 44 24 40               	movq	64(%rsp), %rax
   1290b: 48 3b 68 10                  	cmpq	16(%rax), %rbp
   1290f: 0f 83 fe 12 00 00            	jae	0x13c13 <bpf_object_open.part.0+0x2483>
; 		if (ELF64_ST_TYPE(sym->st_info) == STT_SECTION && sym->st_name == 0)
   12915: 0f b6 43 04                  	movzbl	4(%rbx), %eax
   12919: 8b 13                        	movl	(%rbx), %edx
; 		insn_idx = rel->r_offset / BPF_INSN_SZ;
   1291b: 48 c1 ed 03                  	shrq	$3, %rbp
; 	scn = elf_getscn(obj->efile.elf, idx);
   1291f: 49 8b bf c0 00 00 00         	movq	192(%r15), %rdi
; 		if (ELF64_ST_TYPE(sym->st_info) == STT_SECTION && sym->st_name == 0)
   12926: 83 e0 0f                     	andl	$15, %eax
   12929: 3c 03                        	cmpb	$3, %al
   1292b: 75 08                        	jne	0x12935 <bpf_object_open.part.0+0x11a5>
   1292d: 85 d2                        	testl	%edx, %edx
   1292f: 0f 84 23 0b 00 00            	je	0x13458 <bpf_object_open.part.0+0x1cc8>
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   12935: 49 8b b7 e8 00 00 00         	movq	232(%r15), %rsi
; 			sym_name = elf_sym_str(obj, sym->st_name);
   1293c: 41 89 d6                     	movl	%edx, %r14d
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   1293f: 4c 89 f2                     	movq	%r14, %rdx
   12942: e8 29 2f ff ff               	callq	0x5870 <.plt.sec+0x200>
   12947: 49 89 c1                     	movq	%rax, %r9
; 	if (!name) {
   1294a: 48 85 c0                     	testq	%rax, %rax
   1294d: 0f 84 f8 12 00 00            	je	0x13c4b <bpf_object_open.part.0+0x24bb>
; 		pr_debug("sec '%s': relo #%d: insn #%u against '%s'\n",
   12953: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   12958: 31 c0                        	xorl	%eax, %eax
   1295a: 41 89 e8                     	movl	%ebp, %r8d
   1295d: 44 89 e9                     	movl	%r13d, %ecx
   12960: 48 8d 35 01 3c 02 00         	leaq	146433(%rip), %rsi      # 0x36568 <strs.2+0x36d8>
   12967: bf 02 00 00 00               	movl	$2, %edi
   1296c: 4c 89 4c 24 38               	movq	%r9, 56(%rsp)
   12971: e8 5a 57 ff ff               	callq	0x80d0 <libbpf_print>
; 		prog = find_prog_by_sec_insn(obj, sec_idx, insn_idx);
   12976: 48 8b 74 24 28               	movq	40(%rsp), %rsi
   1297b: 89 ea                        	movl	%ebp, %edx
   1297d: 4c 89 ff                     	movq	%r15, %rdi
   12980: e8 9b 3b ff ff               	callq	0x6520 <find_prog_by_sec_insn>
; 		if (!prog) {
   12985: 4c 8b 4c 24 38               	movq	56(%rsp), %r9
   1298a: 48 85 c0                     	testq	%rax, %rax
; 		prog = find_prog_by_sec_insn(obj, sec_idx, insn_idx);
   1298d: 49 89 c6                     	movq	%rax, %r14
; 		if (!prog) {
   12990: 0f 84 9a 0d 00 00            	je	0x13730 <bpf_object_open.part.0+0x1fa0>
; 		relos = libbpf_reallocarray(prog->reloc_desc,
   12996: 48 8b 78 48                  	movq	72(%rax), %rdi
; 					    prog->nr_reloc + 1, sizeof(*relos));
   1299a: 8b 40 50                     	movl	80(%rax), %eax
   1299d: 4c 89 4c 24 38               	movq	%r9, 56(%rsp)
   129a2: 83 c0 01                     	addl	$1, %eax
; 		relos = libbpf_reallocarray(prog->reloc_desc,
   129a5: 48 98                        	cltq
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   129a7: 48 89 c6                     	movq	%rax, %rsi
   129aa: 48 c1 e6 04                  	shlq	$4, %rsi
   129ae: 48 c1 e8 3c                  	shrq	$60, %rax
   129b2: 0f 95 c0                     	setne	%al
   129b5: 0f b6 c0                     	movzbl	%al, %eax
   129b8: 48 89 44 24 58               	movq	%rax, 88(%rsp)
   129bd: 48 85 c0                     	testq	%rax, %rax
   129c0: 0f 85 43 f1 ff ff            	jne	0x11b09 <bpf_object_open.part.0+0x379>
; 	return realloc(ptr, total);
   129c6: e8 55 31 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 		if (!relos)
   129cb: 48 85 c0                     	testq	%rax, %rax
   129ce: 0f 84 35 f1 ff ff            	je	0x11b09 <bpf_object_open.part.0+0x379>
; 		err = bpf_program__record_reloc(prog, &relos[prog->nr_reloc],
   129d4: 49 63 56 50                  	movslq	80(%r14), %rdx
; 		insn_idx -= prog->sec_insn_off;
   129d8: 41 89 ea                     	movl	%ebp, %r10d
; 	size_t map_idx, nr_maps = prog->obj->nr_maps;
   129db: 49 8b 6e 70                  	movq	112(%r14), %rbp
; 		prog->reloc_desc = relos;
   129df: 49 89 46 48                  	movq	%rax, 72(%r14)
; 		insn_idx -= prog->sec_insn_off;
   129e3: 45 2b 56 20                  	subl	32(%r14), %r10d
; 	__u32 shdr_idx = sym->st_shndx;
   129e7: 44 0f b7 5b 06               	movzwl	6(%rbx), %r11d
; 		err = bpf_program__record_reloc(prog, &relos[prog->nr_reloc],
   129ec: 48 89 d1                     	movq	%rdx, %rcx
   129ef: 48 c1 e2 04                  	shlq	$4, %rdx
; 	size_t map_idx, nr_maps = prog->obj->nr_maps;
   129f3: 48 8b 75 70                  	movq	112(%rbp), %rsi
; 	if (!is_call_insn(insn) && !is_ldimm64_insn(insn)) {
   129f7: 4c 8b 4c 24 38               	movq	56(%rsp), %r9
; 		err = bpf_program__record_reloc(prog, &relos[prog->nr_reloc],
   129fc: 4c 8d 2c 10                  	leaq	(%rax,%rdx), %r13
; 	struct bpf_insn *insn = &prog->insns[insn_idx];
   12a00: 49 8b 46 38                  	movq	56(%r14), %rax
   12a04: 44 89 d2                     	movl	%r10d, %edx
; 	__u32 shdr_idx = sym->st_shndx;
   12a07: 45 89 d8                     	movl	%r11d, %r8d
; 	size_t map_idx, nr_maps = prog->obj->nr_maps;
   12a0a: 48 89 74 24 60               	movq	%rsi, 96(%rsp)
; 	struct bpf_insn *insn = &prog->insns[insn_idx];
   12a0f: 48 8d 04 d0                  	leaq	(%rax,%rdx,8), %rax
; 	__u32 shdr_idx = sym->st_shndx;
   12a13: 4c 89 da                     	movq	%r11, %rdx
; 	return insn->code == (BPF_JMP | BPF_CALL);
   12a16: 0f b6 30                     	movzbl	(%rax), %esi
; 	struct bpf_insn *insn = &prog->insns[insn_idx];
   12a19: 48 89 44 24 48               	movq	%rax, 72(%rsp)
; 	if (!is_call_insn(insn) && !is_ldimm64_insn(insn)) {
   12a1e: 40 80 fe 85                  	cmpb	$-123, %sil
   12a22: 74 0a                        	je	0x12a2e <bpf_object_open.part.0+0x129e>
   12a24: 40 80 fe 18                  	cmpb	$24, %sil
   12a28: 0f 85 0d 1e 00 00            	jne	0x1483b <bpf_object_open.part.0+0x30ab>
; 	if (sym_is_extern(sym)) {
   12a2e: 0f b6 7b 04                  	movzbl	4(%rbx), %edi
; 	int bind = ELF64_ST_BIND(sym->st_info);
   12a32: 89 f8                        	movl	%edi, %eax
   12a34: c0 e8 04                     	shrb	$4, %al
; 	       (bind == STB_GLOBAL || bind == STB_WEAK) &&
   12a37: 66 85 d2                     	testw	%dx, %dx
   12a3a: 0f 84 90 05 00 00            	je	0x12fd0 <bpf_object_open.part.0+0x1840>
; 	if (is_call_insn(insn)) {
   12a40: 40 80 fe 85                  	cmpb	$-123, %sil
   12a44: 0f 84 da 25 00 00            	je	0x15024 <bpf_object_open.part.0+0x3894>
; 	if (!shdr_idx || shdr_idx >= SHN_LORESERVE) {
   12a4a: 41 8d 73 ff                  	leal	-1(%r11), %esi
   12a4e: 81 fe fe fe 00 00            	cmpl	$65278, %esi            # imm = 0xFEFE
   12a54: 0f 87 aa 25 00 00            	ja	0x15004 <bpf_object_open.part.0+0x3874>
; 	if (sym->st_shndx != text_shndx)
   12a5a: 44 39 9d 04 01 00 00         	cmpl	%r11d, 260(%rbp)
   12a61: 0f 84 ae 0b 00 00            	je	0x13615 <bpf_object_open.part.0+0x1e85>
; 	scn = elf_getscn(obj->efile.elf, idx);
   12a67: 48 8b bd c0 00 00 00         	movq	192(%rbp), %rdi
; 	if (shndx == obj->efile.symbols_shndx)
   12a6e: 44 3b 9d 08 01 00 00         	cmpl	264(%rbp), %r11d
   12a75: 0f 84 55 14 00 00            	je	0x13ed0 <bpf_object_open.part.0+0x2740>
; 	switch (obj->efile.secs[shndx].sec_type) {
   12a7b: 4c 8b 85 f0 00 00 00         	movq	240(%rbp), %r8
   12a82: 48 8d 04 52                  	leaq	(%rdx,%rdx,2), %rax
   12a86: 49 8d 04 c0                  	leaq	(%r8,%rax,8), %rax
   12a8a: 8b 00                        	movl	(%rax), %eax
   12a8c: 83 e8 02                     	subl	$2, %eax
   12a8f: 83 f8 02                     	cmpl	$2, %eax
   12a92: 0f 87 56 10 00 00            	ja	0x13aee <bpf_object_open.part.0+0x235e>
   12a98: 48 8d 0d 31 03 02 00         	leaq	131889(%rip), %rcx      # 0x32dd0 <CSWTCH.547>
; 	scn = elf_getscn(obj->efile.elf, idx);
   12a9f: 48 89 d6                     	movq	%rdx, %rsi
   12aa2: 44 89 54 24 78               	movl	%r10d, 120(%rsp)
   12aa7: 8b 04 81                     	movl	(%rcx,%rax,4), %eax
   12aaa: 4c 89 4c 24 70               	movq	%r9, 112(%rsp)
   12aaf: 44 89 5c 24 48               	movl	%r11d, 72(%rsp)
   12ab4: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
   12ab9: 89 44 24 38                  	movl	%eax, 56(%rsp)
   12abd: e8 3e 31 ff ff               	callq	0x5c00 <.plt.sec+0x590>
; 	if (!scn) {
   12ac2: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   12ac7: 44 8b 5c 24 48               	movl	72(%rsp), %r11d
   12acc: 48 85 c0                     	testq	%rax, %rax
   12acf: 4c 8b 4c 24 70               	movq	112(%rsp), %r9
   12ad4: 44 8b 54 24 78               	movl	120(%rsp), %r10d
; 	scn = elf_getscn(obj->efile.elf, idx);
   12ad9: 48 89 c6                     	movq	%rax, %rsi
; 	if (!scn) {
   12adc: 0f 84 03 1d 00 00            	je	0x147e5 <bpf_object_open.part.0+0x3055>
; 	sym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));
   12ae2: 48 89 ef                     	movq	%rbp, %rdi
   12ae5: 44 89 94 24 80 00 00 00      	movl	%r10d, 128(%rsp)
   12aed: 4c 89 4c 24 78               	movq	%r9, 120(%rsp)
   12af2: 44 89 5c 24 70               	movl	%r11d, 112(%rsp)
   12af7: 48 89 54 24 48               	movq	%rdx, 72(%rsp)
   12afc: e8 3f 80 ff ff               	callq	0xab40 <elf_sec_name>
; 	if (type == LIBBPF_MAP_UNSPEC) {
   12b01: 8b 7c 24 38                  	movl	56(%rsp), %edi
   12b05: 48 8b 54 24 48               	movq	72(%rsp), %rdx
   12b0a: 44 8b 5c 24 70               	movl	112(%rsp), %r11d
; 	sym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));
   12b0f: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	if (type == LIBBPF_MAP_UNSPEC) {
   12b14: 85 ff                        	testl	%edi, %edi
   12b16: 4c 8b 4c 24 78               	movq	120(%rsp), %r9
   12b1b: 44 8b 94 24 80 00 00 00      	movl	128(%rsp), %r10d
   12b23: 0f 84 2c 10 00 00            	je	0x13b55 <bpf_object_open.part.0+0x23c5>
; 	switch (obj->efile.secs[shndx].sec_type) {
   12b29: 4c 8b 9d f0 00 00 00         	movq	240(%rbp), %r11
   12b30: 48 8d 04 52                  	leaq	(%rdx,%rdx,2), %rax
   12b34: 49 8d 04 c3                  	leaq	(%r11,%rax,8), %rax
   12b38: 8b 00                        	movl	(%rax), %eax
   12b3a: 83 e8 02                     	subl	$2, %eax
   12b3d: 83 f8 02                     	cmpl	$2, %eax
   12b40: 0f 86 66 12 00 00            	jbe	0x13dac <bpf_object_open.part.0+0x261c>
; 		pr_warn("prog '%s': bad data relo against section '%s'\n",
   12b46: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   12b4b: 49 8b 16                     	movq	(%r14), %rdx
   12b4e: 31 ff                        	xorl	%edi, %edi
   12b50: 31 c0                        	xorl	%eax, %eax
   12b52: 48 8d 35 4f 3d 02 00         	leaq	146767(%rip), %rsi      # 0x368a8 <strs.2+0x3a18>
   12b59: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   12b60: e8 6b 55 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   12b65: e9 8e f0 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   12b6a: 49 63 8f f8 00 00 00         	movslq	248(%r15), %rcx
   12b71: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	for (i = 0; i < obj->efile.sec_cnt; i++) {
   12b78: 48 83 44 24 08 01            	addq	$1, 8(%rsp)
   12b7e: 48 8b 44 24 08               	movq	8(%rsp), %rax
   12b83: 39 c1                        	cmpl	%eax, %ecx
   12b85: 0f 8f dd fb ff ff            	jg	0x12768 <bpf_object_open.part.0+0xfd8>
; 	for (i = 0; i < obj->nr_programs; i++) {
   12b8b: 31 db                        	xorl	%ebx, %ebx
   12b8d: 49 83 7f 60 00               	cmpq	$0, 96(%r15)
; 		qsort(p->reloc_desc, p->nr_reloc, sizeof(*p->reloc_desc), cmp_relocs);
   12b92: 48 8d 2d a7 46 ff ff         	leaq	-47449(%rip), %rbp      # 0x7240 <cmp_relocs>
; 	for (i = 0; i < obj->nr_programs; i++) {
   12b99: 74 34                        	je	0x12bcf <bpf_object_open.part.0+0x143f>
   12b9b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		struct bpf_program *p = &obj->programs[i];
   12ba0: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
   12ba4: 48 c1 e0 06                  	shlq	$6, %rax
   12ba8: 49 03 47 58                  	addq	88(%r15), %rax
; 		if (!p->nr_reloc)
   12bac: 48 63 70 50                  	movslq	80(%rax), %rsi
   12bb0: 85 f6                        	testl	%esi, %esi
   12bb2: 74 11                        	je	0x12bc5 <bpf_object_open.part.0+0x1435>
; 		qsort(p->reloc_desc, p->nr_reloc, sizeof(*p->reloc_desc), cmp_relocs);
   12bb4: 48 8b 78 48                  	movq	72(%rax), %rdi
   12bb8: 48 89 e9                     	movq	%rbp, %rcx
   12bbb: ba 10 00 00 00               	movl	$16, %edx
   12bc0: e8 9b 2b ff ff               	callq	0x5760 <.plt.sec+0xf0>
; 	for (i = 0; i < obj->nr_programs; i++) {
   12bc5: 48 83 c3 01                  	addq	$1, %rbx
   12bc9: 49 3b 5f 60                  	cmpq	96(%r15), %rbx
   12bcd: 72 d1                        	jb	0x12ba0 <bpf_object_open.part.0+0x1410>
; 	if (!obj->efile.elf)
   12bcf: 49 8b bf c0 00 00 00         	movq	192(%r15), %rdi
   12bd6: 48 85 ff                     	testq	%rdi, %rdi
   12bd9: 0f 84 3b ed ff ff            	je	0x1191a <bpf_object_open.part.0+0x18a>
; 	elf_end(obj->efile.elf);
   12bdf: e8 4c 2e ff ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	zfree(&obj->efile.secs);
   12be4: 49 8b bf f0 00 00 00         	movq	240(%r15), %rdi
; 	obj->efile.elf = NULL;
   12beb: 49 c7 87 c0 00 00 00 00 00 00 00     	movq	$0, 192(%r15)
; 	obj->efile.symbols = NULL;
   12bf6: 49 c7 87 d0 00 00 00 00 00 00 00     	movq	$0, 208(%r15)
; 	obj->efile.st_ops_data = NULL;
   12c01: 49 c7 87 d8 00 00 00 00 00 00 00     	movq	$0, 216(%r15)
; 	zfree(&obj->efile.secs);
   12c0c: e8 af 2a ff ff               	callq	0x56c0 <.plt.sec+0x50>
; 	zclose(obj->efile.fd);
   12c11: 41 8b bf a8 00 00 00         	movl	168(%r15), %edi
; 	zfree(&obj->efile.secs);
   12c18: 49 c7 87 f0 00 00 00 00 00 00 00     	movq	$0, 240(%r15)
; 	obj->efile.sec_cnt = 0;
   12c23: 41 c7 87 f8 00 00 00 00 00 00 00     	movl	$0, 248(%r15)
; 	zclose(obj->efile.fd);
   12c2e: 85 ff                        	testl	%edi, %edi
   12c30: 78 05                        	js	0x12c37 <bpf_object_open.part.0+0x14a7>
   12c32: e8 c9 2c ff ff               	callq	0x5900 <.plt.sec+0x290>
   12c37: 41 c7 87 a8 00 00 00 ff ff ff ff     	movl	$4294967295, 168(%r15) # imm = 0xFFFFFFFF
; 	obj->efile.obj_buf = NULL;
   12c42: 49 c7 87 b0 00 00 00 00 00 00 00     	movq	$0, 176(%r15)
; 	obj->efile.obj_buf_sz = 0;
   12c4d: 49 c7 87 b8 00 00 00 00 00 00 00     	movq	$0, 184(%r15)
   12c58: e9 bd ec ff ff               	jmp	0x1191a <bpf_object_open.part.0+0x18a>
   12c5d: 0f 1f 00                     	nopl	(%rax)
; 	if (!obj->efile.btf_maps_sec_btf_id || !obj->btf)
   12c60: 41 8b b7 00 01 00 00         	movl	256(%r15), %esi
   12c67: 85 f6                        	testl	%esi, %esi
   12c69: 0f 84 f9 04 00 00            	je	0x13168 <bpf_object_open.part.0+0x19d8>
   12c6f: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   12c76: 48 85 ff                     	testq	%rdi, %rdi
   12c79: 0f 84 e9 04 00 00            	je	0x13168 <bpf_object_open.part.0+0x19d8>
; 	sec = btf__type_by_id(obj->btf, obj->efile.btf_maps_sec_btf_id);
   12c7f: e8 1c 73 01 00               	callq	0x29fa0 <btf__type_by_id>
   12c84: 48 89 c3                     	movq	%rax, %rbx
; 	if (!sec)
   12c87: 48 85 c0                     	testq	%rax, %rax
   12c8a: 0f 84 d8 04 00 00            	je	0x13168 <bpf_object_open.part.0+0x19d8>
; 	nrels = shdr->sh_size / shdr->sh_entsize;
   12c90: 48 8b 45 20                  	movq	32(%rbp), %rax
   12c94: 31 d2                        	xorl	%edx, %edx
   12c96: 48 f7 75 38                  	divq	56(%rbp)
; 	for (i = 0; i < nrels; i++) {
   12c9a: 85 c0                        	testl	%eax, %eax
   12c9c: 0f 8e c8 fe ff ff            	jle	0x12b6a <bpf_object_open.part.0+0x13da>
   12ca2: 83 e8 01                     	subl	$1, %eax
   12ca5: 45 31 ed                     	xorl	%r13d, %r13d
   12ca8: 4c 89 fd                     	movq	%r15, %rbp
; 	struct bpf_program *targ_prog = NULL;
   12cab: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
   12cb4: 48 89 44 24 58               	movq	%rax, 88(%rsp)
; 	struct bpf_map *map = NULL, *targ_map = NULL;
   12cb9: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
; 	if (idx >= data->d_size / sizeof(Elf64_Rel))
   12cc2: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   12cc7: 44 89 6c 24 20               	movl	%r13d, 32(%rsp)
   12ccc: 48 8b 41 10                  	movq	16(%rcx), %rax
   12cd0: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   12cd5: 48 c1 e8 04                  	shrq	$4, %rax
   12cd9: 49 39 c5                     	cmpq	%rax, %r13
   12cdc: 0f 83 bc 08 00 00            	jae	0x1359e <bpf_object_open.part.0+0x1e0e>
; 	return (Elf64_Rel *)data->d_buf + idx;
   12ce2: 4d 89 ef                     	movq	%r13, %r15
   12ce5: 49 c1 e7 04                  	shlq	$4, %r15
; 		if (!rel) {
   12ce9: 4c 03 39                     	addq	(%rcx), %r15
   12cec: 0f 84 ac 08 00 00            	je	0x1359e <bpf_object_open.part.0+0x1e0e>
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   12cf2: 48 8b b5 d0 00 00 00         	movq	208(%rbp), %rsi
; 		sym = elf_sym_by_idx(obj, ELF64_R_SYM(rel->r_info));
   12cf9: 41 8b 4f 0c                  	movl	12(%r15), %ecx
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   12cfd: 48 b8 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rax # imm = 0xAAAAAAAAAAAAAAAB
   12d07: 48 f7 66 10                  	mulq	16(%rsi)
   12d0b: 48 c1 ea 04                  	shrq	$4, %rdx
   12d0f: 48 39 d1                     	cmpq	%rdx, %rcx
   12d12: 0f 83 51 09 00 00            	jae	0x13669 <bpf_object_open.part.0+0x1ed9>
; 	return (Elf64_Sym *)obj->efile.symbols->d_buf + idx;
   12d18: 48 8b 16                     	movq	(%rsi), %rdx
   12d1b: 48 8d 04 49                  	leaq	(%rcx,%rcx,2), %rax
   12d1f: 4c 8d 24 c2                  	leaq	(%rdx,%rax,8), %r12
; 		if (!sym) {
   12d23: 4d 85 e4                     	testq	%r12, %r12
   12d26: 0f 84 3d 09 00 00            	je	0x13669 <bpf_object_open.part.0+0x1ed9>
; 		name = elf_sym_str(obj, sym->st_name) ?: "<?>";
   12d2c: 45 8b 34 24                  	movl	(%r12), %r14d
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   12d30: 48 8b b5 e8 00 00 00         	movq	232(%rbp), %rsi
   12d37: 48 8b bd c0 00 00 00         	movq	192(%rbp), %rdi
   12d3e: 4c 89 f2                     	movq	%r14, %rdx
   12d41: e8 2a 2b ff ff               	callq	0x5870 <.plt.sec+0x200>
   12d46: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	if (!name) {
   12d4b: 48 85 c0                     	testq	%rax, %rax
   12d4e: 0f 84 14 08 00 00            	je	0x13568 <bpf_object_open.part.0+0x1dd8>
; 		pr_debug(".maps relo #%d: for %zd value %zd rel->r_offset %zu name %d ('%s')\n",
   12d54: 41 8b 04 24                  	movl	(%r12), %eax
   12d58: 4d 8b 44 24 08               	movq	8(%r12), %r8
   12d5d: bf 02 00 00 00               	movl	$2, %edi
   12d62: 48 8d 35 af 34 02 00         	leaq	144559(%rip), %rsi      # 0x36218 <strs.2+0x3388>
   12d69: 41 8b 4f 0c                  	movl	12(%r15), %ecx
   12d6d: 4d 8b 0f                     	movq	(%r15), %r9
   12d70: ff 74 24 18                  	pushq	24(%rsp)
   12d74: 50                           	pushq	%rax
   12d75: 31 c0                        	xorl	%eax, %eax
   12d77: 8b 54 24 30                  	movl	48(%rsp), %edx
   12d7b: e8 50 53 ff ff               	callq	0x80d0 <libbpf_print>
; 		for (j = 0; j < obj->nr_maps; j++) {
   12d80: 48 8b 7d 70                  	movq	112(%rbp), %rdi
   12d84: 41 5b                        	popq	%r11
   12d86: 41 5e                        	popq	%r14
   12d88: 48 85 ff                     	testq	%rdi, %rdi
   12d8b: 74 52                        	je	0x12ddf <bpf_object_open.part.0+0x164f>
; 			if (map->sec_idx != obj->efile.btf_maps_shndx)
   12d8d: 44 8b 8d fc 00 00 00         	movl	252(%rbp), %r9d
   12d94: 4c 8b 75 68                  	movq	104(%rbp), %r14
; 		for (j = 0; j < obj->nr_maps; j++) {
   12d98: 31 c0                        	xorl	%eax, %eax
   12d9a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			if (map->sec_idx != obj->efile.btf_maps_shndx)
   12da0: 45 39 4e 1c                  	cmpl	%r9d, 28(%r14)
   12da4: 75 29                        	jne	0x12dcf <bpf_object_open.part.0+0x163f>
; 			vi = btf_var_secinfos(sec) + map->btf_var_idx;
   12da6: 41 8b 56 48                  	movl	72(%r14), %edx
; 			if (vi->offset <= rel->r_offset &&
   12daa: 49 8b 0f                     	movq	(%r15), %rcx
; 			vi = btf_var_secinfos(sec) + map->btf_var_idx;
   12dad: 48 8d 54 52 03               	leaq	3(%rdx,%rdx,2), %rdx
   12db2: 4c 8d 04 93                  	leaq	(%rbx,%rdx,4), %r8
; 			if (vi->offset <= rel->r_offset &&
   12db6: 41 8b 70 04                  	movl	4(%r8), %esi
   12dba: 48 89 f2                     	movq	%rsi, %rdx
   12dbd: 48 39 ce                     	cmpq	%rcx, %rsi
   12dc0: 77 0d                        	ja	0x12dcf <bpf_object_open.part.0+0x163f>
; 			    rel->r_offset + bpf_ptr_sz <= vi->offset + vi->size)
   12dc2: 48 83 c1 08                  	addq	$8, %rcx
   12dc6: 41 03 50 08                  	addl	8(%r8), %edx
; 			if (vi->offset <= rel->r_offset &&
   12dca: 48 39 d1                     	cmpq	%rdx, %rcx
   12dcd: 76 3f                        	jbe	0x12e0e <bpf_object_open.part.0+0x167e>
; 		for (j = 0; j < obj->nr_maps; j++) {
   12dcf: 48 83 c0 01                  	addq	$1, %rax
   12dd3: 49 81 c6 a0 00 00 00         	addq	$160, %r14
   12dda: 48 39 f8                     	cmpq	%rdi, %rax
   12ddd: 75 c1                        	jne	0x12da0 <bpf_object_open.part.0+0x1610>
   12ddf: 4d 89 fc                     	movq	%r15, %r12
; 			pr_warn(".maps relo #%d: cannot find map '%s' at rel->r_offset %zu\n",
   12de2: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   12de7: 8b 54 24 20                  	movl	32(%rsp), %edx
   12deb: 31 ff                        	xorl	%edi, %edi
   12ded: 4d 8b 04 24                  	movq	(%r12), %r8
   12df1: 48 8d 35 70 34 02 00         	leaq	144496(%rip), %rsi      # 0x36268 <strs.2+0x33d8>
   12df8: 31 c0                        	xorl	%eax, %eax
   12dfa: 49 89 ef                     	movq	%rbp, %r15
   12dfd: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   12e04: e8 c7 52 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   12e09: e9 ea ed ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		is_map_in_map = bpf_map_type__is_map_in_map(map->def.type);
   12e0e: 41 8b 46 30                  	movl	48(%r14), %eax
; 	if (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
   12e12: 8d 50 f4                     	leal	-12(%rax), %edx
   12e15: 83 fa 01                     	cmpl	$1, %edx
   12e18: 0f 86 08 05 00 00            	jbe	0x13326 <bpf_object_open.part.0+0x1b96>
; 		} else if (is_prog_array) {
   12e1e: 83 f8 03                     	cmpl	$3, %eax
   12e21: 0f 85 a1 0c 00 00            	jne	0x13ac8 <bpf_object_open.part.0+0x2338>
; 			targ_prog = bpf_object__find_program_by_name(obj, name);
   12e27: 48 8b 74 24 18               	movq	24(%rsp), %rsi
   12e2c: 48 89 ef                     	movq	%rbp, %rdi
   12e2f: 4c 89 44 24 40               	movq	%r8, 64(%rsp)
   12e34: e8 87 be ff ff               	callq	0xecc0 <bpf_object__find_program_by_name>
; 			if (!targ_prog) {
   12e39: 4c 8b 44 24 40               	movq	64(%rsp), %r8
   12e3e: 48 85 c0                     	testq	%rax, %rax
; 			targ_prog = bpf_object__find_program_by_name(obj, name);
   12e41: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 			if (!targ_prog) {
   12e46: 0f 84 5b 1a 00 00            	je	0x148a7 <bpf_object_open.part.0+0x3117>
; 			if (targ_prog->sec_idx != sym->st_shndx ||
   12e4c: 48 8b 4c 24 28               	movq	40(%rsp), %rcx
   12e51: 41 0f b7 44 24 06            	movzwl	6(%r12), %eax
   12e57: 48 8b 51 10                  	movq	16(%rcx), %rdx
   12e5b: 48 39 c2                     	cmpq	%rax, %rdx
   12e5e: 0f 85 ff 08 00 00            	jne	0x13763 <bpf_object_open.part.0+0x1fd3>
; 			    targ_prog->sec_insn_off * 8 != sym->st_value ||
   12e64: 48 8b 41 20                  	movq	32(%rcx), %rax
   12e68: 48 89 44 24 40               	movq	%rax, 64(%rsp)
   12e6d: 48 c1 e0 03                  	shlq	$3, %rax
; 			if (targ_prog->sec_idx != sym->st_shndx ||
   12e71: 49 3b 44 24 08               	cmpq	8(%r12), %rax
   12e76: 0f 85 e7 08 00 00            	jne	0x13763 <bpf_object_open.part.0+0x1fd3>
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   12e7c: 48 63 85 04 01 00 00         	movslq	260(%rbp), %rax
; 	return false;
   12e83: c6 44 24 40 00               	movb	$0, 64(%rsp)
; 		type = is_map_in_map ? "map" : "prog";
   12e88: 4c 8d 25 e9 f1 01 00         	leaq	127465(%rip), %r12      # 0x32078 <_IO_stdin_used+0x2078>
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   12e8f: 48 39 c2                     	cmpq	%rax, %rdx
   12e92: 0f 84 c0 08 00 00            	je	0x13758 <bpf_object_open.part.0+0x1fc8>
; 		var = btf__type_by_id(obj->btf, vi->type);
   12e98: 41 8b 30                     	movl	(%r8), %esi
   12e9b: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   12ea2: 4c 89 44 24 50               	movq	%r8, 80(%rsp)
   12ea7: e8 f4 70 01 00               	callq	0x29fa0 <btf__type_by_id>
; 		def = skip_mods_and_typedefs(obj->btf, var->type, NULL);
   12eac: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   12eb3: 31 d2                        	xorl	%edx, %edx
   12eb5: 8b 70 08                     	movl	8(%rax), %esi
   12eb8: e8 b3 86 ff ff               	callq	0xb570 <skip_mods_and_typedefs>
   12ebd: 48 89 c2                     	movq	%rax, %rdx
; 	return BTF_INFO_VLEN(t->info);
   12ec0: 8b 40 04                     	movl	4(%rax), %eax
; 		if (btf_vlen(def) == 0)
   12ec3: 66 85 c0                     	testw	%ax, %ax
   12ec6: 0f 84 fc 0b 00 00            	je	0x13ac8 <bpf_object_open.part.0+0x2338>
; 		member = btf_members(def) + btf_vlen(def) - 1;
   12ecc: 0f b7 c0                     	movzwl	%ax, %eax
; 		mname = btf__name_by_offset(obj->btf, member->name_off);
   12ecf: 48 8b bd 10 01 00 00         	movq	272(%rbp), %rdi
   12ed6: 48 89 54 24 48               	movq	%rdx, 72(%rsp)
   12edb: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   12edf: 8b 34 82                     	movl	(%rdx,%rax,4), %esi
   12ee2: e8 09 8c 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 		if (strcmp(mname, "values"))
   12ee7: 48 8d 35 38 f0 01 00         	leaq	127032(%rip), %rsi      # 0x31f26 <_IO_stdin_used+0x1f26>
; 		mname = btf__name_by_offset(obj->btf, member->name_off);
   12eee: 48 89 c7                     	movq	%rax, %rdi
; 		if (strcmp(mname, "values"))
   12ef1: e8 ba 2a ff ff               	callq	0x59b0 <.plt.sec+0x340>
   12ef6: 85 c0                        	testl	%eax, %eax
   12ef8: 0f 85 ca 0b 00 00            	jne	0x13ac8 <bpf_object_open.part.0+0x2338>
; 	return BTF_INFO_VLEN(t->info);
   12efe: 48 8b 54 24 48               	movq	72(%rsp), %rdx
; 		if (rel->r_offset - vi->offset < moff)
   12f03: 4c 8b 44 24 50               	movq	80(%rsp), %r8
; 	return BTF_INFO_VLEN(t->info);
   12f08: 8b 72 04                     	movl	4(%rdx), %esi
; 		if (rel->r_offset - vi->offset < moff)
   12f0b: 41 8b 78 04                  	movl	4(%r8), %edi
; 		moff = btf_member_bit_offset(def, btf_vlen(def) - 1) / 8;
   12f0f: 0f b7 c6                     	movzwl	%si, %eax
; 	const struct btf_member *m = btf_members(t) + member_idx;
   12f12: 83 e8 01                     	subl	$1, %eax
; 	return kflag ? BTF_MEMBER_BIT_OFFSET(m->offset) : m->offset;
   12f15: 48 8d 44 40 03               	leaq	3(%rax,%rax,2), %rax
   12f1a: 8b 44 82 08                  	movl	8(%rdx,%rax,4), %eax
   12f1e: 89 c2                        	movl	%eax, %edx
   12f20: 81 e2 ff ff ff 00            	andl	$16777215, %edx         # imm = 0xFFFFFF
   12f26: 85 f6                        	testl	%esi, %esi
; 		if (rel->r_offset - vi->offset < moff)
   12f28: 48 89 fe                     	movq	%rdi, %rsi
; 	return kflag ? BTF_MEMBER_BIT_OFFSET(m->offset) : m->offset;
   12f2b: 0f 48 c2                     	cmovsl	%edx, %eax
; 		moff = btf_member_bit_offset(def, btf_vlen(def) - 1) / 8;
   12f2e: c1 e8 03                     	shrl	$3, %eax
   12f31: 89 c2                        	movl	%eax, %edx
; 		if (rel->r_offset - vi->offset < moff)
   12f33: 49 8b 07                     	movq	(%r15), %rax
   12f36: 49 89 c0                     	movq	%rax, %r8
   12f39: 49 29 f8                     	subq	%rdi, %r8
   12f3c: 89 d7                        	movl	%edx, %edi
   12f3e: 49 39 f8                     	cmpq	%rdi, %r8
   12f41: 0f 82 81 0b 00 00            	jb	0x13ac8 <bpf_object_open.part.0+0x2338>
; 		moff = rel->r_offset - vi->offset - moff;
   12f47: 41 89 c0                     	movl	%eax, %r8d
   12f4a: 41 29 f0                     	subl	%esi, %r8d
   12f4d: 41 29 d0                     	subl	%edx, %r8d
; 		if (moff % bpf_ptr_sz)
   12f50: 41 f6 c0 07                  	testb	$7, %r8b
   12f54: 0f 85 6e 0b 00 00            	jne	0x13ac8 <bpf_object_open.part.0+0x2338>
; 			tmp = libbpf_reallocarray(map->init_slots, new_sz, host_ptr_sz);
   12f5a: 49 8b 7e 78                  	movq	120(%r14), %rdi
; 		moff /= bpf_ptr_sz;
   12f5e: 41 c1 e8 03                  	shrl	$3, %r8d
; 		if (moff >= map->init_slots_sz) {
   12f62: 45 3b 86 80 00 00 00         	cmpl	128(%r14), %r8d
   12f69: 0f 83 52 06 00 00            	jae	0x135c1 <bpf_object_open.part.0+0x1e31>
; 		map->init_slots[moff] = is_map_in_map ? (void *)targ_map : (void *)targ_prog;
   12f6f: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   12f74: 80 7c 24 40 00               	cmpb	$0, 64(%rsp)
   12f79: 44 89 c0                     	movl	%r8d, %eax
; 		pr_debug(".maps relo #%d: map '%s' slot [%d] points to %s '%s'\n",
   12f7c: 4d 89 e1                     	movq	%r12, %r9
; 		map->init_slots[moff] = is_map_in_map ? (void *)targ_map : (void *)targ_prog;
   12f7f: 48 0f 45 54 24 38            	cmovneq	56(%rsp), %rdx
; 		pr_debug(".maps relo #%d: map '%s' slot [%d] points to %s '%s'\n",
   12f85: 48 83 ec 08                  	subq	$8, %rsp
   12f89: 48 8d 35 60 34 02 00         	leaq	144480(%rip), %rsi      # 0x363f0 <strs.2+0x3560>
; 		map->init_slots[moff] = is_map_in_map ? (void *)targ_map : (void *)targ_prog;
   12f90: 48 89 14 c7                  	movq	%rdx, (%rdi,%rax,8)
; 		pr_debug(".maps relo #%d: map '%s' slot [%d] points to %s '%s'\n",
   12f94: 49 8b 4e 08                  	movq	8(%r14), %rcx
   12f98: 31 c0                        	xorl	%eax, %eax
   12f9a: bf 02 00 00 00               	movl	$2, %edi
   12f9f: ff 74 24 20                  	pushq	32(%rsp)
   12fa3: 8b 54 24 30                  	movl	48(%rsp), %edx
   12fa7: e8 24 51 ff ff               	callq	0x80d0 <libbpf_print>
; 	for (i = 0; i < nrels; i++) {
   12fac: 41 59                        	popq	%r9
   12fae: 49 8d 45 01                  	leaq	1(%r13), %rax
   12fb2: 41 5a                        	popq	%r10
   12fb4: 4c 3b 6c 24 58               	cmpq	88(%rsp), %r13
   12fb9: 0f 84 d1 0e 00 00            	je	0x13e90 <bpf_object_open.part.0+0x2700>
   12fbf: 49 89 c5                     	movq	%rax, %r13
   12fc2: e9 fb fc ff ff               	jmp	0x12cc2 <bpf_object_open.part.0+0x1532>
   12fc7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	       (bind == STB_GLOBAL || bind == STB_WEAK) &&
   12fd0: 0f b6 c0                     	movzbl	%al, %eax
   12fd3: 83 e8 01                     	subl	$1, %eax
; 	return sym->st_shndx == SHN_UNDEF &&
   12fd6: 83 f8 01                     	cmpl	$1, %eax
   12fd9: 0f 86 b2 04 00 00            	jbe	0x13491 <bpf_object_open.part.0+0x1d01>
   12fdf: 4c 8b 54 24 48               	movq	72(%rsp), %r10
   12fe4: 4c 89 cb                     	movq	%r9, %rbx
   12fe7: 49 89 eb                     	movq	%rbp, %r11
; 	if (is_call_insn(insn)) {
   12fea: 40 80 fe 85                  	cmpb	$-123, %sil
   12fee: 0f 85 4f 1b 00 00            	jne	0x14b43 <bpf_object_open.part.0+0x33b3>
; 		if (insn->src_reg != BPF_PSEUDO_CALL) {
   12ff4: 41 0f b6 42 01               	movzbl	1(%r10), %eax
   12ff9: 83 e0 f0                     	andl	$-16, %eax
   12ffc: 3c 10                        	cmpb	$16, %al
   12ffe: 0f 84 e6 1a 00 00            	je	0x14aea <bpf_object_open.part.0+0x335a>
; 			pr_warn("prog '%s': incorrect bpf_call opcode\n", prog->name);
   13004: 49 8b 16                     	movq	(%r14), %rdx
   13007: 48 8d 35 5a 36 02 00         	leaq	144986(%rip), %rsi      # 0x36668 <strs.2+0x37d8>
   1300e: 31 ff                        	xorl	%edi, %edi
   13010: 31 c0                        	xorl	%eax, %eax
   13012: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   13019: e8 b2 50 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   1301e: e9 d5 eb ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   13023: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			pr_warn("sec '%s': failed to get relo #%d\n", relo_sec_name, i);
   13028: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   1302d: 44 89 e9                     	movl	%r13d, %ecx
   13030: 31 ff                        	xorl	%edi, %edi
   13032: 31 c0                        	xorl	%eax, %eax
   13034: 48 8d 35 35 34 02 00         	leaq	144437(%rip), %rsi      # 0x36470 <strs.2+0x35e0>
   1303b: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   13042: e8 89 50 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13047: e9 ac eb ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   1304c: 0f 1f 40 00                  	nopl	(%rax)
; 	nrels = shdr->sh_size / shdr->sh_entsize;
   13050: 48 8b 45 20                  	movq	32(%rbp), %rax
   13054: 31 d2                        	xorl	%edx, %edx
; 	btf = obj->btf;
   13056: 4d 8b b7 10 01 00 00         	movq	272(%r15), %r14
; 	nrels = shdr->sh_size / shdr->sh_entsize;
   1305d: 48 f7 75 38                  	divq	56(%rbp)
; 	for (i = 0; i < nrels; i++) {
   13061: 85 c0                        	testl	%eax, %eax
   13063: 0f 8e 0f fb ff ff            	jle	0x12b78 <bpf_object_open.part.0+0x13e8>
   13069: 83 e8 01                     	subl	$1, %eax
   1306c: 4c 89 fd                     	movq	%r15, %rbp
   1306f: 45 31 ed                     	xorl	%r13d, %r13d
   13072: 4d 89 f7                     	movq	%r14, %r15
   13075: 48 89 44 24 48               	movq	%rax, 72(%rsp)
; 	if (idx >= data->d_size / sizeof(Elf64_Rel))
   1307a: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   1307f: 44 89 ea                     	movl	%r13d, %edx
   13082: 48 8b 41 10                  	movq	16(%rcx), %rax
   13086: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1308b: 48 c1 e8 04                  	shrq	$4, %rax
   1308f: 4c 39 e8                     	cmpq	%r13, %rax
   13092: 0f 86 25 06 00 00            	jbe	0x136bd <bpf_object_open.part.0+0x1f2d>
; 	return (Elf64_Rel *)data->d_buf + idx;
   13098: 4c 89 eb                     	movq	%r13, %rbx
   1309b: 48 c1 e3 04                  	shlq	$4, %rbx
; 		if (!rel) {
   1309f: 48 03 19                     	addq	(%rcx), %rbx
   130a2: 0f 84 15 06 00 00            	je	0x136bd <bpf_object_open.part.0+0x1f2d>
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   130a8: 48 8b 8d d0 00 00 00         	movq	208(%rbp), %rcx
; 		sym = elf_sym_by_idx(obj, ELF64_R_SYM(rel->r_info));
   130af: 44 8b 43 0c                  	movl	12(%rbx), %r8d
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   130b3: 48 b8 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rax # imm = 0xAAAAAAAAAAAAAAAB
   130bd: 48 f7 61 10                  	mulq	16(%rcx)
   130c1: 48 c1 ea 04                  	shrq	$4, %rdx
   130c5: 49 39 d0                     	cmpq	%rdx, %r8
   130c8: 0f 83 40 06 00 00            	jae	0x1370e <bpf_object_open.part.0+0x1f7e>
; 	return (Elf64_Sym *)obj->efile.symbols->d_buf + idx;
   130ce: 48 8b 11                     	movq	(%rcx), %rdx
   130d1: 4b 8d 04 40                  	leaq	(%r8,%r8,2), %rax
   130d5: 4c 8d 34 c2                  	leaq	(%rdx,%rax,8), %r14
; 		if (!sym) {
   130d9: 4d 85 f6                     	testq	%r14, %r14
   130dc: 0f 84 2c 06 00 00            	je	0x1370e <bpf_object_open.part.0+0x1f7e>
; 		name = elf_sym_str(obj, sym->st_name) ?: "<?>";
   130e2: 45 8b 26                     	movl	(%r14), %r12d
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   130e5: 48 8b b5 e8 00 00 00         	movq	232(%rbp), %rsi
   130ec: 48 8b bd c0 00 00 00         	movq	192(%rbp), %rdi
   130f3: 4c 89 e2                     	movq	%r12, %rdx
   130f6: e8 75 27 ff ff               	callq	0x5870 <.plt.sec+0x200>
   130fb: 49 89 c0                     	movq	%rax, %r8
; 	if (!name) {
   130fe: 48 85 c0                     	testq	%rax, %rax
   13101: 0f 84 85 05 00 00            	je	0x1368c <bpf_object_open.part.0+0x1efc>
; 	for (i = 0; i < obj->nr_maps; i++) {
   13107: 48 8b 4d 70                  	movq	112(%rbp), %rcx
; 		map = find_struct_ops_map_by_offset(obj, rel->r_offset);
   1310b: 4c 8b 0b                     	movq	(%rbx), %r9
; 	for (i = 0; i < obj->nr_maps; i++) {
   1310e: 48 85 c9                     	testq	%rcx, %rcx
   13111: 74 3f                        	je	0x13152 <bpf_object_open.part.0+0x19c2>
   13113: 4c 8b 65 68                  	movq	104(%rbp), %r12
   13117: 31 c0                        	xorl	%eax, %eax
   13119: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (!bpf_map__is_struct_ops(map))
   13120: 41 83 7c 24 30 1a            	cmpl	$26, 48(%r12)
   13126: 75 1a                        	jne	0x13142 <bpf_object_open.part.0+0x19b2>
; 		if (map->sec_offset <= offset &&
   13128: 49 8b 54 24 20               	movq	32(%r12), %rdx
   1312d: 49 39 d1                     	cmpq	%rdx, %r9
   13130: 72 10                        	jb	0x13142 <bpf_object_open.part.0+0x19b2>
; 		    offset - map->sec_offset < map->def.value_size)
   13132: 4c 89 cf                     	movq	%r9, %rdi
   13135: 41 8b 74 24 38               	movl	56(%r12), %esi
   1313a: 48 29 d7                     	subq	%rdx, %rdi
; 		if (map->sec_offset <= offset &&
   1313d: 48 39 f7                     	cmpq	%rsi, %rdi
   13140: 72 32                        	jb	0x13174 <bpf_object_open.part.0+0x19e4>
; 	for (i = 0; i < obj->nr_maps; i++) {
   13142: 48 83 c0 01                  	addq	$1, %rax
   13146: 49 81 c4 a0 00 00 00         	addq	$160, %r12
   1314d: 48 39 c8                     	cmpq	%rcx, %rax
   13150: 75 ce                        	jne	0x13120 <bpf_object_open.part.0+0x1990>
; 			pr_warn("struct_ops reloc: cannot find map at rel->r_offset %zu\n",
   13152: 4c 89 ca                     	movq	%r9, %rdx
   13155: 48 8d 35 5c 38 02 00         	leaq	145500(%rip), %rsi      # 0x369b8 <strs.2+0x3b28>
   1315c: 31 ff                        	xorl	%edi, %edi
   1315e: 31 c0                        	xorl	%eax, %eax
   13160: 49 89 ef                     	movq	%rbp, %r15
   13163: e8 68 4f ff ff               	callq	0x80d0 <libbpf_print>
   13168: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   1316f: e9 84 ea ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		shdr_idx = sym->st_shndx;
   13174: 45 0f b7 5e 06               	movzwl	6(%r14), %r11d
; 		st_ops = map->st_ops;
   13179: 49 8b 44 24 68               	movq	104(%r12), %rax
; 		moff = rel->r_offset - map->sec_offset;
   1317e: 45 89 ca                     	movl	%r9d, %r10d
; 		pr_debug("struct_ops reloc %s: for %lld value %lld shdr_idx %u rel->r_offset %zu map->sec_offset %zu name %d (\'%s\')\n",
   13181: 41 8b 3e                     	movl	(%r14), %edi
; 		moff = rel->r_offset - map->sec_offset;
   13184: 41 29 d2                     	subl	%edx, %r10d
; 		pr_debug("struct_ops reloc %s: for %lld value %lld shdr_idx %u rel->r_offset %zu map->sec_offset %zu name %d (\'%s\')\n",
   13187: 49 8b 76 08                  	movq	8(%r14), %rsi
; 		st_ops = map->st_ops;
   1318b: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 		pr_debug("struct_ops reloc %s: for %lld value %lld shdr_idx %u rel->r_offset %zu map->sec_offset %zu name %d (\'%s\')\n",
   13190: 8b 4b 0c                     	movl	12(%rbx), %ecx
; 		moff = rel->r_offset - map->sec_offset;
   13193: 44 89 54 24 28               	movl	%r10d, 40(%rsp)
; 		pr_debug("struct_ops reloc %s: for %lld value %lld shdr_idx %u rel->r_offset %zu map->sec_offset %zu name %d (\'%s\')\n",
   13198: 49 8b 44 24 08               	movq	8(%r12), %rax
; 		shdr_idx = sym->st_shndx;
   1319d: 66 44 89 5c 24 38            	movw	%r11w, 56(%rsp)
; 		pr_debug("struct_ops reloc %s: for %lld value %lld shdr_idx %u rel->r_offset %zu map->sec_offset %zu name %d (\'%s\')\n",
   131a3: 41 50                        	pushq	%r8
   131a5: 49 89 f0                     	movq	%rsi, %r8
   131a8: 48 8d 35 49 38 02 00         	leaq	145481(%rip), %rsi      # 0x369f8 <strs.2+0x3b68>
   131af: 57                           	pushq	%rdi
   131b0: bf 02 00 00 00               	movl	$2, %edi
   131b5: 52                           	pushq	%rdx
   131b6: 48 89 c2                     	movq	%rax, %rdx
   131b9: 31 c0                        	xorl	%eax, %eax
   131bb: 41 51                        	pushq	%r9
   131bd: 45 89 d9                     	movl	%r11d, %r9d
   131c0: 44 89 5c 24 40               	movl	%r11d, 64(%rsp)
   131c5: e8 06 4f ff ff               	callq	0x80d0 <libbpf_print>
; 		if (shdr_idx >= SHN_LORESERVE) {
   131ca: 48 83 c4 20                  	addq	$32, %rsp
   131ce: 44 8b 54 24 28               	movl	40(%rsp), %r10d
   131d3: 81 7c 24 20 ff fe 00 00      	cmpl	$65279, 32(%rsp)        # imm = 0xFEFF
   131db: 0f 87 b0 0d 00 00            	ja	0x13f91 <bpf_object_open.part.0+0x2801>
; 		if (sym->st_value % BPF_INSN_SZ) {
   131e1: 49 8b 46 08                  	movq	8(%r14), %rax
   131e5: a8 07                        	testb	$7, %al
   131e7: 0f 85 7d 0d 00 00            	jne	0x13f6a <bpf_object_open.part.0+0x27da>
; 		insn_idx = sym->st_value / BPF_INSN_SZ;
   131ed: 48 c1 e8 03                  	shrq	$3, %rax
; 		member = find_member_by_offset(st_ops->type, moff * 8);
   131f1: 42 8d 3c d5 00 00 00 00      	leal	(,%r10,8), %edi
; 		insn_idx = sym->st_value / BPF_INSN_SZ;
   131f9: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 		member = find_member_by_offset(st_ops->type, moff * 8);
   131fe: 48 8b 44 24 18               	movq	24(%rsp), %rax
   13203: 48 8b 40 08                  	movq	8(%rax), %rax
; 	return BTF_INFO_VLEN(t->info);
   13207: 8b 70 04                     	movl	4(%rax), %esi
; 	return (struct btf_member *)(t + 1);
   1320a: 4c 8d 48 0c                  	leaq	12(%rax), %r9
; 	for (i = 0, m = btf_members(t); i < btf_vlen(t); i++, m++) {
   1320e: 89 f2                        	movl	%esi, %edx
   13210: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   13216: 0f 84 b8 01 00 00            	je	0x133d4 <bpf_object_open.part.0+0x1c44>
   1321c: 83 ea 01                     	subl	$1, %edx
; 	return BTF_INFO_KFLAG(t->info);
   1321f: c1 ee 1f                     	shrl	$31, %esi
; 	for (i = 0, m = btf_members(t); i < btf_vlen(t); i++, m++) {
   13222: 4d 89 ce                     	movq	%r9, %r14
   13225: 48 8d 14 52                  	leaq	(%rdx,%rdx,2), %rdx
   13229: 4c 8d 44 90 18               	leaq	24(%rax,%rdx,4), %r8
   1322e: eb 0d                        	jmp	0x1323d <bpf_object_open.part.0+0x1aad>
   13230: 49 83 c6 0c                  	addq	$12, %r14
   13234: 4d 39 f0                     	cmpq	%r14, %r8
   13237: 0f 84 97 01 00 00            	je	0x133d4 <bpf_object_open.part.0+0x1c44>
; 	return kflag ? BTF_MEMBER_BIT_OFFSET(m->offset) : m->offset;
   1323d: 41 8b 46 08                  	movl	8(%r14), %eax
   13241: 89 c2                        	movl	%eax, %edx
   13243: 81 e2 ff ff ff 00            	andl	$16777215, %edx         # imm = 0xFFFFFF
   13249: 85 f6                        	testl	%esi, %esi
   1324b: 0f 45 c2                     	cmovnel	%edx, %eax
; 		if (btf_member_bit_offset(t, i) == bit_offset)
   1324e: 39 c7                        	cmpl	%eax, %edi
   13250: 75 de                        	jne	0x13230 <bpf_object_open.part.0+0x1aa0>
; 		member_idx = member - btf_members(st_ops->type);
   13252: 4c 89 f3                     	movq	%r14, %rbx
; 		name = btf__name_by_offset(btf, member->name_off);
   13255: 41 8b 36                     	movl	(%r14), %esi
   13258: 4c 89 ff                     	movq	%r15, %rdi
; 		member_idx = member - btf_members(st_ops->type);
   1325b: 48 b8 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rax # imm = 0xAAAAAAAAAAAAAAAB
   13265: 4c 29 cb                     	subq	%r9, %rbx
   13268: 48 c1 fb 02                  	sarq	$2, %rbx
   1326c: 48 0f af d8                  	imulq	%rax, %rbx
; 		name = btf__name_by_offset(btf, member->name_off);
   13270: e8 7b 88 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 	t = skip_mods_and_typedefs(btf, id, NULL);
   13275: 41 8b 76 04                  	movl	4(%r14), %esi
   13279: 31 d2                        	xorl	%edx, %edx
   1327b: 4c 89 ff                     	movq	%r15, %rdi
; 		name = btf__name_by_offset(btf, member->name_off);
   1327e: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 	t = skip_mods_and_typedefs(btf, id, NULL);
   13283: e8 e8 82 ff ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	return BTF_INFO_KIND(t->info);
   13288: 0f b6 50 07                  	movzbl	7(%rax), %edx
   1328c: 83 e2 1f                     	andl	$31, %edx
; 	if (!btf_is_ptr(t))
   1328f: 66 83 fa 02                  	cmpw	$2, %dx
   13293: 0f 85 e7 00 00 00            	jne	0x13380 <bpf_object_open.part.0+0x1bf0>
; 	t = skip_mods_and_typedefs(btf, t->type, res_id);
   13299: 8b 70 08                     	movl	8(%rax), %esi
   1329c: 31 d2                        	xorl	%edx, %edx
   1329e: 4c 89 ff                     	movq	%r15, %rdi
   132a1: e8 ca 82 ff ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	return BTF_INFO_KIND(t->info);
   132a6: 0f b6 40 07                  	movzbl	7(%rax), %eax
   132aa: 83 e0 1f                     	andl	$31, %eax
; 	return btf_is_func_proto(t) ? t : NULL;
   132ad: 66 83 f8 0d                  	cmpw	$13, %ax
   132b1: 0f 85 c9 00 00 00            	jne	0x13380 <bpf_object_open.part.0+0x1bf0>
; 		prog = find_prog_by_sec_insn(obj, shdr_idx, insn_idx);
   132b7: 8b 54 24 28                  	movl	40(%rsp), %edx
   132bb: 0f b7 74 24 38               	movzwl	56(%rsp), %esi
   132c0: 48 89 ef                     	movq	%rbp, %rdi
   132c3: e8 58 32 ff ff               	callq	0x6520 <find_prog_by_sec_insn>
; 		if (!prog) {
   132c8: 48 85 c0                     	testq	%rax, %rax
   132cb: 0f 84 40 0d 00 00            	je	0x14011 <bpf_object_open.part.0+0x2881>
; 		if (prog->type != BPF_PROG_TYPE_STRUCT_OPS) {
   132d1: 83 b8 80 00 00 00 1b         	cmpl	$27, 128(%rax)
   132d8: 0f 85 df 0c 00 00            	jne	0x13fbd <bpf_object_open.part.0+0x282d>
; 			prog->attach_btf_id = st_ops->type_id;
   132de: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
; 		if (!prog->attach_btf_id) {
   132e3: 8b 90 90 00 00 00            	movl	144(%rax), %edx
; 			prog->attach_btf_id = st_ops->type_id;
   132e9: 8b 49 30                     	movl	48(%rcx), %ecx
; 		if (!prog->attach_btf_id) {
   132ec: 85 d2                        	testl	%edx, %edx
   132ee: 0f 85 07 01 00 00            	jne	0x133fb <bpf_object_open.part.0+0x1c6b>
; 			prog->attach_btf_id = st_ops->type_id;
   132f4: 89 88 90 00 00 00            	movl	%ecx, 144(%rax)
; 			prog->expected_attach_type = member_idx;
   132fa: 89 98 84 00 00 00            	movl	%ebx, 132(%rax)
; 		st_ops->progs[member_idx] = prog;
   13300: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   13305: 89 db                        	movl	%ebx, %ebx
   13307: 48 8b 51 10                  	movq	16(%rcx), %rdx
   1330b: 48 89 04 da                  	movq	%rax, (%rdx,%rbx,8)
; 	for (i = 0; i < nrels; i++) {
   1330f: 49 8d 45 01                  	leaq	1(%r13), %rax
   13313: 4c 39 6c 24 48               	cmpq	%r13, 72(%rsp)
   13318: 0f 84 72 0b 00 00            	je	0x13e90 <bpf_object_open.part.0+0x2700>
   1331e: 49 89 c5                     	movq	%rax, %r13
   13321: e9 54 fd ff ff               	jmp	0x1307a <bpf_object_open.part.0+0x18ea>
; 			if (sym->st_shndx != obj->efile.btf_maps_shndx) {
   13326: 41 0f b7 54 24 06            	movzwl	6(%r12), %edx
   1332c: 41 39 d1                     	cmpl	%edx, %r9d
   1332f: 0f 85 93 10 00 00            	jne	0x143c8 <bpf_object_open.part.0+0x2c38>
; 			if (map->def.type == BPF_MAP_TYPE_HASH_OF_MAPS &&
   13335: 83 f8 0d                     	cmpl	$13, %eax
   13338: 75 0b                        	jne	0x13345 <bpf_object_open.part.0+0x1bb5>
   1333a: 41 83 7e 34 04               	cmpl	$4, 52(%r14)
   1333f: 0f 85 88 15 00 00            	jne	0x148cd <bpf_object_open.part.0+0x313d>
; 			targ_map = bpf_object__find_map_by_name(obj, name);
   13345: 48 8b 74 24 18               	movq	24(%rsp), %rsi
   1334a: 48 89 ef                     	movq	%rbp, %rdi
   1334d: 4c 89 44 24 40               	movq	%r8, 64(%rsp)
   13352: e8 59 e3 ff ff               	callq	0x116b0 <bpf_object__find_map_by_name>
; 			if (!targ_map) {
   13357: 4c 8b 44 24 40               	movq	64(%rsp), %r8
   1335c: 48 85 c0                     	testq	%rax, %rax
; 			targ_map = bpf_object__find_map_by_name(obj, name);
   1335f: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 			if (!targ_map) {
   13364: 0f 84 fa 14 00 00            	je	0x14864 <bpf_object_open.part.0+0x30d4>
; 		return true;
   1336a: c6 44 24 40 01               	movb	$1, 64(%rsp)
; 		type = is_map_in_map ? "map" : "prog";
   1336f: 4c 8d 25 cb f6 01 00         	leaq	128715(%rip), %r12      # 0x32a41 <_IO_stdin_used+0x2a41>
   13376: e9 1d fb ff ff               	jmp	0x12e98 <bpf_object_open.part.0+0x1708>
   1337b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   13380: 4c 8b 74 24 40               	movq	64(%rsp), %r14
; 			pr_warn("struct_ops reloc %s: cannot relocate non func ptr %s\n",
   13385: 49 8b 54 24 08               	movq	8(%r12), %rdx
   1338a: 31 ff                        	xorl	%edi, %edi
   1338c: 31 c0                        	xorl	%eax, %eax
   1338e: 48 8d 35 bb 2c 02 00         	leaq	142523(%rip), %rsi      # 0x36050 <strs.2+0x31c0>
   13395: 49 89 ef                     	movq	%rbp, %r15
   13398: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   1339f: 4c 89 f1                     	movq	%r14, %rcx
   133a2: e8 29 4d ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   133a7: e9 4c e8 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   133ac: 0f 1f 40 00                  	nopl	(%rax)
; 			pr_warn("sec '%s': symbol #%zu not found for relo #%d\n",
   133b0: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   133b5: 45 89 e8                     	movl	%r13d, %r8d
   133b8: 31 ff                        	xorl	%edi, %edi
   133ba: 31 c0                        	xorl	%eax, %eax
   133bc: 48 8d 35 dd 30 02 00         	leaq	143581(%rip), %rsi      # 0x364a0 <strs.2+0x3610>
   133c3: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   133ca: e8 01 4d ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   133cf: e9 24 e8 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("struct_ops reloc %s: cannot find member at moff %u\n",
   133d4: 49 8b 54 24 08               	movq	8(%r12), %rdx
   133d9: 44 89 d1                     	movl	%r10d, %ecx
   133dc: 31 ff                        	xorl	%edi, %edi
   133de: 31 c0                        	xorl	%eax, %eax
   133e0: 48 8d 35 91 35 02 00         	leaq	144785(%rip), %rsi      # 0x36978 <strs.2+0x3ae8>
   133e7: 49 89 ef                     	movq	%rbp, %r15
   133ea: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   133f1: e8 da 4c ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   133f6: e9 fd e7 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("struct_ops reloc %s: cannot use prog %s in sec %s with type %u attach_btf_id %u expected_attach_type %u for func ptr %s\n",
   133fb: 8b b0 84 00 00 00            	movl	132(%rax), %esi
; 		if (prog->attach_btf_id != st_ops->type_id ||
   13401: 39 ca                        	cmpl	%ecx, %edx
   13403: 75 08                        	jne	0x1340d <bpf_object_open.part.0+0x1c7d>
   13405: 39 f3                        	cmpl	%esi, %ebx
   13407: 0f 84 f3 fe ff ff            	je	0x13300 <bpf_object_open.part.0+0x1b70>
; 			pr_warn("struct_ops reloc %s: cannot use prog %s in sec %s with type %u attach_btf_id %u expected_attach_type %u for func ptr %s\n",
   1340d: 4c 8b 74 24 40               	movq	64(%rsp), %r14
   13412: 89 d1                        	movl	%edx, %ecx
   13414: 48 83 ec 08                  	subq	$8, %rsp
   13418: 4c 8b 40 08                  	movq	8(%rax), %r8
   1341c: 4d 8b 54 24 08               	movq	8(%r12), %r10
   13421: 41 b9 1b 00 00 00            	movl	$27, %r9d
   13427: 31 ff                        	xorl	%edi, %edi
   13429: 49 89 ef                     	movq	%rbp, %r15
   1342c: 41 56                        	pushq	%r14
   1342e: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   13435: 56                           	pushq	%rsi
   13436: 4c 89 d2                     	movq	%r10, %rdx
   13439: 48 8d 35 f0 2c 02 00         	leaq	142576(%rip), %rsi      # 0x36130 <strs.2+0x32a0>
   13440: 51                           	pushq	%rcx
   13441: 48 8b 08                     	movq	(%rax), %rcx
   13444: 31 c0                        	xorl	%eax, %eax
   13446: e8 85 4c ff ff               	callq	0x80d0 <libbpf_print>
   1344b: 48 83 c4 20                  	addq	$32, %rsp
   1344f: e9 a4 e7 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   13454: 0f 1f 40 00                  	nopl	(%rax)
; 			sym_name = elf_sec_name(obj, elf_sec_by_idx(obj, sym->st_shndx));
   13458: 45 0f b7 f0                  	movzwl	%r8w, %r14d
; 	scn = elf_getscn(obj->efile.elf, idx);
   1345c: 4c 89 f6                     	movq	%r14, %rsi
   1345f: e8 9c 27 ff ff               	callq	0x5c00 <.plt.sec+0x590>
   13464: 49 89 c1                     	movq	%rax, %r9
; 	if (!scn) {
   13467: 48 85 c0                     	testq	%rax, %rax
   1346a: 0f 84 cf 0b 00 00            	je	0x1403f <bpf_object_open.part.0+0x28af>
; 			sym_name = elf_sec_name(obj, elf_sec_by_idx(obj, sym->st_shndx));
   13470: 4c 89 ce                     	movq	%r9, %rsi
   13473: 4c 89 ff                     	movq	%r15, %rdi
   13476: e8 c5 76 ff ff               	callq	0xab40 <elf_sec_name>
   1347b: 49 89 c1                     	movq	%rax, %r9
; 		sym_name = sym_name ?: "<?";
   1347e: 48 85 c0                     	testq	%rax, %rax
   13481: 48 8d 05 f5 eb 01 00         	leaq	125941(%rip), %rax      # 0x3207d <_IO_stdin_used+0x207d>
   13488: 4c 0f 44 c8                  	cmoveq	%rax, %r9
   1348c: e9 c2 f4 ff ff               	jmp	0x12953 <bpf_object_open.part.0+0x11c3>
; 	       (bind == STB_GLOBAL || bind == STB_WEAK) &&
   13491: 83 e7 0f                     	andl	$15, %edi
   13494: 0f 85 45 fb ff ff            	jne	0x12fdf <bpf_object_open.part.0+0x184f>
; 		int sym_idx = ELF64_R_SYM(rel->r_info);
   1349a: 48 8b 44 24 18               	movq	24(%rsp), %rax
; 		int i, n = obj->nr_extern;
   1349f: 8b 95 90 00 00 00            	movl	144(%rbp), %edx
; 		int sym_idx = ELF64_R_SYM(rel->r_info);
   134a5: 8b 48 0c                     	movl	12(%rax), %ecx
   134a8: 41 89 c8                     	movl	%ecx, %r8d
; 		for (i = 0; i < n; i++) {
   134ab: 85 d2                        	testl	%edx, %edx
   134ad: 0f 8e 90 00 00 00            	jle	0x13543 <bpf_object_open.part.0+0x1db3>
   134b3: 48 8b 85 88 00 00 00         	movq	136(%rbp), %rax
   134ba: 31 db                        	xorl	%ebx, %ebx
   134bc: eb 0d                        	jmp	0x134cb <bpf_object_open.part.0+0x1d3b>
   134be: 66 90                        	nop
   134c0: 83 c3 01                     	addl	$1, %ebx
   134c3: 48 83 c0 38                  	addq	$56, %rax
   134c7: 39 da                        	cmpl	%ebx, %edx
   134c9: 74 78                        	je	0x13543 <bpf_object_open.part.0+0x1db3>
; 			if (ext->sym_idx == sym_idx)
   134cb: 44 3b 40 04                  	cmpl	4(%rax), %r8d
   134cf: 75 ef                        	jne	0x134c0 <bpf_object_open.part.0+0x1d30>
; 		pr_debug("prog '%s': found extern #%d '%s' (sym %d) for insn #%u\n",
   134d1: 48 83 ec 08                  	subq	$8, %rsp
   134d5: 4c 8b 40 10                  	movq	16(%rax), %r8
   134d9: 49 8b 16                     	movq	(%r14), %rdx
   134dc: 31 c0                        	xorl	%eax, %eax
   134de: 41 52                        	pushq	%r10
   134e0: 41 89 c9                     	movl	%ecx, %r9d
   134e3: 89 d9                        	movl	%ebx, %ecx
   134e5: bf 02 00 00 00               	movl	$2, %edi
   134ea: 48 8d 35 7f 35 02 00         	leaq	144767(%rip), %rsi      # 0x36a70 <strs.2+0x3be0>
   134f1: 44 89 54 24 28               	movl	%r10d, 40(%rsp)
   134f6: e8 d5 4b ff ff               	callq	0x80d0 <libbpf_print>
; 		if (insn->code == (BPF_JMP | BPF_CALL))
   134fb: 5f                           	popq	%rdi
   134fc: 41 58                        	popq	%r8
; 			reloc_desc->type = RELO_EXTERN_VAR;
   134fe: 48 8b 44 24 48               	movq	72(%rsp), %rax
; 		reloc_desc->insn_idx = insn_idx;
   13503: 44 8b 54 24 18               	movl	24(%rsp), %r10d
; 		prog->nr_reloc++;
   13508: 41 8b 4e 50                  	movl	80(%r14), %ecx
; 			reloc_desc->type = RELO_EXTERN_VAR;
   1350c: 80 38 85                     	cmpb	$-123, (%rax)
; 		reloc_desc->insn_idx = insn_idx;
   1350f: 45 89 55 04                  	movl	%r10d, 4(%r13)
; 			reloc_desc->type = RELO_EXTERN_VAR;
   13513: 0f 94 c0                     	sete	%al
; 		reloc_desc->sym_off = i; /* sym_off stores extern index */
   13516: 41 89 5d 0c                  	movl	%ebx, 12(%r13)
; 			reloc_desc->type = RELO_EXTERN_VAR;
   1351a: 0f b6 c0                     	movzbl	%al, %eax
   1351d: 83 c0 03                     	addl	$3, %eax
   13520: 41 89 45 00                  	movl	%eax, (%r13)
; 		prog->nr_reloc++;
   13524: 83 c1 01                     	addl	$1, %ecx
   13527: 41 89 4e 50                  	movl	%ecx, 80(%r14)
; 	for (i = 0; i < nrels; i++) {
   1352b: 49 8d 44 24 01               	leaq	1(%r12), %rax
   13530: 4c 3b 64 24 50               	cmpq	80(%rsp), %r12
   13535: 0f 84 2f f6 ff ff            	je	0x12b6a <bpf_object_open.part.0+0x13da>
   1353b: 49 89 c4                     	movq	%rax, %r12
   1353e: e9 2c f3 ff ff               	jmp	0x1286f <bpf_object_open.part.0+0x10df>
   13543: 4c 89 cb                     	movq	%r9, %rbx
; 			pr_warn("prog '%s': extern relo failed to find extern for '%s' (%d)\n",
   13546: 49 8b 16                     	movq	(%r14), %rdx
   13549: 48 8d 35 60 35 02 00         	leaq	144736(%rip), %rsi      # 0x36ab0 <strs.2+0x3c20>
   13550: 31 ff                        	xorl	%edi, %edi
   13552: 48 89 d9                     	movq	%rbx, %rcx
   13555: 31 c0                        	xorl	%eax, %eax
   13557: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   1355e: e8 6d 4b ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13563: e9 90 e6 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   13568: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   1356d: e8 ee 24 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   13572: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   13577: 4c 89 f2                     	movq	%r14, %rdx
   1357a: 31 ff                        	xorl	%edi, %edi
   1357c: 49 89 c0                     	movq	%rax, %r8
   1357f: 48 8d 35 5a 08 02 00         	leaq	133210(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
   13586: 31 c0                        	xorl	%eax, %eax
   13588: e8 43 4b ff ff               	callq	0x80d0 <libbpf_print>
; 		name = elf_sym_str(obj, sym->st_name) ?: "<?>";
   1358d: 48 8d 05 d8 e8 01 00         	leaq	125144(%rip), %rax      # 0x31e6c <_IO_stdin_used+0x1e6c>
   13594: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   13599: e9 b6 f7 ff ff               	jmp	0x12d54 <bpf_object_open.part.0+0x15c4>
; 			pr_warn(".maps relo #%d: failed to get ELF relo\n", i);
   1359e: 8b 54 24 20                  	movl	32(%rsp), %edx
   135a2: 48 8d 35 0f 2c 02 00         	leaq	142351(%rip), %rsi      # 0x361b8 <strs.2+0x3328>
   135a9: 31 ff                        	xorl	%edi, %edi
   135ab: 31 c0                        	xorl	%eax, %eax
   135ad: 49 89 ef                     	movq	%rbp, %r15
   135b0: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   135b7: e8 14 4b ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   135bc: e9 37 e6 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			new_sz = moff + 1;
   135c1: 41 8d 70 01                  	leal	1(%r8), %esi
   135c5: 44 89 44 24 48               	movl	%r8d, 72(%rsp)
   135ca: 49 89 f7                     	movq	%rsi, %r15
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   135cd: 48 c1 e6 03                  	shlq	$3, %rsi
; 	return realloc(ptr, total);
   135d1: e8 4a 25 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 			if (!tmp)
   135d6: 48 85 c0                     	testq	%rax, %rax
   135d9: 0f 84 2d 1a 00 00            	je	0x1500c <bpf_object_open.part.0+0x387c>
; 			       (new_sz - map->init_slots_sz) * host_ptr_sz);
   135df: 49 63 b6 80 00 00 00         	movslq	128(%r14), %rsi
   135e6: 44 89 fa                     	movl	%r15d, %edx
; 			map->init_slots = tmp;
   135e9: 49 89 46 78                  	movq	%rax, 120(%r14)
; 			       (new_sz - map->init_slots_sz) * host_ptr_sz);
   135ed: 29 f2                        	subl	%esi, %edx
; 			memset(map->init_slots + map->init_slots_sz, 0,
   135ef: 48 8d 3c f0                  	leaq	(%rax,%rsi,8), %rdi
;   return __builtin___memset_chk (__dest, __ch, __len,
   135f3: 31 f6                        	xorl	%esi, %esi
; 			       (new_sz - map->init_slots_sz) * host_ptr_sz);
   135f5: c1 e2 03                     	shll	$3, %edx
; 			memset(map->init_slots + map->init_slots_sz, 0,
   135f8: 48 63 d2                     	movslq	%edx, %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
   135fb: e8 c0 22 ff ff               	callq	0x58c0 <.plt.sec+0x250>
; 			map->init_slots_sz = new_sz;
   13600: 45 89 be 80 00 00 00         	movl	%r15d, 128(%r14)
   13607: 49 8b 7e 78                  	movq	120(%r14), %rdi
   1360b: 44 8b 44 24 48               	movl	72(%rsp), %r8d
   13610: e9 5a f9 ff ff               	jmp	0x12f6f <bpf_object_open.part.0+0x17df>
; 	int bind = ELF64_ST_BIND(sym->st_info);
   13615: 0f b6 c0                     	movzbl	%al, %eax
; 	int type = ELF64_ST_TYPE(sym->st_info);
   13618: 83 e7 0f                     	andl	$15, %edi
; 	if (bind == STB_LOCAL && type == STT_SECTION)
   1361b: 85 c0                        	testl	%eax, %eax
   1361d: 75 05                        	jne	0x13624 <bpf_object_open.part.0+0x1e94>
   1361f: 83 ff 03                     	cmpl	$3, %edi
   13622: 74 12                        	je	0x13636 <bpf_object_open.part.0+0x1ea6>
; 	if (sym_is_subprog(sym, obj->efile.text_shndx)) {
   13624: 83 f8 01                     	cmpl	$1, %eax
   13627: 0f 85 3a f4 ff ff            	jne	0x12a67 <bpf_object_open.part.0+0x12d7>
   1362d: 83 ff 02                     	cmpl	$2, %edi
   13630: 0f 85 31 f4 ff ff            	jne	0x12a67 <bpf_object_open.part.0+0x12d7>
; 		if ((sym->st_value % BPF_INSN_SZ) || (insn->imm % BPF_INSN_SZ)) {
   13636: 48 8b 44 24 48               	movq	72(%rsp), %rax
   1363b: 4c 8b 43 08                  	movq	8(%rbx), %r8
   1363f: 8b 40 04                     	movl	4(%rax), %eax
   13642: 41 f6 c0 07                  	testb	$7, %r8b
   13646: 0f 85 4e 0e 00 00            	jne	0x1449a <bpf_object_open.part.0+0x2d0a>
   1364c: a8 07                        	testb	$7, %al
   1364e: 0f 85 46 0e 00 00            	jne	0x1449a <bpf_object_open.part.0+0x2d0a>
; 		reloc_desc->type = RELO_SUBPROG_ADDR;
   13654: 41 c7 45 00 05 00 00 00      	movl	$5, (%r13)
; 		reloc_desc->insn_idx = insn_idx;
   1365c: 45 89 55 04                  	movl	%r10d, 4(%r13)
; 		reloc_desc->sym_off = sym->st_value;
   13660: 45 89 45 0c                  	movl	%r8d, 12(%r13)
; 		if (err)
   13664: e9 bb fe ff ff               	jmp	0x13524 <bpf_object_open.part.0+0x1d94>
; 			pr_warn(".maps relo #%d: symbol %zx not found\n",
   13669: 8b 54 24 20                  	movl	32(%rsp), %edx
   1366d: 48 8d 35 74 2b 02 00         	leaq	142196(%rip), %rsi      # 0x361e8 <strs.2+0x3358>
   13674: 31 ff                        	xorl	%edi, %edi
   13676: 31 c0                        	xorl	%eax, %eax
   13678: 49 89 ef                     	movq	%rbp, %r15
   1367b: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   13682: e8 49 4a ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13687: e9 6c e5 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   1368c: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   13691: e8 ca 23 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   13696: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   1369b: 4c 89 e2                     	movq	%r12, %rdx
   1369e: 31 ff                        	xorl	%edi, %edi
   136a0: 49 89 c0                     	movq	%rax, %r8
   136a3: 48 8d 35 36 07 02 00         	leaq	132918(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
   136aa: 31 c0                        	xorl	%eax, %eax
   136ac: e8 1f 4a ff ff               	callq	0x80d0 <libbpf_print>
; 		name = elf_sym_str(obj, sym->st_name) ?: "<?>";
   136b1: 4c 8d 05 b4 e7 01 00         	leaq	124852(%rip), %r8       # 0x31e6c <_IO_stdin_used+0x1e6c>
   136b8: e9 4a fa ff ff               	jmp	0x13107 <bpf_object_open.part.0+0x1977>
; 			pr_warn("struct_ops reloc: failed to get %d reloc\n", i);
   136bd: 48 8d 35 7c 28 02 00         	leaq	141436(%rip), %rsi      # 0x35f40 <strs.2+0x30b0>
   136c4: 31 ff                        	xorl	%edi, %edi
   136c6: 31 c0                        	xorl	%eax, %eax
   136c8: 49 89 ef                     	movq	%rbp, %r15
   136cb: e8 00 4a ff ff               	callq	0x80d0 <libbpf_print>
   136d0: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   136d7: e9 1c e5 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_debug("Non-VAR type seen in section %s\n", name);
   136dc: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   136e1: bf 02 00 00 00               	movl	$2, %edi
   136e6: 31 c0                        	xorl	%eax, %eax
   136e8: 4d 89 f7                     	movq	%r14, %r15
   136eb: 48 8d 35 0e 27 02 00         	leaq	141070(%rip), %rsi      # 0x35e00 <strs.2+0x2f70>
   136f2: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   136f9: bd 16 00 00 00               	movl	$22, %ebp
; 			return -EINVAL;
   136fe: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_debug("Non-VAR type seen in section %s\n", name);
   13704: e8 c7 49 ff ff               	callq	0x80d0 <libbpf_print>
; 			if (err)
   13709: e9 2f ef ff ff               	jmp	0x1263d <bpf_object_open.part.0+0xead>
; 			pr_warn("struct_ops reloc: symbol %zx not found\n",
   1370e: 4c 89 c2                     	movq	%r8, %rdx
   13711: 48 8d 35 60 28 02 00         	leaq	141408(%rip), %rsi      # 0x35f78 <strs.2+0x30e8>
   13718: 31 ff                        	xorl	%edi, %edi
   1371a: 31 c0                        	xorl	%eax, %eax
   1371c: e8 af 49 ff ff               	callq	0x80d0 <libbpf_print>
   13721: 49 89 ef                     	movq	%rbp, %r15
   13724: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   1372b: e9 c8 e4 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_debug("sec '%s': relo #%d: couldn't find program in section '%s' for insn #%u, probably overridden weak function, skipping...\n",
   13730: 4c 8b 44 24 68               	movq	104(%rsp), %r8
   13735: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   1373a: 41 89 e9                     	movl	%ebp, %r9d
   1373d: 44 89 e9                     	movl	%r13d, %ecx
   13740: 48 8d 35 59 2e 02 00         	leaq	142937(%rip), %rsi      # 0x365a0 <strs.2+0x3710>
   13747: bf 02 00 00 00               	movl	$2, %edi
   1374c: 31 c0                        	xorl	%eax, %eax
   1374e: e8 7d 49 ff ff               	callq	0x80d0 <libbpf_print>
; 			continue;
   13753: e9 d3 fd ff ff               	jmp	0x1352b <bpf_object_open.part.0+0x1d9b>
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   13758: 48 83 7d 60 01               	cmpq	$1, 96(%rbp)
   1375d: 0f 86 d7 04 00 00            	jbe	0x13c3a <bpf_object_open.part.0+0x24aa>
; 				pr_warn(".maps relo #%d: '%s' isn't an entry-point program\n",
   13763: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   13768: 8b 54 24 20                  	movl	32(%rsp), %edx
   1376c: 31 ff                        	xorl	%edi, %edi
   1376e: 31 c0                        	xorl	%eax, %eax
   13770: 48 8d 35 39 2c 02 00         	leaq	142393(%rip), %rsi      # 0x363b0 <strs.2+0x3520>
   13777: 49 89 ef                     	movq	%rbp, %r15
   1377a: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   13781: e8 4a 49 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13786: e9 6d e4 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 				pr_warn("prog '%s': failed to initialize: %d\n",
   1378b: 48 63 d8                     	movslq	%eax, %rbx
   1378e: 48 8b 55 00                  	movq	(%rbp), %rdx
   13792: 48 8d 35 77 27 02 00         	leaq	141175(%rip), %rsi      # 0x35f10 <strs.2+0x3080>
   13799: 31 ff                        	xorl	%edi, %edi
   1379b: 89 d9                        	movl	%ebx, %ecx
   1379d: 31 c0                        	xorl	%eax, %eax
   1379f: e8 2c 49 ff ff               	callq	0x80d0 <libbpf_print>
; 				return err;
   137a4: e9 4f e4 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	return ERR_PTR(err);
   137a9: 48 63 d8                     	movslq	%eax, %rbx
   137ac: e9 47 e4 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	       (bind == STB_GLOBAL || bind == STB_WEAK) &&
   137b1: 83 e2 0f                     	andl	$15, %edx
   137b4: 0f 85 9a eb ff ff            	jne	0x12354 <bpf_object_open.part.0+0xbc4>
; 		ext_name = elf_sym_str(obj, sym->st_name);
   137ba: 45 8b 26                     	movl	(%r14), %r12d
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   137bd: 49 8b b7 e8 00 00 00         	movq	232(%r15), %rsi
   137c4: 49 8b bf c0 00 00 00         	movq	192(%r15), %rdi
   137cb: 4c 89 e2                     	movq	%r12, %rdx
   137ce: e8 9d 20 ff ff               	callq	0x5870 <.plt.sec+0x200>
   137d3: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	if (!name) {
   137d8: 48 85 c0                     	testq	%rax, %rax
   137db: 0f 84 06 08 00 00            	je	0x13fe7 <bpf_object_open.part.0+0x2857>
; 		if (!ext_name || !ext_name[0])
   137e1: 48 8b 44 24 08               	movq	8(%rsp), %rax
   137e6: 80 38 00                     	cmpb	$0, (%rax)
   137e9: 0f 84 65 eb ff ff            	je	0x12354 <bpf_object_open.part.0+0xbc4>
; 		ext = libbpf_reallocarray(ext, obj->nr_extern + 1, sizeof(*ext));
   137ef: 41 8b 87 90 00 00 00         	movl	144(%r15), %eax
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   137f6: ba 38 00 00 00               	movl	$56, %edx
; 		ext = obj->externs;
   137fb: 49 8b bf 88 00 00 00         	movq	136(%r15), %rdi
; 		ext = libbpf_reallocarray(ext, obj->nr_extern + 1, sizeof(*ext));
   13802: 8d 70 01                     	leal	1(%rax), %esi
   13805: 48 63 f6                     	movslq	%esi, %rsi
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   13808: 48 89 f0                     	movq	%rsi, %rax
   1380b: 48 f7 e2                     	mulq	%rdx
   1380e: 48 89 c6                     	movq	%rax, %rsi
   13811: 0f 80 f2 e2 ff ff            	jo	0x11b09 <bpf_object_open.part.0+0x379>
; 	return realloc(ptr, total);
   13817: e8 04 23 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 		if (!ext)
   1381c: 48 85 c0                     	testq	%rax, %rax
   1381f: 0f 84 e4 e2 ff ff            	je	0x11b09 <bpf_object_open.part.0+0x379>
; 		ext = &ext[obj->nr_extern];
   13825: 49 63 b7 90 00 00 00         	movslq	144(%r15), %rsi
;   return __builtin___memset_chk (__dest, __ch, __len,
   1382c: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 		obj->externs = ext;
   13830: 49 89 87 88 00 00 00         	movq	%rax, 136(%r15)
; 		ext = &ext[obj->nr_extern];
   13837: 48 8d 14 f5 00 00 00 00      	leaq	(,%rsi,8), %rdx
   1383f: 48 29 f2                     	subq	%rsi, %rdx
   13842: 4c 8d 2c d0                  	leaq	(%rax,%rdx,8), %r13
;   return __builtin___memset_chk (__dest, __ch, __len,
   13846: 49 c7 45 30 00 00 00 00      	movq	$0, 48(%r13)
   1384e: 41 0f 11 45 00               	movups	%xmm0, (%r13)
   13853: 41 0f 11 45 10               	movups	%xmm0, 16(%r13)
   13858: 41 0f 11 45 20               	movups	%xmm0, 32(%r13)
; 		ext->btf_id = find_extern_btf_id(obj->btf, ext_name);
   1385d: 49 8b af 10 01 00 00         	movq	272(%r15), %rbp
; 		obj->nr_extern++;
   13864: 41 83 87 90 00 00 00 01      	addl	$1, 144(%r15)
; 	if (!btf)
   1386c: 48 85 ed                     	testq	%rbp, %rbp
   1386f: 0f 84 80 17 00 00            	je	0x14ff5 <bpf_object_open.part.0+0x3865>
; 	n = btf__type_cnt(btf);
   13875: 48 89 ef                     	movq	%rbp, %rdi
   13878: e8 c3 66 01 00               	callq	0x29f40 <btf__type_cnt>
   1387d: 89 44 24 38                  	movl	%eax, 56(%rsp)
; 	for (i = 1; i < n; i++) {
   13881: 83 f8 01                     	cmpl	$1, %eax
   13884: 0f 8e ed ea ff ff            	jle	0x12377 <bpf_object_open.part.0+0xbe7>
   1388a: 48 89 5c 24 58               	movq	%rbx, 88(%rsp)
   1388f: 41 bc 01 00 00 00            	movl	$1, %r12d
   13895: 48 89 eb                     	movq	%rbp, %rbx
; 		t = btf__type_by_id(btf, i);
   13898: 44 89 e6                     	movl	%r12d, %esi
   1389b: 48 89 df                     	movq	%rbx, %rdi
   1389e: e8 fd 66 01 00               	callq	0x29fa0 <btf__type_by_id>
   138a3: 48 89 c5                     	movq	%rax, %rbp
; 	return BTF_INFO_KIND(t->info);
   138a6: 0f b6 40 07                  	movzbl	7(%rax), %eax
; 		if (!btf_is_var(t) && !btf_is_func(t))
   138aa: 83 e0 1d                     	andl	$29, %eax
   138ad: 66 83 f8 0c                  	cmpw	$12, %ax
   138b1: 0f 85 b1 ea ff ff            	jne	0x12368 <bpf_object_open.part.0+0xbd8>
; 		tname = btf__name_by_offset(btf, t->name_off);
   138b7: 8b 75 00                     	movl	(%rbp), %esi
   138ba: 48 89 df                     	movq	%rbx, %rdi
   138bd: e8 2e 82 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 		if (strcmp(tname, ext_name))
   138c2: 48 8b 74 24 08               	movq	8(%rsp), %rsi
; 		tname = btf__name_by_offset(btf, t->name_off);
   138c7: 48 89 c7                     	movq	%rax, %rdi
; 		if (strcmp(tname, ext_name))
   138ca: e8 e1 20 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   138cf: 85 c0                        	testl	%eax, %eax
   138d1: 0f 85 91 ea ff ff            	jne	0x12368 <bpf_object_open.part.0+0xbd8>
; 	return BTF_INFO_KIND(t->info);
   138d7: 8b 75 04                     	movl	4(%rbp), %esi
   138da: 48 8b 5c 24 58               	movq	88(%rsp), %rbx
   138df: 89 f0                        	movl	%esi, %eax
   138e1: c1 e8 18                     	shrl	$24, %eax
   138e4: 83 e0 1f                     	andl	$31, %eax
; 		if (btf_is_var(t) &&
   138e7: 66 83 f8 0e                  	cmpw	$14, %ax
   138eb: 0f 84 81 05 00 00            	je	0x13e72 <bpf_object_open.part.0+0x26e2>
; 		if (btf_is_func(t) && btf_func_linkage(t) != BTF_FUNC_EXTERN)
   138f1: 66 83 f8 0c                  	cmpw	$12, %ax
   138f5: 75 0a                        	jne	0x13901 <bpf_object_open.part.0+0x2171>
   138f7: 66 83 fe 02                  	cmpw	$2, %si
   138fb: 0f 85 7b 05 00 00            	jne	0x13e7c <bpf_object_open.part.0+0x26ec>
; 		ext->btf_id = find_extern_btf_id(obj->btf, ext_name);
   13901: 45 89 65 08                  	movl	%r12d, 8(%r13)
; 		t = btf__type_by_id(obj->btf, ext->btf_id);
   13905: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   1390c: 44 89 e6                     	movl	%r12d, %esi
   1390f: e8 8c 66 01 00               	callq	0x29fa0 <btf__type_by_id>
; 		ext->name = btf__name_by_offset(obj->btf, t->name_off);
   13914: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   1391b: 8b 30                        	movl	(%rax), %esi
; 		t = btf__type_by_id(obj->btf, ext->btf_id);
   1391d: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 		ext->name = btf__name_by_offset(obj->btf, t->name_off);
   13922: e8 c9 81 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 		ext->sec_btf_id = find_extern_sec_btf_id(obj->btf, ext->btf_id);
   13927: 45 8b 65 08                  	movl	8(%r13), %r12d
; 		ext->name = btf__name_by_offset(obj->btf, t->name_off);
   1392b: 49 89 45 10                  	movq	%rax, 16(%r13)
; 		ext->sym_idx = i;
   1392f: 8b 44 24 10                  	movl	16(%rsp), %eax
   13933: 41 89 45 04                  	movl	%eax, 4(%r13)
; 		ext->is_weak = ELF64_ST_BIND(sym->st_info) == STB_WEAK;
   13937: 41 0f b6 46 04               	movzbl	4(%r14), %eax
; 		ext->sec_btf_id = find_extern_sec_btf_id(obj->btf, ext->btf_id);
   1393c: 4d 8b b7 10 01 00 00         	movq	272(%r15), %r14
; 		ext->is_weak = ELF64_ST_BIND(sym->st_info) == STB_WEAK;
   13943: c0 e8 04                     	shrb	$4, %al
   13946: 3c 02                        	cmpb	$2, %al
   13948: 41 0f 94 45 19               	sete	25(%r13)
; 	if (!btf)
   1394d: 4d 85 f6                     	testq	%r14, %r14
   13950: 0f 84 be 16 00 00            	je	0x15014 <bpf_object_open.part.0+0x3884>
; 	n = btf__type_cnt(btf);
   13956: 4c 89 f7                     	movq	%r14, %rdi
   13959: e8 e2 65 01 00               	callq	0x29f40 <btf__type_cnt>
; 	for (i = 1; i < n; i++) {
   1395e: 83 f8 01                     	cmpl	$1, %eax
   13961: 0f 8e e9 03 00 00            	jle	0x13d50 <bpf_object_open.part.0+0x25c0>
   13967: 48 89 5c 24 10               	movq	%rbx, 16(%rsp)
   1396c: bd 01 00 00 00               	movl	$1, %ebp
   13971: 44 89 e3                     	movl	%r12d, %ebx
   13974: 41 89 c4                     	movl	%eax, %r12d
   13977: eb 13                        	jmp	0x1398c <bpf_object_open.part.0+0x21fc>
   13979: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   13980: 83 c5 01                     	addl	$1, %ebp
   13983: 41 39 ec                     	cmpl	%ebp, %r12d
   13986: 0f 84 c4 03 00 00            	je	0x13d50 <bpf_object_open.part.0+0x25c0>
; 		t = btf__type_by_id(btf, i);
   1398c: 89 ee                        	movl	%ebp, %esi
   1398e: 4c 89 f7                     	movq	%r14, %rdi
   13991: e8 0a 66 01 00               	callq	0x29fa0 <btf__type_by_id>
; 	return BTF_INFO_KIND(t->info);
   13996: 8b 70 04                     	movl	4(%rax), %esi
   13999: 89 f2                        	movl	%esi, %edx
   1399b: c1 ea 18                     	shrl	$24, %edx
   1399e: 83 e2 1f                     	andl	$31, %edx
; 		if (!btf_is_datasec(t))
   139a1: 66 83 fa 0f                  	cmpw	$15, %dx
   139a5: 75 d9                        	jne	0x13980 <bpf_object_open.part.0+0x21f0>
; 	return (struct btf_var_secinfo *)(t + 1);
   139a7: 48 8d 50 0c                  	leaq	12(%rax), %rdx
; 		for (j = 0; j < btf_vlen(t); j++, vs++) {
   139ab: 81 e6 ff ff 00 00            	andl	$65535, %esi            # imm = 0xFFFF
   139b1: 74 cd                        	je	0x13980 <bpf_object_open.part.0+0x21f0>
   139b3: 83 ee 01                     	subl	$1, %esi
   139b6: 48 8d 34 76                  	leaq	(%rsi,%rsi,2), %rsi
   139ba: 48 8d 44 b0 18               	leaq	24(%rax,%rsi,4), %rax
   139bf: eb 10                        	jmp	0x139d1 <bpf_object_open.part.0+0x2241>
   139c1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   139c8: 48 83 c2 0c                  	addq	$12, %rdx
   139cc: 48 39 c2                     	cmpq	%rax, %rdx
   139cf: 74 af                        	je	0x13980 <bpf_object_open.part.0+0x21f0>
; 			if (vs->type == ext_btf_id)
   139d1: 39 1a                        	cmpl	%ebx, (%rdx)
   139d3: 75 f3                        	jne	0x139c8 <bpf_object_open.part.0+0x2238>
; 		ext->sec_btf_id = find_extern_sec_btf_id(obj->btf, ext->btf_id);
   139d5: 41 89 6d 0c                  	movl	%ebp, 12(%r13)
; 		sec = (void *)btf__type_by_id(obj->btf, ext->sec_btf_id);
   139d9: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   139e0: 89 ee                        	movl	%ebp, %esi
; 		ext->sec_btf_id = find_extern_sec_btf_id(obj->btf, ext->btf_id);
   139e2: 48 8b 5c 24 10               	movq	16(%rsp), %rbx
; 		sec = (void *)btf__type_by_id(obj->btf, ext->sec_btf_id);
   139e7: e8 b4 65 01 00               	callq	0x29fa0 <btf__type_by_id>
; 		sec_name = btf__name_by_offset(obj->btf, sec->name_off);
   139ec: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   139f3: 8b 30                        	movl	(%rax), %esi
; 		sec = (void *)btf__type_by_id(obj->btf, ext->sec_btf_id);
   139f5: 49 89 c6                     	movq	%rax, %r14
; 		sec_name = btf__name_by_offset(obj->btf, sec->name_off);
   139f8: e8 f3 80 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 		if (strcmp(sec_name, KCONFIG_SEC) == 0) {
   139fd: 48 8d 35 35 e6 01 00         	leaq	124469(%rip), %rsi      # 0x32039 <_IO_stdin_used+0x2039>
   13a04: 48 89 c7                     	movq	%rax, %rdi
; 		sec_name = btf__name_by_offset(obj->btf, sec->name_off);
   13a07: 49 89 c4                     	movq	%rax, %r12
; 		if (strcmp(sec_name, KCONFIG_SEC) == 0) {
   13a0a: e8 a1 1f ff ff               	callq	0x59b0 <.plt.sec+0x340>
   13a0f: 85 c0                        	testl	%eax, %eax
   13a11: 0f 85 65 02 00 00            	jne	0x13c7c <bpf_object_open.part.0+0x24ec>
; 	return BTF_INFO_KIND(t->info);
   13a17: 48 8b 44 24 38               	movq	56(%rsp), %rax
   13a1c: 0f b6 40 07                  	movzbl	7(%rax), %eax
   13a20: 83 e0 1f                     	andl	$31, %eax
; 			if (btf_is_func(t)) {
   13a23: 66 83 f8 0c                  	cmpw	$12, %ax
   13a27: 0f 84 84 14 00 00            	je	0x14eb1 <bpf_object_open.part.0+0x3721>
; 			ext->kcfg.sz = btf__resolve_size(obj->btf, t->type);
   13a2d: 48 8b 44 24 38               	movq	56(%rsp), %rax
; 			ext->type = EXT_KCFG;
   13a32: 41 c7 45 00 01 00 00 00      	movl	$1, (%r13)
; 			ext->kcfg.sz = btf__resolve_size(obj->btf, t->type);
   13a3a: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   13a41: 8b 70 08                     	movl	8(%rax), %esi
   13a44: e8 77 7a 01 00               	callq	0x2b4c0 <btf__resolve_size>
   13a49: 41 89 45 24                  	movl	%eax, 36(%r13)
   13a4d: 89 c1                        	movl	%eax, %ecx
; 			if (ext->kcfg.sz <= 0) {
   13a4f: 85 c0                        	testl	%eax, %eax
   13a51: 0f 8e cd 12 00 00            	jle	0x14d24 <bpf_object_open.part.0+0x3594>
; 			ext->kcfg.align = btf__align_of(obj->btf, t->type);
   13a57: 48 8b 44 24 38               	movq	56(%rsp), %rax
   13a5c: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   13a63: 8b 70 08                     	movl	8(%rax), %esi
   13a66: e8 65 7c 01 00               	callq	0x2b6d0 <btf__align_of>
   13a6b: 41 89 45 28                  	movl	%eax, 40(%r13)
   13a6f: 89 c1                        	movl	%eax, %ecx
; 			if (ext->kcfg.align <= 0) {
   13a71: 85 c0                        	testl	%eax, %eax
   13a73: 0f 8e 8a 12 00 00            	jle	0x14d03 <bpf_object_open.part.0+0x3573>
; 			ext->kcfg.type = find_kcfg_type(obj->btf, t->type,
   13a79: 48 8b 44 24 38               	movq	56(%rsp), %rax
   13a7e: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   13a85: 49 8d 55 30                  	leaq	48(%r13), %rdx
   13a89: 8b 70 08                     	movl	8(%rax), %esi
   13a8c: e8 4f 7b ff ff               	callq	0xb5e0 <find_kcfg_type>
   13a91: 41 89 45 20                  	movl	%eax, 32(%r13)
; 			if (ext->kcfg.type == KCFG_UNKNOWN) {
   13a95: 85 c0                        	testl	%eax, %eax
   13a97: 0f 84 e8 10 00 00            	je	0x14b85 <bpf_object_open.part.0+0x33f5>
   13a9d: 4c 89 74 24 50               	movq	%r14, 80(%rsp)
   13aa2: e9 ad e8 ff ff               	jmp	0x12354 <bpf_object_open.part.0+0xbc4>
; 			pr_warn("internal error at %d\n", __LINE__);
   13aa7: ba a2 19 00 00               	movl	$6562, %edx             # imm = 0x19A2
   13aac: 48 8d 35 63 e6 01 00         	leaq	124515(%rip), %rsi      # 0x32116 <_IO_stdin_used+0x2116>
   13ab3: 31 ff                        	xorl	%edi, %edi
   13ab5: 31 c0                        	xorl	%eax, %eax
   13ab7: e8 14 46 ff ff               	callq	0x80d0 <libbpf_print>
   13abc: 48 c7 c3 5c f0 ff ff         	movq	$-4004, %rbx            # imm = 0xF05C
   13ac3: e9 30 e1 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   13ac8: 49 89 ef                     	movq	%rbp, %r15
   13acb: e9 98 f6 ff ff               	jmp	0x13168 <bpf_object_open.part.0+0x19d8>
   13ad0: c7 44 24 48 00 00 00 00      	movl	$0, 72(%rsp)
   13ad8: e9 cd e7 ff ff               	jmp	0x122aa <bpf_object_open.part.0+0xb1a>
; 		return 0;
   13add: c7 44 24 48 00 00 00 00      	movl	$0, 72(%rsp)
; 	n = sh->sh_size / sh->sh_entsize;
   13ae5: 48 8b 4d 38                  	movq	56(%rbp), %rcx
   13ae9: e9 bc e7 ff ff               	jmp	0x122aa <bpf_object_open.part.0+0xb1a>
; 	scn = elf_getscn(obj->efile.elf, idx);
   13aee: 48 89 d6                     	movq	%rdx, %rsi
   13af1: 44 89 54 24 70               	movl	%r10d, 112(%rsp)
   13af6: 4c 89 4c 24 48               	movq	%r9, 72(%rsp)
   13afb: 44 89 5c 24 38               	movl	%r11d, 56(%rsp)
   13b00: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
   13b05: e8 f6 20 ff ff               	callq	0x5c00 <.plt.sec+0x590>
; 	if (!scn) {
   13b0a: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   13b0f: 44 8b 5c 24 38               	movl	56(%rsp), %r11d
   13b14: 48 85 c0                     	testq	%rax, %rax
   13b17: 4c 8b 4c 24 48               	movq	72(%rsp), %r9
   13b1c: 44 8b 54 24 70               	movl	112(%rsp), %r10d
; 	scn = elf_getscn(obj->efile.elf, idx);
   13b21: 48 89 c6                     	movq	%rax, %rsi
; 	if (!scn) {
   13b24: 0f 84 b3 0c 00 00            	je	0x147dd <bpf_object_open.part.0+0x304d>
; 	sym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));
   13b2a: 48 89 ef                     	movq	%rbp, %rdi
   13b2d: 44 89 54 24 70               	movl	%r10d, 112(%rsp)
   13b32: 4c 89 4c 24 48               	movq	%r9, 72(%rsp)
   13b37: 44 89 5c 24 38               	movl	%r11d, 56(%rsp)
   13b3c: e8 ff 6f ff ff               	callq	0xab40 <elf_sec_name>
   13b41: 44 8b 5c 24 38               	movl	56(%rsp), %r11d
   13b46: 4c 8b 4c 24 48               	movq	72(%rsp), %r9
   13b4b: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	if (type == LIBBPF_MAP_UNSPEC) {
   13b50: 44 8b 54 24 70               	movl	112(%rsp), %r10d
; 		if (!bpf_object__shndx_is_maps(obj, shdr_idx)) {
   13b55: 44 39 9d fc 00 00 00         	cmpl	%r11d, 252(%rbp)
   13b5c: 0f 85 ad 10 00 00            	jne	0x14c0f <bpf_object_open.part.0+0x347f>
; 		for (map_idx = 0; map_idx < nr_maps; map_idx++) {
   13b62: 48 83 7c 24 60 00            	cmpq	$0, 96(%rsp)
; 			    map->sec_offset != sym->st_value)
   13b68: 48 8b 4b 08                  	movq	8(%rbx), %rcx
; 		for (map_idx = 0; map_idx < nr_maps; map_idx++) {
   13b6c: 0f 84 2d 03 00 00            	je	0x13e9f <bpf_object_open.part.0+0x270f>
   13b72: 48 8b 45 68                  	movq	104(%rbp), %rax
   13b76: 48 8b 7c 24 60               	movq	96(%rsp), %rdi
   13b7b: 48 8b 54 24 58               	movq	88(%rsp), %rdx
   13b80: eb 13                        	jmp	0x13b95 <bpf_object_open.part.0+0x2405>
   13b82: 48 83 c2 01                  	addq	$1, %rdx
   13b86: 48 05 a0 00 00 00            	addq	$160, %rax
   13b8c: 48 39 d7                     	cmpq	%rdx, %rdi
   13b8f: 0f 84 0a 03 00 00            	je	0x13e9f <bpf_object_open.part.0+0x270f>
; 			if (map->libbpf_type != type ||
   13b95: 8b 70 58                     	movl	88(%rax), %esi
   13b98: 85 f6                        	testl	%esi, %esi
   13b9a: 75 e6                        	jne	0x13b82 <bpf_object_open.part.0+0x23f2>
; 			    map->sec_idx != sym->st_shndx ||
   13b9c: 44 8b 48 1c                  	movl	28(%rax), %r9d
   13ba0: 0f b7 73 06                  	movzwl	6(%rbx), %esi
; 			if (map->libbpf_type != type ||
   13ba4: 41 39 f1                     	cmpl	%esi, %r9d
   13ba7: 75 d9                        	jne	0x13b82 <bpf_object_open.part.0+0x23f2>
; 			    map->sec_idx != sym->st_shndx ||
   13ba9: 48 39 48 20                  	cmpq	%rcx, 32(%rax)
   13bad: 75 d3                        	jne	0x13b82 <bpf_object_open.part.0+0x23f2>
; 			pr_debug("prog '%s': found map %zd (%s, sec %d, off %zu) for insn #%u\n",
   13baf: 48 89 54 24 58               	movq	%rdx, 88(%rsp)
   13bb4: 4c 8b 40 08                  	movq	8(%rax), %r8
   13bb8: 48 89 d5                     	movq	%rdx, %rbp
   13bbb: 31 c0                        	xorl	%eax, %eax
   13bbd: 41 52                        	pushq	%r10
   13bbf: 48 8d 35 4a 2c 02 00         	leaq	142410(%rip), %rsi      # 0x36810 <strs.2+0x3980>
   13bc6: bf 02 00 00 00               	movl	$2, %edi
   13bcb: 44 89 54 24 40               	movl	%r10d, 64(%rsp)
   13bd0: 51                           	pushq	%rcx
   13bd1: 48 89 d1                     	movq	%rdx, %rcx
   13bd4: 49 8b 16                     	movq	(%r14), %rdx
   13bd7: e8 f4 44 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (map_idx >= nr_maps) {
   13bdc: 58                           	popq	%rax
   13bdd: 5a                           	popq	%rdx
   13bde: 48 39 6c 24 60               	cmpq	%rbp, 96(%rsp)
   13be3: 44 8b 54 24 38               	movl	56(%rsp), %r10d
   13be8: 0f 86 4b 10 00 00            	jbe	0x14c39 <bpf_object_open.part.0+0x34a9>
; 		reloc_desc->map_idx = map_idx;
   13bee: 8b 44 24 58                  	movl	88(%rsp), %eax
; 		prog->nr_reloc++;
   13bf2: 41 8b 4e 50                  	movl	80(%r14), %ecx
; 		reloc_desc->insn_idx = insn_idx;
   13bf6: 45 89 55 04                  	movl	%r10d, 4(%r13)
; 		reloc_desc->type = RELO_LD64;
   13bfa: 41 c7 45 00 00 00 00 00      	movl	$0, (%r13)
; 		reloc_desc->map_idx = map_idx;
   13c02: 41 89 45 08                  	movl	%eax, 8(%r13)
; 		reloc_desc->sym_off = 0; /* sym->st_value determines map_idx */
   13c06: 41 c7 45 0c 00 00 00 00      	movl	$0, 12(%r13)
; 		if (err)
   13c0e: e9 11 f9 ff ff               	jmp	0x13524 <bpf_object_open.part.0+0x1d94>
; 			pr_warn("sec '%s': invalid offset 0x%zx for relo #%d\n",
   13c13: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   13c18: 45 89 e8                     	movl	%r13d, %r8d
   13c1b: 48 89 e9                     	movq	%rbp, %rcx
   13c1e: 31 ff                        	xorl	%edi, %edi
   13c20: 48 8d 35 09 29 02 00         	leaq	141577(%rip), %rsi      # 0x36530 <strs.2+0x36a0>
   13c27: 31 c0                        	xorl	%eax, %eax
   13c29: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   13c30: e8 9b 44 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13c35: e9 be df ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	return false;
   13c3a: c6 44 24 40 00               	movb	$0, 64(%rsp)
; 		type = is_map_in_map ? "map" : "prog";
   13c3f: 4c 8d 25 32 e4 01 00         	leaq	123954(%rip), %r12      # 0x32078 <_IO_stdin_used+0x2078>
   13c46: e9 4d f2 ff ff               	jmp	0x12e98 <bpf_object_open.part.0+0x1708>
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   13c4b: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   13c50: e8 0b 1e ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   13c55: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   13c5a: 4c 89 f2                     	movq	%r14, %rdx
   13c5d: 31 ff                        	xorl	%edi, %edi
   13c5f: 49 89 c0                     	movq	%rax, %r8
   13c62: 48 8d 35 77 01 02 00         	leaq	131447(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
   13c69: 31 c0                        	xorl	%eax, %eax
   13c6b: e8 60 44 ff ff               	callq	0x80d0 <libbpf_print>
; 		sym_name = sym_name ?: "<?";
   13c70: 4c 8d 0d 06 e4 01 00         	leaq	123910(%rip), %r9       # 0x3207d <_IO_stdin_used+0x207d>
   13c77: e9 d7 ec ff ff               	jmp	0x12953 <bpf_object_open.part.0+0x11c3>
; 		} else if (strcmp(sec_name, KSYMS_SEC) == 0) {
   13c7c: 48 8d 35 81 e4 01 00         	leaq	124033(%rip), %rsi      # 0x32104 <_IO_stdin_used+0x2104>
   13c83: 4c 89 e7                     	movq	%r12, %rdi
   13c86: e8 25 1d ff ff               	callq	0x59b0 <.plt.sec+0x340>
   13c8b: 85 c0                        	testl	%eax, %eax
   13c8d: 0f 85 45 12 00 00            	jne	0x14ed8 <bpf_object_open.part.0+0x3748>
; 			skip_mods_and_typedefs(obj->btf, t->type,
   13c93: 48 8b 44 24 38               	movq	56(%rsp), %rax
; 			ext->type = EXT_KSYM;
   13c98: 41 c7 45 00 02 00 00 00      	movl	$2, (%r13)
; 			skip_mods_and_typedefs(obj->btf, t->type,
   13ca0: 49 8d 55 30                  	leaq	48(%r13), %rdx
   13ca4: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   13cab: 8b 70 08                     	movl	8(%rax), %esi
   13cae: e8 bd 78 ff ff               	callq	0xb570 <skip_mods_and_typedefs>
   13cb3: 4c 89 74 24 40               	movq	%r14, 64(%rsp)
   13cb8: e9 97 e6 ff ff               	jmp	0x12354 <bpf_object_open.part.0+0xbc4>
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   13cbd: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
; 	sec_name = elf_sec_name(obj, scn);
   13cc2: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   13cc9: e8 92 1d ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   13cce: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   13cd3: 4c 89 f2                     	movq	%r14, %rdx
   13cd6: 31 ff                        	xorl	%edi, %edi
   13cd8: 49 89 c0                     	movq	%rax, %r8
   13cdb: 48 8d 35 fe 00 02 00         	leaq	131326(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
   13ce2: 31 c0                        	xorl	%eax, %eax
   13ce4: e8 e7 43 ff ff               	callq	0x80d0 <libbpf_print>
; 	sec_name = elf_sec_name(obj, scn);
   13ce9: 4c 89 ee                     	movq	%r13, %rsi
   13cec: 4c 89 ff                     	movq	%r15, %rdi
   13cef: e8 4c 6e ff ff               	callq	0xab40 <elf_sec_name>
; 	if (!relo_sec_name || !sec_name)
   13cf4: e9 ff de ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   13cf9: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   13cfe: e8 5d 1d ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   13d03: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   13d08: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   13d0d: 31 ff                        	xorl	%edi, %edi
   13d0f: 49 89 c0                     	movq	%rax, %r8
   13d12: 48 8d 35 57 14 02 00         	leaq	136279(%rip), %rsi      # 0x35170 <strs.2+0x22e0>
   13d19: 31 c0                        	xorl	%eax, %eax
   13d1b: e8 b0 43 ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
   13d20: e9 bc ea ff ff               	jmp	0x127e1 <bpf_object_open.part.0+0x1051>
; 			pr_debug("No name found in string section for VAR kind\n");
   13d25: 4d 89 f7                     	movq	%r14, %r15
   13d28: 48 8d 35 01 21 02 00         	leaq	139521(%rip), %rsi      # 0x35e30 <strs.2+0x2fa0>
   13d2f: bf 02 00 00 00               	movl	$2, %edi
   13d34: 48 c7 c3 fe ff ff ff         	movq	$-2, %rbx
   13d3b: bd 02 00 00 00               	movl	$2, %ebp
; 			return -ENOENT;
   13d40: 41 bc fe ff ff ff            	movl	$4294967294, %r12d      # imm = 0xFFFFFFFE
; 			pr_debug("No name found in string section for VAR kind\n");
   13d46: e8 85 43 ff ff               	callq	0x80d0 <libbpf_print>
; 			if (err)
   13d4b: e9 ed e8 ff ff               	jmp	0x1263d <bpf_object_open.part.0+0xead>
   13d50: 4c 8b 74 24 28               	movq	40(%rsp), %r14
; 		if (ext->sec_btf_id <= 0) {
   13d55: 45 8b 65 08                  	movl	8(%r13), %r12d
; 	return -ENOENT;
   13d59: 41 b8 fe ff ff ff            	movl	$4294967294, %r8d       # imm = 0xFFFFFFFE
; 		ext->sec_btf_id = find_extern_sec_btf_id(obj->btf, ext->btf_id);
   13d5f: 45 89 45 0c                  	movl	%r8d, 12(%r13)
; 			pr_warn("failed to find BTF for extern '%s' [%d] section: %d\n",
   13d63: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   13d68: 44 89 e1                     	movl	%r12d, %ecx
   13d6b: 31 ff                        	xorl	%edi, %edi
   13d6d: 48 8d 35 1c 1e 02 00         	leaq	138780(%rip), %rsi      # 0x35b90 <strs.2+0x2d00>
   13d74: 31 c0                        	xorl	%eax, %eax
   13d76: e8 55 43 ff ff               	callq	0x80d0 <libbpf_print>
; 			return ext->sec_btf_id;
   13d7b: 49 63 5d 0c                  	movslq	12(%r13), %rbx
   13d7f: e9 1a e6 ff ff               	jmp	0x1239e <bpf_object_open.part.0+0xc0e>
   13d84: 0f 1f 40 00                  	nopl	(%rax)
; 			pr_warn("sec '%s': corrupted symbol #%zu pointing to invalid section #%zu for relo #%d\n",
   13d88: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   13d8d: 45 89 e1                     	movl	%r12d, %r9d
   13d90: 31 ff                        	xorl	%edi, %edi
   13d92: 31 c0                        	xorl	%eax, %eax
   13d94: 48 8d 35 3d 27 02 00         	leaq	141117(%rip), %rsi      # 0x364d8 <strs.2+0x3648>
   13d9b: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   13da2: e8 29 43 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13da7: e9 4c de ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	for (map_idx = 0; map_idx < nr_maps; map_idx++) {
   13dac: 48 83 7c 24 60 00            	cmpq	$0, 96(%rsp)
   13db2: 74 33                        	je	0x13de7 <bpf_object_open.part.0+0x2657>
   13db4: 48 8b 45 68                  	movq	104(%rbp), %rax
   13db8: 48 8b 7c 24 60               	movq	96(%rsp), %rdi
   13dbd: 48 8b 54 24 58               	movq	88(%rsp), %rdx
   13dc2: 8b 4c 24 38                  	movl	56(%rsp), %ecx
; 		if (map->libbpf_type != type || map->sec_idx != sym->st_shndx)
   13dc6: 39 48 58                     	cmpl	%ecx, 88(%rax)
   13dc9: 75 0d                        	jne	0x13dd8 <bpf_object_open.part.0+0x2648>
   13dcb: 44 8b 48 1c                  	movl	28(%rax), %r9d
   13dcf: 0f b7 73 06                  	movzwl	6(%rbx), %esi
   13dd3: 41 39 f1                     	cmpl	%esi, %r9d
   13dd6: 74 33                        	je	0x13e0b <bpf_object_open.part.0+0x267b>
; 	for (map_idx = 0; map_idx < nr_maps; map_idx++) {
   13dd8: 48 83 c2 01                  	addq	$1, %rdx
   13ddc: 48 05 a0 00 00 00            	addq	$160, %rax
   13de2: 48 39 d7                     	cmpq	%rdx, %rdi
   13de5: 75 df                        	jne	0x13dc6 <bpf_object_open.part.0+0x2636>
; 		pr_warn("prog '%s': data relo failed to find map for section '%s'\n",
   13de7: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   13dec: 49 8b 16                     	movq	(%r14), %rdx
   13def: 31 ff                        	xorl	%edi, %edi
   13df1: 31 c0                        	xorl	%eax, %eax
   13df3: 48 8d 35 e6 2a 02 00         	leaq	142054(%rip), %rsi      # 0x368e0 <strs.2+0x3a50>
   13dfa: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   13e01: e8 ca 42 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13e06: e9 ed dd ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_debug("prog '%s': found data map %zd (%s, sec %d, off %zu) for insn %u\n",
   13e0b: 48 89 54 24 58               	movq	%rdx, 88(%rsp)
   13e10: 4c 8b 40 08                  	movq	8(%rax), %r8
   13e14: 48 89 d5                     	movq	%rdx, %rbp
   13e17: 48 89 d1                     	movq	%rdx, %rcx
   13e1a: 41 52                        	pushq	%r10
   13e1c: 49 8b 16                     	movq	(%r14), %rdx
   13e1f: bf 02 00 00 00               	movl	$2, %edi
   13e24: 48 8d 35 fd 2a 02 00         	leaq	142077(%rip), %rsi      # 0x36928 <strs.2+0x3a98>
   13e2b: 44 89 54 24 40               	movl	%r10d, 64(%rsp)
   13e30: ff 70 20                     	pushq	32(%rax)
   13e33: 31 c0                        	xorl	%eax, %eax
   13e35: e8 96 42 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (map_idx >= nr_maps) {
   13e3a: 41 59                        	popq	%r9
   13e3c: 41 5a                        	popq	%r10
   13e3e: 48 8b 44 24 60               	movq	96(%rsp), %rax
   13e43: 44 8b 54 24 38               	movl	56(%rsp), %r10d
   13e48: 48 39 c5                     	cmpq	%rax, %rbp
   13e4b: 73 9a                        	jae	0x13de7 <bpf_object_open.part.0+0x2657>
; 	reloc_desc->map_idx = map_idx;
   13e4d: 8b 44 24 58                  	movl	88(%rsp), %eax
; 		prog->nr_reloc++;
   13e51: 41 8b 4e 50                  	movl	80(%r14), %ecx
; 	reloc_desc->type = RELO_DATA;
   13e55: 41 c7 45 00 02 00 00 00      	movl	$2, (%r13)
; 	reloc_desc->insn_idx = insn_idx;
   13e5d: 45 89 55 04                  	movl	%r10d, 4(%r13)
; 	reloc_desc->map_idx = map_idx;
   13e61: 41 89 45 08                  	movl	%eax, 8(%r13)
; 	reloc_desc->sym_off = sym->st_value;
   13e65: 48 8b 43 08                  	movq	8(%rbx), %rax
   13e69: 41 89 45 0c                  	movl	%eax, 12(%r13)
; 		if (err)
   13e6d: e9 b2 f6 ff ff               	jmp	0x13524 <bpf_object_open.part.0+0x1d94>
; 		if (btf_is_var(t) &&
   13e72: 83 7d 0c 02                  	cmpl	$2, 12(%rbp)
   13e76: 0f 84 85 fa ff ff            	je	0x13901 <bpf_object_open.part.0+0x2171>
   13e7c: 4c 8b 74 24 28               	movq	40(%rsp), %r14
; 			return -EINVAL;
   13e81: b9 ea ff ff ff               	movl	$4294967274, %ecx       # imm = 0xFFFFFFEA
   13e86: e9 f6 e4 ff ff               	jmp	0x12381 <bpf_object_open.part.0+0xbf1>
   13e8b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   13e90: 48 63 8d f8 00 00 00         	movslq	248(%rbp), %rcx
   13e97: 49 89 ef                     	movq	%rbp, %r15
   13e9a: e9 d9 ec ff ff               	jmp	0x12b78 <bpf_object_open.part.0+0x13e8>
   13e9f: 4c 8b 54 24 18               	movq	24(%rsp), %r10
; 			pr_warn("prog '%s': map relo failed to find map for section '%s', off %zu\n",
   13ea4: 49 8b 16                     	movq	(%r14), %rdx
   13ea7: 49 89 c8                     	movq	%rcx, %r8
   13eaa: 48 8d 35 a7 29 02 00         	leaq	141735(%rip), %rsi      # 0x36858 <strs.2+0x39c8>
   13eb1: 4c 89 d1                     	movq	%r10, %rcx
   13eb4: 31 ff                        	xorl	%edi, %edi
   13eb6: 31 c0                        	xorl	%eax, %eax
   13eb8: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   13ebf: e8 0c 42 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13ec4: e9 2f dd ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
   13ec9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	scn = elf_getscn(obj->efile.elf, idx);
   13ed0: 48 89 d6                     	movq	%rdx, %rsi
   13ed3: 44 89 54 24 70               	movl	%r10d, 112(%rsp)
   13ed8: 4c 89 4c 24 48               	movq	%r9, 72(%rsp)
   13edd: 44 89 5c 24 38               	movl	%r11d, 56(%rsp)
   13ee2: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
   13ee7: e8 14 1d ff ff               	callq	0x5c00 <.plt.sec+0x590>
; 	if (!scn) {
   13eec: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   13ef1: 44 8b 5c 24 38               	movl	56(%rsp), %r11d
   13ef6: 48 85 c0                     	testq	%rax, %rax
   13ef9: 4c 8b 4c 24 48               	movq	72(%rsp), %r9
   13efe: 44 8b 54 24 70               	movl	112(%rsp), %r10d
; 	scn = elf_getscn(obj->efile.elf, idx);
   13f03: 48 89 c6                     	movq	%rax, %rsi
; 	if (!scn) {
   13f06: 0f 84 b6 0d 00 00            	je	0x14cc2 <bpf_object_open.part.0+0x3532>
; 	sym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));
   13f0c: 48 89 ef                     	movq	%rbp, %rdi
   13f0f: 44 89 54 24 70               	movl	%r10d, 112(%rsp)
   13f14: 48 89 54 24 48               	movq	%rdx, 72(%rsp)
   13f19: e8 22 6c ff ff               	callq	0xab40 <elf_sec_name>
   13f1e: 48 8b 54 24 48               	movq	72(%rsp), %rdx
   13f23: 44 8b 54 24 70               	movl	112(%rsp), %r10d
; 		return LIBBPF_MAP_KCONFIG;
   13f28: c7 44 24 38 04 00 00 00      	movl	$4, 56(%rsp)
; 	sym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));
   13f30: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	if (type == LIBBPF_MAP_UNSPEC) {
   13f35: e9 ef eb ff ff               	jmp	0x12b29 <bpf_object_open.part.0+0x1399>
; 	n = sh->sh_size / sh->sh_entsize;
   13f3a: 48 8b 44 24 08               	movq	8(%rsp), %rax
   13f3f: c7 44 24 48 00 00 00 00      	movl	$0, 72(%rsp)
   13f47: 48 8b 48 38                  	movq	56(%rax), %rcx
   13f4b: e9 5a e3 ff ff               	jmp	0x122aa <bpf_object_open.part.0+0xb1a>
; 		pr_warn("cannot create a dummy_ksym var\n");
   13f50: 48 8d 35 a9 1b 02 00         	leaq	138153(%rip), %rsi      # 0x35b00 <strs.2+0x2c70>
   13f57: 31 ff                        	xorl	%edi, %edi
   13f59: 31 c0                        	xorl	%eax, %eax
   13f5b: e8 70 41 ff ff               	callq	0x80d0 <libbpf_print>
; 	return ERR_PTR(err);
   13f60: 48 63 5c 24 48               	movslq	72(%rsp), %rbx
   13f65: e9 8e dc ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("struct_ops reloc %s: invalid target program offset %llu\n",
   13f6a: 49 8b 54 24 08               	movq	8(%r12), %rdx
   13f6f: 48 89 c1                     	movq	%rax, %rcx
   13f72: 31 ff                        	xorl	%edi, %edi
   13f74: 31 c0                        	xorl	%eax, %eax
   13f76: 48 8d 35 8b 20 02 00         	leaq	139403(%rip), %rsi      # 0x36008 <strs.2+0x3178>
   13f7d: 49 89 ef                     	movq	%rbp, %r15
   13f80: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   13f87: e8 44 41 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13f8c: e9 67 dc ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("struct_ops reloc %s: rel->r_offset %zu shdr_idx %u unsupported non-static function\n",
   13f91: 48 8b 0b                     	movq	(%rbx), %rcx
   13f94: 49 8b 54 24 08               	movq	8(%r12), %rdx
   13f99: 31 ff                        	xorl	%edi, %edi
   13f9b: 31 c0                        	xorl	%eax, %eax
   13f9d: 44 8b 44 24 20               	movl	32(%rsp), %r8d
   13fa2: 48 8d 35 ff 1f 02 00         	leaq	139263(%rip), %rsi      # 0x35fa8 <strs.2+0x3118>
   13fa9: 49 89 ef                     	movq	%rbp, %r15
   13fac: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   13fb3: e8 18 41 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13fb8: e9 3b dc ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("struct_ops reloc %s: prog %s is not struct_ops BPF program\n",
   13fbd: 4d 8b 44 24 08               	movq	8(%r12), %r8
   13fc2: 48 8b 08                     	movq	(%rax), %rcx
   13fc5: 31 ff                        	xorl	%edi, %edi
   13fc7: 31 c0                        	xorl	%eax, %eax
   13fc9: 48 8d 35 18 21 02 00         	leaq	139544(%rip), %rsi      # 0x360e8 <strs.2+0x3258>
   13fd0: 49 89 ef                     	movq	%rbp, %r15
   13fd3: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   13fda: 4c 89 c2                     	movq	%r8, %rdx
   13fdd: e8 ee 40 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   13fe2: e9 11 dc ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   13fe7: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   13fec: e8 6f 1a ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   13ff1: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   13ff6: 4c 89 e2                     	movq	%r12, %rdx
   13ff9: 31 ff                        	xorl	%edi, %edi
   13ffb: 49 89 c0                     	movq	%rax, %r8
   13ffe: 48 8d 35 db fd 01 00         	leaq	130523(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
   14005: 31 c0                        	xorl	%eax, %eax
   14007: e8 c4 40 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (!ext_name || !ext_name[0])
   1400c: e9 43 e3 ff ff               	jmp	0x12354 <bpf_object_open.part.0+0xbc4>
   14011: 4c 8b 74 24 40               	movq	64(%rsp), %r14
; 			pr_warn("struct_ops reloc %s: cannot find prog at shdr_idx %u to relocate func ptr %s\n",
   14016: 49 8b 54 24 08               	movq	8(%r12), %rdx
   1401b: 31 ff                        	xorl	%edi, %edi
   1401d: 49 89 ef                     	movq	%rbp, %r15
   14020: 8b 4c 24 20                  	movl	32(%rsp), %ecx
   14024: 48 8d 35 65 20 02 00         	leaq	139365(%rip), %rsi      # 0x36090 <strs.2+0x3200>
   1402b: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   14032: 4d 89 f0                     	movq	%r14, %r8
   14035: e8 96 40 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   1403a: e9 b9 db ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   1403f: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   14044: 48 89 44 24 38               	movq	%rax, 56(%rsp)
   14049: e8 12 1a ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   1404e: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   14053: 4c 89 f2                     	movq	%r14, %rdx
   14056: 31 ff                        	xorl	%edi, %edi
   14058: 49 89 c0                     	movq	%rax, %r8
   1405b: 48 8d 35 0e 11 02 00         	leaq	135438(%rip), %rsi      # 0x35170 <strs.2+0x22e0>
   14062: 31 c0                        	xorl	%eax, %eax
   14064: e8 67 40 ff ff               	callq	0x80d0 <libbpf_print>
   14069: 4c 8b 4c 24 38               	movq	56(%rsp), %r9
; 		return NULL;
   1406e: e9 fd f3 ff ff               	jmp	0x13470 <bpf_object_open.part.0+0x1ce0>
; 			pr_info("elf: skipping section(%d) %s (size %zu)\n", idx, name,
   14073: 4c 8b 43 20                  	movq	32(%rbx), %r8
   14077: 8b 54 24 08                  	movl	8(%rsp), %edx
   1407b: 4c 89 e1                     	movq	%r12, %rcx
   1407e: bf 01 00 00 00               	movl	$1, %edi
   14083: 48 8d 35 fe 19 02 00         	leaq	137726(%rip), %rsi      # 0x35a88 <strs.2+0x2bf8>
   1408a: 31 c0                        	xorl	%eax, %eax
   1408c: e8 3f 40 ff ff               	callq	0x80d0 <libbpf_print>
   14091: e9 fa dc ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 		} else if (sh->sh_type == SHT_PROGBITS && data->d_size > 0) {
   14096: 48 8b 45 10                  	movq	16(%rbp), %rax
   1409a: 48 89 44 24 58               	movq	%rax, 88(%rsp)
   1409f: 48 85 c0                     	testq	%rax, %rax
   140a2: 74 cf                        	je	0x14073 <bpf_object_open.part.0+0x28e3>
; 			if (sh->sh_flags & SHF_EXECINSTR) {
   140a4: f6 43 08 04                  	testb	$4, 8(%rbx)
   140a8: 0f 84 59 09 00 00            	je	0x14a07 <bpf_object_open.part.0+0x3277>
; 				if (strcmp(name, ".text") == 0)
   140ae: 48 8d 35 e0 df 01 00         	leaq	122848(%rip), %rsi      # 0x32095 <_IO_stdin_used+0x2095>
   140b5: 4c 89 e7                     	movq	%r12, %rdi
   140b8: e8 f3 18 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   140bd: 85 c0                        	testl	%eax, %eax
   140bf: 75 0b                        	jne	0x140cc <bpf_object_open.part.0+0x293c>
; 					obj->efile.text_shndx = idx;
   140c1: 8b 44 24 10                  	movl	16(%rsp), %eax
   140c5: 41 89 85 04 01 00 00         	movl	%eax, 260(%r13)
; 				err = bpf_object__add_programs(obj, data, name, idx);
   140cc: 48 8b 45 00                  	movq	(%rbp), %rax
; 	nr_syms = symbols->d_size / sizeof(Elf64_Sym);
   140d0: 49 8b 8d d0 00 00 00         	movq	208(%r13), %rcx
   140d7: bf 18 00 00 00               	movl	$24, %edi
   140dc: 31 d2                        	xorl	%edx, %edx
   140de: 48 89 44 24 60               	movq	%rax, 96(%rsp)
; 	progs = obj->programs;
   140e3: 49 8b 45 58                  	movq	88(%r13), %rax
; 	nr_syms = symbols->d_size / sizeof(Elf64_Sym);
   140e7: 48 8b 71 10                  	movq	16(%rcx), %rsi
; 	progs = obj->programs;
   140eb: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 	nr_progs = obj->nr_programs;
   140f0: 41 8b 45 60                  	movl	96(%r13), %eax
   140f4: 89 44 24 40                  	movl	%eax, 64(%rsp)
; 	nr_syms = symbols->d_size / sizeof(Elf64_Sym);
   140f8: 48 89 f0                     	movq	%rsi, %rax
   140fb: 48 f7 f7                     	divq	%rdi
   140fe: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
; 	for (i = 0; i < nr_syms; i++) {
   14106: 48 83 fe 17                  	cmpq	$23, %rsi
   1410a: 0f 86 80 dc ff ff            	jbe	0x11d90 <bpf_object_open.part.0+0x600>
;   return __builtin___memset_chk (__dest, __ch, __len,
   14110: 4c 89 b4 24 90 00 00 00      	movq	%r14, 144(%rsp)
   14118: 4d 89 e6                     	movq	%r12, %r14
; 	for (i = 0; i < nr_syms; i++) {
   1411b: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   14124: 4c 89 bc 24 98 00 00 00      	movq	%r15, 152(%rsp)
   1412c: eb 22                        	jmp	0x14150 <bpf_object_open.part.0+0x29c0>
   1412e: 66 90                        	nop
; 	for (i = 0; i < nr_syms; i++) {
   14130: 48 83 44 24 18 01            	addq	$1, 24(%rsp)
   14136: 48 8b 44 24 18               	movq	24(%rsp), %rax
   1413b: 48 3b 84 24 88 00 00 00      	cmpq	136(%rsp), %rax
   14143: 0f 83 53 0d 00 00            	jae	0x14e9c <bpf_object_open.part.0+0x370c>
   14149: 49 8b 8d d0 00 00 00         	movq	208(%r13), %rcx
; 	if (idx >= obj->efile.symbols->d_size / sizeof(Elf64_Sym))
   14150: 48 b8 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rax # imm = 0xAAAAAAAAAAAAAAAB
   1415a: 48 f7 61 10                  	mulq	16(%rcx)
   1415e: 48 8b 44 24 18               	movq	24(%rsp), %rax
   14163: 48 c1 ea 04                  	shrq	$4, %rdx
   14167: 48 39 c2                     	cmpq	%rax, %rdx
   1416a: 0f 86 30 1b ff ff            	jbe	0x5ca0 <bpf_object_open.part.0.cold>
; 	return (Elf64_Sym *)obj->efile.symbols->d_buf + idx;
   14170: 48 8b 11                     	movq	(%rcx), %rdx
   14173: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   14177: 48 8d 1c c2                  	leaq	(%rdx,%rax,8), %rbx
; 		if (sym->st_shndx != sec_idx)
   1417b: 0f b7 43 06                  	movzwl	6(%rbx), %eax
   1417f: 39 44 24 08                  	cmpl	%eax, 8(%rsp)
   14183: 75 ab                        	jne	0x14130 <bpf_object_open.part.0+0x29a0>
; 		if (ELF64_ST_TYPE(sym->st_info) != STT_FUNC)
   14185: 0f b6 43 04                  	movzbl	4(%rbx), %eax
   14189: 83 e0 0f                     	andl	$15, %eax
   1418c: 3c 02                        	cmpb	$2, %al
   1418e: 75 a0                        	jne	0x14130 <bpf_object_open.part.0+0x29a0>
; 		name = elf_sym_str(obj, sym->st_name);
   14190: 8b 2b                        	movl	(%rbx), %ebp
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   14192: 49 8b b5 e8 00 00 00         	movq	232(%r13), %rsi
   14199: 49 8b bd c0 00 00 00         	movq	192(%r13), %rdi
; 		prog_sz = sym->st_size;
   141a0: 4c 8b 63 10                  	movq	16(%rbx), %r12
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   141a4: 48 89 ea                     	movq	%rbp, %rdx
; 		sec_off = sym->st_value;
   141a7: 4c 8b 7b 08                  	movq	8(%rbx), %r15
; 	name = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);
   141ab: e8 c0 16 ff ff               	callq	0x5870 <.plt.sec+0x200>
   141b0: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	if (!name) {
   141b5: 48 85 c0                     	testq	%rax, %rax
   141b8: 0f 84 84 0d 00 00            	je	0x14f42 <bpf_object_open.part.0+0x37b2>
; 		if (sec_off + prog_sz > sec_sz) {
   141be: 4b 8d 04 3c                  	leaq	(%r12,%r15), %rax
   141c2: 48 39 44 24 58               	cmpq	%rax, 88(%rsp)
   141c7: 0f 82 4d 0d 00 00            	jb	0x14f1a <bpf_object_open.part.0+0x378a>
; 		if (sec_idx != obj->efile.text_shndx && ELF64_ST_BIND(sym->st_info) == STB_LOCAL) {
   141cd: 8b 44 24 08                  	movl	8(%rsp), %eax
   141d1: 41 3b 85 04 01 00 00         	cmpl	260(%r13), %eax
   141d8: 74 0d                        	je	0x141e7 <bpf_object_open.part.0+0x2a57>
   141da: 0f b6 43 04                  	movzbl	4(%rbx), %eax
   141de: c0 e8 04                     	shrb	$4, %al
   141e1: 0f 84 b1 0d 00 00            	je	0x14f98 <bpf_object_open.part.0+0x3808>
; 		pr_debug("sec '%s': found program '%s' at insn offset %zu (%zu bytes), code size %zu insns (%zu bytes)\n",
   141e7: 4c 89 e0                     	movq	%r12, %rax
   141ea: 4c 89 f9                     	movq	%r15, %rcx
   141ed: 4d 89 f9                     	movq	%r15, %r9
   141f0: 4c 89 f2                     	movq	%r14, %rdx
   141f3: 48 c1 e8 03                  	shrq	$3, %rax
   141f7: 48 c1 e9 03                  	shrq	$3, %rcx
   141fb: bf 02 00 00 00               	movl	$2, %edi
   14200: 48 8d 35 21 17 02 00         	leaq	136993(%rip), %rsi      # 0x35928 <strs.2+0x2a98>
   14207: 48 89 44 24 68               	movq	%rax, 104(%rsp)
   1420c: 49 89 c8                     	movq	%rcx, %r8
   1420f: 48 89 4c 24 70               	movq	%rcx, 112(%rsp)
   14214: 41 54                        	pushq	%r12
   14216: 50                           	pushq	%rax
   14217: 48 8b 4c 24 20               	movq	32(%rsp), %rcx
   1421c: 31 c0                        	xorl	%eax, %eax
   1421e: e8 ad 3e ff ff               	callq	0x80d0 <libbpf_print>
; 		progs = libbpf_reallocarray(progs, nr_progs + 1, sizeof(*progs));
   14223: 8b 44 24 50                  	movl	80(%rsp), %eax
   14227: 83 c0 01                     	addl	$1, %eax
   1422a: 89 84 24 88 00 00 00         	movl	%eax, 136(%rsp)
   14231: 48 98                        	cltq
   14233: 48 89 84 24 90 00 00 00      	movq	%rax, 144(%rsp)
   1423b: 48 89 c1                     	movq	%rax, %rcx
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   1423e: b8 c0 00 00 00               	movl	$192, %eax
   14243: 41 58                        	popq	%r8
   14245: 48 f7 e1                     	mulq	%rcx
   14248: 41 59                        	popq	%r9
   1424a: 48 89 c6                     	movq	%rax, %rsi
   1424d: 0f 80 a4 0c 00 00            	jo	0x14ef7 <bpf_object_open.part.0+0x3767>
; 	return realloc(ptr, total);
   14253: 48 8b 7c 24 38               	movq	56(%rsp), %rdi
   14258: e8 c3 18 ff ff               	callq	0x5b20 <.plt.sec+0x4b0>
   1425d: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 		if (!progs) {
   14262: 48 85 c0                     	testq	%rax, %rax
   14265: 0f 84 8c 0c 00 00            	je	0x14ef7 <bpf_object_open.part.0+0x3767>
; 		prog = &progs[nr_progs];
   1426b: 48 63 44 24 40               	movslq	64(%rsp), %rax
; 		obj->programs = progs;
   14270: 48 8b 4c 24 38               	movq	56(%rsp), %rcx
; 		prog = &progs[nr_progs];
   14275: 4c 8d 04 40                  	leaq	(%rax,%rax,2), %r8
; 		err = bpf_object__init_prog(obj, prog, name, sec_idx, sec_name,
   14279: 48 8b 44 24 60               	movq	96(%rsp), %rax
; 		obj->programs = progs;
   1427e: 49 89 4d 58                  	movq	%rcx, 88(%r13)
; 		prog = &progs[nr_progs];
   14282: 49 c1 e0 06                  	shlq	$6, %r8
; 		err = bpf_object__init_prog(obj, prog, name, sec_idx, sec_name,
   14286: 4c 01 f8                     	addq	%r15, %rax
; 		prog = &progs[nr_progs];
   14289: 4a 8d 2c 01                  	leaq	(%rcx,%r8), %rbp
; 		err = bpf_object__init_prog(obj, prog, name, sec_idx, sec_name,
   1428d: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 	if (insn_data_sz == 0 || insn_data_sz % BPF_INSN_SZ || sec_off % BPF_INSN_SZ) {
   14292: 4d 85 e4                     	testq	%r12, %r12
   14295: 0f 84 27 0d 00 00            	je	0x14fc2 <bpf_object_open.part.0+0x3832>
   1429b: 4c 89 e0                     	movq	%r12, %rax
   1429e: 4c 09 f8                     	orq	%r15, %rax
   142a1: a8 07                        	testb	$7, %al
   142a3: 0f 85 19 0d 00 00            	jne	0x14fc2 <bpf_object_open.part.0+0x3832>
;   return __builtin___memset_chk (__dest, __ch, __len,
   142a9: 31 c0                        	xorl	%eax, %eax
   142ab: b9 30 00 00 00               	movl	$48, %ecx
   142b0: 48 89 ef                     	movq	%rbp, %rdi
   142b3: f3 ab                        	rep		stosl	%eax, %es:(%rdi)
; 	prog->sec_idx = sec_idx;
   142b5: 48 8b 44 24 50               	movq	80(%rsp), %rax
; 	prog->obj = obj;
   142ba: 4c 89 6d 70                  	movq	%r13, 112(%rbp)
; 	prog->fd = -1;
   142be: c7 45 78 ff ff ff ff         	movl	$4294967295, 120(%rbp)  # imm = 0xFFFFFFFF
; 	prog->sec_idx = sec_idx;
   142c5: 48 89 45 10                  	movq	%rax, 16(%rbp)
; 	prog->sec_insn_off = sec_off / BPF_INSN_SZ;
   142c9: 48 8b 44 24 70               	movq	112(%rsp), %rax
   142ce: 48 89 45 20                  	movq	%rax, 32(%rbp)
; 	prog->sec_insn_cnt = insn_data_sz / BPF_INSN_SZ;
   142d2: 48 8b 44 24 68               	movq	104(%rsp), %rax
   142d7: 48 89 45 28                  	movq	%rax, 40(%rbp)
; 	prog->insns_cnt = prog->sec_insn_cnt;
   142db: 48 89 45 40                  	movq	%rax, 64(%rbp)
; 	if (sec_name[0] == '?') {
   142df: 41 80 3e 3f                  	cmpb	$63, (%r14)
   142e3: 0f 84 bb 06 00 00            	je	0x149a4 <bpf_object_open.part.0+0x3214>
; 		prog->autoload = true;
   142e9: c6 45 7c 01                  	movb	$1, 124(%rbp)
   142ed: 4d 89 f7                     	movq	%r14, %r15
; 	prog->log_level = obj->log_level;
   142f0: 41 8b 85 68 01 00 00         	movl	360(%r13), %eax
; 	prog->autoattach = true;
   142f7: c6 45 7d 01                  	movb	$1, 125(%rbp)
; 	prog->sec_name = strdup(sec_name);
   142fb: 4c 89 ff                     	movq	%r15, %rdi
; 	prog->log_level = obj->log_level;
   142fe: 89 45 68                     	movl	%eax, 104(%rbp)
; 	prog->sec_name = strdup(sec_name);
   14301: e8 0a 19 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   14306: 48 89 45 08                  	movq	%rax, 8(%rbp)
; 	if (!prog->sec_name)
   1430a: 48 85 c0                     	testq	%rax, %rax
   1430d: 0f 84 34 0a 00 00            	je	0x14d47 <bpf_object_open.part.0+0x35b7>
; 	prog->name = strdup(name);
   14313: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   14318: e8 f3 18 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   1431d: 48 89 45 00                  	movq	%rax, (%rbp)
; 	if (!prog->name)
   14321: 48 85 c0                     	testq	%rax, %rax
   14324: 0f 84 1d 0a 00 00            	je	0x14d47 <bpf_object_open.part.0+0x35b7>
; 	prog->insns = malloc(insn_data_sz);
   1432a: 4c 89 e7                     	movq	%r12, %rdi
   1432d: e8 5e 17 ff ff               	callq	0x5a90 <.plt.sec+0x420>
   14332: 48 89 45 38                  	movq	%rax, 56(%rbp)
   14336: 48 89 c7                     	movq	%rax, %rdi
; 	if (!prog->insns)
   14339: 48 85 c0                     	testq	%rax, %rax
   1433c: 0f 84 05 0a 00 00            	je	0x14d47 <bpf_object_open.part.0+0x35b7>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   14342: 48 8b 74 24 40               	movq	64(%rsp), %rsi
   14347: 4c 89 e2                     	movq	%r12, %rdx
   1434a: e8 f1 16 ff ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 		if (ELF64_ST_BIND(sym->st_info) != STB_LOCAL
   1434f: 0f b6 43 04                  	movzbl	4(%rbx), %eax
   14353: c0 e8 04                     	shrb	$4, %al
   14356: 74 13                        	je	0x1436b <bpf_object_open.part.0+0x2bdb>
; 			|| ELF64_ST_VISIBILITY(sym->st_other) == STV_INTERNAL))
   14358: 0f b6 43 05                  	movzbl	5(%rbx), %eax
   1435c: 83 e0 03                     	andl	$3, %eax
   1435f: 83 e8 01                     	subl	$1, %eax
; 		    && (ELF64_ST_VISIBILITY(sym->st_other) == STV_HIDDEN
   14362: 83 f8 01                     	cmpl	$1, %eax
   14365: 77 04                        	ja	0x1436b <bpf_object_open.part.0+0x2bdb>
; 			prog->mark_btf_static = true;
   14367: c6 45 7e 01                  	movb	$1, 126(%rbp)
; 		obj->nr_programs = nr_progs;
   1436b: 48 8b 84 24 80 00 00 00      	movq	128(%rsp), %rax
   14373: 49 89 45 60                  	movq	%rax, 96(%r13)
; 		nr_progs++;
   14377: 8b 44 24 78                  	movl	120(%rsp), %eax
   1437b: 89 44 24 40                  	movl	%eax, 64(%rsp)
   1437f: e9 ac fd ff ff               	jmp	0x14130 <bpf_object_open.part.0+0x29a0>
; 		qsort(obj->programs, obj->nr_programs, sizeof(*obj->programs), cmp_progs);
   14384: 49 8b 7d 58                  	movq	88(%r13), %rdi
   14388: 48 8d 0d 71 21 ff ff         	leaq	-56975(%rip), %rcx      # 0x6500 <cmp_progs>
   1438f: ba c0 00 00 00               	movl	$192, %edx
   14394: e8 c7 13 ff ff               	callq	0x5760 <.plt.sec+0xf0>
   14399: e9 d6 dd ff ff               	jmp	0x12174 <bpf_object_open.part.0+0x9e4>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   1439e: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   143a3: e8 b8 16 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   143a8: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   143ad: 4c 89 e2                     	movq	%r12, %rdx
   143b0: 31 ff                        	xorl	%edi, %edi
   143b2: 49 89 c0                     	movq	%rax, %r8
   143b5: 48 8d 35 b4 0d 02 00         	leaq	134580(%rip), %rsi      # 0x35170 <strs.2+0x22e0>
   143bc: 31 c0                        	xorl	%eax, %eax
   143be: e8 0d 3d ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
   143c3: e9 fa dd ff ff               	jmp	0x121c2 <bpf_object_open.part.0+0xa32>
; 				pr_warn(".maps relo #%d: '%s' isn't a BTF-defined map\n",
   143c8: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   143cd: 8b 54 24 20                  	movl	32(%rsp), %edx
   143d1: 31 ff                        	xorl	%edi, %edi
   143d3: 31 c0                        	xorl	%eax, %eax
   143d5: 48 8d 35 d4 1e 02 00         	leaq	138964(%rip), %rsi      # 0x362b0 <strs.2+0x3420>
   143dc: 49 89 ef                     	movq	%rbp, %r15
   143df: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   143e6: e8 e5 3c ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   143eb: e9 08 d8 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			int targ_sec_idx = sh->sh_info; /* points to other section */
   143f0: 48 63 43 2c                  	movslq	44(%rbx), %rax
; 			if (sh->sh_entsize != sizeof(Elf64_Rel) ||
   143f4: 48 83 7b 38 10               	cmpq	$16, 56(%rbx)
; 			int targ_sec_idx = sh->sh_info; /* points to other section */
   143f9: 89 44 24 38                  	movl	%eax, 56(%rsp)
; 			if (sh->sh_entsize != sizeof(Elf64_Rel) ||
   143fd: 0f 85 48 d9 ff ff            	jne	0x11d4b <bpf_object_open.part.0+0x5bb>
   14403: 41 3b 85 f8 00 00 00         	cmpl	248(%r13), %eax
   1440a: 0f 8d 3b d9 ff ff            	jge	0x11d4b <bpf_object_open.part.0+0x5bb>
; 	scn = elf_getscn(obj->efile.elf, idx);
   14410: 49 8b bd c0 00 00 00         	movq	192(%r13), %rdi
   14417: 48 89 c6                     	movq	%rax, %rsi
; 	sh = elf_sec_hdr(obj, elf_sec_by_idx(obj, idx));
   1441a: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	scn = elf_getscn(obj->efile.elf, idx);
   1441f: e8 dc 17 ff ff               	callq	0x5c00 <.plt.sec+0x590>
   14424: 49 89 c1                     	movq	%rax, %r9
; 	if (!scn) {
   14427: 48 85 c0                     	testq	%rax, %rax
   1442a: 0f 84 9f 08 00 00            	je	0x14ccf <bpf_object_open.part.0+0x353f>
; 	sh = elf_sec_hdr(obj, elf_sec_by_idx(obj, idx));
   14430: 4c 89 ce                     	movq	%r9, %rsi
   14433: 4c 89 ef                     	movq	%r13, %rdi
   14436: e8 a5 4a ff ff               	callq	0x8ee0 <elf_sec_hdr>
; 	if (!sh)
   1443b: 48 85 c0                     	testq	%rax, %rax
   1443e: 0f 84 da 04 00 00            	je	0x1491e <bpf_object_open.part.0+0x318e>
; 			if (!section_have_execinstr(obj, targ_sec_idx) &&
   14444: f6 40 08 04                  	testb	$4, 8(%rax)
   14448: 0f 84 d0 04 00 00            	je	0x1491e <bpf_object_open.part.0+0x318e>
; 			sec_desc->sec_type = SEC_RELO;
   1444e: 48 8b 44 24 18               	movq	24(%rsp), %rax
   14453: c7 00 01 00 00 00            	movl	$1, (%rax)
; 			sec_desc->shdr = sh;
   14459: 48 89 58 08                  	movq	%rbx, 8(%rax)
; 			sec_desc->data = data;
   1445d: 48 89 68 10                  	movq	%rbp, 16(%rax)
   14461: e9 2a d9 ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 		pr_debug("Invalid size for section %s: %u bytes\n", name, size);
   14466: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   1446b: 31 c9                        	xorl	%ecx, %ecx
   1446d: 48 8d 35 5c 19 02 00         	leaq	137564(%rip), %rsi      # 0x35dd0 <strs.2+0x2f40>
   14474: 31 c0                        	xorl	%eax, %eax
   14476: bf 02 00 00 00               	movl	$2, %edi
   1447b: 4d 89 f7                     	movq	%r14, %r15
   1447e: bd 02 00 00 00               	movl	$2, %ebp
   14483: 48 c7 c3 fe ff ff ff         	movq	$-2, %rbx
   1448a: e8 41 3c ff ff               	callq	0x80d0 <libbpf_print>
; 		return -ENOENT;
   1448f: 41 bc fe ff ff ff            	movl	$4294967294, %r12d      # imm = 0xFFFFFFFE
   14495: e9 a3 e1 ff ff               	jmp	0x1263d <bpf_object_open.part.0+0xead>
; 			pr_warn("prog '%s': bad subprog addr relo against '%s' at offset %zu+%d\n",
   1449a: 49 8b 16                     	movq	(%r14), %rdx
   1449d: 4c 89 c9                     	movq	%r9, %rcx
   144a0: 48 8d 35 e1 22 02 00         	leaq	140001(%rip), %rsi      # 0x36788 <strs.2+0x38f8>
   144a7: 41 89 c1                     	movl	%eax, %r9d
   144aa: 31 ff                        	xorl	%edi, %edi
   144ac: 31 c0                        	xorl	%eax, %eax
   144ae: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   144b5: e8 16 3c ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   144ba: e9 39 d7 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	pr_debug("collected %d externs total\n", obj->nr_extern);
   144bf: 41 8b 97 90 00 00 00         	movl	144(%r15), %edx
   144c6: 31 c0                        	xorl	%eax, %eax
   144c8: bf 02 00 00 00               	movl	$2, %edi
   144cd: 48 8d 35 2c 18 02 00         	leaq	137260(%rip), %rsi      # 0x35d00 <strs.2+0x2e70>
   144d4: 4c 8b 74 24 28               	movq	40(%rsp), %r14
   144d9: e8 f2 3b ff ff               	callq	0x80d0 <libbpf_print>
; 	if (!obj->nr_extern)
   144de: 41 8b 87 90 00 00 00         	movl	144(%r15), %eax
   144e5: 85 c0                        	testl	%eax, %eax
   144e7: 0f 84 b9 de ff ff            	je	0x123a6 <bpf_object_open.part.0+0xc16>
; 	qsort(obj->externs, obj->nr_extern, sizeof(*ext), cmp_externs);
   144ed: 49 8b bf 88 00 00 00         	movq	136(%r15), %rdi
   144f4: 48 63 f0                     	movslq	%eax, %rsi
   144f7: ba 38 00 00 00               	movl	$56, %edx
   144fc: 48 8d 0d dd 21 ff ff         	leaq	-56867(%rip), %rcx      # 0x66e0 <cmp_externs>
   14503: e8 58 12 ff ff               	callq	0x5760 <.plt.sec+0xf0>
; 	if (ksym_sec) {
   14508: 48 83 7c 24 40 00            	cmpq	$0, 64(%rsp)
   1450e: 0f 84 72 01 00 00            	je	0x14686 <bpf_object_open.part.0+0x2ef6>
; 		int int_btf_id = find_int_btf_id(obj->btf);
   14514: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
; 		for (i = 0; i < obj->nr_extern; i++) {
   1451b: 31 db                        	xorl	%ebx, %ebx
; 			pr_debug("extern (ksym) #%d: symbol %d, name %s\n",
   1451d: 48 8d 2d 04 18 02 00         	leaq	137220(%rip), %rbp      # 0x35d28 <strs.2+0x2e98>
; 		int int_btf_id = find_int_btf_id(obj->btf);
   14524: e8 d7 2a ff ff               	callq	0x7000 <find_int_btf_id>
; 		dummy_var = btf__type_by_id(obj->btf, dummy_var_btf_id);
   14529: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   14530: 8b 74 24 48                  	movl	72(%rsp), %esi
; 		int int_btf_id = find_int_btf_id(obj->btf);
   14534: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 		dummy_var = btf__type_by_id(obj->btf, dummy_var_btf_id);
   14538: e8 63 5a 01 00               	callq	0x29fa0 <btf__type_by_id>
; 		for (i = 0; i < obj->nr_extern; i++) {
   1453d: 41 83 bf 90 00 00 00 00      	cmpl	$0, 144(%r15)
; 		dummy_var = btf__type_by_id(obj->btf, dummy_var_btf_id);
   14545: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 		for (i = 0; i < obj->nr_extern; i++) {
   1454a: 7e 40                        	jle	0x1458c <bpf_object_open.part.0+0x2dfc>
; 			ext = &obj->externs[i];
   1454c: 49 8b 8f 88 00 00 00         	movq	136(%r15), %rcx
   14553: 48 8d 04 dd 00 00 00 00      	leaq	(,%rbx,8), %rax
   1455b: 89 da                        	movl	%ebx, %edx
   1455d: 48 29 d8                     	subq	%rbx, %rax
   14560: 48 8d 04 c1                  	leaq	(%rcx,%rax,8), %rax
; 			if (ext->type != EXT_KSYM)
   14564: 83 38 02                     	cmpl	$2, (%rax)
   14567: 75 16                        	jne	0x1457f <bpf_object_open.part.0+0x2def>
; 			pr_debug("extern (ksym) #%d: symbol %d, name %s\n",
   14569: 8b 48 04                     	movl	4(%rax), %ecx
   1456c: 4c 8b 40 10                  	movq	16(%rax), %r8
   14570: 48 89 ee                     	movq	%rbp, %rsi
   14573: bf 02 00 00 00               	movl	$2, %edi
   14578: 31 c0                        	xorl	%eax, %eax
   1457a: e8 51 3b ff ff               	callq	0x80d0 <libbpf_print>
; 		for (i = 0; i < obj->nr_extern; i++) {
   1457f: 48 83 c3 01                  	addq	$1, %rbx
   14583: 41 39 9f 90 00 00 00         	cmpl	%ebx, 144(%r15)
   1458a: 7f c0                        	jg	0x1454c <bpf_object_open.part.0+0x2dbc>
; 	return BTF_INFO_VLEN(t->info);
   1458c: 48 8b 44 24 40               	movq	64(%rsp), %rax
   14591: 0f b7 40 04                  	movzwl	4(%rax), %eax
; 		for (i = 0, off = 0; i < n; i++, off += sizeof(int)) {
   14595: 85 c0                        	testl	%eax, %eax
   14597: 0f 84 d8 06 00 00            	je	0x14c75 <bpf_object_open.part.0+0x34e5>
   1459d: 83 e8 01                     	subl	$1, %eax
   145a0: 48 8b 4c 24 40               	movq	64(%rsp), %rcx
   145a5: 4c 89 74 24 38               	movq	%r14, 56(%rsp)
   145aa: 48 6b c0 0c                  	imulq	$12, %rax, %rax
   145ae: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
   145b6: 48 8d 69 0c                  	leaq	12(%rcx), %rbp
   145ba: 48 8d 44 01 18               	leaq	24(%rcx,%rax), %rax
   145bf: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 			vt = (void *)btf__type_by_id(obj->btf, vs->type);
   145c4: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   145cb: 8b 75 00                     	movl	(%rbp), %esi
   145ce: e8 cd 59 01 00               	callq	0x29fa0 <btf__type_by_id>
; 			ext_name = btf__name_by_offset(obj->btf, vt->name_off);
   145d3: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   145da: 8b 30                        	movl	(%rax), %esi
; 			vt = (void *)btf__type_by_id(obj->btf, vs->type);
   145dc: 48 89 c3                     	movq	%rax, %rbx
; 			ext_name = btf__name_by_offset(obj->btf, vt->name_off);
   145df: e8 0c 75 01 00               	callq	0x2baf0 <btf__name_by_offset>
   145e4: 49 89 c4                     	movq	%rax, %r12
; 	for (i = 0; i < obj->nr_extern; i++) {
   145e7: 41 8b 87 90 00 00 00         	movl	144(%r15), %eax
   145ee: 85 c0                        	testl	%eax, %eax
   145f0: 0f 8e 51 06 00 00            	jle	0x14c47 <bpf_object_open.part.0+0x34b7>
   145f6: 8d 78 ff                     	leal	-1(%rax), %edi
; 		if (strcmp(obj->externs[i].name, name) == 0)
   145f9: 49 8b b7 88 00 00 00         	movq	136(%r15), %rsi
   14600: 48 8d 04 fd 00 00 00 00      	leaq	(,%rdi,8), %rax
   14608: 48 29 f8                     	subq	%rdi, %rax
   1460b: 4c 8d 76 10                  	leaq	16(%rsi), %r14
   1460f: 4c 8d 6c c6 48               	leaq	72(%rsi,%rax,8), %r13
   14614: eb 0d                        	jmp	0x14623 <bpf_object_open.part.0+0x2e93>
; 	for (i = 0; i < obj->nr_extern; i++) {
   14616: 49 83 c6 38                  	addq	$56, %r14
   1461a: 4d 39 f5                     	cmpq	%r14, %r13
   1461d: 0f 84 24 06 00 00            	je	0x14c47 <bpf_object_open.part.0+0x34b7>
; 		if (strcmp(obj->externs[i].name, name) == 0)
   14623: 49 8b 3e                     	movq	(%r14), %rdi
   14626: 4c 89 e6                     	movq	%r12, %rsi
   14629: e8 82 13 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   1462e: 85 c0                        	testl	%eax, %eax
   14630: 75 e4                        	jne	0x14616 <bpf_object_open.part.0+0x2e86>
; 	return BTF_INFO_KIND(t->info);
   14632: 0f b6 43 07                  	movzbl	7(%rbx), %eax
   14636: 83 e0 1f                     	andl	$31, %eax
; 			if (btf_is_func(vt)) {
   14639: 66 83 f8 0c                  	cmpw	$12, %ax
   1463d: 0f 84 6d 03 00 00            	je	0x149b0 <bpf_object_open.part.0+0x3220>
; 				vt->type = int_btf_id;
   14643: 8b 44 24 10                  	movl	16(%rsp), %eax
; 				btf_var(vt)->linkage = BTF_VAR_GLOBAL_ALLOCATED;
   14647: c7 43 0c 01 00 00 00         	movl	$1, 12(%rbx)
; 				vt->type = int_btf_id;
   1464e: 89 43 08                     	movl	%eax, 8(%rbx)
; 			vs->offset = off;
   14651: 8b 44 24 08                  	movl	8(%rsp), %eax
; 			vs->size = sizeof(int);
   14655: c7 45 08 04 00 00 00         	movl	$4, 8(%rbp)
; 		for (i = 0, off = 0; i < n; i++, off += sizeof(int)) {
   1465c: 48 83 c5 0c                  	addq	$12, %rbp
; 			vs->offset = off;
   14660: 89 45 f8                     	movl	%eax, -8(%rbp)
; 		for (i = 0, off = 0; i < n; i++, off += sizeof(int)) {
   14663: 83 c0 04                     	addl	$4, %eax
   14666: 89 44 24 08                  	movl	%eax, 8(%rsp)
   1466a: 48 39 6c 24 28               	cmpq	%rbp, 40(%rsp)
   1466f: 0f 85 4f ff ff ff            	jne	0x145c4 <bpf_object_open.part.0+0x2e34>
   14675: 4c 8b 74 24 38               	movq	56(%rsp), %r14
; 		sec->size = off;
   1467a: 48 8b 44 24 40               	movq	64(%rsp), %rax
   1467f: 8b 4c 24 08                  	movl	8(%rsp), %ecx
   14683: 89 48 08                     	movl	%ecx, 8(%rax)
; 	if (kcfg_sec) {
   14686: 48 83 7c 24 50 00            	cmpq	$0, 80(%rsp)
   1468c: 0f 84 14 dd ff ff            	je	0x123a6 <bpf_object_open.part.0+0xc16>
; 		for (i = 0; i < obj->nr_extern; i++) {
   14692: 41 83 bf 90 00 00 00 00      	cmpl	$0, 144(%r15)
   1469a: 7e 6b                        	jle	0x14707 <bpf_object_open.part.0+0x2f77>
; 			pr_debug("extern (kcfg) #%d: symbol %d, off %u, name %s\n",
   1469c: 44 8b 6c 24 20               	movl	32(%rsp), %r13d
; 		for (i = 0; i < obj->nr_extern; i++) {
   146a1: 31 db                        	xorl	%ebx, %ebx
   146a3: 31 ed                        	xorl	%ebp, %ebp
; 			pr_debug("extern (kcfg) #%d: symbol %d, off %u, name %s\n",
   146a5: 4c 8d 25 ac 16 02 00         	leaq	136876(%rip), %r12      # 0x35d58 <strs.2+0x2ec8>
; 			ext = &obj->externs[i];
   146ac: 49 8b 8f 88 00 00 00         	movq	136(%r15), %rcx
   146b3: 48 01 e9                     	addq	%rbp, %rcx
; 			if (ext->type != EXT_KCFG)
   146b6: 83 39 01                     	cmpl	$1, (%rcx)
   146b9: 75 37                        	jne	0x146f2 <bpf_object_open.part.0+0x2f62>
; 			ext->kcfg.data_off = roundup(off, ext->kcfg.align);
   146bb: 8b 71 28                     	movl	40(%rcx), %esi
; 			pr_debug("extern (kcfg) #%d: symbol %d, off %u, name %s\n",
   146be: 44 8b 51 04                  	movl	4(%rcx), %r10d
   146c2: bf 02 00 00 00               	movl	$2, %edi
   146c7: 4c 8b 49 10                  	movq	16(%rcx), %r9
; 			ext->kcfg.data_off = roundup(off, ext->kcfg.align);
   146cb: 42 8d 44 2e ff               	leal	-1(%rsi,%r13), %eax
; 			off = ext->kcfg.data_off + ext->kcfg.sz;
   146d0: 44 8b 69 24                  	movl	36(%rcx), %r13d
; 			ext->kcfg.data_off = roundup(off, ext->kcfg.align);
   146d4: 99                           	cltd
   146d5: f7 fe                        	idivl	%esi
; 			pr_debug("extern (kcfg) #%d: symbol %d, off %u, name %s\n",
   146d7: 89 da                        	movl	%ebx, %edx
; 			ext->kcfg.data_off = roundup(off, ext->kcfg.align);
   146d9: 0f af c6                     	imull	%esi, %eax
; 			pr_debug("extern (kcfg) #%d: symbol %d, off %u, name %s\n",
   146dc: 4c 89 e6                     	movq	%r12, %rsi
; 			ext->kcfg.data_off = roundup(off, ext->kcfg.align);
   146df: 89 41 2c                     	movl	%eax, 44(%rcx)
   146e2: 41 89 c0                     	movl	%eax, %r8d
; 			off = ext->kcfg.data_off + ext->kcfg.sz;
   146e5: 41 01 c5                     	addl	%eax, %r13d
; 			pr_debug("extern (kcfg) #%d: symbol %d, off %u, name %s\n",
   146e8: 44 89 d1                     	movl	%r10d, %ecx
   146eb: 31 c0                        	xorl	%eax, %eax
   146ed: e8 de 39 ff ff               	callq	0x80d0 <libbpf_print>
; 		for (i = 0; i < obj->nr_extern; i++) {
   146f2: 83 c3 01                     	addl	$1, %ebx
   146f5: 48 83 c5 38                  	addq	$56, %rbp
   146f9: 41 3b 9f 90 00 00 00         	cmpl	144(%r15), %ebx
   14700: 7c aa                        	jl	0x146ac <bpf_object_open.part.0+0x2f1c>
   14702: 44 89 6c 24 20               	movl	%r13d, 32(%rsp)
; 		sec->size = off;
   14707: 48 8b 4c 24 50               	movq	80(%rsp), %rcx
   1470c: 8b 44 24 20                  	movl	32(%rsp), %eax
   14710: 89 41 08                     	movl	%eax, 8(%rcx)
; 	return BTF_INFO_VLEN(t->info);
   14713: 0f b7 41 04                  	movzwl	4(%rcx), %eax
; 		for (i = 0; i < n; i++) {
   14717: 85 c0                        	testl	%eax, %eax
   14719: 0f 84 87 dc ff ff            	je	0x123a6 <bpf_object_open.part.0+0xc16>
   1471f: 83 e8 01                     	subl	$1, %eax
   14722: 4c 89 74 24 10               	movq	%r14, 16(%rsp)
   14727: 48 8d 59 0c                  	leaq	12(%rcx), %rbx
   1472b: 48 6b c0 0c                  	imulq	$12, %rax, %rax
   1472f: 48 8d 44 01 18               	leaq	24(%rcx,%rax), %rax
   14734: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 			t = btf__type_by_id(obj->btf, vs->type);
   14739: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   14740: 8b 33                        	movl	(%rbx), %esi
   14742: e8 59 58 01 00               	callq	0x29fa0 <btf__type_by_id>
; 			ext_name = btf__name_by_offset(obj->btf, t->name_off);
   14747: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   1474e: 8b 30                        	movl	(%rax), %esi
; 			t = btf__type_by_id(obj->btf, vs->type);
   14750: 49 89 c5                     	movq	%rax, %r13
; 			ext_name = btf__name_by_offset(obj->btf, t->name_off);
   14753: e8 98 73 01 00               	callq	0x2baf0 <btf__name_by_offset>
   14758: 49 89 c6                     	movq	%rax, %r14
; 	for (i = 0; i < obj->nr_extern; i++) {
   1475b: 41 8b 87 90 00 00 00         	movl	144(%r15), %eax
   14762: 85 c0                        	testl	%eax, %eax
   14764: 7e 58                        	jle	0x147be <bpf_object_open.part.0+0x302e>
   14766: 8d 48 ff                     	leal	-1(%rax), %ecx
   14769: 49 8b af 88 00 00 00         	movq	136(%r15), %rbp
   14770: 48 8d 04 cd 00 00 00 00      	leaq	(,%rcx,8), %rax
   14778: 48 29 c8                     	subq	%rcx, %rax
   1477b: 4c 8d 64 c5 38               	leaq	56(%rbp,%rax,8), %r12
   14780: eb 09                        	jmp	0x1478b <bpf_object_open.part.0+0x2ffb>
   14782: 48 83 c5 38                  	addq	$56, %rbp
   14786: 49 39 ec                     	cmpq	%rbp, %r12
   14789: 74 33                        	je	0x147be <bpf_object_open.part.0+0x302e>
; 		if (strcmp(obj->externs[i].name, name) == 0)
   1478b: 48 8b 7d 10                  	movq	16(%rbp), %rdi
   1478f: 4c 89 f6                     	movq	%r14, %rsi
   14792: e8 19 12 ff ff               	callq	0x59b0 <.plt.sec+0x340>
   14797: 85 c0                        	testl	%eax, %eax
   14799: 75 e7                        	jne	0x14782 <bpf_object_open.part.0+0x2ff2>
; 			vs->offset = ext->kcfg.data_off;
   1479b: 8b 45 2c                     	movl	44(%rbp), %eax
; 			btf_var(t)->linkage = BTF_VAR_GLOBAL_ALLOCATED;
   1479e: 41 c7 45 0c 01 00 00 00      	movl	$1, 12(%r13)
; 		for (i = 0; i < n; i++) {
   147a6: 48 83 c3 0c                  	addq	$12, %rbx
; 			vs->offset = ext->kcfg.data_off;
   147aa: 89 43 f8                     	movl	%eax, -8(%rbx)
; 		for (i = 0; i < n; i++) {
   147ad: 48 3b 5c 24 08               	cmpq	8(%rsp), %rbx
   147b2: 75 85                        	jne	0x14739 <bpf_object_open.part.0+0x2fa9>
   147b4: 4c 8b 74 24 10               	movq	16(%rsp), %r14
   147b9: e9 e8 db ff ff               	jmp	0x123a6 <bpf_object_open.part.0+0xc16>
; 				pr_warn("failed to find extern definition for BTF var '%s'\n",
   147be: 4c 89 f2                     	movq	%r14, %rdx
   147c1: 48 8d 35 98 23 02 00         	leaq	140184(%rip), %rsi      # 0x36b60 <strs.2+0x3cd0>
   147c8: 31 ff                        	xorl	%edi, %edi
   147ca: 31 c0                        	xorl	%eax, %eax
   147cc: e8 ff 38 ff ff               	callq	0x80d0 <libbpf_print>
   147d1: 48 c7 c3 fd ff ff ff         	movq	$-3, %rbx
   147d8: e9 1b d4 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	if (!scn) {
   147dd: c7 44 24 38 00 00 00 00      	movl	$0, 56(%rsp)
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   147e5: 83 cf ff                     	orl	$-1, %edi
   147e8: 44 89 54 24 78               	movl	%r10d, 120(%rsp)
   147ed: 4c 89 4c 24 70               	movq	%r9, 112(%rsp)
   147f2: 44 89 5c 24 48               	movl	%r11d, 72(%rsp)
   147f7: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
   147fc: e8 5f 12 ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   14801: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   14806: 48 8d 35 63 09 02 00         	leaq	133475(%rip), %rsi      # 0x35170 <strs.2+0x22e0>
   1480d: 31 ff                        	xorl	%edi, %edi
   1480f: 49 89 c0                     	movq	%rax, %r8
   14812: 48 8d 8d 90 01 00 00         	leaq	400(%rbp), %rcx
   14819: 31 c0                        	xorl	%eax, %eax
   1481b: e8 b0 38 ff ff               	callq	0x80d0 <libbpf_print>
   14820: 44 8b 54 24 78               	movl	120(%rsp), %r10d
   14825: 4c 8b 4c 24 70               	movq	112(%rsp), %r9
   1482a: 31 f6                        	xorl	%esi, %esi
   1482c: 44 8b 5c 24 48               	movl	72(%rsp), %r11d
   14831: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   14836: e9 a7 e2 ff ff               	jmp	0x12ae2 <bpf_object_open.part.0+0x1352>
; 		pr_warn("prog '%s': invalid relo against '%s' for insns[%d].code 0x%x\n",
   1483b: 49 8b 16                     	movq	(%r14), %rdx
   1483e: 4c 89 c9                     	movq	%r9, %rcx
   14841: 45 89 d0                     	movl	%r10d, %r8d
   14844: 44 0f b6 ce                  	movzbl	%sil, %r9d
   14848: 31 ff                        	xorl	%edi, %edi
   1484a: 48 8d 35 cf 1d 02 00         	leaq	138703(%rip), %rsi      # 0x36620 <strs.2+0x3790>
   14851: 31 c0                        	xorl	%eax, %eax
   14853: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   1485a: e8 71 38 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   1485f: e9 94 d3 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 				pr_warn(".maps relo #%d: '%s' isn't a valid map reference\n",
   14864: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   14869: 8b 54 24 20                  	movl	32(%rsp), %edx
   1486d: 31 ff                        	xorl	%edi, %edi
   1486f: 49 89 ef                     	movq	%rbp, %r15
   14872: 48 8d 35 b7 1a 02 00         	leaq	137911(%rip), %rsi      # 0x36330 <strs.2+0x34a0>
   14879: 48 c7 c3 fd ff ff ff         	movq	$-3, %rbx
   14880: e8 4b 38 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   14885: e9 6e d3 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("elf: legacy map definitions in 'maps' section are not supported by libbpf v1.0+\n");
   1488a: 48 8d 35 6f 0f 02 00         	leaq	135023(%rip), %rsi      # 0x35800 <strs.2+0x2970>
   14891: 31 ff                        	xorl	%edi, %edi
   14893: 4d 89 ef                     	movq	%r13, %r15
   14896: 48 c7 c3 a1 ff ff ff         	movq	$-95, %rbx
   1489d: e8 2e 38 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__init_maps(obj, opts);
   148a2: e9 51 d3 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 				pr_warn(".maps relo #%d: '%s' isn't a valid program reference\n",
   148a7: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   148ac: 8b 54 24 20                  	movl	32(%rsp), %edx
   148b0: 31 ff                        	xorl	%edi, %edi
   148b2: 49 89 ef                     	movq	%rbp, %r15
   148b5: 48 8d 35 b4 1a 02 00         	leaq	137908(%rip), %rsi      # 0x36370 <strs.2+0x34e0>
   148bc: 48 c7 c3 fd ff ff ff         	movq	$-3, %rbx
   148c3: e8 08 38 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   148c8: e9 2b d3 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 				pr_warn(".maps relo #%d: hash-of-maps '%s' should have key size %zu.\n",
   148cd: 49 8b 4e 08                  	movq	8(%r14), %rcx
   148d1: 8b 54 24 20                  	movl	32(%rsp), %edx
   148d5: 41 b8 04 00 00 00            	movl	$4, %r8d
   148db: 31 ff                        	xorl	%edi, %edi
   148dd: 48 8d 35 04 1a 02 00         	leaq	137732(%rip), %rsi      # 0x362e8 <strs.2+0x3458>
   148e4: 31 c0                        	xorl	%eax, %eax
   148e6: 49 89 ef                     	movq	%rbp, %r15
   148e9: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   148f0: e8 db 37 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   148f5: e9 fe d2 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("invalid kver section in %s\n", obj->path);
   148fa: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   148ff: 48 8d 35 aa 0e 02 00         	leaq	134826(%rip), %rsi      # 0x357b0 <strs.2+0x2920>
   14906: 31 ff                        	xorl	%edi, %edi
   14908: 31 c0                        	xorl	%eax, %eax
   1490a: 4d 89 ef                     	movq	%r13, %r15
   1490d: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   14914: e8 b7 37 ff ff               	callq	0x80d0 <libbpf_print>
; 			if (err)
   14919: e9 da d2 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			    strcmp(name, ".rel" STRUCT_OPS_SEC) &&
   1491e: 48 8d 35 c0 d7 01 00         	leaq	120768(%rip), %rsi      # 0x320e5 <_IO_stdin_used+0x20e5>
   14925: 4c 89 e7                     	movq	%r12, %rdi
   14928: e8 83 10 ff ff               	callq	0x59b0 <.plt.sec+0x340>
; 			if (!section_have_execinstr(obj, targ_sec_idx) &&
   1492d: 85 c0                        	testl	%eax, %eax
   1492f: 0f 84 19 fb ff ff            	je	0x1444e <bpf_object_open.part.0+0x2cbe>
; 			    strcmp(name, ".rel" MAPS_ELF_SEC)) {
   14935: 48 8d 35 b9 d7 01 00         	leaq	120761(%rip), %rsi      # 0x320f5 <_IO_stdin_used+0x20f5>
   1493c: 4c 89 e7                     	movq	%r12, %rdi
   1493f: e8 6c 10 ff ff               	callq	0x59b0 <.plt.sec+0x340>
; 			    strcmp(name, ".rel" STRUCT_OPS_SEC) &&
   14944: 85 c0                        	testl	%eax, %eax
   14946: 0f 84 02 fb ff ff            	je	0x1444e <bpf_object_open.part.0+0x2cbe>
; 	scn = elf_getscn(obj->efile.elf, idx);
   1494c: 49 8b bd c0 00 00 00         	movq	192(%r13), %rdi
   14953: 48 8b 74 24 10               	movq	16(%rsp), %rsi
   14958: e8 a3 12 ff ff               	callq	0x5c00 <.plt.sec+0x590>
   1495d: 48 89 c5                     	movq	%rax, %rbp
; 	if (!scn) {
   14960: 48 85 c0                     	testq	%rax, %rax
   14963: 0f 84 09 05 00 00            	je	0x14e72 <bpf_object_open.part.0+0x36e2>
; 				pr_info("elf: skipping relo section(%d) %s for section(%d) %s\n",
   14969: 48 89 ee                     	movq	%rbp, %rsi
   1496c: 4c 89 ef                     	movq	%r13, %rdi
   1496f: e8 cc 61 ff ff               	callq	0xab40 <elf_sec_name>
   14974: 49 89 c1                     	movq	%rax, %r9
   14977: 48 85 c0                     	testq	%rax, %rax
   1497a: 0f 84 e6 04 00 00            	je	0x14e66 <bpf_object_open.part.0+0x36d6>
   14980: 44 8b 44 24 38               	movl	56(%rsp), %r8d
   14985: 8b 54 24 08                  	movl	8(%rsp), %edx
   14989: 4c 89 e1                     	movq	%r12, %rcx
   1498c: 31 c0                        	xorl	%eax, %eax
   1498e: 48 8d 35 b3 10 02 00         	leaq	135347(%rip), %rsi      # 0x35a48 <strs.2+0x2bb8>
   14995: bf 01 00 00 00               	movl	$1, %edi
   1499a: e8 31 37 ff ff               	callq	0x80d0 <libbpf_print>
; 				continue;
   1499f: e9 ec d3 ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 		sec_name++;
   149a4: 49 8d 46 01                  	leaq	1(%r14), %rax
   149a8: 49 89 c7                     	movq	%rax, %r15
   149ab: e9 40 f9 ff ff               	jmp	0x142f0 <bpf_object_open.part.0+0x2b60>
; 				func_proto = btf__type_by_id(obj->btf,
   149b0: 8b 73 08                     	movl	8(%rbx), %esi
   149b3: 49 8b bf 10 01 00 00         	movq	272(%r15), %rdi
   149ba: e8 e1 55 01 00               	callq	0x29fa0 <btf__type_by_id>
   149bf: 0f b7 48 04                  	movzwl	4(%rax), %ecx
   149c3: 48 89 c2                     	movq	%rax, %rdx
; 				for (j = 0; j < btf_vlen(func_proto); j++)
   149c6: 85 c9                        	testl	%ecx, %ecx
   149c8: 74 2b                        	je	0x149f5 <bpf_object_open.part.0+0x3265>
   149ca: 83 e9 01                     	subl	$1, %ecx
   149cd: 48 8b 74 24 18               	movq	24(%rsp), %rsi
   149d2: 48 8d 40 0c                  	leaq	12(%rax), %rax
   149d6: 48 8d 54 ca 14               	leaq	20(%rdx,%rcx,8), %rdx
; 					if (param[j].type && !param[j].name_off)
   149db: 8b 78 04                     	movl	4(%rax), %edi
   149de: 85 ff                        	testl	%edi, %edi
   149e0: 74 0a                        	je	0x149ec <bpf_object_open.part.0+0x325c>
   149e2: 8b 08                        	movl	(%rax), %ecx
   149e4: 85 c9                        	testl	%ecx, %ecx
   149e6: 75 04                        	jne	0x149ec <bpf_object_open.part.0+0x325c>
; 							dummy_var->name_off;
   149e8: 8b 0e                        	movl	(%rsi), %ecx
; 						param[j].name_off =
   149ea: 89 08                        	movl	%ecx, (%rax)
; 				for (j = 0; j < btf_vlen(func_proto); j++)
   149ec: 48 83 c0 08                  	addq	$8, %rax
   149f0: 48 39 c2                     	cmpq	%rax, %rdx
   149f3: 75 e6                        	jne	0x149db <bpf_object_open.part.0+0x324b>
; 				vs->type = dummy_var_btf_id;
   149f5: 8b 44 24 48                  	movl	72(%rsp), %eax
   149f9: 89 45 00                     	movl	%eax, (%rbp)
; 				vt->info |= BTF_FUNC_GLOBAL;
   149fc: 66 c7 43 04 01 00            	movw	$1, 4(%rbx)
   14a02: e9 4a fc ff ff               	jmp	0x14651 <bpf_object_open.part.0+0x2ec1>
; 			} else if (strcmp(name, DATA_SEC) == 0 ||
   14a07: 48 8d 35 e5 d5 01 00         	leaq	120293(%rip), %rsi      # 0x31ff3 <_IO_stdin_used+0x1ff3>
   14a0e: 4c 89 e7                     	movq	%r12, %rdi
   14a11: e8 9a 0f ff ff               	callq	0x59b0 <.plt.sec+0x340>
   14a16: 85 c0                        	testl	%eax, %eax
   14a18: 0f 84 4a 01 00 00            	je	0x14b68 <bpf_object_open.part.0+0x33d8>
; 				   str_has_pfx(name, DATA_SEC ".")) {
   14a1e: ba 06 00 00 00               	movl	$6, %edx
   14a23: 48 8d 35 ab d6 01 00         	leaq	120491(%rip), %rsi      # 0x320d5 <_IO_stdin_used+0x20d5>
   14a2a: 4c 89 e7                     	movq	%r12, %rdi
   14a2d: e8 ee 0c ff ff               	callq	0x5720 <.plt.sec+0xb0>
; 			} else if (strcmp(name, DATA_SEC) == 0 ||
   14a32: 85 c0                        	testl	%eax, %eax
   14a34: 0f 84 2e 01 00 00            	je	0x14b68 <bpf_object_open.part.0+0x33d8>
; 			} else if (strcmp(name, RODATA_SEC) == 0 ||
   14a3a: 48 8d 35 b8 d5 01 00         	leaq	120248(%rip), %rsi      # 0x31ff9 <_IO_stdin_used+0x1ff9>
   14a41: 4c 89 e7                     	movq	%r12, %rdi
   14a44: e8 67 0f ff ff               	callq	0x59b0 <.plt.sec+0x340>
   14a49: 85 c0                        	testl	%eax, %eax
   14a4b: 0f 84 72 01 00 00            	je	0x14bc3 <bpf_object_open.part.0+0x3433>
; 				   str_has_pfx(name, RODATA_SEC ".")) {
   14a51: ba 08 00 00 00               	movl	$8, %edx
   14a56: 48 8d 35 7f d6 01 00         	leaq	120447(%rip), %rsi      # 0x320dc <_IO_stdin_used+0x20dc>
   14a5d: 4c 89 e7                     	movq	%r12, %rdi
   14a60: e8 bb 0c ff ff               	callq	0x5720 <.plt.sec+0xb0>
; 			} else if (strcmp(name, RODATA_SEC) == 0 ||
   14a65: 85 c0                        	testl	%eax, %eax
   14a67: 0f 84 56 01 00 00            	je	0x14bc3 <bpf_object_open.part.0+0x3433>
; 			} else if (strcmp(name, STRUCT_OPS_SEC) == 0) {
   14a6d: 48 8d 35 75 d6 01 00         	leaq	120437(%rip), %rsi      # 0x320e9 <_IO_stdin_used+0x20e9>
   14a74: 4c 89 e7                     	movq	%r12, %rdi
   14a77: e8 34 0f ff ff               	callq	0x59b0 <.plt.sec+0x340>
   14a7c: 85 c0                        	testl	%eax, %eax
   14a7e: 0f 85 20 01 00 00            	jne	0x14ba4 <bpf_object_open.part.0+0x3414>
; 				obj->efile.st_ops_shndx = idx;
   14a84: 8b 44 24 10                  	movl	16(%rsp), %eax
; 				obj->efile.st_ops_data = data;
   14a88: 49 89 ad d8 00 00 00         	movq	%rbp, 216(%r13)
; 				obj->efile.st_ops_shndx = idx;
   14a8f: 41 89 85 0c 01 00 00         	movl	%eax, 268(%r13)
   14a96: e9 f5 d2 ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 	pr_debug("collected %d externs total\n", obj->nr_extern);
   14a9b: 41 8b 97 90 00 00 00         	movl	144(%r15), %edx
   14aa2: 31 c0                        	xorl	%eax, %eax
   14aa4: bf 02 00 00 00               	movl	$2, %edi
   14aa9: 48 8d 35 50 12 02 00         	leaq	135760(%rip), %rsi      # 0x35d00 <strs.2+0x2e70>
   14ab0: e8 1b 36 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (!obj->nr_extern)
   14ab5: 41 8b 87 90 00 00 00         	movl	144(%r15), %eax
   14abc: 85 c0                        	testl	%eax, %eax
   14abe: 0f 84 e2 d8 ff ff            	je	0x123a6 <bpf_object_open.part.0+0xc16>
; 	qsort(obj->externs, obj->nr_extern, sizeof(*ext), cmp_externs);
   14ac4: 49 8b bf 88 00 00 00         	movq	136(%r15), %rdi
   14acb: 48 63 f0                     	movslq	%eax, %rsi
   14ace: ba 38 00 00 00               	movl	$56, %edx
   14ad3: 48 8d 0d 06 1c ff ff         	leaq	-58362(%rip), %rcx      # 0x66e0 <cmp_externs>
   14ada: e8 81 0c ff ff               	callq	0x5760 <.plt.sec+0xf0>
; 	if (kcfg_sec) {
   14adf: e9 c2 d8 ff ff               	jmp	0x123a6 <bpf_object_open.part.0+0xc16>
   14ae4: 4c 89 cb                     	movq	%r9, %rbx
   14ae7: 49 89 eb                     	movq	%rbp, %r11
; 	scn = elf_getscn(obj->efile.elf, idx);
   14aea: 49 8b bb c0 00 00 00         	movq	192(%r11), %rdi
; 			sym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));
   14af1: 44 0f b7 e2                  	movzwl	%dx, %r12d
; 	scn = elf_getscn(obj->efile.elf, idx);
   14af5: 4c 89 5c 24 08               	movq	%r11, 8(%rsp)
   14afa: 4c 89 e6                     	movq	%r12, %rsi
   14afd: e8 fe 10 ff ff               	callq	0x5c00 <.plt.sec+0x590>
; 	if (!scn) {
   14b02: 4c 8b 5c 24 08               	movq	8(%rsp), %r11
   14b07: 48 85 c0                     	testq	%rax, %rax
; 	scn = elf_getscn(obj->efile.elf, idx);
   14b0a: 48 89 c5                     	movq	%rax, %rbp
; 	if (!scn) {
   14b0d: 0f 84 c8 00 00 00            	je	0x14bdb <bpf_object_open.part.0+0x344b>
; 			sym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));
   14b13: 4c 89 df                     	movq	%r11, %rdi
   14b16: 48 89 ee                     	movq	%rbp, %rsi
   14b19: e8 22 60 ff ff               	callq	0xab40 <elf_sec_name>
; 			pr_warn("prog '%s': bad call relo against '%s' in section '%s'\n",
   14b1e: 49 8b 16                     	movq	(%r14), %rdx
   14b21: 48 89 d9                     	movq	%rbx, %rcx
   14b24: 31 ff                        	xorl	%edi, %edi
; 			sym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));
   14b26: 49 89 c0                     	movq	%rax, %r8
; 			pr_warn("prog '%s': bad call relo against '%s' in section '%s'\n",
   14b29: 48 8d 35 68 1b 02 00         	leaq	138088(%rip), %rsi      # 0x36698 <strs.2+0x3808>
   14b30: 31 c0                        	xorl	%eax, %eax
   14b32: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   14b39: e8 92 35 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   14b3e: e9 b5 d0 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 	if (is_call_insn(insn)) {
   14b43: 45 31 c0                     	xorl	%r8d, %r8d
; 		pr_warn("prog '%s': invalid relo against '%s' in special section 0x%x; forgot to initialize global var?..\n",
   14b46: 49 8b 16                     	movq	(%r14), %rdx
   14b49: 48 89 d9                     	movq	%rbx, %rcx
   14b4c: 48 8d 35 c5 1b 02 00         	leaq	138181(%rip), %rsi      # 0x36718 <strs.2+0x3888>
   14b53: 31 ff                        	xorl	%edi, %edi
   14b55: 31 c0                        	xorl	%eax, %eax
   14b57: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   14b5e: e8 6d 35 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   14b63: e9 90 d0 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 				sec_desc->sec_type = SEC_DATA;
   14b68: 48 8b 44 24 18               	movq	24(%rsp), %rax
   14b6d: c7 00 03 00 00 00            	movl	$3, (%rax)
; 				sec_desc->shdr = sh;
   14b73: 48 89 58 08                  	movq	%rbx, 8(%rax)
; 				sec_desc->data = data;
   14b77: 48 89 68 10                  	movq	%rbp, 16(%rax)
   14b7b: e9 10 d2 ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; }
   14b80: e8 7b 0c ff ff               	callq	0x5800 <.plt.sec+0x190>
; 				pr_warn("extern (kcfg) '%s': type is unsupported\n", ext_name);
   14b85: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   14b8a: 48 8d 35 07 11 02 00         	leaq	135431(%rip), %rsi      # 0x35c98 <strs.2+0x2e08>
   14b91: 31 ff                        	xorl	%edi, %edi
   14b93: 48 c7 c3 a1 ff ff ff         	movq	$-95, %rbx
   14b9a: e8 31 35 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object_init_progs(obj, opts);
   14b9f: e9 54 d0 ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 				pr_info("elf: skipping unrecognized data section(%d) %s\n",
   14ba4: 8b 54 24 08                  	movl	8(%rsp), %edx
   14ba8: 4c 89 e1                     	movq	%r12, %rcx
   14bab: 48 8d 35 5e 0e 02 00         	leaq	134750(%rip), %rsi      # 0x35a10 <strs.2+0x2b80>
   14bb2: 31 c0                        	xorl	%eax, %eax
   14bb4: bf 01 00 00 00               	movl	$1, %edi
   14bb9: e8 12 35 ff ff               	callq	0x80d0 <libbpf_print>
   14bbe: e9 cd d1 ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 				sec_desc->sec_type = SEC_RODATA;
   14bc3: 48 8b 44 24 18               	movq	24(%rsp), %rax
   14bc8: c7 00 04 00 00 00            	movl	$4, (%rax)
; 				sec_desc->shdr = sh;
   14bce: 48 89 58 08                  	movq	%rbx, 8(%rax)
; 				sec_desc->data = data;
   14bd2: 48 89 68 10                  	movq	%rbp, 16(%rax)
   14bd6: e9 b5 d1 ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   14bdb: 83 cf ff                     	orl	$-1, %edi
   14bde: e8 7d 0e ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   14be3: 4c 8b 5c 24 08               	movq	8(%rsp), %r11
   14be8: 4c 89 e2                     	movq	%r12, %rdx
   14beb: 31 ff                        	xorl	%edi, %edi
   14bed: 49 89 c0                     	movq	%rax, %r8
   14bf0: 48 8d 35 79 05 02 00         	leaq	132473(%rip), %rsi      # 0x35170 <strs.2+0x22e0>
   14bf7: 31 c0                        	xorl	%eax, %eax
   14bf9: 49 8d 8b 90 01 00 00         	leaq	400(%r11), %rcx
   14c00: e8 cb 34 ff ff               	callq	0x80d0 <libbpf_print>
   14c05: 4c 8b 5c 24 08               	movq	8(%rsp), %r11
; 		return NULL;
   14c0a: e9 04 ff ff ff               	jmp	0x14b13 <bpf_object_open.part.0+0x3383>
; 			pr_warn("prog '%s': bad map relo against '%s' in section '%s'\n",
   14c0f: 4c 8b 54 24 18               	movq	24(%rsp), %r10
   14c14: 49 8b 16                     	movq	(%r14), %rdx
   14c17: 4c 89 c9                     	movq	%r9, %rcx
   14c1a: 31 ff                        	xorl	%edi, %edi
   14c1c: 48 8d 35 ad 1b 02 00         	leaq	138157(%rip), %rsi      # 0x367d0 <strs.2+0x3940>
   14c23: 31 c0                        	xorl	%eax, %eax
   14c25: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   14c2c: 4d 89 d0                     	movq	%r10, %r8
   14c2f: e8 9c 34 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   14c34: e9 bf cf ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("prog '%s': map relo failed to find map for section '%s', off %zu\n",
   14c39: 4c 8b 54 24 18               	movq	24(%rsp), %r10
   14c3e: 48 8b 4b 08                  	movq	8(%rbx), %rcx
   14c42: e9 5d f2 ff ff               	jmp	0x13ea4 <bpf_object_open.part.0+0x2714>
; 	return BTF_INFO_KIND(t->info);
   14c47: 0f b6 7b 07                  	movzbl	7(%rbx), %edi
; 				pr_warn("failed to find extern definition for BTF %s '%s'\n",
   14c4b: 4c 89 e1                     	movq	%r12, %rcx
   14c4e: 48 8d 35 cb 1e 02 00         	leaq	138955(%rip), %rsi      # 0x36b20 <strs.2+0x3c90>
   14c55: 48 c7 c3 fd ff ff ff         	movq	$-3, %rbx
; 	return __btf_kind_str(btf_kind(t));
   14c5c: 83 e7 1f                     	andl	$31, %edi
   14c5f: e8 2c 17 ff ff               	callq	0x6390 <__btf_kind_str>
; 				pr_warn("failed to find extern definition for BTF %s '%s'\n",
   14c64: 31 ff                        	xorl	%edi, %edi
; 	return __btf_kind_str(btf_kind(t));
   14c66: 48 89 c2                     	movq	%rax, %rdx
; 				pr_warn("failed to find extern definition for BTF %s '%s'\n",
   14c69: 31 c0                        	xorl	%eax, %eax
   14c6b: e8 60 34 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object_init_progs(obj, opts);
   14c70: e9 83 cf ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		for (i = 0, off = 0; i < n; i++, off += sizeof(int)) {
   14c75: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
   14c7d: e9 f8 f9 ff ff               	jmp	0x1467a <bpf_object_open.part.0+0x2eea>
; 		pr_warn("elf: couldn't find symbol table in %s, stripped object file?\n",
   14c82: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   14c87: 48 8d 35 92 0a 02 00         	leaq	133778(%rip), %rsi      # 0x35720 <strs.2+0x2890>
   14c8e: 31 ff                        	xorl	%edi, %edi
   14c90: 31 c0                        	xorl	%eax, %eax
   14c92: 48 c7 c3 fe ff ff ff         	movq	$-2, %rbx
   14c99: e8 32 34 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__collect_externs(obj);
   14c9e: e9 55 cf ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("alloc memory failed for %s\n", path);
   14ca3: 4c 89 c2                     	movq	%r8, %rdx
   14ca6: 48 8d 35 eb 09 02 00         	leaq	133611(%rip), %rsi      # 0x35698 <strs.2+0x2808>
   14cad: 31 ff                        	xorl	%edi, %edi
   14caf: 31 c0                        	xorl	%eax, %eax
   14cb1: e8 1a 34 ff ff               	callq	0x80d0 <libbpf_print>
; 		return ERR_PTR(-ENOMEM);
   14cb6: 49 c7 c7 f4 ff ff ff         	movq	$-12, %r15
   14cbd: e9 58 cc ff ff               	jmp	0x1191a <bpf_object_open.part.0+0x18a>
; 		return LIBBPF_MAP_KCONFIG;
   14cc2: c7 44 24 38 04 00 00 00      	movl	$4, 56(%rsp)
   14cca: e9 16 fb ff ff               	jmp	0x147e5 <bpf_object_open.part.0+0x3055>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   14ccf: 83 cf ff                     	orl	$-1, %edi
   14cd2: 48 89 44 24 40               	movq	%rax, 64(%rsp)
   14cd7: e8 84 0d ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   14cdc: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   14ce1: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   14ce6: 31 ff                        	xorl	%edi, %edi
   14ce8: 49 89 c0                     	movq	%rax, %r8
   14ceb: 48 8d 35 7e 04 02 00         	leaq	132222(%rip), %rsi      # 0x35170 <strs.2+0x22e0>
   14cf2: 31 c0                        	xorl	%eax, %eax
   14cf4: e8 d7 33 ff ff               	callq	0x80d0 <libbpf_print>
   14cf9: 4c 8b 4c 24 40               	movq	64(%rsp), %r9
; 		return NULL;
   14cfe: e9 2d f7 ff ff               	jmp	0x14430 <bpf_object_open.part.0+0x2ca0>
; 				pr_warn("failed to determine alignment of extern (kcfg) '%s': %d\n",
   14d03: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   14d08: 48 8d 35 41 0f 02 00         	leaq	134977(%rip), %rsi      # 0x35c50 <strs.2+0x2dc0>
   14d0f: 31 ff                        	xorl	%edi, %edi
   14d11: 31 c0                        	xorl	%eax, %eax
   14d13: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   14d1a: e8 b1 33 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object_init_progs(obj, opts);
   14d1f: e9 d4 ce ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 				pr_warn("failed to resolve size of extern (kcfg) '%s': %d\n",
   14d24: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   14d29: 48 8d 35 e0 0e 02 00         	leaq	134880(%rip), %rsi      # 0x35c10 <strs.2+0x2d80>
   14d30: 31 ff                        	xorl	%edi, %edi
   14d32: 31 c0                        	xorl	%eax, %eax
   14d34: 4c 8b 74 24 28               	movq	40(%rsp), %r14
   14d39: e8 92 33 ff ff               	callq	0x80d0 <libbpf_print>
; 				return ext->kcfg.sz;
   14d3e: 49 63 5d 24                  	movslq	36(%r13), %rbx
   14d42: e9 57 d6 ff ff               	jmp	0x1239e <bpf_object_open.part.0+0xc0e>
; 	pr_warn("sec '%s': failed to allocate memory for prog '%s'\n", sec_name, name);
   14d47: 4c 8b 5c 24 10               	movq	16(%rsp), %r11
   14d4c: 4c 89 fa                     	movq	%r15, %rdx
   14d4f: 31 ff                        	xorl	%edi, %edi
   14d51: 31 c0                        	xorl	%eax, %eax
   14d53: 48 8d 35 46 1e 02 00         	leaq	138822(%rip), %rsi      # 0x36ba0 <strs.2+0x3d10>
   14d5a: 48 89 6c 24 08               	movq	%rbp, 8(%rsp)
   14d5f: 4d 89 ef                     	movq	%r13, %r15
   14d62: 4c 89 d9                     	movq	%r11, %rcx
   14d65: e8 66 33 ff ff               	callq	0x80d0 <libbpf_print>
; 	zclose(prog->fd);
   14d6a: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   14d6f: 41 8b 78 78                  	movl	120(%r8), %edi
   14d73: 85 ff                        	testl	%edi, %edi
   14d75: 78 0f                        	js	0x14d86 <bpf_object_open.part.0+0x35f6>
   14d77: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
   14d7c: e8 7f 0b ff ff               	callq	0x5900 <.plt.sec+0x290>
   14d81: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   14d86: 41 c7 40 78 ff ff ff ff      	movl	$4294967295, 120(%r8)   # imm = 0xFFFFFFFF
; 	zfree(&prog->func_info);
   14d8e: 49 8b b8 98 00 00 00         	movq	152(%r8), %rdi
; 	prog->sec_idx = -1;
   14d95: 48 c7 c3 f4 ff ff ff         	movq	$-12, %rbx
; 	zfree(&prog->func_info);
   14d9c: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
   14da1: e8 1a 09 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   14da6: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   14dab: 49 c7 80 98 00 00 00 00 00 00 00     	movq	$0, 152(%r8)
; 	zfree(&prog->line_info);
   14db6: 49 8b b8 a8 00 00 00         	movq	168(%r8), %rdi
   14dbd: e8 fe 08 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   14dc2: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   14dc7: 49 c7 80 a8 00 00 00 00 00 00 00     	movq	$0, 168(%r8)
; 	zfree(&prog->name);
   14dd2: 49 8b 38                     	movq	(%r8), %rdi
   14dd5: e8 e6 08 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   14dda: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   14ddf: 49 c7 00 00 00 00 00         	movq	$0, (%r8)
; 	zfree(&prog->sec_name);
   14de6: 49 8b 78 08                  	movq	8(%r8), %rdi
   14dea: e8 d1 08 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   14def: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   14df4: 49 c7 40 08 00 00 00 00      	movq	$0, 8(%r8)
; 	zfree(&prog->insns);
   14dfc: 49 8b 78 38                  	movq	56(%r8), %rdi
   14e00: e8 bb 08 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   14e05: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   14e0a: 49 c7 40 38 00 00 00 00      	movq	$0, 56(%r8)
; 	zfree(&prog->reloc_desc);
   14e12: 49 8b 78 48                  	movq	72(%r8), %rdi
   14e16: e8 a5 08 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   14e1b: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   14e20: 49 c7 40 48 00 00 00 00      	movq	$0, 72(%r8)
; 	prog->nr_reloc = 0;
   14e28: 41 c7 40 50 00 00 00 00      	movl	$0, 80(%r8)
; 	prog->insns_cnt = 0;
   14e30: 49 c7 40 40 00 00 00 00      	movq	$0, 64(%r8)
; 	prog->sec_idx = -1;
   14e38: 49 c7 40 10 ff ff ff ff      	movq	$-1, 16(%r8)
; 		if (err)
   14e40: e9 b3 cd ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("elf: symbol strings section missing or invalid in %s\n", obj->path);
   14e45: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   14e4a: 48 8d 35 6f 0c 02 00         	leaq	134255(%rip), %rsi      # 0x35ac0 <strs.2+0x2c30>
   14e51: 31 ff                        	xorl	%edi, %edi
   14e53: 31 c0                        	xorl	%eax, %eax
   14e55: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   14e5c: e8 6f 32 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__init_maps(obj, opts);
   14e61: e9 92 cd ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 				pr_info("elf: skipping relo section(%d) %s for section(%d) %s\n",
   14e66: 4c 8d 0d ff cf 01 00         	leaq	118783(%rip), %r9       # 0x31e6c <_IO_stdin_used+0x1e6c>
   14e6d: e9 0e fb ff ff               	jmp	0x14980 <bpf_object_open.part.0+0x31f0>
; 		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
   14e72: 83 cf ff                     	orl	$-1, %edi
   14e75: e8 e6 0b ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   14e7a: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   14e7f: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   14e84: 31 ff                        	xorl	%edi, %edi
   14e86: 49 89 c0                     	movq	%rax, %r8
   14e89: 48 8d 35 e0 02 02 00         	leaq	131808(%rip), %rsi      # 0x35170 <strs.2+0x22e0>
   14e90: 31 c0                        	xorl	%eax, %eax
   14e92: e8 39 32 ff ff               	callq	0x80d0 <libbpf_print>
; 		return NULL;
   14e97: e9 cd fa ff ff               	jmp	0x14969 <bpf_object_open.part.0+0x31d9>
   14e9c: 4c 8b b4 24 90 00 00 00      	movq	144(%rsp), %r14
   14ea4: 4c 8b bc 24 98 00 00 00      	movq	152(%rsp), %r15
   14eac: e9 df ce ff ff               	jmp	0x11d90 <bpf_object_open.part.0+0x600>
; 				pr_warn("extern function %s is unsupported under %s section\n",
   14eb1: 49 8b 55 10                  	movq	16(%r13), %rdx
   14eb5: 48 8d 0d 7d d1 01 00         	leaq	119165(%rip), %rcx      # 0x32039 <_IO_stdin_used+0x2039>
   14ebc: 31 ff                        	xorl	%edi, %edi
   14ebe: 31 c0                        	xorl	%eax, %eax
   14ec0: 48 8d 35 09 0d 02 00         	leaq	134409(%rip), %rsi      # 0x35bd0 <strs.2+0x2d40>
   14ec7: 48 c7 c3 a1 ff ff ff         	movq	$-95, %rbx
   14ece: e8 fd 31 ff ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__init_maps(obj, opts);
   14ed3: e9 20 cd ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("unrecognized extern section '%s'\n", sec_name);
   14ed8: 4c 89 e2                     	movq	%r12, %rdx
   14edb: 48 8d 35 ee 0d 02 00         	leaq	134638(%rip), %rsi      # 0x35cd0 <strs.2+0x2e40>
   14ee2: 31 ff                        	xorl	%edi, %edi
   14ee4: 31 c0                        	xorl	%eax, %eax
   14ee6: e8 e5 31 ff ff               	callq	0x80d0 <libbpf_print>
   14eeb: 48 c7 c3 a1 ff ff ff         	movq	$-95, %rbx
   14ef2: e9 01 cd ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("sec '%s': failed to alloc memory for new program '%s'\n",
   14ef7: 4c 8b 5c 24 10               	movq	16(%rsp), %r11
   14efc: 4c 89 f2                     	movq	%r14, %rdx
   14eff: 31 ff                        	xorl	%edi, %edi
   14f01: 31 c0                        	xorl	%eax, %eax
   14f03: 48 8d 35 86 0a 02 00         	leaq	133766(%rip), %rsi      # 0x35990 <strs.2+0x2b00>
   14f0a: 4d 89 ef                     	movq	%r13, %r15
   14f0d: 4c 89 d9                     	movq	%r11, %rcx
   14f10: e8 bb 31 ff ff               	callq	0x80d0 <libbpf_print>
   14f15: e9 ef cb ff ff               	jmp	0x11b09 <bpf_object_open.part.0+0x379>
; 			pr_warn("sec '%s': program at offset %zu crosses section boundary\n",
   14f1a: 4d 89 fa                     	movq	%r15, %r10
   14f1d: 4c 89 f2                     	movq	%r14, %rdx
   14f20: 48 8d 35 79 09 02 00         	leaq	133497(%rip), %rsi      # 0x358a0 <strs.2+0x2a10>
   14f27: 31 ff                        	xorl	%edi, %edi
   14f29: 4c 89 d1                     	movq	%r10, %rcx
   14f2c: 31 c0                        	xorl	%eax, %eax
   14f2e: 4d 89 ef                     	movq	%r13, %r15
   14f31: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
   14f38: e8 93 31 ff ff               	callq	0x80d0 <libbpf_print>
; 				if (err)
   14f3d: e9 b6 cc ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   14f42: 83 cf ff                     	orl	$-1, %edi
   14f45: 4c 89 7c 24 10               	movq	%r15, 16(%rsp)
; 			pr_warn("sec '%s': failed to get symbol name for offset %zu\n",
   14f4a: 48 c7 c3 5f f0 ff ff         	movq	$-4001, %rbx            # imm = 0xF05F
; 		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
   14f51: 4d 89 ef                     	movq	%r13, %r15
   14f54: 48 89 6c 24 08               	movq	%rbp, 8(%rsp)
   14f59: e8 02 0b ff ff               	callq	0x5a60 <.plt.sec+0x3f0>
   14f5e: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   14f63: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   14f68: 31 ff                        	xorl	%edi, %edi
   14f6a: 49 89 c0                     	movq	%rax, %r8
   14f6d: 48 8d 35 6c ee 01 00         	leaq	126572(%rip), %rsi      # 0x33de0 <strs.2+0xf50>
   14f74: 31 c0                        	xorl	%eax, %eax
   14f76: e8 55 31 ff ff               	callq	0x80d0 <libbpf_print>
; 			pr_warn("sec '%s': failed to get symbol name for offset %zu\n",
   14f7b: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   14f80: 4c 89 f2                     	movq	%r14, %rdx
   14f83: 31 ff                        	xorl	%edi, %edi
   14f85: 48 8d 35 d4 08 02 00         	leaq	133332(%rip), %rsi      # 0x35860 <strs.2+0x29d0>
   14f8c: 31 c0                        	xorl	%eax, %eax
   14f8e: e8 3d 31 ff ff               	callq	0x80d0 <libbpf_print>
; 				if (err)
   14f93: e9 60 cc ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 			pr_warn("sec '%s': program '%s' is static and not supported\n", sec_name, name);
   14f98: 4c 8b 5c 24 10               	movq	16(%rsp), %r11
   14f9d: 4c 89 f2                     	movq	%r14, %rdx
   14fa0: 31 ff                        	xorl	%edi, %edi
   14fa2: 31 c0                        	xorl	%eax, %eax
   14fa4: 48 8d 35 3d 09 02 00         	leaq	133437(%rip), %rsi      # 0x358e8 <strs.2+0x2a58>
   14fab: 4d 89 ef                     	movq	%r13, %r15
   14fae: 48 c7 c3 a1 ff ff ff         	movq	$-95, %rbx
   14fb5: 4c 89 d9                     	movq	%r11, %rcx
   14fb8: e8 13 31 ff ff               	callq	0x80d0 <libbpf_print>
; 				if (err)
   14fbd: e9 36 cc ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_warn("sec '%s': corrupted program '%s', offset %zu, size %zu\n",
   14fc2: 4c 8b 5c 24 10               	movq	16(%rsp), %r11
   14fc7: 4d 89 fa                     	movq	%r15, %r10
   14fca: 4d 89 e1                     	movq	%r12, %r9
   14fcd: 4c 89 f2                     	movq	%r14, %rdx
   14fd0: 4d 89 d0                     	movq	%r10, %r8
   14fd3: 48 8d 35 f6 09 02 00         	leaq	133622(%rip), %rsi      # 0x359d0 <strs.2+0x2b40>
   14fda: 31 ff                        	xorl	%edi, %edi
   14fdc: 31 c0                        	xorl	%eax, %eax
   14fde: 4c 89 d9                     	movq	%r11, %rcx
   14fe1: 4d 89 ef                     	movq	%r13, %r15
   14fe4: 48 c7 c3 ea ff ff ff         	movq	$-22, %rbx
   14feb: e8 e0 30 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   14ff0: e9 03 cc ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		return -ESRCH;
   14ff5: 4c 8b 74 24 28               	movq	40(%rsp), %r14
   14ffa: b9 fd ff ff ff               	movl	$4294967293, %ecx       # imm = 0xFFFFFFFD
   14fff: e9 7d d3 ff ff               	jmp	0x12381 <bpf_object_open.part.0+0xbf1>
   15004: 4c 89 cb                     	movq	%r9, %rbx
   15007: e9 3a fb ff ff               	jmp	0x14b46 <bpf_object_open.part.0+0x33b6>
   1500c: 49 89 ef                     	movq	%rbp, %r15
   1500f: e9 f5 ca ff ff               	jmp	0x11b09 <bpf_object_open.part.0+0x379>
   15014: 4c 8b 74 24 28               	movq	40(%rsp), %r14
; 		return -ESRCH;
   15019: 41 b8 fd ff ff ff            	movl	$4294967293, %r8d       # imm = 0xFFFFFFFD
   1501f: e9 3b ed ff ff               	jmp	0x13d5f <bpf_object_open.part.0+0x25cf>
; 		if (insn->src_reg != BPF_PSEUDO_CALL) {
   15024: 48 8b 44 24 48               	movq	72(%rsp), %rax
   15029: 0f b6 40 01                  	movzbl	1(%rax), %eax
   1502d: 83 e0 f0                     	andl	$-16, %eax
   15030: 3c 10                        	cmpb	$16, %al
   15032: 0f 85 cc df ff ff            	jne	0x13004 <bpf_object_open.part.0+0x1874>
; 		if (!shdr_idx || shdr_idx != obj->efile.text_shndx) {
   15038: 44 39 9d 04 01 00 00         	cmpl	%r11d, 260(%rbp)
   1503f: 0f 85 9f fa ff ff            	jne	0x14ae4 <bpf_object_open.part.0+0x3354>
; 		if (sym->st_value % BPF_INSN_SZ) {
   15045: 4c 8b 43 08                  	movq	8(%rbx), %r8
   15049: 41 f6 c0 07                  	testb	$7, %r8b
   1504d: 75 15                        	jne	0x15064 <bpf_object_open.part.0+0x38d4>
; 		reloc_desc->type = RELO_CALL;
   1504f: 41 c7 45 00 01 00 00 00      	movl	$1, (%r13)
; 		reloc_desc->insn_idx = insn_idx;
   15057: 45 89 55 04                  	movl	%r10d, 4(%r13)
; 		reloc_desc->sym_off = sym->st_value;
   1505b: 45 89 45 0c                  	movl	%r8d, 12(%r13)
; 		if (err)
   1505f: e9 c0 e4 ff ff               	jmp	0x13524 <bpf_object_open.part.0+0x1d94>
; 			pr_warn("prog '%s': bad call relo against '%s' at offset %zu\n",
   15064: 49 8b 16                     	movq	(%r14), %rdx
   15067: 4c 89 c9                     	movq	%r9, %rcx
   1506a: 48 8d 35 67 16 02 00         	leaq	136807(%rip), %rsi      # 0x366d8 <strs.2+0x3848>
   15071: 31 ff                        	xorl	%edi, %edi
   15073: 31 c0                        	xorl	%eax, %eax
   15075: 48 c7 c3 5b f0 ff ff         	movq	$-4005, %rbx            # imm = 0xF05B
   1507c: e8 4f 30 ff ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   15081: e9 72 cb ff ff               	jmp	0x11bf8 <bpf_object_open.part.0+0x468>
; 		pr_debug("No name found in string section for DATASEC kind.\n");
   15086: 4d 89 f7                     	movq	%r14, %r15
   15089: 48 8d 35 00 0d 02 00         	leaq	134400(%rip), %rsi      # 0x35d90 <strs.2+0x2f00>
   15090: e9 9a ec ff ff               	jmp	0x13d2f <bpf_object_open.part.0+0x259f>
   15095: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

00000000000150a0 <bpf_object__open_file>:
; {
   150a0: f3 0f 1e fa                  	endbr64
   150a4: 41 54                        	pushq	%r12
   150a6: 55                           	pushq	%rbp
   150a7: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!path)
   150ab: 48 85 ff                     	testq	%rdi, %rdi
   150ae: 0f 84 8c 00 00 00            	je	0x15140 <bpf_object__open_file+0xa0>
; 	pr_debug("loading %s\n", path);
   150b4: 48 89 fa                     	movq	%rdi, %rdx
   150b7: 31 c0                        	xorl	%eax, %eax
   150b9: 48 89 fd                     	movq	%rdi, %rbp
   150bc: 49 89 f4                     	movq	%rsi, %r12
   150bf: bf 02 00 00 00               	movl	$2, %edi
   150c4: 48 8d 35 71 d0 01 00         	leaq	118897(%rip), %rsi      # 0x3213c <_IO_stdin_used+0x213c>
   150cb: e8 00 30 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   150d0: bf 01 00 00 00               	movl	$1, %edi
   150d5: e8 36 06 ff ff               	callq	0x5710 <.plt.sec+0xa0>
   150da: 85 c0                        	testl	%eax, %eax
   150dc: 74 22                        	je	0x15100 <bpf_object__open_file+0x60>
   150de: 31 d2                        	xorl	%edx, %edx
   150e0: 31 f6                        	xorl	%esi, %esi
   150e2: 4c 89 e1                     	movq	%r12, %rcx
   150e5: 48 89 ef                     	movq	%rbp, %rdi
   150e8: e8 a3 c6 ff ff               	callq	0x11790 <bpf_object_open.part.0>
; 	if (IS_ERR(ret))
   150ed: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   150f3: 77 3b                        	ja	0x15130 <bpf_object__open_file+0x90>
; }
   150f5: 48 83 c4 08                  	addq	$8, %rsp
   150f9: 5d                           	popq	%rbp
   150fa: 41 5c                        	popq	%r12
   150fc: c3                           	retq
   150fd: 0f 1f 00                     	nopl	(%rax)
; 		pr_warn("failed to init libelf for %s\n",
   15100: 48 89 ea                     	movq	%rbp, %rdx
   15103: 48 8d 35 06 1b 02 00         	leaq	137990(%rip), %rsi      # 0x36c10 <strs.2+0x3d80>
   1510a: 31 ff                        	xorl	%edi, %edi
   1510c: bd a0 0f 00 00               	movl	$4000, %ebp             # imm = 0xFA0
   15111: e8 ba 2f ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -PTR_ERR(ret);
   15116: e8 d5 05 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   1511b: 89 28                        	movl	%ebp, (%rax)
; }
   1511d: 48 83 c4 08                  	addq	$8, %rsp
; 	return IS_ERR(ret) ? NULL : ret;
   15121: 31 c0                        	xorl	%eax, %eax
; }
   15123: 5d                           	popq	%rbp
   15124: 41 5c                        	popq	%r12
   15126: c3                           	retq
   15127: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		errno = -PTR_ERR(ret);
   15130: 89 c5                        	movl	%eax, %ebp
   15132: f7 dd                        	negl	%ebp
   15134: eb e0                        	jmp	0x15116 <bpf_object__open_file+0x76>
   15136: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	errno = -err;
   15140: e8 ab 05 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   15145: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   1514b: 48 83 c4 08                  	addq	$8, %rsp
; 	errno = -err;
   1514f: 31 c0                        	xorl	%eax, %eax
; }
   15151: 5d                           	popq	%rbp
   15152: 41 5c                        	popq	%r12
   15154: c3                           	retq
   15155: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

0000000000015160 <bpf_object__open>:
; {
   15160: f3 0f 1e fa                  	endbr64
; 	return bpf_object__open_file(path, NULL);
   15164: 31 f6                        	xorl	%esi, %esi
   15166: e9 35 ff ff ff               	jmp	0x150a0 <bpf_object__open_file>
   1516b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000015170 <bpf_object__open_mem>:
; {
   15170: f3 0f 1e fa                  	endbr64
   15174: 41 55                        	pushq	%r13
   15176: 41 54                        	pushq	%r12
   15178: 55                           	pushq	%rbp
; 	if (!obj_buf || obj_buf_sz == 0)
   15179: 48 85 ff                     	testq	%rdi, %rdi
   1517c: 74 72                        	je	0x151f0 <bpf_object__open_mem+0x80>
   1517e: 49 89 f4                     	movq	%rsi, %r12
   15181: 48 85 f6                     	testq	%rsi, %rsi
   15184: 74 6a                        	je	0x151f0 <bpf_object__open_mem+0x80>
   15186: 48 89 fd                     	movq	%rdi, %rbp
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   15189: bf 01 00 00 00               	movl	$1, %edi
   1518e: 49 89 d5                     	movq	%rdx, %r13
   15191: e8 7a 05 ff ff               	callq	0x5710 <.plt.sec+0xa0>
   15196: 85 c0                        	testl	%eax, %eax
   15198: 74 26                        	je	0x151c0 <bpf_object__open_mem+0x50>
   1519a: 31 ff                        	xorl	%edi, %edi
   1519c: 4c 89 e9                     	movq	%r13, %rcx
   1519f: 4c 89 e2                     	movq	%r12, %rdx
   151a2: 48 89 ee                     	movq	%rbp, %rsi
   151a5: e8 e6 c5 ff ff               	callq	0x11790 <bpf_object_open.part.0>
; 	if (IS_ERR(ret))
   151aa: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   151b0: 77 56                        	ja	0x15208 <bpf_object__open_mem+0x98>
; }
   151b2: 5d                           	popq	%rbp
   151b3: 41 5c                        	popq	%r12
   151b5: 41 5d                        	popq	%r13
   151b7: c3                           	retq
   151b8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		pr_warn("failed to init libelf for %s\n",
   151c0: 48 8d 15 89 cf 01 00         	leaq	118665(%rip), %rdx      # 0x32150 <_IO_stdin_used+0x2150>
   151c7: 48 8d 35 42 1a 02 00         	leaq	137794(%rip), %rsi      # 0x36c10 <strs.2+0x3d80>
   151ce: 31 ff                        	xorl	%edi, %edi
   151d0: bd a0 0f 00 00               	movl	$4000, %ebp             # imm = 0xFA0
   151d5: e8 f6 2e ff ff               	callq	0x80d0 <libbpf_print>
; 		errno = -PTR_ERR(ret);
   151da: e8 11 05 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   151df: 89 28                        	movl	%ebp, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   151e1: 31 c0                        	xorl	%eax, %eax
; }
   151e3: 5d                           	popq	%rbp
   151e4: 41 5c                        	popq	%r12
   151e6: 41 5d                        	popq	%r13
   151e8: c3                           	retq
   151e9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	errno = -err;
   151f0: e8 fb 04 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   151f5: c7 00 16 00 00 00            	movl	$22, (%rax)
   151fb: 31 c0                        	xorl	%eax, %eax
; }
   151fd: 5d                           	popq	%rbp
   151fe: 41 5c                        	popq	%r12
   15200: 41 5d                        	popq	%r13
   15202: c3                           	retq
   15203: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		errno = -PTR_ERR(ret);
   15208: 89 c5                        	movl	%eax, %ebp
   1520a: f7 dd                        	negl	%ebp
   1520c: eb cc                        	jmp	0x151da <bpf_object__open_mem+0x6a>
   1520e: 66 90                        	nop

0000000000015210 <populate_skeleton_maps>:
; {
   15210: 41 57                        	pushq	%r15
   15212: 41 56                        	pushq	%r14
   15214: 41 55                        	pushq	%r13
   15216: 41 54                        	pushq	%r12
   15218: 55                           	pushq	%rbp
   15219: 53                           	pushq	%rbx
   1521a: 48 83 ec 18                  	subq	$24, %rsp
   1521e: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
; 	for (i = 0; i < map_cnt; i++) {
   15223: 48 85 d2                     	testq	%rdx, %rdx
   15226: 74 78                        	je	0x152a0 <populate_skeleton_maps+0x90>
   15228: 48 89 fd                     	movq	%rdi, %rbp
   1522b: 48 89 f3                     	movq	%rsi, %rbx
   1522e: 45 31 ed                     	xorl	%r13d, %r13d
   15231: eb 26                        	jmp	0x15259 <populate_skeleton_maps+0x49>
   15233: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		if (mmaped && (*map)->libbpf_type != LIBBPF_MAP_KCONFIG)
   15238: 4d 85 f6                     	testq	%r14, %r14
   1523b: 74 0d                        	je	0x1524a <populate_skeleton_maps+0x3a>
   1523d: 83 78 58 04                  	cmpl	$4, 88(%rax)
   15241: 74 07                        	je	0x1524a <populate_skeleton_maps+0x3a>
; 			*mmaped = (*map)->mmaped;
   15243: 48 8b 40 60                  	movq	96(%rax), %rax
   15247: 49 89 06                     	movq	%rax, (%r14)
; 	for (i = 0; i < map_cnt; i++) {
   1524a: 49 83 c5 01                  	addq	$1, %r13
   1524e: 48 83 c3 18                  	addq	$24, %rbx
   15252: 4c 3b 6c 24 08               	cmpq	8(%rsp), %r13
   15257: 74 47                        	je	0x152a0 <populate_skeleton_maps+0x90>
; 		const char *name = maps[i].name;
   15259: 4c 8b 3b                     	movq	(%rbx), %r15
; 		struct bpf_map **map = maps[i].map;
   1525c: 4c 8b 63 08                  	movq	8(%rbx), %r12
; 		*map = bpf_object__find_map_by_name(obj, name);
   15260: 48 89 ef                     	movq	%rbp, %rdi
; 		void **mmaped = maps[i].mmaped;
   15263: 4c 8b 73 10                  	movq	16(%rbx), %r14
; 		*map = bpf_object__find_map_by_name(obj, name);
   15267: 4c 89 fe                     	movq	%r15, %rsi
   1526a: e8 41 c4 ff ff               	callq	0x116b0 <bpf_object__find_map_by_name>
   1526f: 49 89 04 24                  	movq	%rax, (%r12)
; 		if (!*map) {
   15273: 48 85 c0                     	testq	%rax, %rax
   15276: 75 c0                        	jne	0x15238 <populate_skeleton_maps+0x28>
; 			pr_warn("failed to find skeleton map '%s'\n", name);
   15278: 4c 89 fa                     	movq	%r15, %rdx
   1527b: 48 8d 35 b6 19 02 00         	leaq	137654(%rip), %rsi      # 0x36c38 <strs.2+0x3da8>
   15282: 31 ff                        	xorl	%edi, %edi
   15284: e8 47 2e ff ff               	callq	0x80d0 <libbpf_print>
; }
   15289: 48 83 c4 18                  	addq	$24, %rsp
; 			return -ESRCH;
   1528d: b8 fd ff ff ff               	movl	$4294967293, %eax       # imm = 0xFFFFFFFD
; }
   15292: 5b                           	popq	%rbx
   15293: 5d                           	popq	%rbp
   15294: 41 5c                        	popq	%r12
   15296: 41 5d                        	popq	%r13
   15298: 41 5e                        	popq	%r14
   1529a: 41 5f                        	popq	%r15
   1529c: c3                           	retq
   1529d: 0f 1f 00                     	nopl	(%rax)
   152a0: 48 83 c4 18                  	addq	$24, %rsp
; 	return 0;
   152a4: 31 c0                        	xorl	%eax, %eax
; }
   152a6: 5b                           	popq	%rbx
   152a7: 5d                           	popq	%rbp
   152a8: 41 5c                        	popq	%r12
   152aa: 41 5d                        	popq	%r13
   152ac: 41 5e                        	popq	%r14
   152ae: 41 5f                        	popq	%r15
   152b0: c3                           	retq
   152b1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   152bc: 0f 1f 40 00                  	nopl	(%rax)

00000000000152c0 <bpf_object__find_map_fd_by_name>:
; {
   152c0: f3 0f 1e fa                  	endbr64
   152c4: 48 83 ec 08                  	subq	$8, %rsp
; 	return bpf_map__fd(bpf_object__find_map_by_name(obj, name));
   152c8: e8 e3 c3 ff ff               	callq	0x116b0 <bpf_object__find_map_by_name>
; 	return map ? map->fd : libbpf_err(-EINVAL);
   152cd: 48 85 c0                     	testq	%rax, %rax
   152d0: 74 08                        	je	0x152da <bpf_object__find_map_fd_by_name+0x1a>
   152d2: 8b 40 18                     	movl	24(%rax), %eax
; }
   152d5: 48 83 c4 08                  	addq	$8, %rsp
   152d9: c3                           	retq
; 		errno = -ret;
   152da: e8 11 04 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   152df: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return map ? map->fd : libbpf_err(-EINVAL);
   152e5: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; 	return bpf_map__fd(bpf_object__find_map_by_name(obj, name));
   152ea: eb e9                        	jmp	0x152d5 <bpf_object__find_map_fd_by_name+0x15>
   152ec: 0f 1f 40 00                  	nopl	(%rax)

00000000000152f0 <libbpf_get_error>:
; {
   152f0: f3 0f 1e fa                  	endbr64
   152f4: 53                           	pushq	%rbx
   152f5: 48 89 fb                     	movq	%rdi, %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
   152f8: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   152ff: 77 0f                        	ja	0x15310 <libbpf_get_error+0x20>
; 		return 0;
   15301: 31 c0                        	xorl	%eax, %eax
; 	if (!IS_ERR_OR_NULL(ptr))
   15303: 48 85 ff                     	testq	%rdi, %rdi
   15306: 74 08                        	je	0x15310 <libbpf_get_error+0x20>
; }
   15308: 5b                           	popq	%rbx
   15309: c3                           	retq
   1530a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
   15310: e8 db 03 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
   15315: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   1531c: 77 12                        	ja	0x15330 <libbpf_get_error+0x40>
; 	return -errno;
   1531e: 8b 18                        	movl	(%rax), %ebx
   15320: f7 db                        	negl	%ebx
   15322: 48 63 c3                     	movslq	%ebx, %rax
; }
   15325: 5b                           	popq	%rbx
   15326: c3                           	retq
   15327: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
   15330: f7 db                        	negl	%ebx
   15332: 89 18                        	movl	%ebx, (%rax)
   15334: eb ea                        	jmp	0x15320 <libbpf_get_error+0x30>
   15336: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000015340 <bpf_link__update_program>:
; {
   15340: f3 0f 1e fa                  	endbr64
   15344: 48 83 ec 18                  	subq	$24, %rsp
; 	if (!prog)
   15348: 48 85 f6                     	testq	%rsi, %rsi
   1534b: 74 3f                        	je	0x1538c <bpf_link__update_program+0x4c>
; 	if (prog->fd < 0)
   1534d: 8b 76 78                     	movl	120(%rsi), %esi
   15350: 85 f6                        	testl	%esi, %esi
   15352: 78 1c                        	js	0x15370 <bpf_link__update_program+0x30>
; 	ret = bpf_link_update(bpf_link__fd(link), bpf_program__fd(prog), NULL);
   15354: 8b 7f 18                     	movl	24(%rdi), %edi
   15357: 31 d2                        	xorl	%edx, %edx
   15359: e8 d2 1c 01 00               	callq	0x27030 <bpf_link_update>
; 	return ret < 0 ? -errno : ret;
   1535e: 85 c0                        	testl	%eax, %eax
   15360: 79 09                        	jns	0x1536b <bpf_link__update_program+0x2b>
   15362: e8 89 03 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   15367: 8b 00                        	movl	(%rax), %eax
   15369: f7 d8                        	negl	%eax
; }
   1536b: 48 83 c4 18                  	addq	$24, %rsp
   1536f: c3                           	retq
   15370: 48 89 7c 24 08               	movq	%rdi, 8(%rsp)
; 		errno = -ret;
   15375: e8 76 03 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOENT);
   1537a: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   1537f: be fe ff ff ff               	movl	$4294967294, %esi       # imm = 0xFFFFFFFE
; 		errno = -ret;
   15384: c7 00 02 00 00 00            	movl	$2, (%rax)
   1538a: eb c8                        	jmp	0x15354 <bpf_link__update_program+0x14>
   1538c: 48 89 7c 24 08               	movq	%rdi, 8(%rsp)
   15391: e8 5a 03 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   15396: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
; 		return libbpf_err(-EINVAL);
   1539b: be ea ff ff ff               	movl	$4294967274, %esi       # imm = 0xFFFFFFEA
; 		errno = -ret;
   153a0: c7 00 16 00 00 00            	movl	$22, (%rax)
   153a6: eb ac                        	jmp	0x15354 <bpf_link__update_program+0x14>
   153a8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

00000000000153b0 <bpf_link__disconnect>:
; {
   153b0: f3 0f 1e fa                  	endbr64
; 	link->disconnected = true;
   153b4: c6 47 1c 01                  	movb	$1, 28(%rdi)
; }
   153b8: c3                           	retq
   153b9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

00000000000153c0 <bpf_link__destroy>:
; {
   153c0: f3 0f 1e fa                  	endbr64
; 	if (IS_ERR_OR_NULL(link))
   153c4: 48 85 ff                     	testq	%rdi, %rdi
   153c7: 74 17                        	je	0x153e0 <bpf_link__destroy+0x20>
   153c9: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   153d0: 77 0e                        	ja	0x153e0 <bpf_link__destroy+0x20>
   153d2: e9 c9 28 ff ff               	jmp	0x7ca0 <bpf_link__destroy.part.0>
   153d7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; }
   153e0: 31 c0                        	xorl	%eax, %eax
   153e2: c3                           	retq
   153e3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   153ee: 66 90                        	nop

00000000000153f0 <bpf_link__fd>:
; {
   153f0: f3 0f 1e fa                  	endbr64
; 	return link->fd;
   153f4: 8b 47 18                     	movl	24(%rdi), %eax
; }
   153f7: c3                           	retq
   153f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000015400 <bpf_link__pin_path>:
; {
   15400: f3 0f 1e fa                  	endbr64
; 	return link->pin_path;
   15404: 48 8b 47 10                  	movq	16(%rdi), %rax
; }
   15408: c3                           	retq
   15409: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000015410 <bpf_link__open>:
; {
   15410: f3 0f 1e fa                  	endbr64
   15414: 41 55                        	pushq	%r13
   15416: 41 54                        	pushq	%r12
   15418: 55                           	pushq	%rbp
   15419: 48 89 fd                     	movq	%rdi, %rbp
; 	fd = bpf_obj_get(path);
   1541c: e8 ef 15 01 00               	callq	0x26a10 <bpf_obj_get>
; 	if (fd < 0) {
   15421: 85 c0                        	testl	%eax, %eax
   15423: 78 4b                        	js	0x15470 <bpf_link__open+0x60>
; 	link = calloc(1, sizeof(*link));
   15425: be 20 00 00 00               	movl	$32, %esi
   1542a: bf 01 00 00 00               	movl	$1, %edi
   1542f: 41 89 c5                     	movl	%eax, %r13d
   15432: e8 59 05 ff ff               	callq	0x5990 <.plt.sec+0x320>
   15437: 49 89 c4                     	movq	%rax, %r12
; 	if (!link) {
   1543a: 48 85 c0                     	testq	%rax, %rax
   1543d: 74 64                        	je	0x154a3 <bpf_link__open+0x93>
; 	link->detach = &bpf_link__detach_fd;
   1543f: 48 8d 05 8a 24 ff ff         	leaq	-56182(%rip), %rax      # 0x78d0 <bpf_link__detach_fd>
; 	link->fd = fd;
   15446: 45 89 6c 24 18               	movl	%r13d, 24(%r12)
; 	link->pin_path = strdup(path);
   1544b: 48 89 ef                     	movq	%rbp, %rdi
; 	link->detach = &bpf_link__detach_fd;
   1544e: 49 89 04 24                  	movq	%rax, (%r12)
; 	link->pin_path = strdup(path);
   15452: e8 b9 07 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   15457: 49 89 44 24 10               	movq	%rax, 16(%r12)
; 	if (!link->pin_path) {
   1545c: 48 85 c0                     	testq	%rax, %rax
   1545f: 74 57                        	je	0x154b8 <bpf_link__open+0xa8>
; }
   15461: 4c 89 e0                     	movq	%r12, %rax
   15464: 5d                           	popq	%rbp
   15465: 41 5c                        	popq	%r12
   15467: 41 5d                        	popq	%r13
   15469: c3                           	retq
   1546a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		fd = -errno;
   15470: e8 7b 02 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to open link at %s: %d\n", path, fd);
   15475: 48 89 ea                     	movq	%rbp, %rdx
   15478: 48 8d 35 e9 17 02 00         	leaq	137193(%rip), %rsi      # 0x36c68 <strs.2+0x3dd8>
   1547f: 31 ff                        	xorl	%edi, %edi
; 		fd = -errno;
   15481: 44 8b 28                     	movl	(%rax), %r13d
   15484: 49 89 c4                     	movq	%rax, %r12
; 		pr_warn("failed to open link at %s: %d\n", path, fd);
   15487: 31 c0                        	xorl	%eax, %eax
; 		fd = -errno;
   15489: 44 89 e9                     	movl	%r13d, %ecx
   1548c: f7 d9                        	negl	%ecx
; 		pr_warn("failed to open link at %s: %d\n", path, fd);
   1548e: e8 3d 2c ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   15493: 45 89 2c 24                  	movl	%r13d, (%r12)
; 		return libbpf_err_ptr(fd);
   15497: 45 31 e4                     	xorl	%r12d, %r12d
; }
   1549a: 5d                           	popq	%rbp
   1549b: 4c 89 e0                     	movq	%r12, %rax
   1549e: 41 5c                        	popq	%r12
   154a0: 41 5d                        	popq	%r13
   154a2: c3                           	retq
; 		close(fd);
   154a3: 44 89 ef                     	movl	%r13d, %edi
   154a6: e8 55 04 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	errno = -err;
   154ab: e8 40 02 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   154b0: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err_ptr(-ENOMEM);
   154b6: eb a9                        	jmp	0x15461 <bpf_link__open+0x51>
; 		bpf_link__destroy(link);
   154b8: 4c 89 e7                     	movq	%r12, %rdi
; 		return libbpf_err_ptr(-ENOMEM);
   154bb: 45 31 e4                     	xorl	%r12d, %r12d
; 		bpf_link__destroy(link);
   154be: e8 fd fe ff ff               	callq	0x153c0 <bpf_link__destroy>
; 	errno = -err;
   154c3: e8 28 02 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   154c8: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err_ptr(-ENOMEM);
   154ce: eb 91                        	jmp	0x15461 <bpf_link__open+0x51>

00000000000154d0 <bpf_link__detach>:
; {
   154d0: f3 0f 1e fa                  	endbr64
   154d4: 48 83 ec 08                  	subq	$8, %rsp
; 	return bpf_link_detach(link->fd) ? -errno : 0;
   154d8: 8b 7f 18                     	movl	24(%rdi), %edi
   154db: e8 e0 1a 01 00               	callq	0x26fc0 <bpf_link_detach>
   154e0: 85 c0                        	testl	%eax, %eax
   154e2: 74 09                        	je	0x154ed <bpf_link__detach+0x1d>
   154e4: e8 07 02 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   154e9: 8b 00                        	movl	(%rax), %eax
   154eb: f7 d8                        	negl	%eax
; }
   154ed: 48 83 c4 08                  	addq	$8, %rsp
   154f1: c3                           	retq
   154f2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   154fd: 0f 1f 00                     	nopl	(%rax)

0000000000015500 <bpf_link__pin>:
; {
   15500: f3 0f 1e fa                  	endbr64
   15504: 41 55                        	pushq	%r13
   15506: 41 54                        	pushq	%r12
   15508: 55                           	pushq	%rbp
   15509: 53                           	pushq	%rbx
   1550a: 48 83 ec 08                  	subq	$8, %rsp
; 	if (link->pin_path)
   1550e: 48 83 7f 10 00               	cmpq	$0, 16(%rdi)
   15513: 0f 85 df 00 00 00            	jne	0x155f8 <bpf_link__pin+0xf8>
   15519: 48 89 fb                     	movq	%rdi, %rbx
; 	err = make_parent_dir(path);
   1551c: 48 89 f7                     	movq	%rsi, %rdi
   1551f: 48 89 f5                     	movq	%rsi, %rbp
   15522: e8 a9 46 ff ff               	callq	0x9bd0 <make_parent_dir>
   15527: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
   1552a: 85 c0                        	testl	%eax, %eax
   1552c: 74 12                        	je	0x15540 <bpf_link__pin+0x40>
; 	if (ret < 0)
   1552e: 78 70                        	js	0x155a0 <bpf_link__pin+0xa0>
; }
   15530: 48 83 c4 08                  	addq	$8, %rsp
   15534: 44 89 e0                     	movl	%r12d, %eax
   15537: 5b                           	popq	%rbx
   15538: 5d                           	popq	%rbp
   15539: 41 5c                        	popq	%r12
   1553b: 41 5d                        	popq	%r13
   1553d: c3                           	retq
   1553e: 66 90                        	nop
; 	err = check_path(path);
   15540: 48 89 ef                     	movq	%rbp, %rdi
   15543: e8 88 47 ff ff               	callq	0x9cd0 <check_path>
   15548: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
   1554b: 85 c0                        	testl	%eax, %eax
   1554d: 75 df                        	jne	0x1552e <bpf_link__pin+0x2e>
; 	link->pin_path = strdup(path);
   1554f: 48 89 ef                     	movq	%rbp, %rdi
   15552: e8 b9 06 ff ff               	callq	0x5c10 <.plt.sec+0x5a0>
   15557: 48 89 43 10                  	movq	%rax, 16(%rbx)
   1555b: 48 89 c6                     	movq	%rax, %rsi
; 	if (!link->pin_path)
   1555e: 48 85 c0                     	testq	%rax, %rax
   15561: 0f 84 a7 00 00 00            	je	0x1560e <bpf_link__pin+0x10e>
; 	if (bpf_obj_pin(link->fd, link->pin_path)) {
   15567: 8b 7b 18                     	movl	24(%rbx), %edi
   1556a: e8 21 14 01 00               	callq	0x26990 <bpf_obj_pin>
   1556f: 41 89 c4                     	movl	%eax, %r12d
   15572: 85 c0                        	testl	%eax, %eax
   15574: 75 4a                        	jne	0x155c0 <bpf_link__pin+0xc0>
; 	pr_debug("link fd=%d: pinned at %s\n", link->fd, link->pin_path);
   15576: 48 8b 4b 10                  	movq	16(%rbx), %rcx
   1557a: 8b 53 18                     	movl	24(%rbx), %edx
   1557d: 31 c0                        	xorl	%eax, %eax
   1557f: 48 8d 35 0a 17 02 00         	leaq	136970(%rip), %rsi      # 0x36c90 <strs.2+0x3e00>
   15586: bf 02 00 00 00               	movl	$2, %edi
   1558b: e8 40 2b ff ff               	callq	0x80d0 <libbpf_print>
; }
   15590: 48 83 c4 08                  	addq	$8, %rsp
   15594: 44 89 e0                     	movl	%r12d, %eax
   15597: 5b                           	popq	%rbx
   15598: 5d                           	popq	%rbp
   15599: 41 5c                        	popq	%r12
   1559b: 41 5d                        	popq	%r13
   1559d: c3                           	retq
   1559e: 66 90                        	nop
; 		errno = -ret;
   155a0: e8 4b 01 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   155a5: 44 89 e2                     	movl	%r12d, %edx
   155a8: f7 da                        	negl	%edx
   155aa: 89 10                        	movl	%edx, (%rax)
; }
   155ac: 48 83 c4 08                  	addq	$8, %rsp
   155b0: 44 89 e0                     	movl	%r12d, %eax
   155b3: 5b                           	popq	%rbx
   155b4: 5d                           	popq	%rbp
   155b5: 41 5c                        	popq	%r12
   155b7: 41 5d                        	popq	%r13
   155b9: c3                           	retq
   155ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		err = -errno;
   155c0: e8 2b 01 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		zfree(&link->pin_path);
   155c5: 48 8b 7b 10                  	movq	16(%rbx), %rdi
; 		err = -errno;
   155c9: 44 8b 28                     	movl	(%rax), %r13d
   155cc: 48 89 c5                     	movq	%rax, %rbp
; 		zfree(&link->pin_path);
   155cf: e8 ec 00 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   155d4: 48 c7 43 10 00 00 00 00      	movq	$0, 16(%rbx)
; 		err = -errno;
   155dc: 45 89 ec                     	movl	%r13d, %r12d
   155df: 41 f7 dc                     	negl	%r12d
; 	if (ret < 0)
   155e2: 45 85 ed                     	testl	%r13d, %r13d
   155e5: 0f 8e 45 ff ff ff            	jle	0x15530 <bpf_link__pin+0x30>
; 		errno = -ret;
   155eb: 44 89 6d 00                  	movl	%r13d, (%rbp)
   155ef: e9 3c ff ff ff               	jmp	0x15530 <bpf_link__pin+0x30>
   155f4: 0f 1f 40 00                  	nopl	(%rax)
   155f8: e8 f3 00 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EBUSY);
   155fd: 41 bc f0 ff ff ff            	movl	$4294967280, %r12d      # imm = 0xFFFFFFF0
; 		errno = -ret;
   15603: c7 00 10 00 00 00            	movl	$16, (%rax)
   15609: e9 22 ff ff ff               	jmp	0x15530 <bpf_link__pin+0x30>
; 	if (ret < 0)
   1560e: bf f4 ff ff ff               	movl	$4294967284, %edi       # imm = 0xFFFFFFF4
; 		return libbpf_err(-ENOMEM);
   15613: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
   15619: e8 52 1c ff ff               	callq	0x7270 <libbpf_err.part.0>
   1561e: e9 0d ff ff ff               	jmp	0x15530 <bpf_link__pin+0x30>
   15623: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1562e: 66 90                        	nop

0000000000015630 <bpf_link__unpin>:
; {
   15630: f3 0f 1e fa                  	endbr64
   15634: 41 54                        	pushq	%r12
   15636: 53                           	pushq	%rbx
   15637: 48 89 fb                     	movq	%rdi, %rbx
   1563a: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!link->pin_path)
   1563e: 48 8b 7f 10                  	movq	16(%rdi), %rdi
   15642: 48 85 ff                     	testq	%rdi, %rdi
   15645: 74 5f                        	je	0x156a6 <bpf_link__unpin+0x76>
; 	err = unlink(link->pin_path);
   15647: e8 b4 00 ff ff               	callq	0x5700 <.plt.sec+0x90>
   1564c: 41 89 c4                     	movl	%eax, %r12d
; 	if (err != 0)
   1564f: 85 c0                        	testl	%eax, %eax
   15651: 74 1d                        	je	0x15670 <bpf_link__unpin+0x40>
; 		return -errno;
   15653: e8 98 00 ff ff               	callq	0x56f0 <.plt.sec+0x80>
   15658: 44 8b 20                     	movl	(%rax), %r12d
   1565b: 41 f7 dc                     	negl	%r12d
; }
   1565e: 48 83 c4 08                  	addq	$8, %rsp
   15662: 44 89 e0                     	movl	%r12d, %eax
   15665: 5b                           	popq	%rbx
   15666: 41 5c                        	popq	%r12
   15668: c3                           	retq
   15669: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	pr_debug("link fd=%d: unpinned from %s\n", link->fd, link->pin_path);
   15670: 48 8b 4b 10                  	movq	16(%rbx), %rcx
   15674: 8b 53 18                     	movl	24(%rbx), %edx
   15677: 31 c0                        	xorl	%eax, %eax
   15679: 48 8d 35 38 16 02 00         	leaq	136760(%rip), %rsi      # 0x36cb8 <strs.2+0x3e28>
   15680: bf 02 00 00 00               	movl	$2, %edi
   15685: e8 46 2a ff ff               	callq	0x80d0 <libbpf_print>
; 	zfree(&link->pin_path);
   1568a: 48 8b 7b 10                  	movq	16(%rbx), %rdi
   1568e: e8 2d 00 ff ff               	callq	0x56c0 <.plt.sec+0x50>
   15693: 48 c7 43 10 00 00 00 00      	movq	$0, 16(%rbx)
; }
   1569b: 44 89 e0                     	movl	%r12d, %eax
   1569e: 48 83 c4 08                  	addq	$8, %rsp
   156a2: 5b                           	popq	%rbx
   156a3: 41 5c                        	popq	%r12
   156a5: c3                           	retq
; 		errno = -ret;
   156a6: e8 45 00 ff ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   156ab: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   156b1: c7 00 16 00 00 00            	movl	$22, (%rax)
   156b7: eb a5                        	jmp	0x1565e <bpf_link__unpin+0x2e>
   156b9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

00000000000156c0 <bpf_program__attach_perf_event_opts>:
; {
   156c0: f3 0f 1e fa                  	endbr64
   156c4: 41 57                        	pushq	%r15
   156c6: 41 56                        	pushq	%r14
   156c8: 41 55                        	pushq	%r13
   156ca: 41 89 f5                     	movl	%esi, %r13d
   156cd: 41 54                        	pushq	%r12
   156cf: 55                           	pushq	%rbp
   156d0: 48 89 fd                     	movq	%rdi, %rbp
   156d3: 53                           	pushq	%rbx
   156d4: 48 89 d3                     	movq	%rdx, %rbx
   156d7: 48 81 ec 18 01 00 00         	subq	$280, %rsp              # imm = 0x118
   156de: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   156e7: 48 89 84 24 08 01 00 00      	movq	%rax, 264(%rsp)
   156ef: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_perf_event_opts))
   156f1: 48 85 d2                     	testq	%rdx, %rdx
   156f4: 74 5a                        	je	0x15750 <bpf_program__attach_perf_event_opts+0x90>
   156f6: 48 8b 0a                     	movq	(%rdx), %rcx
; 	if (user_sz < sizeof(size_t)) {
   156f9: 48 83 f9 07                  	cmpq	$7, %rcx
   156fd: 0f 86 6d 02 00 00            	jbe	0x15970 <bpf_program__attach_perf_event_opts+0x2b0>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   15703: 48 8d 42 10                  	leaq	16(%rdx), %rax
   15707: 48 8d 51 f0                  	leaq	-16(%rcx), %rdx
; 	while (len > 0) {
   1570b: 48 85 d2                     	testq	%rdx, %rdx
   1570e: 7e 40                        	jle	0x15750 <bpf_program__attach_perf_event_opts+0x90>
   15710: 48 01 d9                     	addq	%rbx, %rcx
   15713: eb 0c                        	jmp	0x15721 <bpf_program__attach_perf_event_opts+0x61>
   15715: 0f 1f 00                     	nopl	(%rax)
; 		p++;
   15718: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   1571c: 48 39 c1                     	cmpq	%rax, %rcx
   1571f: 74 2f                        	je	0x15750 <bpf_program__attach_perf_event_opts+0x90>
; 		if (*p)
   15721: 80 38 00                     	cmpb	$0, (%rax)
   15724: 74 f2                        	je	0x15718 <bpf_program__attach_perf_event_opts+0x58>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   15726: 48 8d 15 2d ca 01 00         	leaq	117293(%rip), %rdx      # 0x3215a <_IO_stdin_used+0x215a>
   1572d: 48 8d 35 dc e8 01 00         	leaq	125148(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   15734: 31 ff                        	xorl	%edi, %edi
   15736: 31 c0                        	xorl	%eax, %eax
   15738: e8 93 29 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   1573d: e8 ae ff fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   15742: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   15745: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
   1574b: e9 ab 01 00 00               	jmp	0x158fb <bpf_program__attach_perf_event_opts+0x23b>
; 	if (pfd < 0) {
   15750: 45 85 ed                     	testl	%r13d, %r13d
   15753: 0f 88 37 02 00 00            	js	0x15990 <bpf_program__attach_perf_event_opts+0x2d0>
; 	if (!prog)
   15759: 48 85 ed                     	testq	%rbp, %rbp
   1575c: 0f 84 65 03 00 00            	je	0x15ac7 <bpf_program__attach_perf_event_opts+0x407>
; 	if (prog->fd < 0)
   15762: 44 8b 75 78                  	movl	120(%rbp), %r14d
   15766: 45 85 f6                     	testl	%r14d, %r14d
   15769: 0f 88 28 03 00 00            	js	0x15a97 <bpf_program__attach_perf_event_opts+0x3d7>
; 	link = calloc(1, sizeof(*link));
   1576f: be 38 00 00 00               	movl	$56, %esi
   15774: bf 01 00 00 00               	movl	$1, %edi
   15779: e8 12 02 ff ff               	callq	0x5990 <.plt.sec+0x320>
   1577e: 49 89 c4                     	movq	%rax, %r12
; 	if (!link)
   15781: 48 85 c0                     	testq	%rax, %rax
   15784: 0f 84 4d 03 00 00            	je	0x15ad7 <bpf_program__attach_perf_event_opts+0x417>
; 	link->link.detach = &bpf_link_perf_detach;
   1578a: 48 8d 05 7f 25 ff ff         	leaq	-55937(%rip), %rax      # 0x7d10 <bpf_link_perf_detach>
; 	link->perf_event_fd = pfd;
   15791: 45 89 6c 24 20               	movl	%r13d, 32(%r12)
; 	if (kernel_supports(prog->obj, FEAT_PERF_LINK)) {
   15796: 48 8b 7d 70                  	movq	112(%rbp), %rdi
   1579a: be 0c 00 00 00               	movl	$12, %esi
; 	link->link.detach = &bpf_link_perf_detach;
   1579f: 49 89 04 24                  	movq	%rax, (%r12)
; 	link->link.dealloc = &bpf_link_perf_dealloc;
   157a3: 48 8d 05 16 0f ff ff         	leaq	-61674(%rip), %rax      # 0x66c0 <bpf_link_perf_dealloc>
   157aa: 49 89 44 24 08               	movq	%rax, 8(%r12)
; 	if (kernel_supports(prog->obj, FEAT_PERF_LINK)) {
   157af: e8 5c 6c ff ff               	callq	0xc410 <kernel_supports>
   157b4: 84 c0                        	testb	%al, %al
   157b6: 0f 84 fc 00 00 00            	je	0x158b8 <bpf_program__attach_perf_event_opts+0x1f8>
; 		DECLARE_LIBBPF_OPTS(bpf_link_create_opts, link_opts,
   157bc: 31 c0                        	xorl	%eax, %eax
   157be: 48 85 db                     	testq	%rbx, %rbx
   157c1: 74 0a                        	je	0x157cd <bpf_program__attach_perf_event_opts+0x10d>
   157c3: 48 83 3b 0f                  	cmpq	$15, (%rbx)
   157c7: 0f 87 93 01 00 00            	ja	0x15960 <bpf_program__attach_perf_event_opts+0x2a0>
   157cd: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 		link_fd = bpf_link_create(prog_fd, pfd, BPF_PERF_EVENT, &link_opts);
   157d1: 44 89 f7                     	movl	%r14d, %edi
   157d4: 48 89 e1                     	movq	%rsp, %rcx
   157d7: ba 29 00 00 00               	movl	$41, %edx
; 		DECLARE_LIBBPF_OPTS(bpf_link_create_opts, link_opts,
   157dc: 0f 11 44 24 58               	movups	%xmm0, 88(%rsp)
; 		link_fd = bpf_link_create(prog_fd, pfd, BPF_PERF_EVENT, &link_opts);
   157e1: 44 89 ee                     	movl	%r13d, %esi
; 		DECLARE_LIBBPF_OPTS(bpf_link_create_opts, link_opts,
   157e4: 0f 11 44 24 48               	movups	%xmm0, 72(%rsp)
   157e9: 66 0f 6f 54 24 50            	movdqa	80(%rsp), %xmm2
   157ef: 0f 11 44 24 68               	movups	%xmm0, 104(%rsp)
   157f4: 48 c7 44 24 78 00 00 00 00   	movq	$0, 120(%rsp)
   157fd: 66 0f 6f 64 24 70            	movdqa	112(%rsp), %xmm4
   15803: 48 c7 44 24 40 40 00 00 00   	movq	$64, 64(%rsp)
   1580c: 66 0f 6f 4c 24 40            	movdqa	64(%rsp), %xmm1
   15812: 48 89 44 24 60               	movq	%rax, 96(%rsp)
   15817: 66 0f 6f 5c 24 60            	movdqa	96(%rsp), %xmm3
   1581d: 0f 29 0c 24                  	movaps	%xmm1, (%rsp)
   15821: 0f 29 54 24 10               	movaps	%xmm2, 16(%rsp)
   15826: 0f 29 5c 24 20               	movaps	%xmm3, 32(%rsp)
   1582b: 0f 29 64 24 30               	movaps	%xmm4, 48(%rsp)
; 		link_fd = bpf_link_create(prog_fd, pfd, BPF_PERF_EVENT, &link_opts);
   15830: e8 1b 25 01 00               	callq	0x27d50 <bpf_link_create>
   15835: 41 89 c6                     	movl	%eax, %r14d
; 		if (link_fd < 0) {
   15838: 85 c0                        	testl	%eax, %eax
   1583a: 0f 88 6c 01 00 00            	js	0x159ac <bpf_program__attach_perf_event_opts+0x2ec>
; 		link->link.fd = link_fd;
   15840: 41 89 44 24 18               	movl	%eax, 24(%r12)
; 	if (ioctl(pfd, PERF_EVENT_IOC_ENABLE, 0) < 0) {
   15845: 31 d2                        	xorl	%edx, %edx
   15847: 31 c0                        	xorl	%eax, %eax
   15849: be 00 24 00 00               	movl	$9216, %esi             # imm = 0x2400
   1584e: 44 89 ef                     	movl	%r13d, %edi
   15851: e8 9a 00 ff ff               	callq	0x58f0 <.plt.sec+0x280>
   15856: 85 c0                        	testl	%eax, %eax
   15858: 0f 89 9d 00 00 00            	jns	0x158fb <bpf_program__attach_perf_event_opts+0x23b>
; 		err = -errno;
   1585e: e8 8d fe fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("prog '%s': failed to enable perf_event FD %d: %s\n",
   15863: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
   1586b: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   15870: 44 8b 38                     	movl	(%rax), %r15d
   15873: 48 89 c3                     	movq	%rax, %rbx
   15876: 44 89 ff                     	movl	%r15d, %edi
   15879: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to enable perf_event FD %d: %s\n",
   1587b: e8 50 81 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   15880: 48 8b 55 00                  	movq	(%rbp), %rdx
   15884: 31 ff                        	xorl	%edi, %edi
   15886: 44 89 e9                     	movl	%r13d, %ecx
   15889: 49 89 c0                     	movq	%rax, %r8
   1588c: 48 8d 35 fd 15 02 00         	leaq	136701(%rip), %rsi      # 0x36e90 <strs.2+0x4000>
   15893: 31 c0                        	xorl	%eax, %eax
   15895: e8 36 28 ff ff               	callq	0x80d0 <libbpf_print>
; 		close(link_fd);
   1589a: 44 89 f7                     	movl	%r14d, %edi
   1589d: e8 5e 00 ff ff               	callq	0x5900 <.plt.sec+0x290>
; 	free(link);
   158a2: 4c 89 e7                     	movq	%r12, %rdi
; 	return libbpf_err_ptr(err);
   158a5: 45 31 e4                     	xorl	%r12d, %r12d
; 	free(link);
   158a8: e8 13 fe fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	errno = -err;
   158ad: 44 89 3b                     	movl	%r15d, (%rbx)
; 	return libbpf_err_ptr(err);
   158b0: eb 49                        	jmp	0x158fb <bpf_program__attach_perf_event_opts+0x23b>
   158b2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		if (OPTS_GET(opts, bpf_cookie, 0)) {
   158b8: 48 85 db                     	testq	%rbx, %rbx
   158bb: 74 06                        	je	0x158c3 <bpf_program__attach_perf_event_opts+0x203>
   158bd: 48 83 3b 0f                  	cmpq	$15, (%rbx)
   158c1: 77 6d                        	ja	0x15930 <bpf_program__attach_perf_event_opts+0x270>
; 		if (ioctl(pfd, PERF_EVENT_IOC_SET_BPF, prog_fd) < 0) {
   158c3: 31 c0                        	xorl	%eax, %eax
   158c5: 44 89 f2                     	movl	%r14d, %edx
   158c8: be 08 24 04 40               	movl	$1074013192, %esi       # imm = 0x40042408
   158cd: 44 89 ef                     	movl	%r13d, %edi
   158d0: e8 1b 00 ff ff               	callq	0x58f0 <.plt.sec+0x280>
   158d5: 85 c0                        	testl	%eax, %eax
   158d7: 0f 88 17 01 00 00            	js	0x159f4 <bpf_program__attach_perf_event_opts+0x334>
; 		link->link.fd = pfd;
   158dd: 45 89 6c 24 18               	movl	%r13d, 24(%r12)
; 	if (ioctl(pfd, PERF_EVENT_IOC_ENABLE, 0) < 0) {
   158e2: 31 d2                        	xorl	%edx, %edx
   158e4: 31 c0                        	xorl	%eax, %eax
   158e6: be 00 24 00 00               	movl	$9216, %esi             # imm = 0x2400
   158eb: 44 89 ef                     	movl	%r13d, %edi
   158ee: e8 fd ff fe ff               	callq	0x58f0 <.plt.sec+0x280>
   158f3: 85 c0                        	testl	%eax, %eax
   158f5: 0f 88 5b 01 00 00            	js	0x15a56 <bpf_program__attach_perf_event_opts+0x396>
; }
   158fb: 48 8b 84 24 08 01 00 00      	movq	264(%rsp), %rax
   15903: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1590c: 0f 85 d5 01 00 00            	jne	0x15ae7 <bpf_program__attach_perf_event_opts+0x427>
   15912: 48 81 c4 18 01 00 00         	addq	$280, %rsp              # imm = 0x118
   15919: 4c 89 e0                     	movq	%r12, %rax
   1591c: 5b                           	popq	%rbx
   1591d: 5d                           	popq	%rbp
   1591e: 41 5c                        	popq	%r12
   15920: 41 5d                        	popq	%r13
   15922: 41 5e                        	popq	%r14
   15924: 41 5f                        	popq	%r15
   15926: c3                           	retq
   15927: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		if (OPTS_GET(opts, bpf_cookie, 0)) {
   15930: 48 83 7b 08 00               	cmpq	$0, 8(%rbx)
   15935: 74 8c                        	je	0x158c3 <bpf_program__attach_perf_event_opts+0x203>
; 			pr_warn("prog '%s': user context value is not supported\n", prog->name);
   15937: 48 8b 55 00                  	movq	(%rbp), %rdx
   1593b: 48 8d 35 66 14 02 00         	leaq	136294(%rip), %rsi      # 0x36da8 <strs.2+0x3f18>
   15942: 31 ff                        	xorl	%edi, %edi
   15944: 31 c0                        	xorl	%eax, %eax
; 	errno = -err;
   15946: 41 bf 5f 00 00 00            	movl	$95, %r15d
; 			pr_warn("prog '%s': user context value is not supported\n", prog->name);
   1594c: e8 7f 27 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   15951: e8 9a fd fe ff               	callq	0x56f0 <.plt.sec+0x80>
   15956: 48 89 c3                     	movq	%rax, %rbx
   15959: e9 44 ff ff ff               	jmp	0x158a2 <bpf_program__attach_perf_event_opts+0x1e2>
   1595e: 66 90                        	nop
; 		DECLARE_LIBBPF_OPTS(bpf_link_create_opts, link_opts,
   15960: 48 8b 43 08                  	movq	8(%rbx), %rax
   15964: e9 64 fe ff ff               	jmp	0x157cd <bpf_program__attach_perf_event_opts+0x10d>
   15969: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   15970: 48 8d 15 e3 c7 01 00         	leaq	116707(%rip), %rdx      # 0x3215a <_IO_stdin_used+0x215a>
   15977: 48 8d 35 3a e6 01 00         	leaq	124474(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   1597e: 31 ff                        	xorl	%edi, %edi
   15980: e8 4b 27 ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   15985: e9 b3 fd ff ff               	jmp	0x1573d <bpf_program__attach_perf_event_opts+0x7d>
   1598a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("prog '%s': invalid perf event FD %d\n",
   15990: 48 8b 55 00                  	movq	(%rbp), %rdx
   15994: 44 89 e9                     	movl	%r13d, %ecx
   15997: 48 8d 35 42 13 02 00         	leaq	136002(%rip), %rsi      # 0x36ce0 <strs.2+0x3e50>
   1599e: 31 ff                        	xorl	%edi, %edi
   159a0: 31 c0                        	xorl	%eax, %eax
   159a2: e8 29 27 ff ff               	callq	0x80d0 <libbpf_print>
   159a7: e9 91 fd ff ff               	jmp	0x1573d <bpf_program__attach_perf_event_opts+0x7d>
; 			err = -errno;
   159ac: e8 3f fd fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("prog '%s': failed to create BPF link for perf_event FD %d: %d (%s)\n",
   159b1: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
   159b9: ba 80 00 00 00               	movl	$128, %edx
; 			err = -errno;
   159be: 44 8b 38                     	movl	(%rax), %r15d
   159c1: 48 89 c3                     	movq	%rax, %rbx
   159c4: 45 89 fe                     	movl	%r15d, %r14d
   159c7: 41 f7 de                     	negl	%r14d
; 			pr_warn("prog '%s': failed to create BPF link for perf_event FD %d: %d (%s)\n",
   159ca: 44 89 f7                     	movl	%r14d, %edi
   159cd: e8 fe 7f 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   159d2: 48 8b 55 00                  	movq	(%rbp), %rdx
   159d6: 45 89 f0                     	movl	%r14d, %r8d
   159d9: 44 89 e9                     	movl	%r13d, %ecx
   159dc: 49 89 c1                     	movq	%rax, %r9
   159df: 48 8d 35 72 13 02 00         	leaq	136050(%rip), %rsi      # 0x36d58 <strs.2+0x3ec8>
   159e6: 31 ff                        	xorl	%edi, %edi
   159e8: 31 c0                        	xorl	%eax, %eax
   159ea: e8 e1 26 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (link_fd >= 0)
   159ef: e9 ae fe ff ff               	jmp	0x158a2 <bpf_program__attach_perf_event_opts+0x1e2>
; 			err = -errno;
   159f4: e8 f7 fc fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("prog '%s': failed to attach to perf_event FD %d: %s\n",
   159f9: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
   15a01: ba 80 00 00 00               	movl	$128, %edx
; 			err = -errno;
   15a06: 44 8b 38                     	movl	(%rax), %r15d
   15a09: 48 89 c3                     	movq	%rax, %rbx
   15a0c: 44 89 ff                     	movl	%r15d, %edi
   15a0f: f7 df                        	negl	%edi
; 			pr_warn("prog '%s': failed to attach to perf_event FD %d: %s\n",
   15a11: e8 ba 7f 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   15a16: 48 8b 55 00                  	movq	(%rbp), %rdx
   15a1a: 31 ff                        	xorl	%edi, %edi
   15a1c: 44 89 e9                     	movl	%r13d, %ecx
   15a1f: 49 89 c0                     	movq	%rax, %r8
   15a22: 48 8d 35 b7 13 02 00         	leaq	136119(%rip), %rsi      # 0x36de0 <strs.2+0x3f50>
   15a29: 31 c0                        	xorl	%eax, %eax
   15a2b: e8 a0 26 ff ff               	callq	0x80d0 <libbpf_print>
; 			if (err == -EPROTO)
   15a30: 41 83 ff 47                  	cmpl	$71, %r15d
   15a34: 0f 85 68 fe ff ff            	jne	0x158a2 <bpf_program__attach_perf_event_opts+0x1e2>
; 				pr_warn("prog '%s': try add PERF_SAMPLE_CALLCHAIN to or remove exclude_callchain_[kernel|user] from pfd %d\n",
   15a3a: 48 8b 55 00                  	movq	(%rbp), %rdx
   15a3e: 44 89 e9                     	movl	%r13d, %ecx
   15a41: 48 8d 35 d8 13 02 00         	leaq	136152(%rip), %rsi      # 0x36e20 <strs.2+0x3f90>
   15a48: 31 ff                        	xorl	%edi, %edi
   15a4a: 31 c0                        	xorl	%eax, %eax
   15a4c: e8 7f 26 ff ff               	callq	0x80d0 <libbpf_print>
   15a51: e9 4c fe ff ff               	jmp	0x158a2 <bpf_program__attach_perf_event_opts+0x1e2>
; 		err = -errno;
   15a56: e8 95 fc fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("prog '%s': failed to enable perf_event FD %d: %s\n",
   15a5b: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
   15a63: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   15a68: 44 8b 38                     	movl	(%rax), %r15d
   15a6b: 48 89 c3                     	movq	%rax, %rbx
   15a6e: 44 89 ff                     	movl	%r15d, %edi
   15a71: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to enable perf_event FD %d: %s\n",
   15a73: e8 58 7f 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   15a78: 48 8b 55 00                  	movq	(%rbp), %rdx
   15a7c: 44 89 e9                     	movl	%r13d, %ecx
   15a7f: 31 ff                        	xorl	%edi, %edi
   15a81: 49 89 c0                     	movq	%rax, %r8
   15a84: 48 8d 35 05 14 02 00         	leaq	136197(%rip), %rsi      # 0x36e90 <strs.2+0x4000>
   15a8b: 31 c0                        	xorl	%eax, %eax
   15a8d: e8 3e 26 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (link_fd >= 0)
   15a92: e9 0b fe ff ff               	jmp	0x158a2 <bpf_program__attach_perf_event_opts+0x1e2>
; 		errno = -ret;
   15a97: e8 54 fc fe ff               	callq	0x56f0 <.plt.sec+0x80>
   15a9c: c7 00 02 00 00 00            	movl	$2, (%rax)
   15aa2: 48 89 c3                     	movq	%rax, %rbx
; 		pr_warn("prog '%s': can't attach BPF program w/o FD (did you load it?)\n",
   15aa5: 48 8b 55 00                  	movq	(%rbp), %rdx
   15aa9: 48 8d 35 60 12 02 00         	leaq	135776(%rip), %rsi      # 0x36d10 <strs.2+0x3e80>
   15ab0: 31 ff                        	xorl	%edi, %edi
   15ab2: 31 c0                        	xorl	%eax, %eax
; 		return libbpf_err_ptr(-EINVAL);
   15ab4: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_warn("prog '%s': can't attach BPF program w/o FD (did you load it?)\n",
   15ab7: e8 14 26 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   15abc: c7 03 16 00 00 00            	movl	$22, (%rbx)
; 		return libbpf_err_ptr(-EINVAL);
   15ac2: e9 34 fe ff ff               	jmp	0x158fb <bpf_program__attach_perf_event_opts+0x23b>
; 		errno = -ret;
   15ac7: e8 24 fc fe ff               	callq	0x56f0 <.plt.sec+0x80>
   15acc: c7 00 16 00 00 00            	movl	$22, (%rax)
   15ad2: 48 89 c3                     	movq	%rax, %rbx
   15ad5: eb ce                        	jmp	0x15aa5 <bpf_program__attach_perf_event_opts+0x3e5>
; 	errno = -err;
   15ad7: e8 14 fc fe ff               	callq	0x56f0 <.plt.sec+0x80>
   15adc: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err_ptr(-ENOMEM);
   15ae2: e9 14 fe ff ff               	jmp	0x158fb <bpf_program__attach_perf_event_opts+0x23b>
; }
   15ae7: e8 14 fd fe ff               	callq	0x5800 <.plt.sec+0x190>
   15aec: 0f 1f 40 00                  	nopl	(%rax)

0000000000015af0 <bpf_program__attach_perf_event>:
; {
   15af0: f3 0f 1e fa                  	endbr64
; 	return bpf_program__attach_perf_event_opts(prog, pfd, NULL);
   15af4: 31 d2                        	xorl	%edx, %edx
   15af6: e9 c5 fb ff ff               	jmp	0x156c0 <bpf_program__attach_perf_event_opts>
   15afb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000015b00 <bpf_program__attach_kprobe_opts>:
; {
   15b00: f3 0f 1e fa                  	endbr64
   15b04: 41 57                        	pushq	%r15
   15b06: 41 56                        	pushq	%r14
   15b08: 41 55                        	pushq	%r13
   15b0a: 41 54                        	pushq	%r12
   15b0c: 55                           	pushq	%rbp
   15b0d: 53                           	pushq	%rbx
   15b0e: 48 89 f3                     	movq	%rsi, %rbx
   15b11: 48 81 ec c8 02 00 00         	subq	$712, %rsp              # imm = 0x2C8
   15b18: 48 89 3c 24                  	movq	%rdi, (%rsp)
   15b1c: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   15b25: 48 89 84 24 b8 02 00 00      	movq	%rax, 696(%rsp)
   15b2d: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   15b2f: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	DECLARE_LIBBPF_OPTS(bpf_perf_event_opts, pe_opts);
   15b38: 48 c7 44 24 20 10 00 00 00   	movq	$16, 32(%rsp)
; 	if (!OPTS_VALID(opts, bpf_kprobe_opts))
   15b41: 48 85 d2                     	testq	%rdx, %rdx
   15b44: 0f 84 a8 00 00 00            	je	0x15bf2 <bpf_program__attach_kprobe_opts+0xf2>
   15b4a: 4c 8b 02                     	movq	(%rdx), %r8
; 	if (user_sz < sizeof(size_t)) {
   15b4d: 49 83 f8 07                  	cmpq	$7, %r8
   15b51: 0f 86 f9 03 00 00            	jbe	0x15f50 <bpf_program__attach_kprobe_opts+0x450>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   15b57: 49 8d 48 e7                  	leaq	-25(%r8), %rcx
   15b5b: 48 8d 42 19                  	leaq	25(%rdx), %rax
; 	while (len > 0) {
   15b5f: 48 85 c9                     	testq	%rcx, %rcx
   15b62: 7e 74                        	jle	0x15bd8 <bpf_program__attach_kprobe_opts+0xd8>
   15b64: 4a 8d 0c 02                  	leaq	(%rdx,%r8), %rcx
   15b68: eb 0f                        	jmp	0x15b79 <bpf_program__attach_kprobe_opts+0x79>
   15b6a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		p++;
   15b70: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   15b74: 48 39 c1                     	cmpq	%rax, %rcx
   15b77: 74 5f                        	je	0x15bd8 <bpf_program__attach_kprobe_opts+0xd8>
; 		if (*p)
   15b79: 80 38 00                     	cmpb	$0, (%rax)
   15b7c: 74 f2                        	je	0x15b70 <bpf_program__attach_kprobe_opts+0x70>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   15b7e: 48 8d 15 f3 c5 01 00         	leaq	116211(%rip), %rdx      # 0x32178 <_IO_stdin_used+0x2178>
   15b85: 48 8d 35 84 e4 01 00         	leaq	124036(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   15b8c: 31 ff                        	xorl	%edi, %edi
   15b8e: 31 c0                        	xorl	%eax, %eax
   15b90: e8 3b 25 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   15b95: e8 56 fb fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   15b9a: 45 31 c0                     	xorl	%r8d, %r8d
; 	errno = -err;
   15b9d: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return NULL;
   15ba3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; }
   15ba8: 48 8b 84 24 b8 02 00 00      	movq	696(%rsp), %rax
   15bb0: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   15bb9: 0f 85 15 05 00 00            	jne	0x160d4 <bpf_program__attach_kprobe_opts+0x5d4>
   15bbf: 48 81 c4 c8 02 00 00         	addq	$712, %rsp              # imm = 0x2C8
   15bc6: 4c 89 c0                     	movq	%r8, %rax
   15bc9: 5b                           	popq	%rbx
   15bca: 5d                           	popq	%rbp
   15bcb: 41 5c                        	popq	%r12
   15bcd: 41 5d                        	popq	%r13
   15bcf: 41 5e                        	popq	%r14
   15bd1: 41 5f                        	popq	%r15
   15bd3: c3                           	retq
   15bd4: 0f 1f 40 00                  	nopl	(%rax)
; 	retprobe = OPTS_GET(opts, retprobe, false);
   15bd8: 49 83 f8 18                  	cmpq	$24, %r8
   15bdc: 0f 87 7e 01 00 00            	ja	0x15d60 <bpf_program__attach_kprobe_opts+0x260>
; 	offset = OPTS_GET(opts, offset, 0);
   15be2: 0f 84 04 05 00 00            	je	0x160ec <bpf_program__attach_kprobe_opts+0x5ec>
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   15be8: 49 83 f8 0f                  	cmpq	$15, %r8
   15bec: 0f 87 02 05 00 00            	ja	0x160f4 <bpf_program__attach_kprobe_opts+0x5f4>
; 	offset = OPTS_GET(opts, offset, 0);
   15bf2: 45 31 f6                     	xorl	%r14d, %r14d
   15bf5: 45 31 ed                     	xorl	%r13d, %r13d
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   15bf8: 31 c0                        	xorl	%eax, %eax
; 	return parse_uint_from_file(file, "%d\n");
   15bfa: 4c 8d 3d 43 36 02 00         	leaq	144963(%rip), %r15      # 0x39244 <strs.2+0x63b4>
   15c01: 48 8d 3d e8 d3 01 00         	leaq	119784(%rip), %rdi      # 0x32ff0 <strs.2+0x160>
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   15c08: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	return parse_uint_from_file(file, "%d\n");
   15c0d: 4c 89 fe                     	movq	%r15, %rsi
   15c10: e8 bb 27 ff ff               	callq	0x83d0 <parse_uint_from_file>
   15c15: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	if (!legacy) {
   15c19: 85 c0                        	testl	%eax, %eax
   15c1b: 0f 88 57 01 00 00            	js	0x15d78 <bpf_program__attach_kprobe_opts+0x278>
; 		pfd = perf_event_open_probe(false /* uprobe */, retprobe,
   15c21: 41 0f b6 f5                  	movzbl	%r13b, %esi
   15c25: 45 31 c9                     	xorl	%r9d, %r9d
   15c28: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   15c2e: 4c 89 f1                     	movq	%r14, %rcx
   15c31: 48 89 da                     	movq	%rbx, %rdx
   15c34: 31 ff                        	xorl	%edi, %edi
; 	char *legacy_probe = NULL;
   15c36: 45 31 e4                     	xorl	%r12d, %r12d
; 		pfd = perf_event_open_probe(false /* uprobe */, retprobe,
   15c39: e8 a2 28 ff ff               	callq	0x84e0 <perf_event_open_probe>
   15c3e: 89 c5                        	movl	%eax, %ebp
; 	if (pfd < 0) {
   15c40: 85 ed                        	testl	%ebp, %ebp
   15c42: 0f 88 28 03 00 00            	js	0x15f70 <bpf_program__attach_kprobe_opts+0x470>
; 	link = bpf_program__attach_perf_event_opts(prog, pfd, &pe_opts);
   15c48: 48 8b 3c 24                  	movq	(%rsp), %rdi
   15c4c: 48 8d 54 24 20               	leaq	32(%rsp), %rdx
   15c51: 89 ee                        	movl	%ebp, %esi
   15c53: e8 68 fa ff ff               	callq	0x156c0 <bpf_program__attach_perf_event_opts>
   15c58: 49 89 c0                     	movq	%rax, %r8
; 	if (!IS_ERR_OR_NULL(ptr))
   15c5b: 48 85 c0                     	testq	%rax, %rax
   15c5e: 74 30                        	je	0x15c90 <bpf_program__attach_kprobe_opts+0x190>
   15c60: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   15c66: 77 28                        	ja	0x15c90 <bpf_program__attach_kprobe_opts+0x190>
; 	if (legacy) {
   15c68: 8b 44 24 0c                  	movl	12(%rsp), %eax
   15c6c: 85 c0                        	testl	%eax, %eax
   15c6e: 0f 89 34 ff ff ff            	jns	0x15ba8 <bpf_program__attach_kprobe_opts+0xa8>
; 		perf_link->legacy_probe_name = legacy_probe;
   15c74: 4d 89 60 28                  	movq	%r12, 40(%r8)
; 		perf_link->legacy_is_kprobe = true;
   15c78: 41 c6 40 30 01               	movb	$1, 48(%r8)
; 		perf_link->legacy_is_retprobe = retprobe;
   15c7d: 45 88 68 31                  	movb	%r13b, 49(%r8)
   15c81: e9 22 ff ff ff               	jmp	0x15ba8 <bpf_program__attach_kprobe_opts+0xa8>
   15c86: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   15c90: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
; 	errno = -err;
   15c95: e8 56 fa fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
   15c9a: 4c 8b 44 24 10               	movq	16(%rsp), %r8
; 	errno = -err;
   15c9f: 49 89 c7                     	movq	%rax, %r15
; 	if (IS_ERR(ptr))
   15ca2: 49 81 f8 00 f0 ff ff         	cmpq	$-4096, %r8             # imm = 0xF000
   15ca9: 0f 87 99 00 00 00            	ja	0x15d48 <bpf_program__attach_kprobe_opts+0x248>
; 	return -errno;
   15caf: 44 8b 10                     	movl	(%rax), %r10d
; 	if (err) {
   15cb2: 45 85 d2                     	testl	%r10d, %r10d
   15cb5: 74 b1                        	je	0x15c68 <bpf_program__attach_kprobe_opts+0x168>
; 		close(pfd);
   15cb7: 89 ef                        	movl	%ebp, %edi
   15cb9: 44 89 54 24 10               	movl	%r10d, 16(%rsp)
   15cbe: e8 3d fc fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	return -errno;
   15cc3: 8b 7c 24 10                  	movl	16(%rsp), %edi
; 		pr_warn("prog '%s': failed to attach to %s '%s+0x%zx': %s\n",
   15cc7: ba 80 00 00 00               	movl	$128, %edx
   15ccc: 48 8d b4 24 b0 01 00 00      	leaq	432(%rsp), %rsi
; 	return -errno;
   15cd4: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to attach to %s '%s+0x%zx': %s\n",
   15cd6: e8 f5 7c 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   15cdb: 45 84 ed                     	testb	%r13b, %r13b
   15cde: 4d 89 f1                     	movq	%r14, %r9
   15ce1: 49 89 d8                     	movq	%rbx, %r8
   15ce4: 48 8d 15 18 c0 01 00         	leaq	114712(%rip), %rdx      # 0x31d03 <_IO_stdin_used+0x1d03>
   15ceb: 48 8d 0d 7c c4 01 00         	leaq	115836(%rip), %rcx      # 0x3216e <_IO_stdin_used+0x216e>
   15cf2: 48 0f 44 ca                  	cmoveq	%rdx, %rcx
   15cf6: 48 83 ec 08                  	subq	$8, %rsp
   15cfa: 48 8d 35 d7 12 02 00         	leaq	135895(%rip), %rsi      # 0x36fd8 <strs.2+0x4148>
   15d01: 31 ff                        	xorl	%edi, %edi
   15d03: 50                           	pushq	%rax
   15d04: 48 8b 44 24 10               	movq	16(%rsp), %rax
   15d09: 48 8b 10                     	movq	(%rax), %rdx
   15d0c: 31 c0                        	xorl	%eax, %eax
   15d0e: e8 bd 23 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (legacy)
   15d13: 5a                           	popq	%rdx
   15d14: 59                           	popq	%rcx
   15d15: 8b 74 24 0c                  	movl	12(%rsp), %esi
   15d19: 44 8b 54 24 10               	movl	16(%rsp), %r10d
   15d1e: 85 f6                        	testl	%esi, %esi
   15d20: 0f 88 95 03 00 00            	js	0x160bb <bpf_program__attach_kprobe_opts+0x5bb>
; 	free(legacy_probe);
   15d26: 4c 89 e7                     	movq	%r12, %rdi
   15d29: 44 89 14 24                  	movl	%r10d, (%rsp)
   15d2d: e8 8e f9 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	errno = -err;
   15d32: 44 8b 14 24                  	movl	(%rsp), %r10d
; 	return libbpf_err_ptr(err);
   15d36: 45 31 c0                     	xorl	%r8d, %r8d
; 	errno = -err;
   15d39: 45 89 17                     	movl	%r10d, (%r15)
; 	return libbpf_err_ptr(err);
   15d3c: e9 67 fe ff ff               	jmp	0x15ba8 <bpf_program__attach_kprobe_opts+0xa8>
   15d41: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
   15d48: 45 89 c2                     	movl	%r8d, %r10d
   15d4b: 41 f7 da                     	negl	%r10d
   15d4e: 44 89 10                     	movl	%r10d, (%rax)
   15d51: e9 5c ff ff ff               	jmp	0x15cb2 <bpf_program__attach_kprobe_opts+0x1b2>
   15d56: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	retprobe = OPTS_GET(opts, retprobe, false);
   15d60: 44 0f b6 6a 18               	movzbl	24(%rdx), %r13d
; 	offset = OPTS_GET(opts, offset, 0);
   15d65: 4c 8b 72 10                  	movq	16(%rdx), %r14
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   15d69: 48 8b 42 08                  	movq	8(%rdx), %rax
   15d6d: e9 88 fe ff ff               	jmp	0x15bfa <bpf_program__attach_kprobe_opts+0xfa>
   15d72: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		 __sync_fetch_and_add(&index, 1));
   15d78: bd 01 00 00 00               	movl	$1, %ebp
   15d7d: f0                           	lock
   15d7e: 0f c1 2d 9f 14 03 00         	xaddl	%ebp, 201887(%rip)      # 0x47224 <index.0>
; 	snprintf(buf, buf_sz, "libbpf_%u_%s_0x%zx_%d", getpid(), kfunc_name, offset,
   15d85: e8 16 fa fe ff               	callq	0x57a0 <.plt.sec+0x130>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   15d8a: b9 00 01 00 00               	movl	$256, %ecx              # imm = 0x100
   15d8f: ba 01 00 00 00               	movl	$1, %edx
   15d94: 4c 8d a4 24 b0 00 00 00      	leaq	176(%rsp), %r12
   15d9c: 48 83 ec 08                  	subq	$8, %rsp
; 	snprintf(buf, buf_sz, "libbpf_%u_%s_0x%zx_%d", getpid(), kfunc_name, offset,
   15da0: 41 89 c1                     	movl	%eax, %r9d
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   15da3: 4c 89 e7                     	movq	%r12, %rdi
   15da6: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
   15dab: 55                           	pushq	%rbp
   15dac: 4c 8d 05 7a bf 01 00         	leaq	114554(%rip), %r8       # 0x31d2d <_IO_stdin_used+0x1d2d>
   15db3: 31 c0                        	xorl	%eax, %eax
   15db5: 41 56                        	pushq	%r14
   15db7: 53                           	pushq	%rbx
   15db8: e8 f3 f8 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 		legacy_probe = strdup(probe_name);
   15dbd: 4c 89 e7                     	movq	%r12, %rdi
   15dc0: 48 83 c4 20                  	addq	$32, %rsp
   15dc4: e8 47 fe fe ff               	callq	0x5c10 <.plt.sec+0x5a0>
   15dc9: 49 89 c4                     	movq	%rax, %r12
; 		if (!legacy_probe)
   15dcc: 48 85 c0                     	testq	%rax, %rax
   15dcf: 0f 84 04 03 00 00            	je	0x160d9 <bpf_program__attach_kprobe_opts+0x5d9>
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
   15dd5: 45 84 ed                     	testb	%r13b, %r13b
   15dd8: 48 8d 05 82 be 01 00         	leaq	114306(%rip), %rax      # 0x31c61 <_IO_stdin_used+0x1c61>
   15ddf: 48 8d 0d 86 be 01 00         	leaq	114310(%rip), %rcx      # 0x31c6c <_IO_stdin_used+0x1c6c>
   15de6: 48 0f 45 c8                  	cmovneq	%rax, %rcx
   15dea: 41 80 fd 01                  	cmpb	$1, %r13b
; 	if (has_debugfs < 0)
   15dee: 8b 05 1c 12 03 00            	movl	201244(%rip), %eax      # 0x47010 <has_debugfs.1>
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
   15df4: 19 d2                        	sbbl	%edx, %edx
   15df6: 83 e2 fe                     	andl	$-2, %edx
   15df9: 83 c2 72                     	addl	$114, %edx
; 	if (has_debugfs < 0)
   15dfc: 85 c0                        	testl	%eax, %eax
   15dfe: 0f 88 14 02 00 00            	js	0x16018 <bpf_program__attach_kprobe_opts+0x518>
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
   15e04: 83 f8 01                     	cmpl	$1, %eax
   15e07: 48 8d 3d 8a d0 01 00         	leaq	118922(%rip), %rdi      # 0x32e98 <strs.2+0x8>
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
   15e0e: 49 89 d9                     	movq	%rbx, %r9
   15e11: 4d 89 e0                     	movq	%r12, %r8
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
   15e14: 48 8d 05 a5 d0 01 00         	leaq	118949(%rip), %rax      # 0x32ec0 <strs.2+0x30>
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
   15e1b: 48 8d 35 21 bf 01 00         	leaq	114465(%rip), %rsi      # 0x31d43 <_IO_stdin_used+0x1d43>
; 	return use_debugfs() ? DEBUGFS"/kprobe_events" : TRACEFS"/kprobe_events";
   15e22: 48 0f 45 f8                  	cmovneq	%rax, %rdi
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
   15e26: 48 83 ec 08                  	subq	$8, %rsp
   15e2a: 31 c0                        	xorl	%eax, %eax
   15e2c: 41 56                        	pushq	%r14
   15e2e: 48 89 4c 24 20               	movq	%rcx, 32(%rsp)
   15e33: e8 78 09 ff ff               	callq	0x67b0 <append_to_file>
; 	if (err < 0) {
   15e38: 41 5b                        	popq	%r11
; 	return append_to_file(tracefs_kprobe_events(), "%c:%s/%s %s+0x%zx",
   15e3a: 89 c5                        	movl	%eax, %ebp
; 	if (err < 0) {
   15e3c: 58                           	popq	%rax
   15e3d: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   15e42: 85 ed                        	testl	%ebp, %ebp
   15e44: 0f 88 96 01 00 00            	js	0x15fe0 <bpf_program__attach_kprobe_opts+0x4e0>
; 	if (has_debugfs < 0)
   15e4a: 8b 05 c0 11 03 00            	movl	201152(%rip), %eax      # 0x47010 <has_debugfs.1>
   15e50: 85 c0                        	testl	%eax, %eax
   15e52: 0f 88 38 02 00 00            	js	0x16090 <bpf_program__attach_kprobe_opts+0x590>
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
   15e58: 83 f8 01                     	cmpl	$1, %eax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   15e5b: ba 01 00 00 00               	movl	$1, %edx
   15e60: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
   15e65: 48 8d 05 a9 bf 01 00         	leaq	114601(%rip), %rax      # 0x31e15 <_IO_stdin_used+0x1e15>
   15e6c: 4c 8d 0d 01 be 01 00         	leaq	114177(%rip), %r9       # 0x31c74 <_IO_stdin_used+0x1c74>
   15e73: 4c 0f 45 c8                  	cmovneq	%rax, %r9
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   15e77: 48 8d 84 24 b0 01 00 00      	leaq	432(%rsp), %rax
   15e7f: 4c 8d 05 a3 bf 01 00         	leaq	114595(%rip), %r8       # 0x31e29 <_IO_stdin_used+0x1e29>
   15e86: 48 89 44 24 10               	movq	%rax, 16(%rsp)
   15e8b: 48 89 c5                     	movq	%rax, %rbp
   15e8e: 48 89 c7                     	movq	%rax, %rdi
   15e91: 31 c0                        	xorl	%eax, %eax
   15e93: 41 54                        	pushq	%r12
   15e95: 51                           	pushq	%rcx
   15e96: b9 00 01 00 00               	movl	$256, %ecx              # imm = 0x100
   15e9b: e8 10 f8 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 	return parse_uint_from_file(file, "%d\n");
   15ea0: 48 89 ef                     	movq	%rbp, %rdi
   15ea3: 4c 89 fe                     	movq	%r15, %rsi
   15ea6: e8 25 25 ff ff               	callq	0x83d0 <parse_uint_from_file>
; 	if (type < 0) {
   15eab: 41 59                        	popq	%r9
   15ead: 41 5a                        	popq	%r10
; 	return parse_uint_from_file(file, "%d\n");
   15eaf: 89 c5                        	movl	%eax, %ebp
; 	if (type < 0) {
   15eb1: 85 c0                        	testl	%eax, %eax
   15eb3: 0f 88 97 01 00 00            	js	0x16050 <bpf_program__attach_kprobe_opts+0x550>
;   return __builtin___memset_chk (__dest, __ch, __len,
   15eb9: 48 8d 54 24 40               	leaq	64(%rsp), %rdx
   15ebe: 31 c0                        	xorl	%eax, %eax
   15ec0: b9 0e 00 00 00               	movl	$14, %ecx
; 	attr.config = type;
   15ec5: 4c 63 cd                     	movslq	%ebp, %r9
;   return __builtin___memset_chk (__dest, __ch, __len,
   15ec8: 48 89 d7                     	movq	%rdx, %rdi
; 	attr.config = type;
   15ecb: 4c 89 4c 24 38               	movq	%r9, 56(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   15ed0: 48 8d 74 24 30               	leaq	48(%rsp), %rsi
; 	pfd = syscall(__NR_perf_event_open, &attr,
   15ed5: 41 b9 08 00 00 00            	movl	$8, %r9d
;   return __builtin___memset_chk (__dest, __ch, __len,
   15edb: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	pfd = syscall(__NR_perf_event_open, &attr,
   15ede: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   15ee4: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
; 	attr.type = PERF_TYPE_TRACEPOINT;
   15ee9: 48 b8 02 00 00 00 80 00 00 00	movabsq	$549755813890, %rax     # imm = 0x8000000002
   15ef3: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	pfd = syscall(__NR_perf_event_open, &attr,
   15ef8: bf 2a 01 00 00               	movl	$298, %edi              # imm = 0x12A
   15efd: 31 c0                        	xorl	%eax, %eax
   15eff: e8 dc fa fe ff               	callq	0x59e0 <.plt.sec+0x370>
   15f04: 89 c5                        	movl	%eax, %ebp
; 	if (pfd < 0) {
   15f06: 85 c0                        	testl	%eax, %eax
   15f08: 0f 89 3a fd ff ff            	jns	0x15c48 <bpf_program__attach_kprobe_opts+0x148>
; 		err = -errno;
   15f0e: e8 dd f7 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("legacy kprobe perf_event_open() failed: %s\n",
   15f13: 48 8b 74 24 10               	movq	16(%rsp), %rsi
   15f18: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   15f1d: 44 8b 08                     	movl	(%rax), %r9d
   15f20: 41 f7 d9                     	negl	%r9d
; 		pr_warn("legacy kprobe perf_event_open() failed: %s\n",
   15f23: 44 89 cf                     	movl	%r9d, %edi
; 		err = -errno;
   15f26: 44 89 cd                     	movl	%r9d, %ebp
; 		pr_warn("legacy kprobe perf_event_open() failed: %s\n",
   15f29: e8 a2 7a 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   15f2e: 48 8d 35 23 10 02 00         	leaq	135203(%rip), %rsi      # 0x36f58 <strs.2+0x40c8>
   15f35: 31 ff                        	xorl	%edi, %edi
   15f37: 48 89 c2                     	movq	%rax, %rdx
   15f3a: 31 c0                        	xorl	%eax, %eax
   15f3c: e8 8f 21 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto err_clean_legacy;
   15f41: e9 34 01 00 00               	jmp	0x1607a <bpf_program__attach_kprobe_opts+0x57a>
   15f46: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   15f50: 4c 89 c1                     	movq	%r8, %rcx
   15f53: 48 8d 15 1e c2 01 00         	leaq	115230(%rip), %rdx      # 0x32178 <_IO_stdin_used+0x2178>
   15f5a: 48 8d 35 57 e0 01 00         	leaq	122967(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   15f61: 31 ff                        	xorl	%edi, %edi
   15f63: e8 68 21 ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   15f68: e9 28 fc ff ff               	jmp	0x15b95 <bpf_program__attach_kprobe_opts+0x95>
   15f6d: 0f 1f 00                     	nopl	(%rax)
; 		err = -errno;
   15f70: e8 7b f7 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("prog '%s': failed to create %s '%s+0x%zx' perf event: %s\n",
   15f75: 48 8d b4 24 b0 01 00 00      	leaq	432(%rsp), %rsi
   15f7d: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   15f82: 44 8b 10                     	movl	(%rax), %r10d
   15f85: 49 89 c7                     	movq	%rax, %r15
   15f88: 44 89 d7                     	movl	%r10d, %edi
   15f8b: 44 89 54 24 0c               	movl	%r10d, 12(%rsp)
   15f90: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to create %s '%s+0x%zx' perf event: %s\n",
   15f92: e8 39 7a 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   15f97: 45 84 ed                     	testb	%r13b, %r13b
   15f9a: 49 89 d8                     	movq	%rbx, %r8
   15f9d: 4d 89 f1                     	movq	%r14, %r9
   15fa0: 48 8d 15 5c bd 01 00         	leaq	114012(%rip), %rdx      # 0x31d03 <_IO_stdin_used+0x1d03>
   15fa7: 48 8d 0d c0 c1 01 00         	leaq	115136(%rip), %rcx      # 0x3216e <_IO_stdin_used+0x216e>
   15fae: 48 0f 44 ca                  	cmoveq	%rdx, %rcx
   15fb2: 48 83 ec 08                  	subq	$8, %rsp
   15fb6: 48 8d 35 d3 0f 02 00         	leaq	135123(%rip), %rsi      # 0x36f90 <strs.2+0x4100>
   15fbd: 31 ff                        	xorl	%edi, %edi
   15fbf: 50                           	pushq	%rax
   15fc0: 48 8b 44 24 10               	movq	16(%rsp), %rax
   15fc5: 48 8b 10                     	movq	(%rax), %rdx
   15fc8: 31 c0                        	xorl	%eax, %eax
   15fca: e8 01 21 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto err_out;
   15fcf: 5f                           	popq	%rdi
   15fd0: 41 58                        	popq	%r8
   15fd2: 44 8b 54 24 0c               	movl	12(%rsp), %r10d
   15fd7: e9 4a fd ff ff               	jmp	0x15d26 <bpf_program__attach_kprobe_opts+0x226>
   15fdc: 0f 1f 40 00                  	nopl	(%rax)
; 		pr_warn("failed to add legacy kprobe event for '%s+0x%zx': %s\n",
   15fe0: 48 8d b4 24 b0 01 00 00      	leaq	432(%rsp), %rsi
   15fe8: 89 ef                        	movl	%ebp, %edi
   15fea: ba 80 00 00 00               	movl	$128, %edx
   15fef: e8 dc 79 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   15ff4: 4c 89 f1                     	movq	%r14, %rcx
   15ff7: 48 89 da                     	movq	%rbx, %rdx
   15ffa: 31 ff                        	xorl	%edi, %edi
   15ffc: 49 89 c0                     	movq	%rax, %r8
   15fff: 48 8d 35 ca 0e 02 00         	leaq	134858(%rip), %rsi      # 0x36ed0 <strs.2+0x4040>
   16006: 31 c0                        	xorl	%eax, %eax
   16008: e8 c3 20 ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
   1600d: e9 2e fc ff ff               	jmp	0x15c40 <bpf_program__attach_kprobe_opts+0x140>
   16012: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
   16018: 31 f6                        	xorl	%esi, %esi
   1601a: 48 8d 3d 53 bc 01 00         	leaq	113747(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
   16021: 48 89 4c 24 18               	movq	%rcx, 24(%rsp)
   16026: 89 54 24 10                  	movl	%edx, 16(%rsp)
   1602a: e8 71 fb fe ff               	callq	0x5ba0 <.plt.sec+0x530>
   1602f: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   16034: 8b 54 24 10                  	movl	16(%rsp), %edx
   16038: 85 c0                        	testl	%eax, %eax
   1603a: 0f 94 c0                     	sete	%al
   1603d: 0f b6 c0                     	movzbl	%al, %eax
   16040: 89 05 ca 0f 03 00            	movl	%eax, 200650(%rip)      # 0x47010 <has_debugfs.1>
   16046: e9 b9 fd ff ff               	jmp	0x15e04 <bpf_program__attach_kprobe_opts+0x304>
   1604b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("failed to determine legacy kprobe event id for '%s+0x%zx': %s\n",
   16050: 48 8b 74 24 10               	movq	16(%rsp), %rsi
   16055: ba 80 00 00 00               	movl	$128, %edx
   1605a: 89 c7                        	movl	%eax, %edi
   1605c: e8 6f 79 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   16061: 4c 89 f1                     	movq	%r14, %rcx
   16064: 48 89 da                     	movq	%rbx, %rdx
   16067: 31 ff                        	xorl	%edi, %edi
   16069: 49 89 c0                     	movq	%rax, %r8
   1606c: 48 8d 35 9d 0e 02 00         	leaq	134813(%rip), %rsi      # 0x36f10 <strs.2+0x4080>
   16073: 31 c0                        	xorl	%eax, %eax
   16075: e8 56 20 ff ff               	callq	0x80d0 <libbpf_print>
; 		pfd = perf_event_kprobe_open_legacy(legacy_probe, retprobe, func_name,
   1607a: 41 0f b6 f5                  	movzbl	%r13b, %esi
; 	remove_kprobe_event_legacy(probe_name, retprobe);
   1607e: 4c 89 e7                     	movq	%r12, %rdi
   16081: e8 9a 1b ff ff               	callq	0x7c20 <remove_kprobe_event_legacy>
; 	return err;
   16086: e9 b5 fb ff ff               	jmp	0x15c40 <bpf_program__attach_kprobe_opts+0x140>
   1608b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
   16090: 31 f6                        	xorl	%esi, %esi
   16092: 48 8d 3d db bb 01 00         	leaq	113627(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
   16099: 48 89 4c 24 10               	movq	%rcx, 16(%rsp)
   1609e: e8 fd fa fe ff               	callq	0x5ba0 <.plt.sec+0x530>
   160a3: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   160a8: 85 c0                        	testl	%eax, %eax
   160aa: 0f 94 c0                     	sete	%al
   160ad: 0f b6 c0                     	movzbl	%al, %eax
   160b0: 89 05 5a 0f 03 00            	movl	%eax, 200538(%rip)      # 0x47010 <has_debugfs.1>
   160b6: e9 9d fd ff ff               	jmp	0x15e58 <bpf_program__attach_kprobe_opts+0x358>
; 		remove_kprobe_event_legacy(legacy_probe, retprobe);
   160bb: 41 0f b6 f5                  	movzbl	%r13b, %esi
   160bf: 4c 89 e7                     	movq	%r12, %rdi
   160c2: 44 89 14 24                  	movl	%r10d, (%rsp)
   160c6: e8 55 1b ff ff               	callq	0x7c20 <remove_kprobe_event_legacy>
   160cb: 44 8b 14 24                  	movl	(%rsp), %r10d
   160cf: e9 52 fc ff ff               	jmp	0x15d26 <bpf_program__attach_kprobe_opts+0x226>
; }
   160d4: e8 27 f7 fe ff               	callq	0x5800 <.plt.sec+0x190>
; 	errno = -err;
   160d9: e8 12 f6 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			return libbpf_err_ptr(-ENOMEM);
   160de: 45 31 c0                     	xorl	%r8d, %r8d
; 	errno = -err;
   160e1: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 	return NULL;
   160e7: e9 bc fa ff ff               	jmp	0x15ba8 <bpf_program__attach_kprobe_opts+0xa8>
   160ec: 45 31 ed                     	xorl	%r13d, %r13d
   160ef: e9 71 fc ff ff               	jmp	0x15d65 <bpf_program__attach_kprobe_opts+0x265>
   160f4: 45 31 ed                     	xorl	%r13d, %r13d
; 	offset = OPTS_GET(opts, offset, 0);
   160f7: 45 31 f6                     	xorl	%r14d, %r14d
   160fa: e9 6a fc ff ff               	jmp	0x15d69 <bpf_program__attach_kprobe_opts+0x269>
   160ff: 90                           	nop

0000000000016100 <attach_kprobe>:
; {
   16100: f3 0f 1e fa                  	endbr64
   16104: 41 55                        	pushq	%r13
;   return __builtin___memset_chk (__dest, __ch, __len,
   16106: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	if (strcmp(prog->sec_name, "kprobe") == 0 || strcmp(prog->sec_name, "kretprobe") == 0)
   1610a: 48 8d 35 f2 bb 01 00         	leaq	113650(%rip), %rsi      # 0x31d03 <_IO_stdin_used+0x1d03>
; {
   16111: 41 54                        	pushq	%r12
   16113: 49 89 fc                     	movq	%rdi, %r12
   16116: 55                           	pushq	%rbp
   16117: 48 89 d5                     	movq	%rdx, %rbp
   1611a: 53                           	pushq	%rbx
   1611b: 48 83 ec 48                  	subq	$72, %rsp
; 	if (strcmp(prog->sec_name, "kprobe") == 0 || strcmp(prog->sec_name, "kretprobe") == 0)
   1611f: 48 8b 5f 08                  	movq	8(%rdi), %rbx
; {
   16123: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1612c: 48 89 44 24 38               	movq	%rax, 56(%rsp)
   16131: 31 c0                        	xorl	%eax, %eax
; 	*link = NULL;
   16133: 48 c7 02 00 00 00 00         	movq	$0, (%rdx)
; 	if (strcmp(prog->sec_name, "kprobe") == 0 || strcmp(prog->sec_name, "kretprobe") == 0)
   1613a: 48 89 df                     	movq	%rbx, %rdi
; 	unsigned long offset = 0;
   1613d: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   16145: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	DECLARE_LIBBPF_OPTS(bpf_kprobe_opts, opts);
   1614e: 48 c7 44 24 10 20 00 00 00   	movq	$32, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   16157: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
; 	if (strcmp(prog->sec_name, "kprobe") == 0 || strcmp(prog->sec_name, "kretprobe") == 0)
   1615c: e8 4f f8 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   16161: 85 c0                        	testl	%eax, %eax
   16163: 0f 84 b7 00 00 00            	je	0x16220 <attach_kprobe+0x120>
   16169: 48 8d 35 fe bf 01 00         	leaq	114686(%rip), %rsi      # 0x3216e <_IO_stdin_used+0x216e>
   16170: 48 89 df                     	movq	%rbx, %rdi
   16173: e8 38 f8 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   16178: 85 c0                        	testl	%eax, %eax
   1617a: 0f 84 a0 00 00 00            	je	0x16220 <attach_kprobe+0x120>
; 	opts.retprobe = str_has_pfx(prog->sec_name, "kretprobe/");
   16180: 48 89 df                     	movq	%rbx, %rdi
   16183: ba 0a 00 00 00               	movl	$10, %edx
   16188: 48 8d 35 f9 bf 01 00         	leaq	114681(%rip), %rsi      # 0x32188 <_IO_stdin_used+0x2188>
   1618f: e8 8c f5 fe ff               	callq	0x5720 <.plt.sec+0xb0>
; 		func_name = prog->sec_name + sizeof("kretprobe/") - 1;
   16194: 48 8d 53 0a                  	leaq	10(%rbx), %rdx
; 	n = sscanf(func_name, "%m[a-zA-Z0-9_.]+%li", &func, &offset);
   16198: 48 89 e1                     	movq	%rsp, %rcx
   1619b: 48 8d 35 f1 bf 01 00         	leaq	114673(%rip), %rsi      # 0x32193 <_IO_stdin_used+0x2193>
; 	opts.retprobe = str_has_pfx(prog->sec_name, "kretprobe/");
   161a2: 85 c0                        	testl	%eax, %eax
   161a4: 0f 94 44 24 28               	sete	40(%rsp)
; 		func_name = prog->sec_name + sizeof("kretprobe/") - 1;
   161a9: 48 83 c3 07                  	addq	$7, %rbx
   161ad: 85 c0                        	testl	%eax, %eax
   161af: 48 0f 45 d3                  	cmovneq	%rbx, %rdx
; 	n = sscanf(func_name, "%m[a-zA-Z0-9_.]+%li", &func, &offset);
   161b3: 31 c0                        	xorl	%eax, %eax
; 		func_name = prog->sec_name + sizeof("kretprobe/") - 1;
   161b5: 49 89 d5                     	movq	%rdx, %r13
; 	n = sscanf(func_name, "%m[a-zA-Z0-9_.]+%li", &func, &offset);
   161b8: 48 8d 54 24 08               	leaq	8(%rsp), %rdx
   161bd: 4c 89 ef                     	movq	%r13, %rdi
   161c0: e8 fb f8 fe ff               	callq	0x5ac0 <.plt.sec+0x450>
; 	if (n < 1) {
   161c5: 85 c0                        	testl	%eax, %eax
   161c7: 0f 8e 99 00 00 00            	jle	0x16266 <attach_kprobe+0x166>
; 	if (opts.retprobe && offset != 0) {
   161cd: 80 7c 24 28 00               	cmpb	$0, 40(%rsp)
   161d2: 48 8b 04 24                  	movq	(%rsp), %rax
; 		free(func);
   161d6: 48 8b 74 24 08               	movq	8(%rsp), %rsi
; 	if (opts.retprobe && offset != 0) {
   161db: 74 09                        	je	0x161e6 <attach_kprobe+0xe6>
   161dd: 48 85 c0                     	testq	%rax, %rax
   161e0: 0f 85 9a 00 00 00            	jne	0x16280 <attach_kprobe+0x180>
; 	*link = bpf_program__attach_kprobe_opts(prog, func, &opts);
   161e6: 48 8d 54 24 10               	leaq	16(%rsp), %rdx
   161eb: 4c 89 e7                     	movq	%r12, %rdi
; 	opts.offset = offset;
   161ee: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	*link = bpf_program__attach_kprobe_opts(prog, func, &opts);
   161f3: e8 08 f9 ff ff               	callq	0x15b00 <bpf_program__attach_kprobe_opts>
; 	free(func);
   161f8: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
; 	*link = bpf_program__attach_kprobe_opts(prog, func, &opts);
   161fd: 48 89 45 00                  	movq	%rax, (%rbp)
; 	free(func);
   16201: e8 ba f4 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return libbpf_get_error(*link);
   16206: 48 8b 5d 00                  	movq	(%rbp), %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
   1620a: 48 85 db                     	testq	%rbx, %rbx
   1620d: 74 31                        	je	0x16240 <attach_kprobe+0x140>
   1620f: 31 c0                        	xorl	%eax, %eax
   16211: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   16218: 77 26                        	ja	0x16240 <attach_kprobe+0x140>
   1621a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; }
   16220: 48 8b 54 24 38               	movq	56(%rsp), %rdx
   16225: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   1622e: 75 6f                        	jne	0x1629f <attach_kprobe+0x19f>
   16230: 48 83 c4 48                  	addq	$72, %rsp
   16234: 5b                           	popq	%rbx
   16235: 5d                           	popq	%rbp
   16236: 41 5c                        	popq	%r12
   16238: 41 5d                        	popq	%r13
   1623a: c3                           	retq
   1623b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
   16240: e8 ab f4 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   16245: 48 89 c2                     	movq	%rax, %rdx
; 	if (IS_ERR(ptr))
   16248: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   1624f: 76 0f                        	jbe	0x16260 <attach_kprobe+0x160>
; 		errno = -PTR_ERR(ptr);
   16251: 89 d8                        	movl	%ebx, %eax
   16253: f7 d8                        	negl	%eax
   16255: 89 02                        	movl	%eax, (%rdx)
; 	return -errno;
   16257: f7 d8                        	negl	%eax
   16259: eb c5                        	jmp	0x16220 <attach_kprobe+0x120>
   1625b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   16260: 8b 00                        	movl	(%rax), %eax
   16262: f7 d8                        	negl	%eax
   16264: eb ba                        	jmp	0x16220 <attach_kprobe+0x120>
; 		pr_warn("kprobe name is invalid: %s\n", func_name);
   16266: 31 c0                        	xorl	%eax, %eax
   16268: 4c 89 ea                     	movq	%r13, %rdx
   1626b: 48 8d 35 a6 0d 02 00         	leaq	134566(%rip), %rsi      # 0x37018 <strs.2+0x4188>
   16272: 31 ff                        	xorl	%edi, %edi
   16274: e8 57 1e ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   16279: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   1627e: eb a0                        	jmp	0x16220 <attach_kprobe+0x120>
; 		free(func);
   16280: 48 89 f7                     	movq	%rsi, %rdi
   16283: e8 38 f4 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		pr_warn("kretprobes do not support offset specification\n");
   16288: 31 c0                        	xorl	%eax, %eax
   1628a: 48 8d 35 af 0d 02 00         	leaq	134575(%rip), %rsi      # 0x37040 <strs.2+0x41b0>
   16291: 31 ff                        	xorl	%edi, %edi
   16293: e8 38 1e ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   16298: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   1629d: eb 81                        	jmp	0x16220 <attach_kprobe+0x120>
; }
   1629f: e8 5c f5 fe ff               	callq	0x5800 <.plt.sec+0x190>
   162a4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   162af: 90                           	nop

00000000000162b0 <bpf_program__attach_kprobe>:
; {
   162b0: f3 0f 1e fa                  	endbr64
   162b4: 48 83 ec 38                  	subq	$56, %rsp
   162b8: 41 89 f0                     	movl	%esi, %r8d
;   return __builtin___memset_chk (__dest, __ch, __len,
   162bb: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   162bf: 48 89 d6                     	movq	%rdx, %rsi
   162c2: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   162cb: 48 89 44 24 28               	movq	%rax, 40(%rsp)
   162d0: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   162d2: 48 89 e2                     	movq	%rsp, %rdx
; 	DECLARE_LIBBPF_OPTS(bpf_kprobe_opts, opts,
   162d5: 48 c7 04 24 20 00 00 00      	movq	$32, (%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   162dd: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
   162e6: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
; 	DECLARE_LIBBPF_OPTS(bpf_kprobe_opts, opts,
   162eb: 44 88 44 24 18               	movb	%r8b, 24(%rsp)
; 	return bpf_program__attach_kprobe_opts(prog, func_name, &opts);
   162f0: e8 0b f8 ff ff               	callq	0x15b00 <bpf_program__attach_kprobe_opts>
; }
   162f5: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   162fa: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   16303: 75 05                        	jne	0x1630a <bpf_program__attach_kprobe+0x5a>
   16305: 48 83 c4 38                  	addq	$56, %rsp
   16309: c3                           	retq
   1630a: e8 f1 f4 fe ff               	callq	0x5800 <.plt.sec+0x190>
   1630f: 90                           	nop

0000000000016310 <bpf_program__attach_ksyscall>:
; {
   16310: f3 0f 1e fa                  	endbr64
   16314: 41 55                        	pushq	%r13
;   return __builtin___memset_chk (__dest, __ch, __len,
   16316: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   1631a: 41 54                        	pushq	%r12
   1631c: 49 89 f4                     	movq	%rsi, %r12
   1631f: 55                           	pushq	%rbp
   16320: 48 89 fd                     	movq	%rdi, %rbp
   16323: 53                           	pushq	%rbx
   16324: 48 89 d3                     	movq	%rdx, %rbx
   16327: 48 81 ec b8 00 00 00         	subq	$184, %rsp
   1632e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   16337: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
   1633f: 31 c0                        	xorl	%eax, %eax
; 	LIBBPF_OPTS(bpf_kprobe_opts, kprobe_opts);
   16341: 48 c7 04 24 20 00 00 00      	movq	$32, (%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   16349: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
   16352: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
; 	if (!OPTS_VALID(opts, bpf_ksyscall_opts))
   16357: 48 85 d2                     	testq	%rdx, %rdx
   1635a: 74 5c                        	je	0x163b8 <bpf_program__attach_ksyscall+0xa8>
   1635c: 48 8b 0a                     	movq	(%rdx), %rcx
; 	if (user_sz < sizeof(size_t)) {
   1635f: 48 83 f9 07                  	cmpq	$7, %rcx
   16363: 0f 86 57 01 00 00            	jbe	0x164c0 <bpf_program__attach_ksyscall+0x1b0>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   16369: 48 8d 42 11                  	leaq	17(%rdx), %rax
   1636d: 48 8d 51 ef                  	leaq	-17(%rcx), %rdx
; 	while (len > 0) {
   16371: 48 85 d2                     	testq	%rdx, %rdx
   16374: 7e 42                        	jle	0x163b8 <bpf_program__attach_ksyscall+0xa8>
   16376: 48 01 d9                     	addq	%rbx, %rcx
   16379: eb 0e                        	jmp	0x16389 <bpf_program__attach_ksyscall+0x79>
   1637b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		p++;
   16380: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   16384: 48 39 c8                     	cmpq	%rcx, %rax
   16387: 74 2f                        	je	0x163b8 <bpf_program__attach_ksyscall+0xa8>
; 		if (*p)
   16389: 80 38 00                     	cmpb	$0, (%rax)
   1638c: 74 f2                        	je	0x16380 <bpf_program__attach_ksyscall+0x70>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   1638e: 48 8d 15 12 be 01 00         	leaq	114194(%rip), %rdx      # 0x321a7 <_IO_stdin_used+0x21a7>
   16395: 48 8d 35 74 dc 01 00         	leaq	121972(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   1639c: 31 ff                        	xorl	%edi, %edi
   1639e: 31 c0                        	xorl	%eax, %eax
   163a0: e8 2b 1d ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   163a5: e8 46 f3 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   163aa: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
   163b0: 31 c0                        	xorl	%eax, %eax
   163b2: eb 76                        	jmp	0x1642a <bpf_program__attach_ksyscall+0x11a>
   163b4: 0f 1f 40 00                  	nopl	(%rax)
; 	if (kernel_supports(prog->obj, FEAT_SYSCALL_WRAPPER)) {
   163b8: 48 8b 45 70                  	movq	112(%rbp), %rax
; 	if (obj && obj->gen_loader)
   163bc: 48 85 c0                     	testq	%rax, %rax
   163bf: 0f 84 8b 00 00 00            	je	0x16450 <bpf_program__attach_ksyscall+0x140>
   163c5: 48 83 b8 a0 00 00 00 00      	cmpq	$0, 160(%rax)
   163cd: 0f 84 7d 00 00 00            	je	0x16450 <bpf_program__attach_ksyscall+0x140>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   163d3: 4c 8d 6c 24 20               	leaq	32(%rsp), %r13
   163d8: 48 83 ec 08                  	subq	$8, %rsp
   163dc: 31 c0                        	xorl	%eax, %eax
   163de: ba 01 00 00 00               	movl	$1, %edx
   163e3: 41 54                        	pushq	%r12
   163e5: b9 80 00 00 00               	movl	$128, %ecx
   163ea: be 80 00 00 00               	movl	$128, %esi
   163ef: 4c 89 ef                     	movq	%r13, %rdi
   163f2: 4c 8d 0d 23 b9 01 00         	leaq	112931(%rip), %r9       # 0x31d1c <_IO_stdin_used+0x1d1c>
   163f9: 4c 8d 05 b9 bd 01 00         	leaq	114105(%rip), %r8       # 0x321b9 <_IO_stdin_used+0x21b9>
   16400: e8 ab f2 fe ff               	callq	0x56b0 <.plt.sec+0x40>
   16405: 58                           	popq	%rax
   16406: 5a                           	popq	%rdx
; 	kprobe_opts.retprobe = OPTS_GET(opts, retprobe, false);
   16407: 48 85 db                     	testq	%rbx, %rbx
   1640a: 0f 85 81 00 00 00            	jne	0x16491 <bpf_program__attach_ksyscall+0x181>
   16410: c6 44 24 18 00               	movb	$0, 24(%rsp)
; 	kprobe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   16415: 31 c0                        	xorl	%eax, %eax
; 	return bpf_program__attach_kprobe_opts(prog, func_name, &kprobe_opts);
   16417: 48 89 e2                     	movq	%rsp, %rdx
   1641a: 4c 89 ee                     	movq	%r13, %rsi
   1641d: 48 89 ef                     	movq	%rbp, %rdi
; 	kprobe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   16420: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	return bpf_program__attach_kprobe_opts(prog, func_name, &kprobe_opts);
   16425: e8 d6 f6 ff ff               	callq	0x15b00 <bpf_program__attach_kprobe_opts>
; }
   1642a: 48 8b 94 24 a8 00 00 00      	movq	168(%rsp), %rdx
   16432: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   1643b: 0f 85 99 00 00 00            	jne	0x164da <bpf_program__attach_ksyscall+0x1ca>
   16441: 48 81 c4 b8 00 00 00         	addq	$184, %rsp
   16448: 5b                           	popq	%rbx
   16449: 5d                           	popq	%rbp
   1644a: 41 5c                        	popq	%r12
   1644c: 41 5d                        	popq	%r13
   1644e: c3                           	retq
   1644f: 90                           	nop
   16450: bf 12 00 00 00               	movl	$18, %edi
   16455: e8 f6 3f ff ff               	callq	0xa450 <kernel_supports.part.0>
; 	if (kernel_supports(prog->obj, FEAT_SYSCALL_WRAPPER)) {
   1645a: 84 c0                        	testb	%al, %al
   1645c: 0f 85 71 ff ff ff            	jne	0x163d3 <bpf_program__attach_ksyscall+0xc3>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   16462: 4c 8d 6c 24 20               	leaq	32(%rsp), %r13
   16467: 4d 89 e1                     	movq	%r12, %r9
   1646a: b9 80 00 00 00               	movl	$128, %ecx
   1646f: ba 01 00 00 00               	movl	$1, %edx
   16474: 4c 8d 05 4a bd 01 00         	leaq	113994(%rip), %r8       # 0x321c5 <_IO_stdin_used+0x21c5>
   1647b: be 80 00 00 00               	movl	$128, %esi
   16480: 4c 89 ef                     	movq	%r13, %rdi
   16483: e8 28 f2 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 	kprobe_opts.retprobe = OPTS_GET(opts, retprobe, false);
   16488: 48 85 db                     	testq	%rbx, %rbx
   1648b: 0f 84 7f ff ff ff            	je	0x16410 <bpf_program__attach_ksyscall+0x100>
   16491: 48 83 3b 10                  	cmpq	$16, (%rbx)
   16495: 77 11                        	ja	0x164a8 <bpf_program__attach_ksyscall+0x198>
   16497: c6 44 24 18 00               	movb	$0, 24(%rsp)
; 	kprobe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   1649c: 0f 85 73 ff ff ff            	jne	0x16415 <bpf_program__attach_ksyscall+0x105>
   164a2: eb 0d                        	jmp	0x164b1 <bpf_program__attach_ksyscall+0x1a1>
   164a4: 0f 1f 40 00                  	nopl	(%rax)
; 	kprobe_opts.retprobe = OPTS_GET(opts, retprobe, false);
   164a8: 80 7b 10 00                  	cmpb	$0, 16(%rbx)
   164ac: 0f 95 44 24 18               	setne	24(%rsp)
; 	kprobe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   164b1: 48 8b 43 08                  	movq	8(%rbx), %rax
   164b5: e9 5d ff ff ff               	jmp	0x16417 <bpf_program__attach_ksyscall+0x107>
   164ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   164c0: 48 8d 15 e0 bc 01 00         	leaq	113888(%rip), %rdx      # 0x321a7 <_IO_stdin_used+0x21a7>
   164c7: 48 8d 35 ea da 01 00         	leaq	121578(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   164ce: 31 ff                        	xorl	%edi, %edi
   164d0: e8 fb 1b ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   164d5: e9 cb fe ff ff               	jmp	0x163a5 <bpf_program__attach_ksyscall+0x95>
; }
   164da: e8 21 f3 fe ff               	callq	0x5800 <.plt.sec+0x190>
   164df: 90                           	nop

00000000000164e0 <attach_ksyscall>:
; {
   164e0: f3 0f 1e fa                  	endbr64
   164e4: 41 54                        	pushq	%r12
;   return __builtin___memset_chk (__dest, __ch, __len,
   164e6: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   164ea: 49 89 fc                     	movq	%rdi, %r12
; 	if (strcmp(prog->sec_name, "ksyscall") == 0 || strcmp(prog->sec_name, "kretsyscall") == 0)
   164ed: 48 8d 35 dd bc 01 00         	leaq	113885(%rip), %rsi      # 0x321d1 <_IO_stdin_used+0x21d1>
; {
   164f4: 55                           	pushq	%rbp
   164f5: 48 89 d5                     	movq	%rdx, %rbp
   164f8: 53                           	pushq	%rbx
   164f9: 48 83 ec 20                  	subq	$32, %rsp
; 	if (strcmp(prog->sec_name, "ksyscall") == 0 || strcmp(prog->sec_name, "kretsyscall") == 0)
   164fd: 48 8b 5f 08                  	movq	8(%rdi), %rbx
; {
   16501: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1650a: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1650f: 31 c0                        	xorl	%eax, %eax
; 	*link = NULL;
   16511: 48 c7 02 00 00 00 00         	movq	$0, (%rdx)
; 	if (strcmp(prog->sec_name, "ksyscall") == 0 || strcmp(prog->sec_name, "kretsyscall") == 0)
   16518: 48 89 df                     	movq	%rbx, %rdi
; 	LIBBPF_OPTS(bpf_ksyscall_opts, opts);
   1651b: 48 c7 04 24 18 00 00 00      	movq	$24, (%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   16523: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
; 	if (strcmp(prog->sec_name, "ksyscall") == 0 || strcmp(prog->sec_name, "kretsyscall") == 0)
   16528: e8 83 f4 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   1652d: 85 c0                        	testl	%eax, %eax
   1652f: 74 4e                        	je	0x1657f <attach_ksyscall+0x9f>
   16531: 48 8d 35 a2 bc 01 00         	leaq	113826(%rip), %rsi      # 0x321da <_IO_stdin_used+0x21da>
   16538: 48 89 df                     	movq	%rbx, %rdi
   1653b: e8 70 f4 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   16540: 85 c0                        	testl	%eax, %eax
   16542: 74 3b                        	je	0x1657f <attach_ksyscall+0x9f>
; 	opts.retprobe = str_has_pfx(prog->sec_name, "kretsyscall/");
   16544: ba 0c 00 00 00               	movl	$12, %edx
   16549: 48 8d 35 96 bc 01 00         	leaq	113814(%rip), %rsi      # 0x321e6 <_IO_stdin_used+0x21e6>
   16550: 48 89 df                     	movq	%rbx, %rdi
   16553: e8 c8 f1 fe ff               	callq	0x5720 <.plt.sec+0xb0>
; 		syscall_name = prog->sec_name + sizeof("kretsyscall/") - 1;
   16558: 48 8d 53 0c                  	leaq	12(%rbx), %rdx
   1655c: 48 8d 73 09                  	leaq	9(%rbx), %rsi
; 	*link = bpf_program__attach_ksyscall(prog, syscall_name, &opts);
   16560: 4c 89 e7                     	movq	%r12, %rdi
; 	opts.retprobe = str_has_pfx(prog->sec_name, "kretsyscall/");
   16563: 85 c0                        	testl	%eax, %eax
; 		syscall_name = prog->sec_name + sizeof("kretsyscall/") - 1;
   16565: 48 0f 44 f2                  	cmoveq	%rdx, %rsi
; 	*link = bpf_program__attach_ksyscall(prog, syscall_name, &opts);
   16569: 48 89 e2                     	movq	%rsp, %rdx
; 	opts.retprobe = str_has_pfx(prog->sec_name, "kretsyscall/");
   1656c: 0f 94 44 24 10               	sete	16(%rsp)
; 	*link = bpf_program__attach_ksyscall(prog, syscall_name, &opts);
   16571: e8 9a fd ff ff               	callq	0x16310 <bpf_program__attach_ksyscall>
   16576: 48 89 45 00                  	movq	%rax, (%rbp)
; 	return *link ? 0 : -errno;
   1657a: 48 85 c0                     	testq	%rax, %rax
   1657d: 74 21                        	je	0x165a0 <attach_ksyscall+0xc0>
; 		return 0;
   1657f: 31 c0                        	xorl	%eax, %eax
; }
   16581: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   16586: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   1658f: 75 1a                        	jne	0x165ab <attach_ksyscall+0xcb>
   16591: 48 83 c4 20                  	addq	$32, %rsp
   16595: 5b                           	popq	%rbx
   16596: 5d                           	popq	%rbp
   16597: 41 5c                        	popq	%r12
   16599: c3                           	retq
   1659a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return *link ? 0 : -errno;
   165a0: e8 4b f1 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   165a5: 8b 00                        	movl	(%rax), %eax
   165a7: f7 d8                        	negl	%eax
   165a9: eb d6                        	jmp	0x16581 <attach_ksyscall+0xa1>
; }
   165ab: e8 50 f2 fe ff               	callq	0x5800 <.plt.sec+0x190>

00000000000165b0 <bpf_program__attach_kprobe_multi_opts>:
; {
   165b0: f3 0f 1e fa                  	endbr64
   165b4: 41 55                        	pushq	%r13
; 	LIBBPF_OPTS(bpf_link_create_opts, lopts);
   165b6: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   165ba: 41 54                        	pushq	%r12
   165bc: 55                           	pushq	%rbp
   165bd: 48 89 fd                     	movq	%rdi, %rbp
   165c0: 53                           	pushq	%rbx
   165c1: 48 89 d3                     	movq	%rdx, %rbx
   165c4: 48 81 ec 38 01 00 00         	subq	$312, %rsp              # imm = 0x138
   165cb: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   165d4: 48 89 84 24 28 01 00 00      	movq	%rax, 296(%rsp)
   165dc: 31 c0                        	xorl	%eax, %eax
; 	LIBBPF_OPTS(bpf_link_create_opts, lopts);
   165de: 0f 11 44 24 68               	movups	%xmm0, 104(%rsp)
   165e3: 0f 11 44 24 78               	movups	%xmm0, 120(%rsp)
   165e8: 66 0f 6f 54 24 70            	movdqa	112(%rsp), %xmm2
   165ee: 0f 11 84 24 88 00 00 00      	movups	%xmm0, 136(%rsp)
   165f6: 66 0f 6f 9c 24 80 00 00 00   	movdqa	128(%rsp), %xmm3
   165ff: 48 c7 84 24 98 00 00 00 00 00 00 00  	movq	$0, 152(%rsp)
   1660b: 66 0f 6f a4 24 90 00 00 00   	movdqa	144(%rsp), %xmm4
   16614: 48 c7 44 24 60 40 00 00 00   	movq	$64, 96(%rsp)
   1661d: 66 0f 6f 4c 24 60            	movdqa	96(%rsp), %xmm1
; 	struct kprobe_multi_resolve res = {
   16623: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
   1662c: 48 89 34 24                  	movq	%rsi, (%rsp)
; 	LIBBPF_OPTS(bpf_link_create_opts, lopts);
   16630: 0f 29 4c 24 20               	movaps	%xmm1, 32(%rsp)
   16635: 0f 29 54 24 30               	movaps	%xmm2, 48(%rsp)
   1663a: 0f 29 5c 24 40               	movaps	%xmm3, 64(%rsp)
   1663f: 0f 29 64 24 50               	movaps	%xmm4, 80(%rsp)
; 	struct kprobe_multi_resolve res = {
   16644: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
; 	if (!OPTS_VALID(opts, bpf_kprobe_multi_opts))
   16649: 48 85 d2                     	testq	%rdx, %rdx
   1664c: 0f 84 4e 01 00 00            	je	0x167a0 <bpf_program__attach_kprobe_multi_opts+0x1f0>
   16652: 48 8b 0a                     	movq	(%rdx), %rcx
; 	if (user_sz < sizeof(size_t)) {
   16655: 48 83 f9 07                  	cmpq	$7, %rcx
   16659: 0f 86 d1 01 00 00            	jbe	0x16830 <bpf_program__attach_kprobe_multi_opts+0x280>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   1665f: 48 8d 42 29                  	leaq	41(%rdx), %rax
   16663: 48 8d 51 d7                  	leaq	-41(%rcx), %rdx
; 	while (len > 0) {
   16667: 48 85 d2                     	testq	%rdx, %rdx
   1666a: 7e 44                        	jle	0x166b0 <bpf_program__attach_kprobe_multi_opts+0x100>
   1666c: 48 8d 14 0b                  	leaq	(%rbx,%rcx), %rdx
   16670: eb 0f                        	jmp	0x16681 <bpf_program__attach_kprobe_multi_opts+0xd1>
   16672: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		p++;
   16678: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   1667c: 48 39 c2                     	cmpq	%rax, %rdx
   1667f: 74 2f                        	je	0x166b0 <bpf_program__attach_kprobe_multi_opts+0x100>
; 		if (*p)
   16681: 80 38 00                     	cmpb	$0, (%rax)
   16684: 74 f2                        	je	0x16678 <bpf_program__attach_kprobe_multi_opts+0xc8>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   16686: 48 8d 15 66 bb 01 00         	leaq	113510(%rip), %rdx      # 0x321f3 <_IO_stdin_used+0x21f3>
   1668d: 48 8d 35 7c d9 01 00         	leaq	121212(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   16694: 31 ff                        	xorl	%edi, %edi
   16696: 31 c0                        	xorl	%eax, %eax
   16698: e8 33 1a ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   1669d: e8 4e f0 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   166a2: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   166a5: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
   166ab: e9 c5 00 00 00               	jmp	0x16775 <bpf_program__attach_kprobe_multi_opts+0x1c5>
; 	syms    = OPTS_GET(opts, syms, false);
   166b0: 31 ff                        	xorl	%edi, %edi
   166b2: 48 83 f9 0f                  	cmpq	$15, %rcx
   166b6: 76 04                        	jbe	0x166bc <bpf_program__attach_kprobe_multi_opts+0x10c>
   166b8: 48 8b 7b 08                  	movq	8(%rbx), %rdi
; 	addrs   = OPTS_GET(opts, addrs, false);
   166bc: 48 83 f9 17                  	cmpq	$23, %rcx
   166c0: 0f 87 42 01 00 00            	ja	0x16808 <bpf_program__attach_kprobe_multi_opts+0x258>
   166c6: 49 89 f0                     	movq	%rsi, %r8
   166c9: 31 d2                        	xorl	%edx, %edx
; 	cnt     = OPTS_GET(opts, cnt, false);
   166cb: 48 83 f9 27                  	cmpq	$39, %rcx
   166cf: 0f 86 1b 01 00 00            	jbe	0x167f0 <bpf_program__attach_kprobe_multi_opts+0x240>
   166d5: 48 8b 43 20                  	movq	32(%rbx), %rax
; 	cookies = OPTS_GET(opts, cookies, false);
   166d9: 48 8b 4b 18                  	movq	24(%rbx), %rcx
; 	if (!pattern && !addrs && !syms)
   166dd: 4d 85 c0                     	testq	%r8, %r8
   166e0: 0f 85 72 01 00 00            	jne	0x16858 <bpf_program__attach_kprobe_multi_opts+0x2a8>
   166e6: 48 85 ff                     	testq	%rdi, %rdi
   166e9: 74 b2                        	je	0x1669d <bpf_program__attach_kprobe_multi_opts+0xed>
; 	if (!pattern && !cnt)
   166eb: 48 09 c6                     	orq	%rax, %rsi
   166ee: 74 ad                        	je	0x1669d <bpf_program__attach_kprobe_multi_opts+0xed>
; 	retprobe = OPTS_GET(opts, retprobe, false);
   166f0: 48 83 3b 28                  	cmpq	$40, (%rbx)
   166f4: 0f 87 26 01 00 00            	ja	0x16820 <bpf_program__attach_kprobe_multi_opts+0x270>
; 	lopts.kprobe_multi.flags = retprobe ? BPF_F_KPROBE_MULTI_RETURN : 0;
   166fa: 31 f6                        	xorl	%esi, %esi
; 	lopts.kprobe_multi.syms = syms;
   166fc: 48 89 7c 24 48               	movq	%rdi, 72(%rsp)
; 	link = calloc(1, sizeof(*link));
   16701: bf 01 00 00 00               	movl	$1, %edi
; 	lopts.kprobe_multi.flags = retprobe ? BPF_F_KPROBE_MULTI_RETURN : 0;
   16706: 89 74 24 40                  	movl	%esi, 64(%rsp)
; 	link = calloc(1, sizeof(*link));
   1670a: be 20 00 00 00               	movl	$32, %esi
; 	lopts.kprobe_multi.addrs = addrs;
   1670f: 48 89 54 24 50               	movq	%rdx, 80(%rsp)
; 	lopts.kprobe_multi.cookies = cookies;
   16714: 48 89 4c 24 58               	movq	%rcx, 88(%rsp)
; 	lopts.kprobe_multi.cnt = cnt;
   16719: 89 44 24 44                  	movl	%eax, 68(%rsp)
; 	link = calloc(1, sizeof(*link));
   1671d: e8 6e f2 fe ff               	callq	0x5990 <.plt.sec+0x320>
   16722: 49 89 c4                     	movq	%rax, %r12
; 	if (!link) {
   16725: 48 85 c0                     	testq	%rax, %rax
   16728: 0f 84 02 02 00 00            	je	0x16930 <bpf_program__attach_kprobe_multi_opts+0x380>
; 	link->detach = &bpf_link__detach_fd;
   1672e: 48 8d 05 9b 11 ff ff         	leaq	-61029(%rip), %rax      # 0x78d0 <bpf_link__detach_fd>
   16735: 49 89 04 24                  	movq	%rax, (%r12)
; 	if (!prog)
   16739: 48 85 ed                     	testq	%rbp, %rbp
   1673c: 0f 84 d5 01 00 00            	je	0x16917 <bpf_program__attach_kprobe_multi_opts+0x367>
; 	if (prog->fd < 0)
   16742: 8b 7d 78                     	movl	120(%rbp), %edi
   16745: 85 ff                        	testl	%edi, %edi
   16747: 0f 88 b5 01 00 00            	js	0x16902 <bpf_program__attach_kprobe_multi_opts+0x352>
; 	link_fd = bpf_link_create(prog_fd, 0, BPF_TRACE_KPROBE_MULTI, &lopts);
   1674d: 31 f6                        	xorl	%esi, %esi
   1674f: 48 8d 4c 24 20               	leaq	32(%rsp), %rcx
   16754: ba 2a 00 00 00               	movl	$42, %edx
   16759: e8 f2 15 01 00               	callq	0x27d50 <bpf_link_create>
; 	if (link_fd < 0) {
   1675e: 85 c0                        	testl	%eax, %eax
   16760: 0f 88 4a 01 00 00            	js	0x168b0 <bpf_program__attach_kprobe_multi_opts+0x300>
; 	link->fd = link_fd;
   16766: 41 89 44 24 18               	movl	%eax, 24(%r12)
; 	free(res.addrs);
   1676b: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   16770: e8 4b ef fe ff               	callq	0x56c0 <.plt.sec+0x50>
; }
   16775: 48 8b 84 24 28 01 00 00      	movq	296(%rsp), %rax
   1677d: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   16786: 0f 85 9f 01 00 00            	jne	0x1692b <bpf_program__attach_kprobe_multi_opts+0x37b>
   1678c: 48 81 c4 38 01 00 00         	addq	$312, %rsp              # imm = 0x138
   16793: 4c 89 e0                     	movq	%r12, %rax
   16796: 5b                           	popq	%rbx
   16797: 5d                           	popq	%rbp
   16798: 41 5c                        	popq	%r12
   1679a: 41 5d                        	popq	%r13
   1679c: c3                           	retq
   1679d: 0f 1f 00                     	nopl	(%rax)
; 	if (!pattern && !addrs && !syms)
   167a0: 48 85 f6                     	testq	%rsi, %rsi
   167a3: 0f 84 f4 fe ff ff            	je	0x1669d <bpf_program__attach_kprobe_multi_opts+0xed>
; 		err = libbpf_kallsyms_parse(resolve_kprobe_multi_cb, &res);
   167a9: 48 89 e6                     	movq	%rsp, %rsi
   167ac: 48 8d 3d 3d 0d ff ff         	leaq	-62147(%rip), %rdi      # 0x74f0 <resolve_kprobe_multi_cb>
   167b3: e8 d8 7e ff ff               	callq	0xe690 <libbpf_kallsyms_parse>
   167b8: 41 89 c4                     	movl	%eax, %r12d
; 		if (err)
   167bb: 85 c0                        	testl	%eax, %eax
   167bd: 0f 85 2d 01 00 00            	jne	0x168f0 <bpf_program__attach_kprobe_multi_opts+0x340>
; 		if (!res.cnt) {
   167c3: 48 8b 44 24 18               	movq	24(%rsp), %rax
; 		addrs = res.addrs;
   167c8: 48 8b 54 24 08               	movq	8(%rsp), %rdx
; 		if (!res.cnt) {
   167cd: 48 85 c0                     	testq	%rax, %rax
   167d0: 0f 84 aa 00 00 00            	je	0x16880 <bpf_program__attach_kprobe_multi_opts+0x2d0>
; 	retprobe = OPTS_GET(opts, retprobe, false);
   167d6: 31 ff                        	xorl	%edi, %edi
   167d8: 31 c9                        	xorl	%ecx, %ecx
   167da: 48 85 db                     	testq	%rbx, %rbx
   167dd: 0f 84 17 ff ff ff            	je	0x166fa <bpf_program__attach_kprobe_multi_opts+0x14a>
   167e3: e9 08 ff ff ff               	jmp	0x166f0 <bpf_program__attach_kprobe_multi_opts+0x140>
   167e8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	cnt     = OPTS_GET(opts, cnt, false);
   167f0: 31 c0                        	xorl	%eax, %eax
; 	cookies = OPTS_GET(opts, cookies, false);
   167f2: 48 83 f9 1f                  	cmpq	$31, %rcx
   167f6: 0f 87 dd fe ff ff            	ja	0x166d9 <bpf_program__attach_kprobe_multi_opts+0x129>
   167fc: 31 c9                        	xorl	%ecx, %ecx
   167fe: e9 da fe ff ff               	jmp	0x166dd <bpf_program__attach_kprobe_multi_opts+0x12d>
   16803: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	addrs   = OPTS_GET(opts, addrs, false);
   16808: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1680c: 49 89 f0                     	movq	%rsi, %r8
   1680f: 49 09 d0                     	orq	%rdx, %r8
   16812: e9 b4 fe ff ff               	jmp	0x166cb <bpf_program__attach_kprobe_multi_opts+0x11b>
   16817: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	lopts.kprobe_multi.flags = retprobe ? BPF_F_KPROBE_MULTI_RETURN : 0;
   16820: 0f b6 73 28                  	movzbl	40(%rbx), %esi
   16824: e9 d3 fe ff ff               	jmp	0x166fc <bpf_program__attach_kprobe_multi_opts+0x14c>
   16829: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   16830: 48 8d 15 bc b9 01 00         	leaq	113084(%rip), %rdx      # 0x321f3 <_IO_stdin_used+0x21f3>
   16837: 48 8d 35 7a d7 01 00         	leaq	120698(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   1683e: 31 ff                        	xorl	%edi, %edi
; 		return libbpf_err_ptr(-EINVAL);
   16840: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   16843: e8 88 18 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   16848: e8 a3 ee fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1684d: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return NULL;
   16853: e9 1d ff ff ff               	jmp	0x16775 <bpf_program__attach_kprobe_multi_opts+0x1c5>
; 	if (!pattern && !addrs && !syms)
   16858: 48 85 f6                     	testq	%rsi, %rsi
   1685b: 40 0f 94 c6                  	sete	%sil
; 	if (pattern && (addrs || syms || cookies || cnt))
   1685f: 0f 84 dd 00 00 00            	je	0x16942 <bpf_program__attach_kprobe_multi_opts+0x392>
   16865: 48 09 f9                     	orq	%rdi, %rcx
   16868: 48 09 ca                     	orq	%rcx, %rdx
   1686b: 48 09 c2                     	orq	%rax, %rdx
   1686e: 0f 85 29 fe ff ff            	jne	0x1669d <bpf_program__attach_kprobe_multi_opts+0xed>
   16874: e9 30 ff ff ff               	jmp	0x167a9 <bpf_program__attach_kprobe_multi_opts+0x1f9>
   16879: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	errno = -err;
   16880: e8 6b ee fe ff               	callq	0x56f0 <.plt.sec+0x80>
   16885: bb 02 00 00 00               	movl	$2, %ebx
; 	struct bpf_link *link = NULL;
   1688a: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   1688d: 49 89 c5                     	movq	%rax, %r13
; 	free(link);
   16890: 4c 89 e7                     	movq	%r12, %rdi
; 	return libbpf_err_ptr(err);
   16893: 45 31 e4                     	xorl	%r12d, %r12d
; 	free(link);
   16896: e8 25 ee fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(res.addrs);
   1689b: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   168a0: e8 1b ee fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	errno = -err;
   168a5: 41 89 5d 00                  	movl	%ebx, (%r13)
; 	return libbpf_err_ptr(err);
   168a9: e9 c7 fe ff ff               	jmp	0x16775 <bpf_program__attach_kprobe_multi_opts+0x1c5>
   168ae: 66 90                        	nop
; 		err = -errno;
   168b0: e8 3b ee fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("prog '%s': failed to attach: %s\n",
   168b5: 48 8d b4 24 a0 00 00 00      	leaq	160(%rsp), %rsi
   168bd: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   168c2: 8b 18                        	movl	(%rax), %ebx
   168c4: 49 89 c5                     	movq	%rax, %r13
   168c7: 89 df                        	movl	%ebx, %edi
   168c9: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to attach: %s\n",
   168cb: e8 00 71 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   168d0: 48 8b 55 00                  	movq	(%rbp), %rdx
   168d4: 48 8d 35 05 d7 01 00         	leaq	120581(%rip), %rsi      # 0x33fe0 <strs.2+0x1150>
   168db: 31 ff                        	xorl	%edi, %edi
   168dd: 48 89 c1                     	movq	%rax, %rcx
   168e0: 31 c0                        	xorl	%eax, %eax
   168e2: e8 e9 17 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto error;
   168e7: eb a7                        	jmp	0x16890 <bpf_program__attach_kprobe_multi_opts+0x2e0>
   168e9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	errno = -err;
   168f0: e8 fb ed fe ff               	callq	0x56f0 <.plt.sec+0x80>
   168f5: 44 89 e3                     	movl	%r12d, %ebx
; 	struct bpf_link *link = NULL;
   168f8: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   168fb: 49 89 c5                     	movq	%rax, %r13
   168fe: f7 db                        	negl	%ebx
   16900: eb 8e                        	jmp	0x16890 <bpf_program__attach_kprobe_multi_opts+0x2e0>
; 		errno = -ret;
   16902: e8 e9 ed fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOENT);
   16907: bf fe ff ff ff               	movl	$4294967294, %edi       # imm = 0xFFFFFFFE
; 		errno = -ret;
   1690c: c7 00 02 00 00 00            	movl	$2, (%rax)
   16912: e9 36 fe ff ff               	jmp	0x1674d <bpf_program__attach_kprobe_multi_opts+0x19d>
; 	if (ret < 0)
   16917: bf ea ff ff ff               	movl	$4294967274, %edi       # imm = 0xFFFFFFEA
   1691c: e8 4f 09 ff ff               	callq	0x7270 <libbpf_err.part.0>
; 		return libbpf_err(-EINVAL);
   16921: bf ea ff ff ff               	movl	$4294967274, %edi       # imm = 0xFFFFFFEA
   16926: e9 22 fe ff ff               	jmp	0x1674d <bpf_program__attach_kprobe_multi_opts+0x19d>
; }
   1692b: e8 d0 ee fe ff               	callq	0x5800 <.plt.sec+0x190>
; 	errno = -err;
   16930: e8 bb ed fe ff               	callq	0x56f0 <.plt.sec+0x80>
   16935: bb 0c 00 00 00               	movl	$12, %ebx
   1693a: 49 89 c5                     	movq	%rax, %r13
   1693d: e9 4e ff ff ff               	jmp	0x16890 <bpf_program__attach_kprobe_multi_opts+0x2e0>
; 	if (!pattern && !cnt)
   16942: 48 85 c0                     	testq	%rax, %rax
   16945: 75 09                        	jne	0x16950 <bpf_program__attach_kprobe_multi_opts+0x3a0>
   16947: 40 84 f6                     	testb	%sil, %sil
   1694a: 0f 85 4d fd ff ff            	jne	0x1669d <bpf_program__attach_kprobe_multi_opts+0xed>
; 	if (addrs && syms)
   16950: 48 85 d2                     	testq	%rdx, %rdx
   16953: 0f 84 97 fd ff ff            	je	0x166f0 <bpf_program__attach_kprobe_multi_opts+0x140>
   16959: 48 85 ff                     	testq	%rdi, %rdi
   1695c: 0f 85 3b fd ff ff            	jne	0x1669d <bpf_program__attach_kprobe_multi_opts+0xed>
   16962: e9 89 fd ff ff               	jmp	0x166f0 <bpf_program__attach_kprobe_multi_opts+0x140>
   16967: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000016970 <attach_kprobe_multi>:
; {
   16970: f3 0f 1e fa                  	endbr64
   16974: 41 54                        	pushq	%r12
;   return __builtin___memset_chk (__dest, __ch, __len,
   16976: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   1697a: 49 89 fc                     	movq	%rdi, %r12
; 	if (strcmp(prog->sec_name, "kprobe.multi") == 0 ||
   1697d: 48 8d 35 85 b8 01 00         	leaq	112773(%rip), %rsi      # 0x32209 <_IO_stdin_used+0x2209>
; {
   16984: 55                           	pushq	%rbp
   16985: 48 89 d5                     	movq	%rdx, %rbp
   16988: 53                           	pushq	%rbx
   16989: 48 83 ec 50                  	subq	$80, %rsp
; 	if (strcmp(prog->sec_name, "kprobe.multi") == 0 ||
   1698d: 48 8b 5f 08                  	movq	8(%rdi), %rbx
; {
   16991: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1699a: 48 89 44 24 48               	movq	%rax, 72(%rsp)
   1699f: 31 c0                        	xorl	%eax, %eax
; 	*link = NULL;
   169a1: 48 c7 02 00 00 00 00         	movq	$0, (%rdx)
; 	if (strcmp(prog->sec_name, "kprobe.multi") == 0 ||
   169a8: 48 89 df                     	movq	%rbx, %rdi
;   return __builtin___memset_chk (__dest, __ch, __len,
   169ab: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
   169b0: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
; 	LIBBPF_OPTS(bpf_kprobe_multi_opts, opts);
   169b9: 48 c7 44 24 10 30 00 00 00   	movq	$48, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   169c2: 0f 11 44 24 28               	movups	%xmm0, 40(%rsp)
; 	if (strcmp(prog->sec_name, "kprobe.multi") == 0 ||
   169c7: e8 e4 ef fe ff               	callq	0x59b0 <.plt.sec+0x340>
   169cc: 85 c0                        	testl	%eax, %eax
   169ce: 0f 84 8c 00 00 00            	je	0x16a60 <attach_kprobe_multi+0xf0>
; 	    strcmp(prog->sec_name, "kretprobe.multi") == 0)
   169d4: 48 8d 35 3b b8 01 00         	leaq	112699(%rip), %rsi      # 0x32216 <_IO_stdin_used+0x2216>
   169db: 48 89 df                     	movq	%rbx, %rdi
   169de: e8 cd ef fe ff               	callq	0x59b0 <.plt.sec+0x340>
; 	if (strcmp(prog->sec_name, "kprobe.multi") == 0 ||
   169e3: 85 c0                        	testl	%eax, %eax
   169e5: 74 79                        	je	0x16a60 <attach_kprobe_multi+0xf0>
; 	opts.retprobe = str_has_pfx(prog->sec_name, "kretprobe.multi/");
   169e7: ba 10 00 00 00               	movl	$16, %edx
   169ec: 48 8d 35 33 b8 01 00         	leaq	112691(%rip), %rsi      # 0x32226 <_IO_stdin_used+0x2226>
   169f3: 48 89 df                     	movq	%rbx, %rdi
   169f6: e8 25 ed fe ff               	callq	0x5720 <.plt.sec+0xb0>
; 		spec = prog->sec_name + sizeof("kretprobe.multi/") - 1;
   169fb: 48 8d 53 10                  	leaq	16(%rbx), %rdx
   169ff: 48 8d 7b 0d                  	leaq	13(%rbx), %rdi
; 	opts.retprobe = str_has_pfx(prog->sec_name, "kretprobe.multi/");
   16a03: 85 c0                        	testl	%eax, %eax
; 	n = sscanf(spec, "%m[a-zA-Z0-9_.*?]", &pattern);
   16a05: 48 8d 35 2b b8 01 00         	leaq	112683(%rip), %rsi      # 0x32237 <_IO_stdin_used+0x2237>
; 		spec = prog->sec_name + sizeof("kretprobe.multi/") - 1;
   16a0c: 48 0f 44 fa                  	cmoveq	%rdx, %rdi
; 	opts.retprobe = str_has_pfx(prog->sec_name, "kretprobe.multi/");
   16a10: 0f 94 44 24 38               	sete	56(%rsp)
; 	n = sscanf(spec, "%m[a-zA-Z0-9_.*?]", &pattern);
   16a15: 48 8d 54 24 08               	leaq	8(%rsp), %rdx
   16a1a: 31 c0                        	xorl	%eax, %eax
   16a1c: e8 9f f0 fe ff               	callq	0x5ac0 <.plt.sec+0x450>
; 	if (n < 1) {
   16a21: 85 c0                        	testl	%eax, %eax
   16a23: 0f 8e 7d 00 00 00            	jle	0x16aa6 <attach_kprobe_multi+0x136>
; 	*link = bpf_program__attach_kprobe_multi_opts(prog, pattern, &opts);
   16a29: 48 8b 74 24 08               	movq	8(%rsp), %rsi
   16a2e: 48 8d 54 24 10               	leaq	16(%rsp), %rdx
   16a33: 4c 89 e7                     	movq	%r12, %rdi
   16a36: e8 75 fb ff ff               	callq	0x165b0 <bpf_program__attach_kprobe_multi_opts>
; 	free(pattern);
   16a3b: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
; 	*link = bpf_program__attach_kprobe_multi_opts(prog, pattern, &opts);
   16a40: 48 89 45 00                  	movq	%rax, (%rbp)
; 	free(pattern);
   16a44: e8 77 ec fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return libbpf_get_error(*link);
   16a49: 48 8b 5d 00                  	movq	(%rbp), %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
   16a4d: 48 85 db                     	testq	%rbx, %rbx
   16a50: 74 2e                        	je	0x16a80 <attach_kprobe_multi+0x110>
   16a52: 31 c0                        	xorl	%eax, %eax
   16a54: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   16a5b: 77 23                        	ja	0x16a80 <attach_kprobe_multi+0x110>
   16a5d: 0f 1f 00                     	nopl	(%rax)
; }
   16a60: 48 8b 54 24 48               	movq	72(%rsp), %rdx
   16a65: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   16a6e: 75 52                        	jne	0x16ac2 <attach_kprobe_multi+0x152>
   16a70: 48 83 c4 50                  	addq	$80, %rsp
   16a74: 5b                           	popq	%rbx
   16a75: 5d                           	popq	%rbp
   16a76: 41 5c                        	popq	%r12
   16a78: c3                           	retq
   16a79: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
   16a80: e8 6b ec fe ff               	callq	0x56f0 <.plt.sec+0x80>
   16a85: 48 89 c2                     	movq	%rax, %rdx
; 	if (IS_ERR(ptr))
   16a88: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   16a8f: 76 0f                        	jbe	0x16aa0 <attach_kprobe_multi+0x130>
; 		errno = -PTR_ERR(ptr);
   16a91: 89 d8                        	movl	%ebx, %eax
   16a93: f7 d8                        	negl	%eax
   16a95: 89 02                        	movl	%eax, (%rdx)
; 	return -errno;
   16a97: f7 d8                        	negl	%eax
   16a99: eb c5                        	jmp	0x16a60 <attach_kprobe_multi+0xf0>
   16a9b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   16aa0: 8b 00                        	movl	(%rax), %eax
   16aa2: f7 d8                        	negl	%eax
   16aa4: eb ba                        	jmp	0x16a60 <attach_kprobe_multi+0xf0>
; 		pr_warn("kprobe multi pattern is invalid: %s\n", pattern);
   16aa6: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   16aab: 31 c0                        	xorl	%eax, %eax
   16aad: 48 8d 35 c4 05 02 00         	leaq	132548(%rip), %rsi      # 0x37078 <strs.2+0x41e8>
   16ab4: 31 ff                        	xorl	%edi, %edi
   16ab6: e8 15 16 ff ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   16abb: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   16ac0: eb 9e                        	jmp	0x16a60 <attach_kprobe_multi+0xf0>
; }
   16ac2: e8 39 ed fe ff               	callq	0x5800 <.plt.sec+0x190>
   16ac7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000016ad0 <bpf_program__attach_uprobe_opts>:
; {
   16ad0: f3 0f 1e fa                  	endbr64
   16ad4: 41 57                        	pushq	%r15
   16ad6: 41 56                        	pushq	%r14
   16ad8: 41 55                        	pushq	%r13
   16ada: 41 54                        	pushq	%r12
   16adc: 55                           	pushq	%rbp
   16add: 53                           	pushq	%rbx
   16ade: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   16ae5: 48 83 0c 24 00               	orq	$0, (%rsp)
   16aea: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   16af1: 48 83 0c 24 00               	orq	$0, (%rsp)
   16af6: 48 81 ec 18 04 00 00         	subq	$1048, %rsp             # imm = 0x418
   16afd: 48 89 7c 24 18               	movq	%rdi, 24(%rsp)
   16b02: 49 89 d7                     	movq	%rdx, %r15
   16b05: 4c 89 c3                     	movq	%r8, %rbx
   16b08: 89 74 24 48                  	movl	%esi, 72(%rsp)
   16b0c: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
   16b11: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   16b1a: 48 89 84 24 08 24 00 00      	movq	%rax, 9224(%rsp)
   16b22: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   16b24: 48 c7 84 24 88 00 00 00 00 00 00 00  	movq	$0, 136(%rsp)
; 	DECLARE_LIBBPF_OPTS(bpf_perf_event_opts, pe_opts);
   16b30: 48 c7 84 24 80 00 00 00 10 00 00 00  	movq	$16, 128(%rsp)
; 	if (!OPTS_VALID(opts, bpf_uprobe_opts))
   16b3c: 4d 85 c0                     	testq	%r8, %r8
   16b3f: 0f 84 8b 04 00 00            	je	0x16fd0 <bpf_program__attach_uprobe_opts+0x500>
   16b45: 49 8b 08                     	movq	(%r8), %rcx
; 	if (user_sz < sizeof(size_t)) {
   16b48: 48 83 f9 07                  	cmpq	$7, %rcx
   16b4c: 0f 86 2e 06 00 00            	jbe	0x17180 <bpf_program__attach_uprobe_opts+0x6b0>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   16b52: 48 8d 51 d8                  	leaq	-40(%rcx), %rdx
   16b56: 49 8d 40 28                  	leaq	40(%r8), %rax
; 	while (len > 0) {
   16b5a: 48 85 d2                     	testq	%rdx, %rdx
   16b5d: 7e 41                        	jle	0x16ba0 <bpf_program__attach_uprobe_opts+0xd0>
   16b5f: 49 8d 14 08                  	leaq	(%r8,%rcx), %rdx
   16b63: eb 0c                        	jmp	0x16b71 <bpf_program__attach_uprobe_opts+0xa1>
   16b65: 0f 1f 00                     	nopl	(%rax)
; 		p++;
   16b68: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   16b6c: 48 39 d0                     	cmpq	%rdx, %rax
   16b6f: 74 2f                        	je	0x16ba0 <bpf_program__attach_uprobe_opts+0xd0>
; 		if (*p)
   16b71: 80 38 00                     	cmpb	$0, (%rax)
   16b74: 74 f2                        	je	0x16b68 <bpf_program__attach_uprobe_opts+0x98>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   16b76: 48 8d 15 d6 b6 01 00         	leaq	112342(%rip), %rdx      # 0x32253 <_IO_stdin_used+0x2253>
   16b7d: 48 8d 35 8c d4 01 00         	leaq	119948(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   16b84: 31 ff                        	xorl	%edi, %edi
   16b86: 31 c0                        	xorl	%eax, %eax
   16b88: e8 43 15 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   16b8d: e8 5e eb fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   16b92: 45 31 f6                     	xorl	%r14d, %r14d
; 	errno = -err;
   16b95: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
   16b9b: e9 d3 04 00 00               	jmp	0x17073 <bpf_program__attach_uprobe_opts+0x5a3>
; 	retprobe = OPTS_GET(opts, retprobe, false);
   16ba0: 48 83 f9 18                  	cmpq	$24, %rcx
   16ba4: 0f 87 3e 04 00 00            	ja	0x16fe8 <bpf_program__attach_uprobe_opts+0x518>
; 	ref_ctr_off = OPTS_GET(opts, ref_ctr_offset, 0);
   16baa: c6 44 24 7d 00               	movb	$0, 125(%rsp)
   16baf: 48 83 f9 0f                  	cmpq	$15, %rcx
   16bb3: 0f 87 37 04 00 00            	ja	0x16ff0 <bpf_program__attach_uprobe_opts+0x520>
   16bb9: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   16bc2: 48 83 f9 17                  	cmpq	$23, %rcx
   16bc6: 0f 86 12 04 00 00            	jbe	0x16fde <bpf_program__attach_uprobe_opts+0x50e>
   16bcc: 48 8b 43 10                  	movq	16(%rbx), %rax
   16bd0: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
; 	if (!binary_path)
   16bd8: 4d 85 ff                     	testq	%r15, %r15
   16bdb: 74 b0                        	je	0x16b8d <bpf_program__attach_uprobe_opts+0xbd>
; 	if (!strchr(binary_path, '/')) {
   16bdd: be 2f 00 00 00               	movl	$47, %esi
   16be2: 4c 89 ff                     	movq	%r15, %rdi
   16be5: e8 36 ec fe ff               	callq	0x5820 <.plt.sec+0x1b0>
   16bea: 49 89 c6                     	movq	%rax, %r14
   16bed: 48 85 c0                     	testq	%rax, %rax
   16bf0: 0f 84 32 06 00 00            	je	0x17228 <bpf_program__attach_uprobe_opts+0x758>
; 	func_name = OPTS_GET(opts, func_name, NULL);
   16bf6: 48 85 db                     	testq	%rbx, %rbx
   16bf9: 0f 84 a9 01 00 00            	je	0x16da8 <bpf_program__attach_uprobe_opts+0x2d8>
   16bff: 48 83 3b 27                  	cmpq	$39, (%rbx)
   16c03: 0f 86 9f 01 00 00            	jbe	0x16da8 <bpf_program__attach_uprobe_opts+0x2d8>
   16c09: 48 8b 43 20                  	movq	32(%rbx), %rax
   16c0d: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	if (func_name) {
   16c12: 48 85 c0                     	testq	%rax, %rax
   16c15: 0f 84 8d 01 00 00            	je	0x16da8 <bpf_program__attach_uprobe_opts+0x2d8>
;       return __open_alias (__path, __oflag, __va_arg_pack ());
   16c1b: be 00 00 08 00               	movl	$524288, %esi           # imm = 0x80000
   16c20: 4c 89 ff                     	movq	%r15, %rdi
   16c23: 31 c0                        	xorl	%eax, %eax
; 	int fd, i, sh_types[2] = { SHT_DYNSYM, SHT_SYMTAB };
   16c25: c7 84 24 7c 01 00 00 02 00 00 00     	movl	$2, 380(%rsp)
;       return __open_alias (__path, __oflag, __va_arg_pack ());
   16c30: e8 2b ef fe ff               	callq	0x5b60 <.plt.sec+0x4f0>
   16c35: 89 44 24 4c                  	movl	%eax, 76(%rsp)
; 	if (fd < 0) {
   16c39: 85 c0                        	testl	%eax, %eax
   16c3b: 0f 88 1f 09 00 00            	js	0x17560 <bpf_program__attach_uprobe_opts+0xa90>
; 	elf = elf_begin(fd, ELF_C_READ_MMAP, NULL);
   16c41: 8b 7c 24 4c                  	movl	76(%rsp), %edi
   16c45: 31 d2                        	xorl	%edx, %edx
   16c47: be 01 00 00 00               	movl	$1, %esi
   16c4c: e8 af ee fe ff               	callq	0x5b00 <.plt.sec+0x490>
   16c51: 49 89 c6                     	movq	%rax, %r14
; 	if (!elf) {
   16c54: 48 85 c0                     	testq	%rax, %rax
   16c57: 0f 84 70 0a 00 00            	je	0x176cd <bpf_program__attach_uprobe_opts+0xbfd>
; 	if (!gelf_getehdr(elf, &ehdr)) {
   16c5d: 48 8d 84 24 80 01 00 00      	leaq	384(%rsp), %rax
   16c65: 4c 89 f7                     	movq	%r14, %rdi
   16c68: 48 89 c6                     	movq	%rax, %rsi
   16c6b: 48 89 44 24 58               	movq	%rax, 88(%rsp)
   16c70: e8 1b ea fe ff               	callq	0x5690 <.plt.sec+0x20>
   16c75: 48 85 c0                     	testq	%rax, %rax
   16c78: 0f 84 a9 09 00 00            	je	0x17627 <bpf_program__attach_uprobe_opts+0xb57>
; 	name_len = strlen(name);
   16c7e: 48 8b 5c 24 28               	movq	40(%rsp), %rbx
; 	is_shared_lib = ehdr.e_type == ET_DYN;
   16c83: 0f b7 84 24 90 01 00 00      	movzwl	400(%rsp), %eax
; 		if (!gelf_getshdr(scn, &sh))
   16c8b: 4c 8d ac 24 f0 00 00 00      	leaq	240(%rsp), %r13
; 	name_len = strlen(name);
   16c93: 48 89 df                     	movq	%rbx, %rdi
; 	is_shared_lib = ehdr.e_type == ET_DYN;
   16c96: 66 89 44 24 7e               	movw	%ax, 126(%rsp)
; 	name_len = strlen(name);
   16c9b: e8 40 eb fe ff               	callq	0x57e0 <.plt.sec+0x170>
; 	is_name_qualified = strstr(name, "@@") != NULL;
   16ca0: 48 89 df                     	movq	%rbx, %rdi
   16ca3: 48 8d 35 b9 b5 01 00         	leaq	112057(%rip), %rsi      # 0x32263 <_IO_stdin_used+0x2263>
   16caa: bb 0b 00 00 00               	movl	$11, %ebx
; 	name_len = strlen(name);
   16caf: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 	is_name_qualified = strstr(name, "@@") != NULL;
   16cb4: e8 a7 ef fe ff               	callq	0x5c60 <.plt.sec+0x5f0>
; 			pr_debug("elf: failed to find symbol table ELF sections in '%s'\n",
   16cb9: 4c 89 7c 24 68               	movq	%r15, 104(%rsp)
; 	is_name_qualified = strstr(name, "@@") != NULL;
   16cbe: 48 89 44 24 60               	movq	%rax, 96(%rsp)
; 	for (i = 0; i < ARRAY_SIZE(sh_types); i++) {
   16cc3: 48 8d 84 24 78 01 00 00      	leaq	376(%rsp), %rax
   16ccb: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	long ret = -ENOENT;
   16cd0: 48 c7 44 24 20 fe ff ff ff   	movq	$-2, 32(%rsp)
   16cd9: 31 ed                        	xorl	%ebp, %ebp
   16cdb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	while ((scn = elf_nextscn(elf, scn)) != NULL) {
   16ce0: 48 89 ee                     	movq	%rbp, %rsi
   16ce3: 4c 89 f7                     	movq	%r14, %rdi
   16ce6: e8 a5 ee fe ff               	callq	0x5b90 <.plt.sec+0x520>
   16ceb: 48 89 c5                     	movq	%rax, %rbp
   16cee: 48 85 c0                     	testq	%rax, %rax
   16cf1: 0f 84 a9 08 00 00            	je	0x175a0 <bpf_program__attach_uprobe_opts+0xad0>
; 		if (!gelf_getshdr(scn, &sh))
   16cf7: 4c 89 ee                     	movq	%r13, %rsi
   16cfa: 48 89 ef                     	movq	%rbp, %rdi
   16cfd: e8 de e9 fe ff               	callq	0x56e0 <.plt.sec+0x70>
   16d02: 48 85 c0                     	testq	%rax, %rax
   16d05: 74 d9                        	je	0x16ce0 <bpf_program__attach_uprobe_opts+0x210>
; 		if (sh.sh_type == sh_type)
   16d07: 39 9c 24 f4 00 00 00         	cmpl	%ebx, 244(%rsp)
   16d0e: 75 d0                        	jne	0x16ce0 <bpf_program__attach_uprobe_opts+0x210>
; 		if (!gelf_getshdr(scn, &sh))
   16d10: 48 8d b4 24 b0 00 00 00      	leaq	176(%rsp), %rsi
   16d18: 48 89 ef                     	movq	%rbp, %rdi
   16d1b: e8 c0 e9 fe ff               	callq	0x56e0 <.plt.sec+0x70>
   16d20: 48 85 c0                     	testq	%rax, %rax
   16d23: 0f 85 7f 06 00 00            	jne	0x173a8 <bpf_program__attach_uprobe_opts+0x8d8>
; 	for (i = 0; i < ARRAY_SIZE(sh_types); i++) {
   16d29: 48 83 44 24 30 04            	addq	$4, 48(%rsp)
   16d2f: 48 8b 44 24 30               	movq	48(%rsp), %rax
   16d34: 48 3b 44 24 58               	cmpq	88(%rsp), %rax
   16d39: 0f 84 31 05 00 00            	je	0x17270 <bpf_program__attach_uprobe_opts+0x7a0>
; 		scn = elf_find_next_scn_by_type(elf, sh_types[i], NULL);
   16d3f: 8b 18                        	movl	(%rax), %ebx
   16d41: eb 96                        	jmp	0x16cd9 <bpf_program__attach_uprobe_opts+0x209>
   16d43: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		if (ret > 0)
   16d48: 48 83 7c 24 20 00            	cmpq	$0, 32(%rsp)
   16d4e: 4c 8b 6c 24 70               	movq	112(%rsp), %r13
   16d53: 7e d4                        	jle	0x16d29 <bpf_program__attach_uprobe_opts+0x259>
   16d55: 4c 8b 7c 24 68               	movq	104(%rsp), %r15
; 		pr_debug("elf: symbol address match for '%s' in '%s': 0x%lx\n", name, binary_path,
   16d5a: 4c 8b 44 24 20               	movq	32(%rsp), %r8
   16d5f: 31 c0                        	xorl	%eax, %eax
   16d61: 48 8d 35 d0 04 02 00         	leaq	132304(%rip), %rsi      # 0x37238 <strs.2+0x43a8>
   16d68: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   16d6d: bf 02 00 00 00               	movl	$2, %edi
   16d72: 4c 89 f9                     	movq	%r15, %rcx
   16d75: e8 56 13 ff ff               	callq	0x80d0 <libbpf_print>
; 	elf_end(elf);
   16d7a: 4c 89 f7                     	movq	%r14, %rdi
   16d7d: e8 ae ec fe ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   16d82: 8b 7c 24 4c                  	movl	76(%rsp), %edi
   16d86: e8 75 eb fe ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (sym_off < 0)
   16d8b: 48 83 7c 24 20 00            	cmpq	$0, 32(%rsp)
   16d91: 0f 88 7d 09 00 00            	js	0x17714 <bpf_program__attach_uprobe_opts+0xc44>
; 		func_offset += sym_off;
   16d97: 48 8b 4c 24 20               	movq	32(%rsp), %rcx
   16d9c: 48 01 4c 24 08               	addq	%rcx, 8(%rsp)
   16da1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return parse_uint_from_file(file, "%d\n");
   16da8: 4c 8d 25 95 24 02 00         	leaq	140437(%rip), %r12      # 0x39244 <strs.2+0x63b4>
   16daf: 48 8d 3d 0a c2 01 00         	leaq	115210(%rip), %rdi      # 0x32fc0 <strs.2+0x130>
   16db6: 4c 89 e6                     	movq	%r12, %rsi
   16db9: e8 12 16 ff ff               	callq	0x83d0 <parse_uint_from_file>
   16dbe: 89 c3                        	movl	%eax, %ebx
; 	if (!legacy) {
   16dc0: 85 c0                        	testl	%eax, %eax
   16dc2: 0f 89 38 02 00 00            	jns	0x17000 <bpf_program__attach_uprobe_opts+0x530>
; 		if (ref_ctr_off)
   16dc8: 48 83 7c 24 10 00            	cmpq	$0, 16(%rsp)
   16dce: 0f 85 84 04 00 00            	jne	0x17258 <bpf_program__attach_uprobe_opts+0x788>
; 	snprintf(buf, buf_sz, "libbpf_%u_%s_0x%zx", getpid(), binary_path, (size_t)offset);
   16dd4: e8 c7 e9 fe ff               	callq	0x57a0 <.plt.sec+0x130>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   16dd9: ba 01 00 00 00               	movl	$1, %edx
   16dde: b9 40 10 00 00               	movl	$4160, %ecx             # imm = 0x1040
   16de3: 4c 8d ac 24 c0 13 00 00      	leaq	5056(%rsp), %r13
   16deb: ff 74 24 08                  	pushq	8(%rsp)
; 	snprintf(buf, buf_sz, "libbpf_%u_%s_0x%zx", getpid(), binary_path, (size_t)offset);
   16def: 41 89 c1                     	movl	%eax, %r9d
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   16df2: 4c 8d 05 6d b4 01 00         	leaq	111725(%rip), %r8       # 0x32266 <_IO_stdin_used+0x2266>
   16df9: 31 c0                        	xorl	%eax, %eax
   16dfb: 41 57                        	pushq	%r15
   16dfd: be 40 10 00 00               	movl	$4160, %esi             # imm = 0x1040
   16e02: 4c 89 ef                     	movq	%r13, %rdi
   16e05: e8 a6 e8 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 	for (i = 0; buf[i]; i++) {
   16e0a: 48 0f be ac 24 d0 13 00 00   	movsbq	5072(%rsp), %rbp
   16e13: 58                           	popq	%rax
   16e14: 5a                           	popq	%rdx
   16e15: 40 84 ed                     	testb	%bpl, %bpl
   16e18: 74 25                        	je	0x16e3f <bpf_program__attach_uprobe_opts+0x36f>
; 		if (!isalnum(buf[i]))
   16e1a: e8 61 ee fe ff               	callq	0x5c80 <.plt.sec+0x610>
   16e1f: 48 8b 10                     	movq	(%rax), %rdx
; 	for (i = 0; buf[i]; i++) {
   16e22: 4c 89 e8                     	movq	%r13, %rax
   16e25: 0f 1f 00                     	nopl	(%rax)
; 		if (!isalnum(buf[i]))
   16e28: f6 04 6a 08                  	testb	$8, (%rdx,%rbp,2)
   16e2c: 75 03                        	jne	0x16e31 <bpf_program__attach_uprobe_opts+0x361>
; 			buf[i] = '_';
   16e2e: c6 00 5f                     	movb	$95, (%rax)
; 	for (i = 0; buf[i]; i++) {
   16e31: 48 0f be 68 01               	movsbq	1(%rax), %rbp
   16e36: 48 83 c0 01                  	addq	$1, %rax
   16e3a: 40 84 ed                     	testb	%bpl, %bpl
   16e3d: 75 e9                        	jne	0x16e28 <bpf_program__attach_uprobe_opts+0x358>
; 		legacy_probe = strdup(probe_name);
   16e3f: 4c 89 ef                     	movq	%r13, %rdi
   16e42: e8 c9 ed fe ff               	callq	0x5c10 <.plt.sec+0x5a0>
   16e47: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 		if (!legacy_probe)
   16e4c: 48 85 c0                     	testq	%rax, %rax
   16e4f: 0f 84 af 08 00 00            	je	0x17704 <bpf_program__attach_uprobe_opts+0xc34>
; 	return append_to_file(tracefs_uprobe_events(), "%c:%s/%s %s:0x%zx",
   16e55: 0f b6 4c 24 7d               	movzbl	125(%rsp), %ecx
   16e5a: 48 8d 05 40 ae 01 00         	leaq	110144(%rip), %rax      # 0x31ca1 <_IO_stdin_used+0x1ca1>
   16e61: 4c 8d 2d 2e ae 01 00         	leaq	110126(%rip), %r13      # 0x31c96 <_IO_stdin_used+0x1c96>
   16e68: 84 c9                        	testb	%cl, %cl
   16e6a: 4c 0f 44 e8                  	cmoveq	%rax, %r13
   16e6e: 80 f9 01                     	cmpb	$1, %cl
; 	if (has_debugfs < 0)
   16e71: 8b 05 99 01 03 00            	movl	197017(%rip), %eax      # 0x47010 <has_debugfs.1>
; 	return append_to_file(tracefs_uprobe_events(), "%c:%s/%s %s:0x%zx",
   16e77: 19 d2                        	sbbl	%edx, %edx
   16e79: 83 e2 fe                     	andl	$-2, %edx
   16e7c: 83 c2 72                     	addl	$114, %edx
; 	if (has_debugfs < 0)
   16e7f: 85 c0                        	testl	%eax, %eax
   16e81: 0f 88 f1 04 00 00            	js	0x17378 <bpf_program__attach_uprobe_opts+0x8a8>
; 	return use_debugfs() ? DEBUGFS"/uprobe_events" : TRACEFS"/uprobe_events";
   16e87: 83 f8 01                     	cmpl	$1, %eax
   16e8a: 48 8d 3d 57 c0 01 00         	leaq	114775(%rip), %rdi      # 0x32ee8 <strs.2+0x58>
; 	return append_to_file(tracefs_uprobe_events(), "%c:%s/%s %s:0x%zx",
   16e91: 4d 89 f9                     	movq	%r15, %r9
   16e94: 4c 89 e9                     	movq	%r13, %rcx
; 	return use_debugfs() ? DEBUGFS"/uprobe_events" : TRACEFS"/uprobe_events";
   16e97: 48 8d 05 72 c0 01 00         	leaq	114802(%rip), %rax      # 0x32f10 <strs.2+0x80>
; 	return append_to_file(tracefs_uprobe_events(), "%c:%s/%s %s:0x%zx",
   16e9e: 48 8d 35 d4 b3 01 00         	leaq	111572(%rip), %rsi      # 0x32279 <_IO_stdin_used+0x2279>
; 	return use_debugfs() ? DEBUGFS"/uprobe_events" : TRACEFS"/uprobe_events";
   16ea5: 48 0f 45 f8                  	cmovneq	%rax, %rdi
; 	return append_to_file(tracefs_uprobe_events(), "%c:%s/%s %s:0x%zx",
   16ea9: 48 83 ec 08                  	subq	$8, %rsp
   16ead: 31 c0                        	xorl	%eax, %eax
   16eaf: ff 74 24 10                  	pushq	16(%rsp)
   16eb3: 4c 8b 44 24 20               	movq	32(%rsp), %r8
   16eb8: e8 f3 f8 fe ff               	callq	0x67b0 <append_to_file>
; 	if (err < 0) {
   16ebd: 41 5b                        	popq	%r11
   16ebf: 41 5e                        	popq	%r14
; 	return append_to_file(tracefs_uprobe_events(), "%c:%s/%s %s:0x%zx",
   16ec1: 89 c5                        	movl	%eax, %ebp
; 	if (err < 0) {
   16ec3: 85 c0                        	testl	%eax, %eax
   16ec5: 0f 88 15 04 00 00            	js	0x172e0 <bpf_program__attach_uprobe_opts+0x810>
; 	if (has_debugfs < 0)
   16ecb: 8b 05 3f 01 03 00            	movl	196927(%rip), %eax      # 0x47010 <has_debugfs.1>
   16ed1: 85 c0                        	testl	%eax, %eax
   16ed3: 0f 88 27 03 00 00            	js	0x17200 <bpf_program__attach_uprobe_opts+0x730>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   16ed9: 4c 8d b4 24 c0 01 00 00      	leaq	448(%rsp), %r14
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
   16ee1: 83 f8 01                     	cmpl	$1, %eax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   16ee4: ff 74 24 10                  	pushq	16(%rsp)
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
   16ee8: 48 8d 05 26 af 01 00         	leaq	110374(%rip), %rax      # 0x31e15 <_IO_stdin_used+0x1e15>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   16eef: 41 55                        	pushq	%r13
   16ef1: b9 00 02 00 00               	movl	$512, %ecx              # imm = 0x200
   16ef6: ba 01 00 00 00               	movl	$1, %edx
   16efb: 4c 89 f7                     	movq	%r14, %rdi
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
   16efe: 4c 8d 0d 6f ad 01 00         	leaq	109935(%rip), %r9       # 0x31c74 <_IO_stdin_used+0x1c74>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   16f05: 4c 8d 05 1d af 01 00         	leaq	110365(%rip), %r8       # 0x31e29 <_IO_stdin_used+0x1e29>
   16f0c: be 00 02 00 00               	movl	$512, %esi              # imm = 0x200
; 	return use_debugfs() ? DEBUGFS : TRACEFS;
   16f11: 4c 0f 45 c8                  	cmovneq	%rax, %r9
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   16f15: 31 c0                        	xorl	%eax, %eax
   16f17: e8 94 e7 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 	return parse_uint_from_file(file, "%d\n");
   16f1c: 4c 89 e6                     	movq	%r12, %rsi
   16f1f: 4c 89 f7                     	movq	%r14, %rdi
   16f22: e8 a9 14 ff ff               	callq	0x83d0 <parse_uint_from_file>
; 	if (type < 0) {
   16f27: 41 59                        	popq	%r9
   16f29: 41 5a                        	popq	%r10
; 	return parse_uint_from_file(file, "%d\n");
   16f2b: 89 c5                        	movl	%eax, %ebp
; 	if (type < 0) {
   16f2d: 85 c0                        	testl	%eax, %eax
   16f2f: 0f 88 6b 02 00 00            	js	0x171a0 <bpf_program__attach_uprobe_opts+0x6d0>
;   return __builtin___memset_chk (__dest, __ch, __len,
   16f35: 48 8d 94 24 00 01 00 00      	leaq	256(%rsp), %rdx
   16f3d: 31 c0                        	xorl	%eax, %eax
   16f3f: b9 0e 00 00 00               	movl	$14, %ecx
; 	pfd = syscall(__NR_perf_event_open, &attr,
   16f44: 41 b9 08 00 00 00            	movl	$8, %r9d
;   return __builtin___memset_chk (__dest, __ch, __len,
   16f4a: 48 89 d7                     	movq	%rdx, %rdi
; 	pfd = syscall(__NR_perf_event_open, &attr,
   16f4d: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
;   return __builtin___memset_chk (__dest, __ch, __len,
   16f52: 48 8d b4 24 f0 00 00 00      	leaq	240(%rsp), %rsi
; 	pfd = syscall(__NR_perf_event_open, &attr,
   16f5a: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
;   return __builtin___memset_chk (__dest, __ch, __len,
   16f60: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	attr.config = type;
   16f63: 48 63 c5                     	movslq	%ebp, %rax
; 	pfd = syscall(__NR_perf_event_open, &attr,
   16f66: 31 c9                        	xorl	%ecx, %ecx
   16f68: bf 2a 01 00 00               	movl	$298, %edi              # imm = 0x12A
; 	attr.config = type;
   16f6d: 48 89 84 24 f8 00 00 00      	movq	%rax, 248(%rsp)
; 	attr.type = PERF_TYPE_TRACEPOINT;
   16f75: 48 b8 02 00 00 00 80 00 00 00	movabsq	$549755813890, %rax     # imm = 0x8000000002
   16f7f: 48 89 84 24 f0 00 00 00      	movq	%rax, 240(%rsp)
; 	pfd = syscall(__NR_perf_event_open, &attr,
   16f87: 8b 44 24 48                  	movl	72(%rsp), %eax
   16f8b: 83 f8 ff                     	cmpl	$-1, %eax
   16f8e: 0f 95 c1                     	setne	%cl
   16f91: f7 d9                        	negl	%ecx
   16f93: 85 c0                        	testl	%eax, %eax
   16f95: 0f 49 d0                     	cmovnsl	%eax, %edx
   16f98: 31 c0                        	xorl	%eax, %eax
   16f9a: e8 41 ea fe ff               	callq	0x59e0 <.plt.sec+0x370>
   16f9f: 89 c5                        	movl	%eax, %ebp
; 	if (pfd < 0) {
   16fa1: 85 c0                        	testl	%eax, %eax
   16fa3: 0f 89 8b 00 00 00            	jns	0x17034 <bpf_program__attach_uprobe_opts+0x564>
; 		err = -errno;
   16fa9: e8 42 e7 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("legacy uprobe perf_event_open() failed: %d\n", err);
   16fae: 48 8d 35 b3 03 02 00         	leaq	132019(%rip), %rsi      # 0x37368 <strs.2+0x44d8>
   16fb5: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
   16fb7: 8b 00                        	movl	(%rax), %eax
   16fb9: f7 d8                        	negl	%eax
   16fbb: 89 c5                        	movl	%eax, %ebp
; 		pr_warn("legacy uprobe perf_event_open() failed: %d\n", err);
   16fbd: 89 c2                        	movl	%eax, %edx
   16fbf: 31 c0                        	xorl	%eax, %eax
   16fc1: e8 0a 11 ff ff               	callq	0x80d0 <libbpf_print>
; 		goto err_clean_legacy;
   16fc6: e9 f0 01 00 00               	jmp	0x171bb <bpf_program__attach_uprobe_opts+0x6eb>
   16fcb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	ref_ctr_off = OPTS_GET(opts, ref_ctr_offset, 0);
   16fd0: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
   16fd9: c6 44 24 7d 00               	movb	$0, 125(%rsp)
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   16fde: 31 c0                        	xorl	%eax, %eax
   16fe0: e9 eb fb ff ff               	jmp	0x16bd0 <bpf_program__attach_uprobe_opts+0x100>
   16fe5: 0f 1f 00                     	nopl	(%rax)
; 	retprobe = OPTS_GET(opts, retprobe, false);
   16fe8: 0f b6 43 18                  	movzbl	24(%rbx), %eax
   16fec: 88 44 24 7d                  	movb	%al, 125(%rsp)
; 	ref_ctr_off = OPTS_GET(opts, ref_ctr_offset, 0);
   16ff0: 48 8b 43 08                  	movq	8(%rbx), %rax
   16ff4: 48 89 44 24 10               	movq	%rax, 16(%rsp)
   16ff9: e9 c4 fb ff ff               	jmp	0x16bc2 <bpf_program__attach_uprobe_opts+0xf2>
   16ffe: 66 90                        	nop
; 		pfd = perf_event_open_probe(true /* uprobe */, retprobe, binary_path,
   17000: 0f b6 74 24 7d               	movzbl	125(%rsp), %esi
   17005: 4c 8b 4c 24 10               	movq	16(%rsp), %r9
   1700a: 4c 89 fa                     	movq	%r15, %rdx
   1700d: bf 01 00 00 00               	movl	$1, %edi
   17012: 44 8b 44 24 48               	movl	72(%rsp), %r8d
   17017: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   1701c: e8 bf 14 ff ff               	callq	0x84e0 <perf_event_open_probe>
; 	char errmsg[STRERR_BUFSIZE], *legacy_probe = NULL;
   17021: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 		pfd = perf_event_open_probe(true /* uprobe */, retprobe, binary_path,
   1702a: 89 c5                        	movl	%eax, %ebp
; 	if (pfd < 0) {
   1702c: 85 ed                        	testl	%ebp, %ebp
   1702e: 0f 88 cc 02 00 00            	js	0x17300 <bpf_program__attach_uprobe_opts+0x830>
; 	link = bpf_program__attach_perf_event_opts(prog, pfd, &pe_opts);
   17034: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
   17039: 48 8d 94 24 80 00 00 00      	leaq	128(%rsp), %rdx
   17041: 89 ee                        	movl	%ebp, %esi
   17043: e8 78 e6 ff ff               	callq	0x156c0 <bpf_program__attach_perf_event_opts>
   17048: 49 89 c6                     	movq	%rax, %r14
; 	if (!IS_ERR_OR_NULL(ptr))
   1704b: 48 85 c0                     	testq	%rax, %rax
   1704e: 74 50                        	je	0x170a0 <bpf_program__attach_uprobe_opts+0x5d0>
   17050: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   17056: 77 48                        	ja	0x170a0 <bpf_program__attach_uprobe_opts+0x5d0>
; 	if (legacy) {
   17058: 85 db                        	testl	%ebx, %ebx
   1705a: 79 17                        	jns	0x17073 <bpf_program__attach_uprobe_opts+0x5a3>
; 		perf_link->legacy_probe_name = legacy_probe;
   1705c: 48 8b 44 24 10               	movq	16(%rsp), %rax
; 		perf_link->legacy_is_kprobe = false;
   17061: 41 c6 46 30 00               	movb	$0, 48(%r14)
; 		perf_link->legacy_probe_name = legacy_probe;
   17066: 49 89 46 28                  	movq	%rax, 40(%r14)
; 		perf_link->legacy_is_retprobe = retprobe;
   1706a: 0f b6 44 24 7d               	movzbl	125(%rsp), %eax
   1706f: 41 88 46 31                  	movb	%al, 49(%r14)
; }
   17073: 48 8b 84 24 08 24 00 00      	movq	9224(%rsp), %rax
   1707b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   17084: 0f 85 75 06 00 00            	jne	0x176ff <bpf_program__attach_uprobe_opts+0xc2f>
   1708a: 48 81 c4 18 24 00 00         	addq	$9240, %rsp             # imm = 0x2418
   17091: 4c 89 f0                     	movq	%r14, %rax
   17094: 5b                           	popq	%rbx
   17095: 5d                           	popq	%rbp
   17096: 41 5c                        	popq	%r12
   17098: 41 5d                        	popq	%r13
   1709a: 41 5e                        	popq	%r14
   1709c: 41 5f                        	popq	%r15
   1709e: c3                           	retq
   1709f: 90                           	nop
; 	errno = -err;
   170a0: e8 4b e6 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   170a5: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ptr))
   170a8: 49 81 fe 00 f0 ff ff         	cmpq	$-4096, %r14            # imm = 0xF000
   170af: 0f 87 b3 00 00 00            	ja	0x17168 <bpf_program__attach_uprobe_opts+0x698>
; 	return -errno;
   170b5: 44 8b 28                     	movl	(%rax), %r13d
; 	if (err) {
   170b8: 45 85 ed                     	testl	%r13d, %r13d
   170bb: 74 9b                        	je	0x17058 <bpf_program__attach_uprobe_opts+0x588>
; 		close(pfd);
   170bd: 89 ef                        	movl	%ebp, %edi
   170bf: e8 3c e8 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	return -errno;
   170c4: 44 89 ef                     	movl	%r13d, %edi
; 		pr_warn("prog '%s': failed to attach to %s '%s:0x%zx': %s\n",
   170c7: ba 80 00 00 00               	movl	$128, %edx
   170cc: 48 8d b4 24 c0 13 00 00      	leaq	5056(%rsp), %rsi
; 	return -errno;
   170d4: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to attach to %s '%s:0x%zx': %s\n",
   170d6: e8 f5 68 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   170db: 80 7c 24 7d 00               	cmpb	$0, 125(%rsp)
   170e0: 0f 85 37 04 00 00            	jne	0x1751d <bpf_program__attach_uprobe_opts+0xa4d>
   170e6: 48 83 ec 08                  	subq	$8, %rsp
   170ea: 48 8d 0d 19 ac 01 00         	leaq	109593(%rip), %rcx      # 0x31d0a <_IO_stdin_used+0x1d0a>
   170f1: 4d 89 f8                     	movq	%r15, %r8
   170f4: 31 ff                        	xorl	%edi, %edi
   170f6: 50                           	pushq	%rax
   170f7: 48 8b 44 24 28               	movq	40(%rsp), %rax
   170fc: 48 8d 35 e5 02 02 00         	leaq	131813(%rip), %rsi      # 0x373e8 <strs.2+0x4558>
   17103: 4c 8b 4c 24 18               	movq	24(%rsp), %r9
   17108: 48 8b 10                     	movq	(%rax), %rdx
   1710b: 31 c0                        	xorl	%eax, %eax
   1710d: e8 be 0f ff ff               	callq	0x80d0 <libbpf_print>
; 	if (legacy)
   17112: 59                           	popq	%rcx
   17113: 5e                           	popq	%rsi
   17114: 85 db                        	testl	%ebx, %ebx
   17116: 0f 89 45 02 00 00            	jns	0x17361 <bpf_program__attach_uprobe_opts+0x891>
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
   1711c: 4c 8d 35 7e ab 01 00         	leaq	109438(%rip), %r14      # 0x31ca1 <_IO_stdin_used+0x1ca1>
; 	if (has_debugfs < 0)
   17123: 8b 05 e7 fe 02 00            	movl	196327(%rip), %eax      # 0x47010 <has_debugfs.1>
   17129: 85 c0                        	testl	%eax, %eax
   1712b: 0f 88 51 05 00 00            	js	0x17682 <bpf_program__attach_uprobe_opts+0xbb2>
; 	return use_debugfs() ? DEBUGFS"/uprobe_events" : TRACEFS"/uprobe_events";
   17131: 83 f8 01                     	cmpl	$1, %eax
   17134: 48 8d 3d ad bd 01 00         	leaq	114093(%rip), %rdi      # 0x32ee8 <strs.2+0x58>
   1713b: 48 8d 05 ce bd 01 00         	leaq	114126(%rip), %rax      # 0x32f10 <strs.2+0x80>
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
   17142: 4c 89 f2                     	movq	%r14, %rdx
; 	return use_debugfs() ? DEBUGFS"/uprobe_events" : TRACEFS"/uprobe_events";
   17145: 48 0f 45 f8                  	cmovneq	%rax, %rdi
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
   17149: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   1714e: 48 8d 35 39 ab 01 00         	leaq	109369(%rip), %rsi      # 0x31c8e <_IO_stdin_used+0x1c8e>
   17155: 31 c0                        	xorl	%eax, %eax
   17157: e8 54 f6 fe ff               	callq	0x67b0 <append_to_file>
   1715c: e9 00 02 00 00               	jmp	0x17361 <bpf_program__attach_uprobe_opts+0x891>
   17161: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
   17168: 45 89 f5                     	movl	%r14d, %r13d
   1716b: 41 f7 dd                     	negl	%r13d
   1716e: 44 89 28                     	movl	%r13d, (%rax)
   17171: e9 42 ff ff ff               	jmp	0x170b8 <bpf_program__attach_uprobe_opts+0x5e8>
   17176: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   17180: 48 8d 15 cc b0 01 00         	leaq	110796(%rip), %rdx      # 0x32253 <_IO_stdin_used+0x2253>
   17187: 48 8d 35 2a ce 01 00         	leaq	118314(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   1718e: 31 ff                        	xorl	%edi, %edi
   17190: e8 3b 0f ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   17195: e9 f3 f9 ff ff               	jmp	0x16b8d <bpf_program__attach_uprobe_opts+0xbd>
   1719a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("failed to determine legacy uprobe event id for %s:0x%zx: %d\n",
   171a0: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   171a5: 41 89 c0                     	movl	%eax, %r8d
   171a8: 4c 89 fa                     	movq	%r15, %rdx
   171ab: 31 ff                        	xorl	%edi, %edi
   171ad: 48 8d 35 6c 01 02 00         	leaq	131436(%rip), %rsi      # 0x37320 <strs.2+0x4490>
   171b4: 31 c0                        	xorl	%eax, %eax
   171b6: e8 15 0f ff ff               	callq	0x80d0 <libbpf_print>
; 	if (has_debugfs < 0)
   171bb: 8b 05 4f fe 02 00            	movl	196175(%rip), %eax      # 0x47010 <has_debugfs.1>
   171c1: 85 c0                        	testl	%eax, %eax
   171c3: 0f 88 f4 03 00 00            	js	0x175bd <bpf_program__attach_uprobe_opts+0xaed>
; 	return use_debugfs() ? DEBUGFS"/uprobe_events" : TRACEFS"/uprobe_events";
   171c9: 83 f8 01                     	cmpl	$1, %eax
   171cc: 48 8d 3d 15 bd 01 00         	leaq	113941(%rip), %rdi      # 0x32ee8 <strs.2+0x58>
   171d3: 48 8d 05 36 bd 01 00         	leaq	113974(%rip), %rax      # 0x32f10 <strs.2+0x80>
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
   171da: 4c 89 ea                     	movq	%r13, %rdx
; 	return use_debugfs() ? DEBUGFS"/uprobe_events" : TRACEFS"/uprobe_events";
   171dd: 48 0f 45 f8                  	cmovneq	%rax, %rdi
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
   171e1: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   171e6: 48 8d 35 a1 aa 01 00         	leaq	109217(%rip), %rsi      # 0x31c8e <_IO_stdin_used+0x1c8e>
   171ed: 31 c0                        	xorl	%eax, %eax
   171ef: e8 bc f5 fe ff               	callq	0x67b0 <append_to_file>
   171f4: e9 33 fe ff ff               	jmp	0x1702c <bpf_program__attach_uprobe_opts+0x55c>
   171f9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
   17200: 31 f6                        	xorl	%esi, %esi
   17202: 48 8d 3d 6b aa 01 00         	leaq	109163(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
   17209: e8 92 e9 fe ff               	callq	0x5ba0 <.plt.sec+0x530>
   1720e: 85 c0                        	testl	%eax, %eax
   17210: 0f 94 c0                     	sete	%al
   17213: 0f b6 c0                     	movzbl	%al, %eax
   17216: 89 05 f4 fd 02 00            	movl	%eax, 196084(%rip)      # 0x47010 <has_debugfs.1>
   1721c: e9 b8 fc ff ff               	jmp	0x16ed9 <bpf_program__attach_uprobe_opts+0x409>
   17221: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		err = resolve_full_path(binary_path, full_binary_path,
   17228: 4c 8d a4 24 c0 03 00 00      	leaq	960(%rsp), %r12
   17230: ba 00 10 00 00               	movl	$4096, %edx             # imm = 0x1000
   17235: 4c 89 ff                     	movq	%r15, %rdi
   17238: 4c 89 e6                     	movq	%r12, %rsi
   1723b: e8 50 2c ff ff               	callq	0x9e90 <resolve_full_path>
   17240: 89 c5                        	movl	%eax, %ebp
; 		if (err) {
   17242: 85 c0                        	testl	%eax, %eax
   17244: 0f 85 b1 03 00 00            	jne	0x175fb <bpf_program__attach_uprobe_opts+0xb2b>
; 		binary_path = full_binary_path;
   1724a: 4d 89 e7                     	movq	%r12, %r15
   1724d: e9 a4 f9 ff ff               	jmp	0x16bf6 <bpf_program__attach_uprobe_opts+0x126>
   17252: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	errno = -err;
   17258: e8 93 e4 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1725d: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return libbpf_err_ptr(err);
   17263: 45 31 f6                     	xorl	%r14d, %r14d
   17266: e9 08 fe ff ff               	jmp	0x17073 <bpf_program__attach_uprobe_opts+0x5a3>
   1726b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		if (ret == 0) {
   17270: 48 83 7c 24 20 00            	cmpq	$0, 32(%rsp)
   17276: 4c 8b 7c 24 68               	movq	104(%rsp), %r15
   1727b: 0f 85 5d 03 00 00            	jne	0x175de <bpf_program__attach_uprobe_opts+0xb0e>
; 			pr_warn("elf: '%s' is 0 in symtab for '%s': %s\n", name, binary_path,
   17281: 66 83 7c 24 7e 03            	cmpw	$3, 126(%rsp)
   17287: 48 8d 05 42 fe 01 00         	leaq	130626(%rip), %rax      # 0x370d0 <strs.2+0x4240>
   1728e: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   17293: 4c 89 f9                     	movq	%r15, %rcx
   17296: 4c 8d 05 0b fe 01 00         	leaq	130571(%rip), %r8       # 0x370a8 <strs.2+0x4218>
   1729d: 48 8d 35 d4 ff 01 00         	leaq	131028(%rip), %rsi      # 0x37278 <strs.2+0x43e8>
   172a4: 4c 0f 45 c0                  	cmovneq	%rax, %r8
   172a8: 31 ff                        	xorl	%edi, %edi
   172aa: 31 c0                        	xorl	%eax, %eax
   172ac: e8 1f 0e ff ff               	callq	0x80d0 <libbpf_print>
; 	elf_end(elf);
   172b1: 4c 89 f7                     	movq	%r14, %rdi
   172b4: 41 be 02 00 00 00            	movl	$2, %r14d
   172ba: e8 71 e7 fe ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   172bf: 8b 7c 24 4c                  	movl	76(%rsp), %edi
   172c3: e8 38 e6 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	errno = -err;
   172c8: e8 23 e4 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   172cd: 44 89 30                     	movl	%r14d, (%rax)
; 			return libbpf_err_ptr(sym_off);
   172d0: 45 31 f6                     	xorl	%r14d, %r14d
   172d3: e9 9b fd ff ff               	jmp	0x17073 <bpf_program__attach_uprobe_opts+0x5a3>
   172d8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		pr_warn("failed to add legacy uprobe event for %s:0x%zx: %d\n",
   172e0: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   172e5: 41 89 c0                     	movl	%eax, %r8d
   172e8: 4c 89 fa                     	movq	%r15, %rdx
   172eb: 31 ff                        	xorl	%edi, %edi
   172ed: 48 8d 35 ec ff 01 00         	leaq	131052(%rip), %rsi      # 0x372e0 <strs.2+0x4450>
   172f4: 31 c0                        	xorl	%eax, %eax
   172f6: e8 d5 0d ff ff               	callq	0x80d0 <libbpf_print>
; 		return err;
   172fb: e9 2c fd ff ff               	jmp	0x1702c <bpf_program__attach_uprobe_opts+0x55c>
; 		err = -errno;
   17300: e8 eb e3 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("prog '%s': failed to create %s '%s:0x%zx' perf event: %s\n",
   17305: 48 8d b4 24 c0 13 00 00      	leaq	5056(%rsp), %rsi
   1730d: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   17312: 44 8b 28                     	movl	(%rax), %r13d
   17315: 49 89 c4                     	movq	%rax, %r12
   17318: 44 89 ef                     	movl	%r13d, %edi
   1731b: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to create %s '%s:0x%zx' perf event: %s\n",
   1731d: e8 ae 66 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   17322: 80 7c 24 7d 00               	cmpb	$0, 125(%rsp)
   17327: 48 8d 15 dc a9 01 00         	leaq	109020(%rip), %rdx      # 0x31d0a <_IO_stdin_used+0x1d0a>
   1732e: 48 8d 0d 14 af 01 00         	leaq	110356(%rip), %rcx      # 0x32249 <_IO_stdin_used+0x2249>
   17335: 48 0f 44 ca                  	cmoveq	%rdx, %rcx
   17339: 48 83 ec 08                  	subq	$8, %rsp
   1733d: 4d 89 f8                     	movq	%r15, %r8
   17340: 31 ff                        	xorl	%edi, %edi
   17342: 50                           	pushq	%rax
   17343: 48 8b 44 24 28               	movq	40(%rsp), %rax
   17348: 48 8d 35 51 00 02 00         	leaq	131153(%rip), %rsi      # 0x373a0 <strs.2+0x4510>
   1734f: 4c 8b 4c 24 18               	movq	24(%rsp), %r9
   17354: 48 8b 10                     	movq	(%rax), %rdx
   17357: 31 c0                        	xorl	%eax, %eax
   17359: e8 72 0d ff ff               	callq	0x80d0 <libbpf_print>
; 		goto err_out;
   1735e: 5f                           	popq	%rdi
   1735f: 41 58                        	popq	%r8
; 	free(legacy_probe);
   17361: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   17366: e8 55 e3 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	errno = -err;
   1736b: 45 89 2c 24                  	movl	%r13d, (%r12)
   1736f: e9 ef fe ff ff               	jmp	0x17263 <bpf_program__attach_uprobe_opts+0x793>
   17374: 0f 1f 40 00                  	nopl	(%rax)
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
   17378: 31 f6                        	xorl	%esi, %esi
   1737a: 48 8d 3d f3 a8 01 00         	leaq	108787(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
   17381: 89 54 24 20                  	movl	%edx, 32(%rsp)
   17385: e8 16 e8 fe ff               	callq	0x5ba0 <.plt.sec+0x530>
   1738a: 8b 54 24 20                  	movl	32(%rsp), %edx
   1738e: 85 c0                        	testl	%eax, %eax
   17390: 0f 94 c0                     	sete	%al
   17393: 0f b6 c0                     	movzbl	%al, %eax
   17396: 89 05 74 fc 02 00            	movl	%eax, 195700(%rip)      # 0x47010 <has_debugfs.1>
   1739c: e9 e6 fa ff ff               	jmp	0x16e87 <bpf_program__attach_uprobe_opts+0x3b7>
   173a1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		strtabidx = sh.sh_link;
   173a8: 8b 84 24 d8 00 00 00         	movl	216(%rsp), %eax
; 		symbols = elf_getdata(scn, 0);
   173af: 48 89 ef                     	movq	%rbp, %rdi
   173b2: 31 f6                        	xorl	%esi, %esi
; 		strtabidx = sh.sh_link;
   173b4: 48 89 44 24 50               	movq	%rax, 80(%rsp)
; 		symbols = elf_getdata(scn, 0);
   173b9: e8 82 e5 fe ff               	callq	0x5940 <.plt.sec+0x2d0>
   173be: 48 89 c5                     	movq	%rax, %rbp
; 		if (!symbols) {
   173c1: 48 85 c0                     	testq	%rax, %rax
   173c4: 0f 84 d9 02 00 00            	je	0x176a3 <bpf_program__attach_uprobe_opts+0xbd3>
; 		nr_syms = symbols->d_size / sh.sh_entsize;
   173ca: 48 8b 70 10                  	movq	16(%rax), %rsi
   173ce: 48 8b 8c 24 e8 00 00 00      	movq	232(%rsp), %rcx
   173d6: 31 d2                        	xorl	%edx, %edx
   173d8: 48 89 f0                     	movq	%rsi, %rax
   173db: 48 f7 f1                     	divq	%rcx
   173de: 49 89 c7                     	movq	%rax, %r15
; 		for (idx = 0; idx < nr_syms; idx++) {
   173e1: 48 39 ce                     	cmpq	%rcx, %rsi
   173e4: 0f 82 3f f9 ff ff            	jb	0x16d29 <bpf_program__attach_uprobe_opts+0x259>
   173ea: 4c 89 6c 24 70               	movq	%r13, 112(%rsp)
   173ef: 31 db                        	xorl	%ebx, %ebx
   173f1: 4c 8d a4 24 90 00 00 00      	leaq	144(%rsp), %r12
; 		int last_bind = -1;
   173f9: c7 44 24 78 ff ff ff ff      	movl	$4294967295, 120(%rsp)  # imm = 0xFFFFFFFF
   17401: eb 12                        	jmp	0x17415 <bpf_program__attach_uprobe_opts+0x945>
   17403: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		for (idx = 0; idx < nr_syms; idx++) {
   17408: 48 83 c3 01                  	addq	$1, %rbx
   1740c: 49 39 df                     	cmpq	%rbx, %r15
   1740f: 0f 86 33 f9 ff ff            	jbe	0x16d48 <bpf_program__attach_uprobe_opts+0x278>
; 			if (!gelf_getsym(symbols, idx, &sym))
   17415: 4c 89 e2                     	movq	%r12, %rdx
   17418: 89 de                        	movl	%ebx, %esi
   1741a: 48 89 ef                     	movq	%rbp, %rdi
   1741d: e8 1e e4 fe ff               	callq	0x5840 <.plt.sec+0x1d0>
   17422: 48 85 c0                     	testq	%rax, %rax
   17425: 74 e1                        	je	0x17408 <bpf_program__attach_uprobe_opts+0x938>
; 			if (GELF_ST_TYPE(sym.st_info) != STT_FUNC)
   17427: 0f b6 84 24 94 00 00 00      	movzbl	148(%rsp), %eax
   1742f: 83 e0 0f                     	andl	$15, %eax
   17432: 3c 02                        	cmpb	$2, %al
   17434: 75 d2                        	jne	0x17408 <bpf_program__attach_uprobe_opts+0x938>
; 			sname = elf_strptr(elf, strtabidx, sym.st_name);
   17436: 8b 94 24 90 00 00 00         	movl	144(%rsp), %edx
   1743d: 48 8b 74 24 50               	movq	80(%rsp), %rsi
   17442: 4c 89 f7                     	movq	%r14, %rdi
   17445: e8 26 e4 fe ff               	callq	0x5870 <.plt.sec+0x200>
; 			if (!sname)
   1744a: 48 85 c0                     	testq	%rax, %rax
   1744d: 74 b9                        	je	0x17408 <bpf_program__attach_uprobe_opts+0x938>
; 			if (strncmp(sname, name, name_len) != 0)
   1744f: 48 8b 54 24 40               	movq	64(%rsp), %rdx
   17454: 48 8b 74 24 28               	movq	40(%rsp), %rsi
   17459: 48 89 c7                     	movq	%rax, %rdi
   1745c: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 			curr_bind = GELF_ST_BIND(sym.st_info);
   17461: 44 0f b6 ac 24 94 00 00 00   	movzbl	148(%rsp), %r13d
; 			if (strncmp(sname, name, name_len) != 0)
   1746a: e8 b1 e2 fe ff               	callq	0x5720 <.plt.sec+0xb0>
   1746f: 85 c0                        	testl	%eax, %eax
   17471: 75 95                        	jne	0x17408 <bpf_program__attach_uprobe_opts+0x938>
; 			if (!is_name_qualified && sname[name_len] != '\0' && sname[name_len] != '@')
   17473: 48 83 7c 24 60 00            	cmpq	$0, 96(%rsp)
   17479: 4c 8b 4c 24 38               	movq	56(%rsp), %r9
   1747e: 0f 84 84 00 00 00            	je	0x17508 <bpf_program__attach_uprobe_opts+0xa38>
; 			curr_bind = GELF_ST_BIND(sym.st_info);
   17484: 44 89 e8                     	movl	%r13d, %eax
   17487: c0 e8 04                     	shrb	$4, %al
; 			if (ret >= 0) {
   1748a: 48 83 7c 24 20 00            	cmpq	$0, 32(%rsp)
; 			curr_bind = GELF_ST_BIND(sym.st_info);
   17490: 44 0f b6 e8                  	movzbl	%al, %r13d
; 			if (ret >= 0) {
   17494: 78 19                        	js	0x174af <bpf_program__attach_uprobe_opts+0x9df>
; 				if (last_bind != STB_WEAK && curr_bind != STB_WEAK) {
   17496: 83 7c 24 78 02               	cmpl	$2, 120(%rsp)
   1749b: 74 0a                        	je	0x174a7 <bpf_program__attach_uprobe_opts+0x9d7>
   1749d: 41 83 fd 02                  	cmpl	$2, %r13d
   174a1: 0f 85 bc 01 00 00            	jne	0x17663 <bpf_program__attach_uprobe_opts+0xb93>
; 				} else if (curr_bind == STB_WEAK) {
   174a7: 3c 02                        	cmpb	$2, %al
   174a9: 0f 84 59 ff ff ff            	je	0x17408 <bpf_program__attach_uprobe_opts+0x938>
; 			sym_scn = elf_getscn(elf, sym.st_shndx);
   174af: 0f b7 b4 24 96 00 00 00      	movzwl	150(%rsp), %esi
   174b7: 4c 89 f7                     	movq	%r14, %rdi
   174ba: e8 41 e7 fe ff               	callq	0x5c00 <.plt.sec+0x590>
   174bf: 48 89 c7                     	movq	%rax, %rdi
; 			if (!sym_scn)
   174c2: 48 85 c0                     	testq	%rax, %rax
   174c5: 0f 84 3d ff ff ff            	je	0x17408 <bpf_program__attach_uprobe_opts+0x938>
; 			if (!gelf_getshdr(sym_scn, &sym_sh))
   174cb: 48 8b 74 24 70               	movq	112(%rsp), %rsi
   174d0: e8 0b e2 fe ff               	callq	0x56e0 <.plt.sec+0x70>
   174d5: 48 85 c0                     	testq	%rax, %rax
   174d8: 0f 84 2a ff ff ff            	je	0x17408 <bpf_program__attach_uprobe_opts+0x938>
; 			ret = sym.st_value - sym_sh.sh_addr + sym_sh.sh_offset;
   174de: 48 8b 84 24 08 01 00 00      	movq	264(%rsp), %rax
   174e6: 48 03 84 24 98 00 00 00      	addq	152(%rsp), %rax
; 			curr_bind = GELF_ST_BIND(sym.st_info);
   174ee: 44 89 6c 24 78               	movl	%r13d, 120(%rsp)
; 			ret = sym.st_value - sym_sh.sh_addr + sym_sh.sh_offset;
   174f3: 48 2b 84 24 00 01 00 00      	subq	256(%rsp), %rax
   174fb: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 			last_bind = curr_bind;
   17500: e9 03 ff ff ff               	jmp	0x17408 <bpf_program__attach_uprobe_opts+0x938>
   17505: 0f 1f 00                     	nopl	(%rax)
; 			if (!is_name_qualified && sname[name_len] != '\0' && sname[name_len] != '@')
   17508: 48 8b 44 24 40               	movq	64(%rsp), %rax
   1750d: 41 f6 04 01 bf               	testb	$-65, (%r9,%rax)
   17512: 0f 84 6c ff ff ff            	je	0x17484 <bpf_program__attach_uprobe_opts+0x9b4>
   17518: e9 eb fe ff ff               	jmp	0x17408 <bpf_program__attach_uprobe_opts+0x938>
; 		pr_warn("prog '%s': failed to attach to %s '%s:0x%zx': %s\n",
   1751d: 48 83 ec 08                  	subq	$8, %rsp
   17521: 4d 89 f8                     	movq	%r15, %r8
   17524: 48 8d 0d 1e ad 01 00         	leaq	109854(%rip), %rcx      # 0x32249 <_IO_stdin_used+0x2249>
   1752b: 31 ff                        	xorl	%edi, %edi
   1752d: 50                           	pushq	%rax
   1752e: 48 8b 44 24 28               	movq	40(%rsp), %rax
   17533: 48 8d 35 ae fe 01 00         	leaq	130734(%rip), %rsi      # 0x373e8 <strs.2+0x4558>
   1753a: 4c 8b 4c 24 18               	movq	24(%rsp), %r9
   1753f: 48 8b 10                     	movq	(%rax), %rdx
   17542: 31 c0                        	xorl	%eax, %eax
   17544: e8 87 0b ff ff               	callq	0x80d0 <libbpf_print>
; 	if (legacy)
   17549: 58                           	popq	%rax
   1754a: 5a                           	popq	%rdx
   1754b: 85 db                        	testl	%ebx, %ebx
   1754d: 0f 89 0e fe ff ff            	jns	0x17361 <bpf_program__attach_uprobe_opts+0x891>
; 	return append_to_file(tracefs_uprobe_events(), "-:%s/%s",
   17553: 4c 8d 35 3c a7 01 00         	leaq	108348(%rip), %r14      # 0x31c96 <_IO_stdin_used+0x1c96>
   1755a: e9 c4 fb ff ff               	jmp	0x17123 <bpf_program__attach_uprobe_opts+0x653>
   1755f: 90                           	nop
; 		ret = -errno;
   17560: e8 8b e1 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to open %s: %s\n", binary_path,
   17565: 48 8d b4 24 c0 13 00 00      	leaq	5056(%rsp), %rsi
   1756d: ba 80 00 00 00               	movl	$128, %edx
; 		ret = -errno;
   17572: 8b 38                        	movl	(%rax), %edi
   17574: f7 df                        	negl	%edi
   17576: 48 63 c7                     	movslq	%edi, %rax
   17579: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 		pr_warn("failed to open %s: %s\n", binary_path,
   1757e: e8 4d 64 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   17583: 4c 89 fa                     	movq	%r15, %rdx
   17586: 48 8d 35 ab fb 01 00         	leaq	129963(%rip), %rsi      # 0x37138 <strs.2+0x42a8>
   1758d: 31 ff                        	xorl	%edi, %edi
   1758f: 48 89 c1                     	movq	%rax, %rcx
   17592: 31 c0                        	xorl	%eax, %eax
   17594: e8 37 0b ff ff               	callq	0x80d0 <libbpf_print>
; 		return ret;
   17599: e9 ed f7 ff ff               	jmp	0x16d8b <bpf_program__attach_uprobe_opts+0x2bb>
   1759e: 66 90                        	nop
; 			pr_debug("elf: failed to find symbol table ELF sections in '%s'\n",
   175a0: 48 8b 54 24 68               	movq	104(%rsp), %rdx
   175a5: 48 8d 35 7c fe 01 00         	leaq	130684(%rip), %rsi      # 0x37428 <strs.2+0x4598>
   175ac: bf 02 00 00 00               	movl	$2, %edi
   175b1: 31 c0                        	xorl	%eax, %eax
   175b3: e8 18 0b ff ff               	callq	0x80d0 <libbpf_print>
; 			continue;
   175b8: e9 6c f7 ff ff               	jmp	0x16d29 <bpf_program__attach_uprobe_opts+0x259>
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
   175bd: 31 f6                        	xorl	%esi, %esi
   175bf: 48 8d 3d ae a6 01 00         	leaq	108206(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
   175c6: e8 d5 e5 fe ff               	callq	0x5ba0 <.plt.sec+0x530>
   175cb: 85 c0                        	testl	%eax, %eax
   175cd: 0f 94 c0                     	sete	%al
   175d0: 0f b6 c0                     	movzbl	%al, %eax
   175d3: 89 05 37 fa 02 00            	movl	%eax, 195127(%rip)      # 0x47010 <has_debugfs.1>
   175d9: e9 eb fb ff ff               	jmp	0x171c9 <bpf_program__attach_uprobe_opts+0x6f9>
; 			pr_warn("elf: failed to find symbol '%s' in '%s'\n", name, binary_path);
   175de: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   175e3: 4c 89 f9                     	movq	%r15, %rcx
   175e6: 31 ff                        	xorl	%edi, %edi
   175e8: 31 c0                        	xorl	%eax, %eax
   175ea: 48 8d 35 b7 fc 01 00         	leaq	130231(%rip), %rsi      # 0x372a8 <strs.2+0x4418>
   175f1: e8 da 0a ff ff               	callq	0x80d0 <libbpf_print>
   175f6: e9 7f f7 ff ff               	jmp	0x16d7a <bpf_program__attach_uprobe_opts+0x2aa>
; 			pr_warn("prog '%s': failed to resolve full path for '%s': %d\n",
   175fb: 41 89 c0                     	movl	%eax, %r8d
   175fe: 48 8b 44 24 18               	movq	24(%rsp), %rax
   17603: 4c 89 f9                     	movq	%r15, %rcx
   17606: 31 ff                        	xorl	%edi, %edi
   17608: 48 8d 35 e9 fa 01 00         	leaq	129769(%rip), %rsi      # 0x370f8 <strs.2+0x4268>
; 	errno = -err;
   1760f: f7 dd                        	negl	%ebp
; 			pr_warn("prog '%s': failed to resolve full path for '%s': %d\n",
   17611: 48 8b 10                     	movq	(%rax), %rdx
   17614: 31 c0                        	xorl	%eax, %eax
   17616: e8 b5 0a ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   1761b: e8 d0 e0 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   17620: 89 28                        	movl	%ebp, (%rax)
; 			return libbpf_err_ptr(err);
   17622: e9 4c fa ff ff               	jmp	0x17073 <bpf_program__attach_uprobe_opts+0x5a3>
; 		pr_warn("elf: failed to get ehdr from %s: %s\n", binary_path, elf_errmsg(-1));
   17627: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   1762c: e8 2f e4 fe ff               	callq	0x5a60 <.plt.sec+0x3f0>
   17631: 4c 89 fa                     	movq	%r15, %rdx
   17634: 48 8d 35 4d fb 01 00         	leaq	129869(%rip), %rsi      # 0x37188 <strs.2+0x42f8>
   1763b: 31 ff                        	xorl	%edi, %edi
   1763d: 48 89 c1                     	movq	%rax, %rcx
   17640: 31 c0                        	xorl	%eax, %eax
   17642: e8 89 0a ff ff               	callq	0x80d0 <libbpf_print>
; 	elf_end(elf);
   17647: 4c 89 f7                     	movq	%r14, %rdi
   1764a: 41 be a1 0f 00 00            	movl	$4001, %r14d            # imm = 0xFA1
   17650: e8 db e3 fe ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   17655: 8b 7c 24 4c                  	movl	76(%rsp), %edi
   17659: e8 a2 e2 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (sym_off < 0)
   1765e: e9 65 fc ff ff               	jmp	0x172c8 <bpf_program__attach_uprobe_opts+0x7f8>
; 					pr_warn("elf: ambiguous match for '%s', '%s' in '%s'\n",
   17663: 4c 8b 44 24 68               	movq	104(%rsp), %r8
   17668: 48 8b 4c 24 28               	movq	40(%rsp), %rcx
   1766d: 4c 89 ca                     	movq	%r9, %rdx
   17670: 31 ff                        	xorl	%edi, %edi
   17672: 48 8d 35 87 fb 01 00         	leaq	129927(%rip), %rsi      # 0x37200 <strs.2+0x4370>
   17679: 31 c0                        	xorl	%eax, %eax
   1767b: e8 50 0a ff ff               	callq	0x80d0 <libbpf_print>
; 					goto out;
   17680: eb c5                        	jmp	0x17647 <bpf_program__attach_uprobe_opts+0xb77>
; 		has_debugfs = access(DEBUGFS, F_OK) == 0;
   17682: 31 f6                        	xorl	%esi, %esi
   17684: 48 8d 3d e9 a5 01 00         	leaq	108009(%rip), %rdi      # 0x31c74 <_IO_stdin_used+0x1c74>
   1768b: e8 10 e5 fe ff               	callq	0x5ba0 <.plt.sec+0x530>
   17690: 85 c0                        	testl	%eax, %eax
   17692: 0f 94 c0                     	sete	%al
   17695: 0f b6 c0                     	movzbl	%al, %eax
   17698: 89 05 72 f9 02 00            	movl	%eax, 194930(%rip)      # 0x47010 <has_debugfs.1>
   1769e: e9 8e fa ff ff               	jmp	0x17131 <bpf_program__attach_uprobe_opts+0x661>
; 			pr_warn("elf: failed to get symbols for symtab section in '%s': %s\n",
   176a3: 4c 8b 7c 24 68               	movq	104(%rsp), %r15
   176a8: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   176ad: e8 ae e3 fe ff               	callq	0x5a60 <.plt.sec+0x3f0>
   176b2: 48 8d 35 ff fa 01 00         	leaq	129791(%rip), %rsi      # 0x371b8 <strs.2+0x4328>
   176b9: 31 ff                        	xorl	%edi, %edi
   176bb: 48 89 c1                     	movq	%rax, %rcx
   176be: 4c 89 fa                     	movq	%r15, %rdx
   176c1: 31 c0                        	xorl	%eax, %eax
   176c3: e8 08 0a ff ff               	callq	0x80d0 <libbpf_print>
; 			goto out;
   176c8: e9 7a ff ff ff               	jmp	0x17647 <bpf_program__attach_uprobe_opts+0xb77>
; 		pr_warn("elf: could not read elf from %s: %s\n", binary_path, elf_errmsg(-1));
   176cd: 83 cf ff                     	orl	$-1, %edi
   176d0: 41 be a1 0f 00 00            	movl	$4001, %r14d            # imm = 0xFA1
   176d6: e8 85 e3 fe ff               	callq	0x5a60 <.plt.sec+0x3f0>
   176db: 4c 89 fa                     	movq	%r15, %rdx
   176de: 48 8d 35 73 fa 01 00         	leaq	129651(%rip), %rsi      # 0x37158 <strs.2+0x42c8>
   176e5: 31 ff                        	xorl	%edi, %edi
   176e7: 48 89 c1                     	movq	%rax, %rcx
   176ea: 31 c0                        	xorl	%eax, %eax
   176ec: e8 df 09 ff ff               	callq	0x80d0 <libbpf_print>
; 		close(fd);
   176f1: 8b 7c 24 4c                  	movl	76(%rsp), %edi
   176f5: e8 06 e2 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (sym_off < 0)
   176fa: e9 c9 fb ff ff               	jmp	0x172c8 <bpf_program__attach_uprobe_opts+0x7f8>
; }
   176ff: e8 fc e0 fe ff               	callq	0x5800 <.plt.sec+0x190>
; 	errno = -err;
   17704: e8 e7 df fe ff               	callq	0x56f0 <.plt.sec+0x80>
   17709: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 			return libbpf_err_ptr(-ENOMEM);
   1770f: e9 4f fb ff ff               	jmp	0x17263 <bpf_program__attach_uprobe_opts+0x793>
; 	errno = -err;
   17714: 44 8b 74 24 20               	movl	32(%rsp), %r14d
   17719: 41 f7 de                     	negl	%r14d
   1771c: e9 a7 fb ff ff               	jmp	0x172c8 <bpf_program__attach_uprobe_opts+0x7f8>
   17721: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1772c: 0f 1f 40 00                  	nopl	(%rax)

0000000000017730 <attach_uprobe>:
; {
   17730: f3 0f 1e fa                  	endbr64
   17734: 41 55                        	pushq	%r13
;   return __builtin___memset_chk (__dest, __ch, __len,
   17736: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	n = sscanf(prog->sec_name, "%m[^/]/%m[^:]:%m[a-zA-Z0-9_.]+%li",
   1773a: 48 8d 35 27 fd 01 00         	leaq	130343(%rip), %rsi      # 0x37468 <strs.2+0x45d8>
; {
   17741: 41 54                        	pushq	%r12
   17743: 55                           	pushq	%rbp
   17744: 48 89 fd                     	movq	%rdi, %rbp
   17747: 53                           	pushq	%rbx
   17748: 48 89 d3                     	movq	%rdx, %rbx
   1774b: 48 83 ec 58                  	subq	$88, %rsp
; 	n = sscanf(prog->sec_name, "%m[^/]/%m[^:]:%m[a-zA-Z0-9_.]+%li",
   1774f: 48 8b 7f 08                  	movq	8(%rdi), %rdi
; {
   17753: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1775c: 48 89 44 24 48               	movq	%rax, 72(%rsp)
   17761: 31 c0                        	xorl	%eax, %eax
; 	n = sscanf(prog->sec_name, "%m[^/]/%m[^:]:%m[a-zA-Z0-9_.]+%li",
   17763: 48 8d 4c 24 08               	leaq	8(%rsp), %rcx
   17768: 4c 8d 4c 24 18               	leaq	24(%rsp), %r9
; 	*link = NULL;
   1776d: 48 c7 02 00 00 00 00         	movq	$0, (%rdx)
; 	n = sscanf(prog->sec_name, "%m[^/]/%m[^:]:%m[a-zA-Z0-9_.]+%li",
   17774: 4c 8d 44 24 10               	leaq	16(%rsp), %r8
   17779: 48 89 e2                     	movq	%rsp, %rdx
; 	DECLARE_LIBBPF_OPTS(bpf_uprobe_opts, opts);
   1777c: 48 c7 44 24 20 28 00 00 00   	movq	$40, 32(%rsp)
; 	char *probe_type = NULL, *binary_path = NULL, *func_name = NULL;
   17785: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
   1778d: 48 c7 44 24 08 00 00 00 00   	movq	$0, 8(%rsp)
   17796: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 	long offset = 0;
   1779f: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   177a8: 0f 11 44 24 28               	movups	%xmm0, 40(%rsp)
   177ad: 0f 11 44 24 38               	movups	%xmm0, 56(%rsp)
; 	n = sscanf(prog->sec_name, "%m[^/]/%m[^:]:%m[a-zA-Z0-9_.]+%li",
   177b2: e8 09 e3 fe ff               	callq	0x5ac0 <.plt.sec+0x450>
; 	switch (n) {
   177b7: 83 f8 02                     	cmpl	$2, %eax
   177ba: 0f 84 e8 00 00 00            	je	0x178a8 <attach_uprobe+0x178>
   177c0: 7f 4e                        	jg	0x17810 <attach_uprobe+0xe0>
   177c2: 45 31 e4                     	xorl	%r12d, %r12d
   177c5: 83 f8 01                     	cmpl	$1, %eax
   177c8: 0f 85 02 01 00 00            	jne	0x178d0 <attach_uprobe+0x1a0>
; 	free(probe_type);
   177ce: 48 8b 3c 24                  	movq	(%rsp), %rdi
   177d2: e8 e9 de fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(binary_path);
   177d7: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   177dc: e8 df de fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(func_name);
   177e1: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   177e6: e8 d5 de fe ff               	callq	0x56c0 <.plt.sec+0x50>
; }
   177eb: 48 8b 44 24 48               	movq	72(%rsp), %rax
   177f0: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   177f9: 0f 85 4e 01 00 00            	jne	0x1794d <attach_uprobe+0x21d>
   177ff: 48 83 c4 58                  	addq	$88, %rsp
   17803: 44 89 e0                     	movl	%r12d, %eax
   17806: 5b                           	popq	%rbx
   17807: 5d                           	popq	%rbp
   17808: 41 5c                        	popq	%r12
   1780a: 41 5d                        	popq	%r13
   1780c: c3                           	retq
   1780d: 0f 1f 00                     	nopl	(%rax)
; 	switch (n) {
   17810: 83 e8 03                     	subl	$3, %eax
   17813: 83 f8 01                     	cmpl	$1, %eax
   17816: 0f 87 b4 00 00 00            	ja	0x178d0 <attach_uprobe+0x1a0>
; 		opts.retprobe = strcmp(probe_type, "uretprobe") == 0 ||
   1781c: 4c 8b 2c 24                  	movq	(%rsp), %r13
   17820: 48 8d 35 22 aa 01 00         	leaq	109090(%rip), %rsi      # 0x32249 <_IO_stdin_used+0x2249>
   17827: 4c 89 ef                     	movq	%r13, %rdi
   1782a: e8 81 e1 fe ff               	callq	0x59b0 <.plt.sec+0x340>
; 		*link = bpf_program__attach_uprobe_opts(prog, -1, binary_path, offset, &opts);
   1782f: 4c 8b 64 24 18               	movq	24(%rsp), %r12
; 		opts.retprobe = strcmp(probe_type, "uretprobe") == 0 ||
   17834: 85 c0                        	testl	%eax, %eax
   17836: 0f 85 bc 00 00 00            	jne	0x178f8 <attach_uprobe+0x1c8>
   1783c: c6 44 24 38 01               	movb	$1, 56(%rsp)
; 		if (opts.retprobe && offset != 0) {
   17841: 4d 85 e4                     	testq	%r12, %r12
   17844: 0f 85 e4 00 00 00            	jne	0x1792e <attach_uprobe+0x1fe>
; 		opts.func_name = func_name;
   1784a: 48 8b 44 24 10               	movq	16(%rsp), %rax
; 		*link = bpf_program__attach_uprobe_opts(prog, -1, binary_path, offset, &opts);
   1784f: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   17854: 48 89 ef                     	movq	%rbp, %rdi
   17857: 4c 89 e1                     	movq	%r12, %rcx
   1785a: 4c 8d 44 24 20               	leaq	32(%rsp), %r8
   1785f: be ff ff ff ff               	movl	$4294967295, %esi       # imm = 0xFFFFFFFF
; 		opts.func_name = func_name;
   17864: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 		*link = bpf_program__attach_uprobe_opts(prog, -1, binary_path, offset, &opts);
   17869: e8 62 f2 ff ff               	callq	0x16ad0 <bpf_program__attach_uprobe_opts>
   1786e: 48 89 03                     	movq	%rax, (%rbx)
   17871: 48 89 c5                     	movq	%rax, %rbp
; 	if (!IS_ERR_OR_NULL(ptr))
   17874: 48 85 c0                     	testq	%rax, %rax
   17877: 74 0f                        	je	0x17888 <attach_uprobe+0x158>
   17879: 45 31 e4                     	xorl	%r12d, %r12d
   1787c: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   17882: 0f 86 46 ff ff ff            	jbe	0x177ce <attach_uprobe+0x9e>
; 		errno = -PTR_ERR(ptr);
   17888: e8 63 de fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
   1788d: 48 81 fd 00 f0 ff ff         	cmpq	$-4096, %rbp            # imm = 0xF000
   17894: 0f 87 86 00 00 00            	ja	0x17920 <attach_uprobe+0x1f0>
; 	return -errno;
   1789a: 44 8b 20                     	movl	(%rax), %r12d
   1789d: 41 f7 dc                     	negl	%r12d
   178a0: e9 29 ff ff ff               	jmp	0x177ce <attach_uprobe+0x9e>
   178a5: 0f 1f 00                     	nopl	(%rax)
; 		pr_warn("prog '%s': section '%s' missing ':function[+offset]' specification\n",
   178a8: 48 8b 4d 08                  	movq	8(%rbp), %rcx
   178ac: 48 8b 55 00                  	movq	(%rbp), %rdx
   178b0: 31 ff                        	xorl	%edi, %edi
   178b2: 31 c0                        	xorl	%eax, %eax
   178b4: 48 8d 35 d5 fb 01 00         	leaq	130005(%rip), %rsi      # 0x37490 <strs.2+0x4600>
; 	int n, ret = -EINVAL;
   178bb: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("prog '%s': section '%s' missing ':function[+offset]' specification\n",
   178c1: e8 0a 08 ff ff               	callq	0x80d0 <libbpf_print>
; 		break;
   178c6: e9 03 ff ff ff               	jmp	0x177ce <attach_uprobe+0x9e>
   178cb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("prog '%s': invalid format of section definition '%s'\n", prog->name,
   178d0: 48 8b 4d 08                  	movq	8(%rbp), %rcx
   178d4: 48 8b 55 00                  	movq	(%rbp), %rdx
   178d8: 31 ff                        	xorl	%edi, %edi
   178da: 31 c0                        	xorl	%eax, %eax
   178dc: 48 8d 35 45 fc 01 00         	leaq	130117(%rip), %rsi      # 0x37528 <strs.2+0x4698>
; 	int n, ret = -EINVAL;
   178e3: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("prog '%s': invalid format of section definition '%s'\n", prog->name,
   178e9: e8 e2 07 ff ff               	callq	0x80d0 <libbpf_print>
; 		break;
   178ee: e9 db fe ff ff               	jmp	0x177ce <attach_uprobe+0x9e>
   178f3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 				strcmp(probe_type, "uretprobe.s") == 0;
   178f8: 48 8d 35 8c a9 01 00         	leaq	108940(%rip), %rsi      # 0x3228b <_IO_stdin_used+0x228b>
   178ff: 4c 89 ef                     	movq	%r13, %rdi
   17902: e8 a9 e0 fe ff               	callq	0x59b0 <.plt.sec+0x340>
; 		opts.retprobe = strcmp(probe_type, "uretprobe") == 0 ||
   17907: 85 c0                        	testl	%eax, %eax
   17909: 0f 84 2d ff ff ff            	je	0x1783c <attach_uprobe+0x10c>
   1790f: c6 44 24 38 00               	movb	$0, 56(%rsp)
; 		if (opts.retprobe && offset != 0) {
   17914: e9 31 ff ff ff               	jmp	0x1784a <attach_uprobe+0x11a>
   17919: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
   17920: 41 89 ec                     	movl	%ebp, %r12d
   17923: 41 f7 dc                     	negl	%r12d
   17926: 44 89 20                     	movl	%r12d, (%rax)
   17929: e9 6f ff ff ff               	jmp	0x1789d <attach_uprobe+0x16d>
; 			pr_warn("prog '%s': uretprobes do not support offset specification\n",
   1792e: 48 8b 55 00                  	movq	(%rbp), %rdx
   17932: 48 8d 35 a7 fb 01 00         	leaq	129959(%rip), %rsi      # 0x374e0 <strs.2+0x4650>
   17939: 31 ff                        	xorl	%edi, %edi
   1793b: 31 c0                        	xorl	%eax, %eax
; 	int n, ret = -EINVAL;
   1793d: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("prog '%s': uretprobes do not support offset specification\n",
   17943: e8 88 07 ff ff               	callq	0x80d0 <libbpf_print>
; 			break;
   17948: e9 81 fe ff ff               	jmp	0x177ce <attach_uprobe+0x9e>
; }
   1794d: e8 ae de fe ff               	callq	0x5800 <.plt.sec+0x190>
   17952: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1795d: 0f 1f 00                     	nopl	(%rax)

0000000000017960 <bpf_program__attach_uprobe>:
; {
   17960: f3 0f 1e fa                  	endbr64
   17964: 48 83 ec 38                  	subq	$56, %rsp
   17968: 41 89 f1                     	movl	%esi, %r9d
;   return __builtin___memset_chk (__dest, __ch, __len,
   1796b: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   1796f: 89 d6                        	movl	%edx, %esi
   17971: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1797a: 48 89 44 24 28               	movq	%rax, 40(%rsp)
   1797f: 31 c0                        	xorl	%eax, %eax
   17981: 48 89 ca                     	movq	%rcx, %rdx
   17984: 4c 89 c1                     	movq	%r8, %rcx
; 	return bpf_program__attach_uprobe_opts(prog, pid, binary_path, func_offset, &opts);
   17987: 49 89 e0                     	movq	%rsp, %r8
;   return __builtin___memset_chk (__dest, __ch, __len,
   1798a: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
; 	DECLARE_LIBBPF_OPTS(bpf_uprobe_opts, opts, .retprobe = retprobe);
   1798f: 48 c7 04 24 28 00 00 00      	movq	$40, (%rsp)
   17997: 44 88 4c 24 18               	movb	%r9b, 24(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1799c: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
; 	return bpf_program__attach_uprobe_opts(prog, pid, binary_path, func_offset, &opts);
   179a1: e8 2a f1 ff ff               	callq	0x16ad0 <bpf_program__attach_uprobe_opts>
; }
   179a6: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   179ab: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   179b4: 75 05                        	jne	0x179bb <bpf_program__attach_uprobe+0x5b>
   179b6: 48 83 c4 38                  	addq	$56, %rsp
   179ba: c3                           	retq
   179bb: e8 40 de fe ff               	callq	0x5800 <.plt.sec+0x190>

00000000000179c0 <bpf_program__attach_usdt>:
; {
   179c0: f3 0f 1e fa                  	endbr64
   179c4: 41 57                        	pushq	%r15
   179c6: 49 89 d7                     	movq	%rdx, %r15
   179c9: 41 56                        	pushq	%r14
   179cb: 49 89 fe                     	movq	%rdi, %r14
   179ce: 41 55                        	pushq	%r13
   179d0: 41 89 f5                     	movl	%esi, %r13d
   179d3: 41 54                        	pushq	%r12
   179d5: 55                           	pushq	%rbp
   179d6: 4c 89 c5                     	movq	%r8, %rbp
   179d9: 53                           	pushq	%rbx
   179da: 48 81 ec 38 02 00 00         	subq	$568, %rsp              # imm = 0x238
; 	struct bpf_object *obj = prog->obj;
   179e1: 48 8b 5f 70                  	movq	112(%rdi), %rbx
; {
   179e5: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
   179ea: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   179f3: 48 89 84 24 28 02 00 00      	movq	%rax, 552(%rsp)
   179fb: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_uprobe_opts))
   179fd: 4d 85 c9                     	testq	%r9, %r9
   17a00: 0f 84 8a 00 00 00            	je	0x17a90 <bpf_program__attach_usdt+0xd0>
   17a06: 49 8b 09                     	movq	(%r9), %rcx
; 	if (user_sz < sizeof(size_t)) {
   17a09: 48 83 f9 07                  	cmpq	$7, %rcx
   17a0d: 0f 86 85 01 00 00            	jbe	0x17b98 <bpf_program__attach_usdt+0x1d8>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   17a13: 48 8d 51 d8                  	leaq	-40(%rcx), %rdx
   17a17: 49 8d 41 28                  	leaq	40(%r9), %rax
; 	while (len > 0) {
   17a1b: 48 85 d2                     	testq	%rdx, %rdx
   17a1e: 7e 70                        	jle	0x17a90 <bpf_program__attach_usdt+0xd0>
   17a20: 4c 01 c9                     	addq	%r9, %rcx
   17a23: eb 0c                        	jmp	0x17a31 <bpf_program__attach_usdt+0x71>
   17a25: 0f 1f 00                     	nopl	(%rax)
; 		p++;
   17a28: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   17a2c: 48 39 c8                     	cmpq	%rcx, %rax
   17a2f: 74 5f                        	je	0x17a90 <bpf_program__attach_usdt+0xd0>
; 		if (*p)
   17a31: 80 38 00                     	cmpb	$0, (%rax)
   17a34: 74 f2                        	je	0x17a28 <bpf_program__attach_usdt+0x68>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   17a36: 48 8d 15 16 a8 01 00         	leaq	108566(%rip), %rdx      # 0x32253 <_IO_stdin_used+0x2253>
   17a3d: 48 8d 35 cc c5 01 00         	leaq	116172(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   17a44: 31 ff                        	xorl	%edi, %edi
   17a46: 31 c0                        	xorl	%eax, %eax
   17a48: e8 83 06 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   17a4d: e8 9e dc fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   17a52: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   17a55: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return NULL;
   17a5b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; }
   17a60: 48 8b 84 24 28 02 00 00      	movq	552(%rsp), %rax
   17a68: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   17a71: 0f 85 ef 01 00 00            	jne	0x17c66 <bpf_program__attach_usdt+0x2a6>
   17a77: 48 81 c4 38 02 00 00         	addq	$568, %rsp              # imm = 0x238
   17a7e: 4c 89 e0                     	movq	%r12, %rax
   17a81: 5b                           	popq	%rbx
   17a82: 5d                           	popq	%rbp
   17a83: 41 5c                        	popq	%r12
   17a85: 41 5d                        	popq	%r13
   17a87: 41 5e                        	popq	%r14
   17a89: 41 5f                        	popq	%r15
   17a8b: c3                           	retq
   17a8c: 0f 1f 40 00                  	nopl	(%rax)
; 	if (prog->fd < 0)
   17a90: 41 8b 46 78                  	movl	120(%r14), %eax
   17a94: 85 c0                        	testl	%eax, %eax
   17a96: 0f 88 54 01 00 00            	js	0x17bf0 <bpf_program__attach_usdt+0x230>
; 	if (!binary_path)
   17a9c: 4d 85 ff                     	testq	%r15, %r15
   17a9f: 74 ac                        	je	0x17a4d <bpf_program__attach_usdt+0x8d>
; 	if (!strchr(binary_path, '/')) {
   17aa1: be 2f 00 00 00               	movl	$47, %esi
   17aa6: 4c 89 ff                     	movq	%r15, %rdi
   17aa9: 4c 89 4c 24 10               	movq	%r9, 16(%rsp)
   17aae: e8 6d dd fe ff               	callq	0x5820 <.plt.sec+0x1b0>
   17ab3: 4c 8b 4c 24 10               	movq	16(%rsp), %r9
   17ab8: 48 85 c0                     	testq	%rax, %rax
   17abb: 49 89 c4                     	movq	%rax, %r12
   17abe: 0f 84 f4 00 00 00            	je	0x17bb8 <bpf_program__attach_usdt+0x1f8>
; 	if (IS_ERR(obj->usdt_man))
   17ac4: 4c 8b a3 88 01 00 00         	movq	392(%rbx), %r12
   17acb: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   17ad2: 0f 87 a8 00 00 00            	ja	0x17b80 <bpf_program__attach_usdt+0x1c0>
; 	if (!obj->usdt_man) {
   17ad8: 4d 85 e4                     	testq	%r12, %r12
   17adb: 74 73                        	je	0x17b50 <bpf_program__attach_usdt+0x190>
; 	usdt_cookie = OPTS_GET(opts, usdt_cookie, 0);
   17add: 31 c0                        	xorl	%eax, %eax
   17adf: 4d 85 c9                     	testq	%r9, %r9
   17ae2: 74 0a                        	je	0x17aee <bpf_program__attach_usdt+0x12e>
   17ae4: 49 83 39 0f                  	cmpq	$15, (%r9)
   17ae8: 76 04                        	jbe	0x17aee <bpf_program__attach_usdt+0x12e>
   17aea: 49 8b 41 08                  	movq	8(%r9), %rax
; 	link = usdt_manager_attach_usdt(obj->usdt_man, prog, pid, binary_path,
   17aee: 48 83 ec 08                  	subq	$8, %rsp
   17af2: 4c 89 f9                     	movq	%r15, %rcx
   17af5: 44 89 ea                     	movl	%r13d, %edx
   17af8: 4c 89 e7                     	movq	%r12, %rdi
   17afb: 50                           	pushq	%rax
   17afc: 4c 8b 44 24 18               	movq	24(%rsp), %r8
   17b01: 49 89 e9                     	movq	%rbp, %r9
   17b04: 4c 89 f6                     	movq	%r14, %rsi
   17b07: e8 e4 c2 00 00               	callq	0x23df0 <usdt_manager_attach_usdt>
; 	return (!ptr) || IS_ERR_VALUE((unsigned long)ptr);
   17b0c: 5a                           	popq	%rdx
   17b0d: 59                           	popq	%rcx
; 	link = usdt_manager_attach_usdt(obj->usdt_man, prog, pid, binary_path,
   17b0e: 49 89 c4                     	movq	%rax, %r12
; 	if (!IS_ERR_OR_NULL(ptr))
   17b11: 48 85 c0                     	testq	%rax, %rax
   17b14: 74 0c                        	je	0x17b22 <bpf_program__attach_usdt+0x162>
   17b16: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   17b1c: 0f 86 3e ff ff ff            	jbe	0x17a60 <bpf_program__attach_usdt+0xa0>
; 	errno = -err;
   17b22: e8 c9 db fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
   17b27: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   17b2e: 77 10                        	ja	0x17b40 <bpf_program__attach_usdt+0x180>
; 	return -errno;
   17b30: 8b 10                        	movl	(%rax), %edx
; 		return libbpf_err_ptr(err);
   17b32: 31 c0                        	xorl	%eax, %eax
   17b34: 85 d2                        	testl	%edx, %edx
   17b36: 4c 0f 45 e0                  	cmovneq	%rax, %r12
   17b3a: e9 21 ff ff ff               	jmp	0x17a60 <bpf_program__attach_usdt+0xa0>
   17b3f: 90                           	nop
; 		errno = -PTR_ERR(ptr);
   17b40: 44 89 e2                     	movl	%r12d, %edx
   17b43: f7 da                        	negl	%edx
   17b45: 89 10                        	movl	%edx, (%rax)
   17b47: eb e9                        	jmp	0x17b32 <bpf_program__attach_usdt+0x172>
   17b49: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		obj->usdt_man = usdt_manager_new(obj);
   17b50: 48 89 df                     	movq	%rbx, %rdi
   17b53: 4c 89 4c 24 10               	movq	%r9, 16(%rsp)
   17b58: e8 93 c1 00 00               	callq	0x23cf0 <usdt_manager_new>
; 		if (IS_ERR(obj->usdt_man))
   17b5d: 4c 8b 4c 24 10               	movq	16(%rsp), %r9
   17b62: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
; 		obj->usdt_man = usdt_manager_new(obj);
   17b68: 48 89 83 88 01 00 00         	movq	%rax, 392(%rbx)
; 		if (IS_ERR(obj->usdt_man))
   17b6f: 0f 87 aa 00 00 00            	ja	0x17c1f <bpf_program__attach_usdt+0x25f>
   17b75: 49 89 c4                     	movq	%rax, %r12
   17b78: e9 60 ff ff ff               	jmp	0x17add <bpf_program__attach_usdt+0x11d>
   17b7d: 0f 1f 00                     	nopl	(%rax)
; 		errno = -PTR_ERR(ret);
   17b80: e8 6b db fe ff               	callq	0x56f0 <.plt.sec+0x80>
   17b85: 41 f7 dc                     	negl	%r12d
   17b88: 44 89 20                     	movl	%r12d, (%rax)
; 		return libbpf_ptr(obj->usdt_man);
   17b8b: 45 31 e4                     	xorl	%r12d, %r12d
   17b8e: e9 cd fe ff ff               	jmp	0x17a60 <bpf_program__attach_usdt+0xa0>
   17b93: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   17b98: 48 8d 15 b4 a6 01 00         	leaq	108212(%rip), %rdx      # 0x32253 <_IO_stdin_used+0x2253>
   17b9f: 48 8d 35 12 c4 01 00         	leaq	115730(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   17ba6: 31 ff                        	xorl	%edi, %edi
   17ba8: e8 23 05 ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   17bad: e9 9b fe ff ff               	jmp	0x17a4d <bpf_program__attach_usdt+0x8d>
   17bb2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		err = resolve_full_path(binary_path, resolved_path, sizeof(resolved_path));
   17bb8: 48 8d 4c 24 20               	leaq	32(%rsp), %rcx
   17bbd: ba 00 02 00 00               	movl	$512, %edx              # imm = 0x200
   17bc2: 4c 89 ff                     	movq	%r15, %rdi
   17bc5: 4c 89 4c 24 18               	movq	%r9, 24(%rsp)
   17bca: 48 89 ce                     	movq	%rcx, %rsi
   17bcd: 48 89 4c 24 10               	movq	%rcx, 16(%rsp)
   17bd2: e8 b9 22 ff ff               	callq	0x9e90 <resolve_full_path>
; 		if (err) {
   17bd7: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   17bdc: 4c 8b 4c 24 18               	movq	24(%rsp), %r9
   17be1: 85 c0                        	testl	%eax, %eax
; 		err = resolve_full_path(binary_path, resolved_path, sizeof(resolved_path));
   17be3: 41 89 c0                     	movl	%eax, %r8d
; 		if (err) {
   17be6: 75 4f                        	jne	0x17c37 <bpf_program__attach_usdt+0x277>
; 		binary_path = resolved_path;
   17be8: 49 89 cf                     	movq	%rcx, %r15
   17beb: e9 d4 fe ff ff               	jmp	0x17ac4 <bpf_program__attach_usdt+0x104>
; 		errno = -ret;
   17bf0: e8 fb da fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("prog '%s': can't attach BPF program w/o FD (did you load it?)\n",
   17bf5: 49 8b 16                     	movq	(%r14), %rdx
   17bf8: 31 ff                        	xorl	%edi, %edi
; 		return libbpf_err_ptr(-EINVAL);
   17bfa: 45 31 e4                     	xorl	%r12d, %r12d
; 		errno = -ret;
   17bfd: c7 00 02 00 00 00            	movl	$2, (%rax)
   17c03: 48 89 c3                     	movq	%rax, %rbx
; 		pr_warn("prog '%s': can't attach BPF program w/o FD (did you load it?)\n",
   17c06: 48 8d 35 03 f1 01 00         	leaq	127235(%rip), %rsi      # 0x36d10 <strs.2+0x3e80>
   17c0d: 31 c0                        	xorl	%eax, %eax
   17c0f: e8 bc 04 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   17c14: c7 03 16 00 00 00            	movl	$22, (%rbx)
; 		return libbpf_err_ptr(-EINVAL);
   17c1a: e9 41 fe ff ff               	jmp	0x17a60 <bpf_program__attach_usdt+0xa0>
   17c1f: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 		errno = -PTR_ERR(ret);
   17c24: e8 c7 da fe ff               	callq	0x56f0 <.plt.sec+0x80>
   17c29: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   17c2e: f7 da                        	negl	%edx
   17c30: 89 10                        	movl	%edx, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   17c32: e9 29 fe ff ff               	jmp	0x17a60 <bpf_program__attach_usdt+0xa0>
; 			pr_warn("prog '%s': failed to resolve full path for '%s': %d\n",
   17c37: 49 8b 16                     	movq	(%r14), %rdx
   17c3a: 89 44 24 08                  	movl	%eax, 8(%rsp)
   17c3e: 4c 89 f9                     	movq	%r15, %rcx
   17c41: 31 ff                        	xorl	%edi, %edi
   17c43: 48 8d 35 ae f4 01 00         	leaq	128174(%rip), %rsi      # 0x370f8 <strs.2+0x4268>
   17c4a: 31 c0                        	xorl	%eax, %eax
   17c4c: e8 7f 04 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   17c51: e8 9a da fe ff               	callq	0x56f0 <.plt.sec+0x80>
   17c56: 44 8b 44 24 08               	movl	8(%rsp), %r8d
   17c5b: 41 f7 d8                     	negl	%r8d
   17c5e: 44 89 00                     	movl	%r8d, (%rax)
; 			return libbpf_err_ptr(err);
   17c61: e9 fa fd ff ff               	jmp	0x17a60 <bpf_program__attach_usdt+0xa0>
; }
   17c66: e8 95 db fe ff               	callq	0x5800 <.plt.sec+0x190>
   17c6b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000017c70 <attach_usdt>:
; {
   17c70: f3 0f 1e fa                  	endbr64
   17c74: 41 55                        	pushq	%r13
; 	if (strcmp(sec_name, "usdt") == 0) {
   17c76: 48 8d 35 1a a6 01 00         	leaq	108058(%rip), %rsi      # 0x32297 <_IO_stdin_used+0x2297>
; {
   17c7d: 41 54                        	pushq	%r12
   17c7f: 55                           	pushq	%rbp
   17c80: 48 89 fd                     	movq	%rdi, %rbp
   17c83: 53                           	pushq	%rbx
   17c84: 48 89 d3                     	movq	%rdx, %rbx
   17c87: 48 83 ec 28                  	subq	$40, %rsp
; 	return prog->sec_name;
   17c8b: 4c 8b 6f 08                  	movq	8(%rdi), %r13
; {
   17c8f: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   17c98: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   17c9d: 31 c0                        	xorl	%eax, %eax
; 	char *path = NULL, *provider = NULL, *name = NULL;
   17c9f: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
   17ca7: 48 c7 44 24 08 00 00 00 00   	movq	$0, 8(%rsp)
; 	if (strcmp(sec_name, "usdt") == 0) {
   17cb0: 4c 89 ef                     	movq	%r13, %rdi
; 	char *path = NULL, *provider = NULL, *name = NULL;
   17cb3: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 	if (strcmp(sec_name, "usdt") == 0) {
   17cbc: e8 ef dc fe ff               	callq	0x59b0 <.plt.sec+0x340>
   17cc1: 85 c0                        	testl	%eax, %eax
   17cc3: 75 33                        	jne	0x17cf8 <attach_usdt+0x88>
; 		*link = NULL;
   17cc5: 48 c7 03 00 00 00 00         	movq	$0, (%rbx)
   17ccc: 41 89 c4                     	movl	%eax, %r12d
; }
   17ccf: 48 8b 44 24 18               	movq	24(%rsp), %rax
   17cd4: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   17cdd: 0f 85 d8 00 00 00            	jne	0x17dbb <attach_usdt+0x14b>
   17ce3: 48 83 c4 28                  	addq	$40, %rsp
   17ce7: 44 89 e0                     	movl	%r12d, %eax
   17cea: 5b                           	popq	%rbx
   17ceb: 5d                           	popq	%rbp
   17cec: 41 5c                        	popq	%r12
   17cee: 41 5d                        	popq	%r13
   17cf0: c3                           	retq
   17cf1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	n = sscanf(sec_name, "usdt/%m[^:]:%m[^:]:%m[^:]", &path, &provider, &name);
   17cf8: 31 c0                        	xorl	%eax, %eax
   17cfa: 48 8d 4c 24 08               	leaq	8(%rsp), %rcx
   17cff: 48 89 e2                     	movq	%rsp, %rdx
   17d02: 4c 89 ef                     	movq	%r13, %rdi
   17d05: 4c 8d 44 24 10               	leaq	16(%rsp), %r8
   17d0a: 48 8d 35 8b a5 01 00         	leaq	107915(%rip), %rsi      # 0x3229c <_IO_stdin_used+0x229c>
   17d11: e8 aa dd fe ff               	callq	0x5ac0 <.plt.sec+0x450>
; 	if (n != 3) {
   17d16: 83 f8 03                     	cmpl	$3, %eax
   17d19: 74 45                        	je	0x17d60 <attach_usdt+0xf0>
; 		pr_warn("invalid section '%s', expected SEC(\"usdt/<path>:<provider>:<name>\")\n",
   17d1b: 4c 89 ea                     	movq	%r13, %rdx
   17d1e: 48 8d 35 43 f8 01 00         	leaq	129091(%rip), %rsi      # 0x37568 <strs.2+0x46d8>
   17d25: 31 ff                        	xorl	%edi, %edi
   17d27: 31 c0                        	xorl	%eax, %eax
   17d29: e8 a2 03 ff ff               	callq	0x80d0 <libbpf_print>
; 		err = -EINVAL;
   17d2e: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 	free(path);
   17d34: 48 8b 3c 24                  	movq	(%rsp), %rdi
   17d38: e8 83 d9 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(provider);
   17d3d: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   17d42: e8 79 d9 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(name);
   17d47: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   17d4c: e8 6f d9 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return err;
   17d51: e9 79 ff ff ff               	jmp	0x17ccf <attach_usdt+0x5f>
   17d56: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		*link = bpf_program__attach_usdt(prog, -1 /* any process */, path,
   17d60: 4c 8b 44 24 10               	movq	16(%rsp), %r8
   17d65: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   17d6a: 48 89 ef                     	movq	%rbp, %rdi
   17d6d: 45 31 c9                     	xorl	%r9d, %r9d
   17d70: 48 8b 14 24                  	movq	(%rsp), %rdx
   17d74: be ff ff ff ff               	movl	$4294967295, %esi       # imm = 0xFFFFFFFF
   17d79: e8 42 fc ff ff               	callq	0x179c0 <bpf_program__attach_usdt>
   17d7e: 48 89 03                     	movq	%rax, (%rbx)
   17d81: 48 89 c5                     	movq	%rax, %rbp
; 	if (!IS_ERR_OR_NULL(ptr))
   17d84: 48 85 c0                     	testq	%rax, %rax
   17d87: 74 0b                        	je	0x17d94 <attach_usdt+0x124>
   17d89: 45 31 e4                     	xorl	%r12d, %r12d
   17d8c: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   17d92: 76 a0                        	jbe	0x17d34 <attach_usdt+0xc4>
; 		errno = -PTR_ERR(ptr);
   17d94: e8 57 d9 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
   17d99: 48 81 fd 00 f0 ff ff         	cmpq	$-4096, %rbp            # imm = 0xF000
   17da0: 77 0e                        	ja	0x17db0 <attach_usdt+0x140>
; 	return -errno;
   17da2: 44 8b 20                     	movl	(%rax), %r12d
   17da5: 41 f7 dc                     	negl	%r12d
   17da8: eb 8a                        	jmp	0x17d34 <attach_usdt+0xc4>
   17daa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
   17db0: 41 89 ec                     	movl	%ebp, %r12d
   17db3: 41 f7 dc                     	negl	%r12d
   17db6: 44 89 20                     	movl	%r12d, (%rax)
   17db9: eb ea                        	jmp	0x17da5 <attach_usdt+0x135>
; }
   17dbb: e8 40 da fe ff               	callq	0x5800 <.plt.sec+0x190>

0000000000017dc0 <bpf_program__attach_tracepoint_opts>:
; {
   17dc0: f3 0f 1e fa                  	endbr64
   17dc4: 41 57                        	pushq	%r15
   17dc6: 41 56                        	pushq	%r14
   17dc8: 49 89 fe                     	movq	%rdi, %r14
   17dcb: 41 55                        	pushq	%r13
   17dcd: 49 89 f5                     	movq	%rsi, %r13
   17dd0: 41 54                        	pushq	%r12
   17dd2: 55                           	pushq	%rbp
   17dd3: 53                           	pushq	%rbx
   17dd4: 48 89 d3                     	movq	%rdx, %rbx
   17dd7: 48 81 ec 38 01 00 00         	subq	$312, %rsp              # imm = 0x138
   17dde: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   17de7: 48 89 84 24 28 01 00 00      	movq	%rax, 296(%rsp)
   17def: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   17df1: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 	DECLARE_LIBBPF_OPTS(bpf_perf_event_opts, pe_opts);
   17dfa: 48 c7 44 24 10 10 00 00 00   	movq	$16, 16(%rsp)
; 	if (!OPTS_VALID(opts, bpf_tracepoint_opts))
   17e03: 48 85 c9                     	testq	%rcx, %rcx
   17e06: 0f 84 94 00 00 00            	je	0x17ea0 <bpf_program__attach_tracepoint_opts+0xe0>
   17e0c: 4c 8b 01                     	movq	(%rcx), %r8
; 	if (user_sz < sizeof(size_t)) {
   17e0f: 49 83 f8 07                  	cmpq	$7, %r8
   17e13: 0f 86 6f 02 00 00            	jbe	0x18088 <bpf_program__attach_tracepoint_opts+0x2c8>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   17e19: 49 8d 50 f0                  	leaq	-16(%r8), %rdx
   17e1d: 48 8d 41 10                  	leaq	16(%rcx), %rax
; 	while (len > 0) {
   17e21: 48 85 d2                     	testq	%rdx, %rdx
   17e24: 0f 8e 86 01 00 00            	jle	0x17fb0 <bpf_program__attach_tracepoint_opts+0x1f0>
   17e2a: 4a 8d 14 01                  	leaq	(%rcx,%r8), %rdx
   17e2e: eb 0d                        	jmp	0x17e3d <bpf_program__attach_tracepoint_opts+0x7d>
; 		p++;
   17e30: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   17e34: 48 39 d0                     	cmpq	%rdx, %rax
   17e37: 0f 84 73 01 00 00            	je	0x17fb0 <bpf_program__attach_tracepoint_opts+0x1f0>
; 		if (*p)
   17e3d: 80 38 00                     	cmpb	$0, (%rax)
   17e40: 74 ee                        	je	0x17e30 <bpf_program__attach_tracepoint_opts+0x70>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   17e42: 48 8d 15 6d a4 01 00         	leaq	107629(%rip), %rdx      # 0x322b6 <_IO_stdin_used+0x22b6>
   17e49: 48 8d 35 c0 c1 01 00         	leaq	115136(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   17e50: 31 ff                        	xorl	%edi, %edi
   17e52: 31 c0                        	xorl	%eax, %eax
   17e54: e8 77 02 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   17e59: e8 92 d8 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   17e5e: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   17e61: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return NULL;
   17e67: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; }
   17e70: 48 8b 84 24 28 01 00 00      	movq	296(%rsp), %rax
   17e78: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   17e81: 0f 85 1e 02 00 00            	jne	0x180a5 <bpf_program__attach_tracepoint_opts+0x2e5>
   17e87: 48 81 c4 38 01 00 00         	addq	$312, %rsp              # imm = 0x138
   17e8e: 4c 89 e0                     	movq	%r12, %rax
   17e91: 5b                           	popq	%rbx
   17e92: 5d                           	popq	%rbp
   17e93: 41 5c                        	popq	%r12
   17e95: 41 5d                        	popq	%r13
   17e97: 41 5e                        	popq	%r14
   17e99: 41 5f                        	popq	%r15
   17e9b: c3                           	retq
   17e9c: 0f 1f 40 00                  	nopl	(%rax)
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   17ea0: 31 c0                        	xorl	%eax, %eax
; 	tp_id = determine_tracepoint_id(tp_category, tp_name);
   17ea2: 48 89 de                     	movq	%rbx, %rsi
   17ea5: 4c 89 ef                     	movq	%r13, %rdi
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   17ea8: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	tp_id = determine_tracepoint_id(tp_category, tp_name);
   17ead: e8 ce 21 ff ff               	callq	0xa080 <determine_tracepoint_id>
   17eb2: 48 63 e8                     	movslq	%eax, %rbp
; 	if (tp_id < 0) {
   17eb5: 85 ed                        	testl	%ebp, %ebp
   17eb7: 0f 88 0b 01 00 00            	js	0x17fc8 <bpf_program__attach_tracepoint_opts+0x208>
;   return __builtin___memset_chk (__dest, __ch, __len,
   17ebd: 48 8d 54 24 30               	leaq	48(%rsp), %rdx
   17ec2: 31 c0                        	xorl	%eax, %eax
   17ec4: b9 0e 00 00 00               	movl	$14, %ecx
; 	pfd = syscall(__NR_perf_event_open, &attr, -1 /* pid */, 0 /* cpu */,
   17ec9: 41 b9 08 00 00 00            	movl	$8, %r9d
;   return __builtin___memset_chk (__dest, __ch, __len,
   17ecf: 48 89 d7                     	movq	%rdx, %rdi
   17ed2: 48 8d 74 24 20               	leaq	32(%rsp), %rsi
; 	pfd = syscall(__NR_perf_event_open, &attr, -1 /* pid */, 0 /* cpu */,
   17ed7: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   17edd: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
;   return __builtin___memset_chk (__dest, __ch, __len,
   17ee2: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	pfd = syscall(__NR_perf_event_open, &attr, -1 /* pid */, 0 /* cpu */,
   17ee5: bf 2a 01 00 00               	movl	$298, %edi              # imm = 0x12A
; 	attr.config = tp_id;
   17eea: 48 89 6c 24 28               	movq	%rbp, 40(%rsp)
; 	attr.type = PERF_TYPE_TRACEPOINT;
   17eef: 48 b8 02 00 00 00 80 00 00 00	movabsq	$549755813890, %rax     # imm = 0x8000000002
   17ef9: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	pfd = syscall(__NR_perf_event_open, &attr, -1 /* pid */, 0 /* cpu */,
   17efe: 31 c0                        	xorl	%eax, %eax
   17f00: e8 db da fe ff               	callq	0x59e0 <.plt.sec+0x370>
   17f05: 89 c5                        	movl	%eax, %ebp
; 	if (pfd < 0) {
   17f07: 85 c0                        	testl	%eax, %eax
   17f09: 0f 88 29 01 00 00            	js	0x18038 <bpf_program__attach_tracepoint_opts+0x278>
; 	link = bpf_program__attach_perf_event_opts(prog, pfd, &pe_opts);
   17f0f: 48 8d 54 24 10               	leaq	16(%rsp), %rdx
   17f14: 89 ee                        	movl	%ebp, %esi
   17f16: 4c 89 f7                     	movq	%r14, %rdi
   17f19: e8 a2 d7 ff ff               	callq	0x156c0 <bpf_program__attach_perf_event_opts>
   17f1e: 49 89 c4                     	movq	%rax, %r12
; 	if (!IS_ERR_OR_NULL(ptr))
   17f21: 48 85 c0                     	testq	%rax, %rax
   17f24: 74 0c                        	je	0x17f32 <bpf_program__attach_tracepoint_opts+0x172>
   17f26: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   17f2c: 0f 86 3e ff ff ff            	jbe	0x17e70 <bpf_program__attach_tracepoint_opts+0xb0>
; 	errno = -err;
   17f32: e8 b9 d7 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   17f37: 49 89 c7                     	movq	%rax, %r15
; 	if (IS_ERR(ptr))
   17f3a: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   17f41: 77 5d                        	ja	0x17fa0 <bpf_program__attach_tracepoint_opts+0x1e0>
; 	return -errno;
   17f43: 44 8b 10                     	movl	(%rax), %r10d
; 	if (err) {
   17f46: 45 85 d2                     	testl	%r10d, %r10d
   17f49: 0f 84 21 ff ff ff            	je	0x17e70 <bpf_program__attach_tracepoint_opts+0xb0>
; 		close(pfd);
   17f4f: 89 ef                        	movl	%ebp, %edi
   17f51: 44 89 54 24 0c               	movl	%r10d, 12(%rsp)
; 		return libbpf_err_ptr(err);
   17f56: 45 31 e4                     	xorl	%r12d, %r12d
; 		close(pfd);
   17f59: e8 a2 d9 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	return -errno;
   17f5e: 8b 7c 24 0c                  	movl	12(%rsp), %edi
; 		pr_warn("prog '%s': failed to attach to tracepoint '%s/%s': %s\n",
   17f62: ba 80 00 00 00               	movl	$128, %edx
   17f67: 48 8d b4 24 a0 00 00 00      	leaq	160(%rsp), %rsi
; 	return -errno;
   17f6f: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to attach to tracepoint '%s/%s': %s\n",
   17f71: e8 5a 5a 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   17f76: 49 8b 16                     	movq	(%r14), %rdx
   17f79: 49 89 d8                     	movq	%rbx, %r8
   17f7c: 4c 89 e9                     	movq	%r13, %rcx
   17f7f: 49 89 c1                     	movq	%rax, %r9
   17f82: 48 8d 35 ff f6 01 00         	leaq	128767(%rip), %rsi      # 0x37688 <strs.2+0x47f8>
   17f89: 31 ff                        	xorl	%edi, %edi
   17f8b: 31 c0                        	xorl	%eax, %eax
   17f8d: e8 3e 01 ff ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   17f92: 44 8b 54 24 0c               	movl	12(%rsp), %r10d
   17f97: 45 89 17                     	movl	%r10d, (%r15)
; 		return libbpf_err_ptr(err);
   17f9a: e9 d1 fe ff ff               	jmp	0x17e70 <bpf_program__attach_tracepoint_opts+0xb0>
   17f9f: 90                           	nop
; 		errno = -PTR_ERR(ptr);
   17fa0: 45 89 e2                     	movl	%r12d, %r10d
   17fa3: 41 f7 da                     	negl	%r10d
   17fa6: 44 89 10                     	movl	%r10d, (%rax)
   17fa9: eb 9b                        	jmp	0x17f46 <bpf_program__attach_tracepoint_opts+0x186>
   17fab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	pe_opts.bpf_cookie = OPTS_GET(opts, bpf_cookie, 0);
   17fb0: 49 83 f8 0f                  	cmpq	$15, %r8
   17fb4: 0f 86 e6 fe ff ff            	jbe	0x17ea0 <bpf_program__attach_tracepoint_opts+0xe0>
   17fba: 48 8b 41 08                  	movq	8(%rcx), %rax
   17fbe: e9 df fe ff ff               	jmp	0x17ea2 <bpf_program__attach_tracepoint_opts+0xe2>
   17fc3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("failed to determine tracepoint '%s/%s' perf event ID: %s\n",
   17fc8: 4c 8d a4 24 a0 00 00 00      	leaq	160(%rsp), %r12
   17fd0: ba 80 00 00 00               	movl	$128, %edx
   17fd5: 89 ef                        	movl	%ebp, %edi
   17fd7: 4c 89 e6                     	movq	%r12, %rsi
   17fda: e8 f1 59 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   17fdf: 48 89 d9                     	movq	%rbx, %rcx
   17fe2: 4c 89 ea                     	movq	%r13, %rdx
   17fe5: 31 ff                        	xorl	%edi, %edi
   17fe7: 49 89 c0                     	movq	%rax, %r8
   17fea: 48 8d 35 c7 f5 01 00         	leaq	128455(%rip), %rsi      # 0x375b8 <strs.2+0x4728>
   17ff1: 31 c0                        	xorl	%eax, %eax
   17ff3: e8 d8 00 ff ff               	callq	0x80d0 <libbpf_print>
; 		pr_warn("prog '%s': failed to create tracepoint '%s/%s' perf event: %s\n",
   17ff8: 4c 89 e6                     	movq	%r12, %rsi
   17ffb: 89 ef                        	movl	%ebp, %edi
   17ffd: ba 80 00 00 00               	movl	$128, %edx
; 	errno = -err;
   18002: f7 dd                        	negl	%ebp
; 		pr_warn("prog '%s': failed to create tracepoint '%s/%s' perf event: %s\n",
   18004: e8 c7 59 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   18009: 49 8b 16                     	movq	(%r14), %rdx
   1800c: 49 89 d8                     	movq	%rbx, %r8
   1800f: 4c 89 e9                     	movq	%r13, %rcx
   18012: 49 89 c1                     	movq	%rax, %r9
   18015: 48 8d 35 24 f6 01 00         	leaq	128548(%rip), %rsi      # 0x37640 <strs.2+0x47b0>
   1801c: 31 ff                        	xorl	%edi, %edi
   1801e: 31 c0                        	xorl	%eax, %eax
   18020: e8 ab 00 ff ff               	callq	0x80d0 <libbpf_print>
; 		return libbpf_err_ptr(pfd);
   18025: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   18028: e8 c3 d6 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1802d: 89 28                        	movl	%ebp, (%rax)
; 		return libbpf_err_ptr(pfd);
   1802f: e9 3c fe ff ff               	jmp	0x17e70 <bpf_program__attach_tracepoint_opts+0xb0>
   18034: 0f 1f 40 00                  	nopl	(%rax)
; 		err = -errno;
   18038: e8 b3 d6 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("tracepoint '%s/%s' perf_event_open() failed: %s\n",
   1803d: 4c 8d a4 24 a0 00 00 00      	leaq	160(%rsp), %r12
   18045: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   1804a: 44 8b 38                     	movl	(%rax), %r15d
; 		pr_warn("tracepoint '%s/%s' perf_event_open() failed: %s\n",
   1804d: 4c 89 e6                     	movq	%r12, %rsi
; 		err = -errno;
   18050: 44 89 fd                     	movl	%r15d, %ebp
   18053: f7 dd                        	negl	%ebp
; 		pr_warn("tracepoint '%s/%s' perf_event_open() failed: %s\n",
   18055: 89 ef                        	movl	%ebp, %edi
   18057: e8 74 59 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1805c: 31 ff                        	xorl	%edi, %edi
   1805e: 48 89 d9                     	movq	%rbx, %rcx
   18061: 4c 89 ea                     	movq	%r13, %rdx
   18064: 49 89 c0                     	movq	%rax, %r8
   18067: 48 8d 35 92 f5 01 00         	leaq	128402(%rip), %rsi      # 0x37600 <strs.2+0x4770>
   1806e: 31 c0                        	xorl	%eax, %eax
   18070: e8 5b 00 ff ff               	callq	0x80d0 <libbpf_print>
; 	if (pfd < 0) {
   18075: 45 85 ff                     	testl	%r15d, %r15d
   18078: 0f 8e 91 fe ff ff            	jle	0x17f0f <bpf_program__attach_tracepoint_opts+0x14f>
   1807e: e9 75 ff ff ff               	jmp	0x17ff8 <bpf_program__attach_tracepoint_opts+0x238>
   18083: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   18088: 4c 89 c1                     	movq	%r8, %rcx
   1808b: 48 8d 15 24 a2 01 00         	leaq	107044(%rip), %rdx      # 0x322b6 <_IO_stdin_used+0x22b6>
   18092: 48 8d 35 1f bf 01 00         	leaq	114463(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   18099: 31 ff                        	xorl	%edi, %edi
   1809b: e8 30 00 ff ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   180a0: e9 b4 fd ff ff               	jmp	0x17e59 <bpf_program__attach_tracepoint_opts+0x99>
; }
   180a5: e8 56 d7 fe ff               	callq	0x5800 <.plt.sec+0x190>
   180aa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

00000000000180b0 <attach_tp>:
; {
   180b0: f3 0f 1e fa                  	endbr64
   180b4: 41 55                        	pushq	%r13
   180b6: 41 54                        	pushq	%r12
   180b8: 55                           	pushq	%rbp
   180b9: 48 89 fd                     	movq	%rdi, %rbp
   180bc: 53                           	pushq	%rbx
   180bd: 48 89 d3                     	movq	%rdx, %rbx
   180c0: 48 83 ec 08                  	subq	$8, %rsp
; 	if (strcmp(prog->sec_name, "tp") == 0 || strcmp(prog->sec_name, "tracepoint") == 0)
   180c4: 4c 8b 67 08                  	movq	8(%rdi), %r12
; 	*link = NULL;
   180c8: 48 c7 02 00 00 00 00         	movq	$0, (%rdx)
; 	if (strcmp(prog->sec_name, "tp") == 0 || strcmp(prog->sec_name, "tracepoint") == 0)
   180cf: 41 80 3c 24 74               	cmpb	$116, (%r12)
   180d4: 75 0c                        	jne	0x180e2 <attach_tp+0x32>
   180d6: 41 80 7c 24 01 70            	cmpb	$112, 1(%r12)
   180dc: 0f 84 ce 00 00 00            	je	0x181b0 <attach_tp+0x100>
   180e2: 48 8d 35 df a2 01 00         	leaq	107231(%rip), %rsi      # 0x323c8 <_IO_stdin_used+0x23c8>
   180e9: 4c 89 e7                     	movq	%r12, %rdi
   180ec: e8 bf d8 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   180f1: 85 c0                        	testl	%eax, %eax
   180f3: 75 0b                        	jne	0x18100 <attach_tp+0x50>
; }
   180f5: 48 83 c4 08                  	addq	$8, %rsp
   180f9: 5b                           	popq	%rbx
   180fa: 5d                           	popq	%rbp
   180fb: 41 5c                        	popq	%r12
   180fd: 41 5d                        	popq	%r13
   180ff: c3                           	retq
; 	sec_name = strdup(prog->sec_name);
   18100: 4c 89 e7                     	movq	%r12, %rdi
   18103: e8 08 db fe ff               	callq	0x5c10 <.plt.sec+0x5a0>
   18108: 49 89 c5                     	movq	%rax, %r13
; 	if (!sec_name)
   1810b: 48 85 c0                     	testq	%rax, %rax
   1810e: 0f 84 e8 00 00 00            	je	0x181fc <attach_tp+0x14c>
; 	if (str_has_pfx(prog->sec_name, "tp/"))
   18114: 41 80 3c 24 74               	cmpb	$116, (%r12)
   18119: 0f 85 b1 00 00 00            	jne	0x181d0 <attach_tp+0x120>
   1811f: 41 80 7c 24 01 70            	cmpb	$112, 1(%r12)
   18125: 0f 85 a5 00 00 00            	jne	0x181d0 <attach_tp+0x120>
   1812b: 41 80 7c 24 02 2f            	cmpb	$47, 2(%r12)
   18131: 0f 85 99 00 00 00            	jne	0x181d0 <attach_tp+0x120>
; 		tp_cat = sec_name + sizeof("tp/") - 1;
   18137: 4c 8d 60 03                  	leaq	3(%rax), %r12
; 	tp_name = strchr(tp_cat, '/');
   1813b: be 2f 00 00 00               	movl	$47, %esi
   18140: 4c 89 e7                     	movq	%r12, %rdi
   18143: e8 d8 d6 fe ff               	callq	0x5820 <.plt.sec+0x1b0>
; 	if (!tp_name) {
   18148: 48 85 c0                     	testq	%rax, %rax
   1814b: 0f 84 99 00 00 00            	je	0x181ea <attach_tp+0x13a>
; 	*tp_name = '\0';
   18151: c6 00 00                     	movb	$0, (%rax)
; 	return bpf_program__attach_tracepoint_opts(prog, tp_category, tp_name, NULL);
   18154: 48 89 ef                     	movq	%rbp, %rdi
   18157: 31 c9                        	xorl	%ecx, %ecx
; 	tp_name++;
   18159: 48 8d 50 01                  	leaq	1(%rax), %rdx
; 	return bpf_program__attach_tracepoint_opts(prog, tp_category, tp_name, NULL);
   1815d: 4c 89 e6                     	movq	%r12, %rsi
   18160: e8 5b fc ff ff               	callq	0x17dc0 <bpf_program__attach_tracepoint_opts>
; 	free(sec_name);
   18165: 4c 89 ef                     	movq	%r13, %rdi
; 	*link = bpf_program__attach_tracepoint(prog, tp_cat, tp_name);
   18168: 48 89 03                     	movq	%rax, (%rbx)
; 	return bpf_program__attach_tracepoint_opts(prog, tp_category, tp_name, NULL);
   1816b: 48 89 c5                     	movq	%rax, %rbp
; 	free(sec_name);
   1816e: e8 4d d5 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (!IS_ERR_OR_NULL(ptr))
   18173: 48 85 ed                     	testq	%rbp, %rbp
   18176: 74 0f                        	je	0x18187 <attach_tp+0xd7>
   18178: 31 c0                        	xorl	%eax, %eax
   1817a: 48 81 fd 00 f0 ff ff         	cmpq	$-4096, %rbp            # imm = 0xF000
   18181: 0f 86 6e ff ff ff            	jbe	0x180f5 <attach_tp+0x45>
; 		errno = -PTR_ERR(ptr);
   18187: e8 64 d5 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1818c: 48 89 c2                     	movq	%rax, %rdx
; 	if (IS_ERR(ptr))
   1818f: 48 81 fd 00 f0 ff ff         	cmpq	$-4096, %rbp            # imm = 0xF000
   18196: 77 48                        	ja	0x181e0 <attach_tp+0x130>
; 	return -errno;
   18198: 8b 00                        	movl	(%rax), %eax
   1819a: f7 d8                        	negl	%eax
; }
   1819c: 48 83 c4 08                  	addq	$8, %rsp
   181a0: 5b                           	popq	%rbx
   181a1: 5d                           	popq	%rbp
   181a2: 41 5c                        	popq	%r12
   181a4: 41 5d                        	popq	%r13
   181a6: c3                           	retq
   181a7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	if (strcmp(prog->sec_name, "tp") == 0 || strcmp(prog->sec_name, "tracepoint") == 0)
   181b0: 41 0f b6 44 24 02            	movzbl	2(%r12), %eax
   181b6: 85 c0                        	testl	%eax, %eax
   181b8: 0f 85 24 ff ff ff            	jne	0x180e2 <attach_tp+0x32>
; }
   181be: 48 83 c4 08                  	addq	$8, %rsp
   181c2: 5b                           	popq	%rbx
   181c3: 5d                           	popq	%rbp
   181c4: 41 5c                        	popq	%r12
   181c6: 41 5d                        	popq	%r13
   181c8: c3                           	retq
   181c9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		tp_cat = sec_name + sizeof("tracepoint/") - 1;
   181d0: 4d 8d 65 0b                  	leaq	11(%r13), %r12
   181d4: e9 62 ff ff ff               	jmp	0x1813b <attach_tp+0x8b>
   181d9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
   181e0: 89 e8                        	movl	%ebp, %eax
   181e2: f7 d8                        	negl	%eax
   181e4: 89 02                        	movl	%eax, (%rdx)
; 	return -errno;
   181e6: f7 d8                        	negl	%eax
   181e8: eb b2                        	jmp	0x1819c <attach_tp+0xec>
; 		free(sec_name);
   181ea: 4c 89 ef                     	movq	%r13, %rdi
   181ed: e8 ce d4 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		return -EINVAL;
   181f2: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   181f7: e9 f9 fe ff ff               	jmp	0x180f5 <attach_tp+0x45>
; 		return -ENOMEM;
   181fc: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   18201: e9 ef fe ff ff               	jmp	0x180f5 <attach_tp+0x45>
   18206: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000018210 <bpf_program__attach_tracepoint>:
; {
   18210: f3 0f 1e fa                  	endbr64
; 	return bpf_program__attach_tracepoint_opts(prog, tp_category, tp_name, NULL);
   18214: 31 c9                        	xorl	%ecx, %ecx
   18216: e9 a5 fb ff ff               	jmp	0x17dc0 <bpf_program__attach_tracepoint_opts>
   1821b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000018220 <bpf_program__attach_raw_tracepoint>:
; {
   18220: f3 0f 1e fa                  	endbr64
   18224: 41 56                        	pushq	%r14
   18226: 41 55                        	pushq	%r13
   18228: 41 54                        	pushq	%r12
   1822a: 55                           	pushq	%rbp
   1822b: 53                           	pushq	%rbx
   1822c: 48 89 fb                     	movq	%rdi, %rbx
   1822f: 48 81 ec 90 00 00 00         	subq	$144, %rsp
   18236: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1823f: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
   18247: 31 c0                        	xorl	%eax, %eax
; 	if (!prog)
   18249: 48 85 ff                     	testq	%rdi, %rdi
   1824c: 0f 84 ed 00 00 00            	je	0x1833f <bpf_program__attach_raw_tracepoint+0x11f>
; 	if (prog->fd < 0)
   18252: 8b 6f 78                     	movl	120(%rdi), %ebp
   18255: 85 ed                        	testl	%ebp, %ebp
   18257: 0f 88 b2 00 00 00            	js	0x1830f <bpf_program__attach_raw_tracepoint+0xef>
   1825d: 49 89 f5                     	movq	%rsi, %r13
; 	link = calloc(1, sizeof(*link));
   18260: bf 01 00 00 00               	movl	$1, %edi
   18265: be 20 00 00 00               	movl	$32, %esi
   1826a: e8 21 d7 fe ff               	callq	0x5990 <.plt.sec+0x320>
   1826f: 49 89 c4                     	movq	%rax, %r12
; 	if (!link)
   18272: 48 85 c0                     	testq	%rax, %rax
   18275: 0f 84 d9 00 00 00            	je	0x18354 <bpf_program__attach_raw_tracepoint+0x134>
; 	link->detach = &bpf_link__detach_fd;
   1827b: 48 8d 05 4e f6 fe ff         	leaq	-68018(%rip), %rax      # 0x78d0 <bpf_link__detach_fd>
; 	pfd = bpf_raw_tracepoint_open(tp_name, prog_fd);
   18282: 89 ee                        	movl	%ebp, %esi
   18284: 4c 89 ef                     	movq	%r13, %rdi
; 	link->detach = &bpf_link__detach_fd;
   18287: 49 89 04 24                  	movq	%rax, (%r12)
; 	pfd = bpf_raw_tracepoint_open(tp_name, prog_fd);
   1828b: e8 c0 f9 00 00               	callq	0x27c50 <bpf_raw_tracepoint_open>
; 	if (pfd < 0) {
   18290: 85 c0                        	testl	%eax, %eax
   18292: 78 34                        	js	0x182c8 <bpf_program__attach_raw_tracepoint+0xa8>
; 	link->fd = pfd;
   18294: 41 89 44 24 18               	movl	%eax, 24(%r12)
; }
   18299: 48 8b 84 24 88 00 00 00      	movq	136(%rsp), %rax
   182a1: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   182aa: 0f 85 9f 00 00 00            	jne	0x1834f <bpf_program__attach_raw_tracepoint+0x12f>
   182b0: 48 81 c4 90 00 00 00         	addq	$144, %rsp
   182b7: 4c 89 e0                     	movq	%r12, %rax
   182ba: 5b                           	popq	%rbx
   182bb: 5d                           	popq	%rbp
   182bc: 41 5c                        	popq	%r12
   182be: 41 5d                        	popq	%r13
   182c0: 41 5e                        	popq	%r14
   182c2: c3                           	retq
   182c3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pfd = -errno;
   182c8: e8 23 d4 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		free(link);
   182cd: 4c 89 e7                     	movq	%r12, %rdi
; 		return libbpf_err_ptr(pfd);
   182d0: 45 31 e4                     	xorl	%r12d, %r12d
; 		pfd = -errno;
   182d3: 44 8b 30                     	movl	(%rax), %r14d
   182d6: 48 89 c5                     	movq	%rax, %rbp
; 		free(link);
   182d9: e8 e2 d3 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		pr_warn("prog '%s': failed to attach to raw tracepoint '%s': %s\n",
   182de: 48 89 e6                     	movq	%rsp, %rsi
   182e1: ba 80 00 00 00               	movl	$128, %edx
; 		pfd = -errno;
   182e6: 44 89 f7                     	movl	%r14d, %edi
   182e9: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to attach to raw tracepoint '%s': %s\n",
   182eb: e8 e0 56 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   182f0: 48 8b 13                     	movq	(%rbx), %rdx
   182f3: 4c 89 e9                     	movq	%r13, %rcx
   182f6: 31 ff                        	xorl	%edi, %edi
   182f8: 49 89 c0                     	movq	%rax, %r8
   182fb: 48 8d 35 c6 f3 01 00         	leaq	127942(%rip), %rsi      # 0x376c8 <strs.2+0x4838>
   18302: 31 c0                        	xorl	%eax, %eax
   18304: e8 c7 fd fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   18309: 44 89 75 00                  	movl	%r14d, (%rbp)
; 		return libbpf_err_ptr(pfd);
   1830d: eb 8a                        	jmp	0x18299 <bpf_program__attach_raw_tracepoint+0x79>
; 		errno = -ret;
   1830f: e8 dc d3 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18314: c7 00 02 00 00 00            	movl	$2, (%rax)
   1831a: 48 89 c5                     	movq	%rax, %rbp
; 		pr_warn("prog '%s': can't attach before loaded\n", prog->name);
   1831d: 48 8b 13                     	movq	(%rbx), %rdx
   18320: 48 8d 35 11 b9 01 00         	leaq	112913(%rip), %rsi      # 0x33c38 <strs.2+0xda8>
   18327: 31 ff                        	xorl	%edi, %edi
   18329: 31 c0                        	xorl	%eax, %eax
; 		return libbpf_err_ptr(-EINVAL);
   1832b: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_warn("prog '%s': can't attach before loaded\n", prog->name);
   1832e: e8 9d fd fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   18333: c7 45 00 16 00 00 00         	movl	$22, (%rbp)
; 		return libbpf_err_ptr(-EINVAL);
   1833a: e9 5a ff ff ff               	jmp	0x18299 <bpf_program__attach_raw_tracepoint+0x79>
; 		errno = -ret;
   1833f: e8 ac d3 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18344: c7 00 16 00 00 00            	movl	$22, (%rax)
   1834a: 48 89 c5                     	movq	%rax, %rbp
   1834d: eb ce                        	jmp	0x1831d <bpf_program__attach_raw_tracepoint+0xfd>
; }
   1834f: e8 ac d4 fe ff               	callq	0x5800 <.plt.sec+0x190>
; 	errno = -err;
   18354: e8 97 d3 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18359: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err_ptr(-ENOMEM);
   1835f: e9 35 ff ff ff               	jmp	0x18299 <bpf_program__attach_raw_tracepoint+0x79>
   18364: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1836f: 90                           	nop

0000000000018370 <attach_raw_tp>:
; {
   18370: f3 0f 1e fa                  	endbr64
   18374: 41 57                        	pushq	%r15
; 		if (!str_has_pfx(prog->sec_name, prefixes[i]))
   18376: 41 bf 06 00 00 00            	movl	$6, %r15d
; {
   1837c: 41 56                        	pushq	%r14
   1837e: 41 55                        	pushq	%r13
   18380: 4c 8d 2d 59 ce 02 00         	leaq	183897(%rip), %r13      # 0x451e0 <prefixes.13>
   18387: 41 54                        	pushq	%r12
; 		if (!str_has_pfx(prog->sec_name, prefixes[i]))
   18389: 4c 8d 25 b6 a8 01 00         	leaq	108726(%rip), %r12      # 0x32c46 <_IO_stdin_used+0x2c46>
; {
   18390: 55                           	pushq	%rbp
   18391: 48 89 fd                     	movq	%rdi, %rbp
   18394: 53                           	pushq	%rbx
   18395: 48 89 d3                     	movq	%rdx, %rbx
   18398: 48 83 ec 08                  	subq	$8, %rsp
; 	*link = NULL;
   1839c: 48 c7 02 00 00 00 00         	movq	$0, (%rdx)
; 		if (!str_has_pfx(prog->sec_name, prefixes[i]))
   183a3: 4c 8b 77 08                  	movq	8(%rdi), %r14
   183a7: 4c 89 e6                     	movq	%r12, %rsi
   183aa: 4c 89 fa                     	movq	%r15, %rdx
   183ad: 4c 89 f7                     	movq	%r14, %rdi
   183b0: e8 6b d3 fe ff               	callq	0x5720 <.plt.sec+0xb0>
   183b5: 41 89 c4                     	movl	%eax, %r12d
   183b8: 85 c0                        	testl	%eax, %eax
   183ba: 75 4c                        	jne	0x18408 <attach_raw_tp+0x98>
; 		if (prog->sec_name[pfx_len] == '\0')
   183bc: 43 0f b6 04 3e               	movzbl	(%r14,%r15), %eax
   183c1: 84 c0                        	testb	%al, %al
   183c3: 74 2b                        	je	0x183f0 <attach_raw_tp+0x80>
; 		if (prog->sec_name[pfx_len] != '/')
   183c5: 3c 2f                        	cmpb	$47, %al
   183c7: 75 3f                        	jne	0x18408 <attach_raw_tp+0x98>
; 		tp_name = prog->sec_name + pfx_len + 1;
   183c9: 4b 8d 74 3e 01               	leaq	1(%r14,%r15), %rsi
; 	*link = bpf_program__attach_raw_tracepoint(prog, tp_name);
   183ce: 48 89 ef                     	movq	%rbp, %rdi
   183d1: e8 4a fe ff ff               	callq	0x18220 <bpf_program__attach_raw_tracepoint>
   183d6: 48 89 03                     	movq	%rax, (%rbx)
; 	if (!IS_ERR_OR_NULL(ptr))
   183d9: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   183e0: 76 0e                        	jbe	0x183f0 <attach_raw_tp+0x80>
; 		errno = -PTR_ERR(ptr);
   183e2: e8 09 d3 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   183e7: 89 da                        	movl	%ebx, %edx
; 	return -errno;
   183e9: 41 89 dc                     	movl	%ebx, %r12d
; 		errno = -PTR_ERR(ptr);
   183ec: f7 da                        	negl	%edx
   183ee: 89 10                        	movl	%edx, (%rax)
; }
   183f0: 48 83 c4 08                  	addq	$8, %rsp
   183f4: 44 89 e0                     	movl	%r12d, %eax
   183f7: 5b                           	popq	%rbx
   183f8: 5d                           	popq	%rbp
   183f9: 41 5c                        	popq	%r12
   183fb: 41 5d                        	popq	%r13
   183fd: 41 5e                        	popq	%r14
   183ff: 41 5f                        	popq	%r15
   18401: c3                           	retq
   18402: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	for (i = 0; i < ARRAY_SIZE(prefixes); i++) {
   18408: 49 83 c5 08                  	addq	$8, %r13
   1840c: 48 8d 05 ed cd 02 00         	leaq	183789(%rip), %rax      # 0x45200 <section_defs>
   18413: 49 39 c5                     	cmpq	%rax, %r13
   18416: 74 18                        	je	0x18430 <attach_raw_tp+0xc0>
; 		if (!str_has_pfx(prog->sec_name, prefixes[i]))
   18418: 4d 8b 65 00                  	movq	(%r13), %r12
   1841c: 4c 89 e7                     	movq	%r12, %rdi
   1841f: e8 bc d3 fe ff               	callq	0x57e0 <.plt.sec+0x170>
   18424: 49 89 c7                     	movq	%rax, %r15
   18427: e9 7b ff ff ff               	jmp	0x183a7 <attach_raw_tp+0x37>
   1842c: 0f 1f 40 00                  	nopl	(%rax)
; 		pr_warn("prog '%s': invalid section name '%s'\n",
   18430: 48 8b 55 00                  	movq	(%rbp), %rdx
   18434: 4c 89 f1                     	movq	%r14, %rcx
   18437: 48 8d 35 ca f2 01 00         	leaq	127690(%rip), %rsi      # 0x37708 <strs.2+0x4878>
   1843e: 31 ff                        	xorl	%edi, %edi
   18440: 31 c0                        	xorl	%eax, %eax
; 		return -EINVAL;
   18442: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("prog '%s': invalid section name '%s'\n",
   18448: e8 83 fc fe ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   1844d: eb a1                        	jmp	0x183f0 <attach_raw_tp+0x80>
   1844f: 90                           	nop

0000000000018450 <bpf_program__attach_trace>:
; {
   18450: f3 0f 1e fa                  	endbr64
; 	return bpf_program__attach_btf_id(prog, NULL);
   18454: 31 f6                        	xorl	%esi, %esi
   18456: e9 05 2c ff ff               	jmp	0xb060 <bpf_program__attach_btf_id>
   1845b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000018460 <bpf_program__attach_trace_opts>:
; {
   18460: f3 0f 1e fa                  	endbr64
; 	return bpf_program__attach_btf_id(prog, opts);
   18464: e9 f7 2b ff ff               	jmp	0xb060 <bpf_program__attach_btf_id>
   18469: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000018470 <bpf_program__attach_lsm>:
   18470: f3 0f 1e fa                  	endbr64
   18474: 31 f6                        	xorl	%esi, %esi
   18476: e9 e5 2b ff ff               	jmp	0xb060 <bpf_program__attach_btf_id>
   1847b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000018480 <bpf_program__attach_cgroup>:
; {
   18480: f3 0f 1e fa                  	endbr64
; 	return bpf_program__attach_fd(prog, cgroup_fd, 0, "cgroup");
   18484: 48 8d 0d c9 a8 01 00         	leaq	108745(%rip), %rcx      # 0x32d54 <_IO_stdin_used+0x2d54>
   1848b: 31 d2                        	xorl	%edx, %edx
   1848d: e9 2e 20 ff ff               	jmp	0xa4c0 <bpf_program__attach_fd>
   18492: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1849d: 0f 1f 00                     	nopl	(%rax)

00000000000184a0 <bpf_program__attach_netns>:
; {
   184a0: f3 0f 1e fa                  	endbr64
; 	return bpf_program__attach_fd(prog, netns_fd, 0, "netns");
   184a4: 48 8d 0d 1f 9e 01 00         	leaq	106015(%rip), %rcx      # 0x322ca <_IO_stdin_used+0x22ca>
   184ab: 31 d2                        	xorl	%edx, %edx
   184ad: e9 0e 20 ff ff               	jmp	0xa4c0 <bpf_program__attach_fd>
   184b2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   184bd: 0f 1f 00                     	nopl	(%rax)

00000000000184c0 <bpf_program__attach_xdp>:
; {
   184c0: f3 0f 1e fa                  	endbr64
; 	return bpf_program__attach_fd(prog, ifindex, 0, "xdp");
   184c4: 48 8d 0d 05 9e 01 00         	leaq	105989(%rip), %rcx      # 0x322d0 <_IO_stdin_used+0x22d0>
   184cb: 31 d2                        	xorl	%edx, %edx
   184cd: e9 ee 1f ff ff               	jmp	0xa4c0 <bpf_program__attach_fd>
   184d2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   184dd: 0f 1f 00                     	nopl	(%rax)

00000000000184e0 <bpf_program__attach_freplace>:
; {
   184e0: f3 0f 1e fa                  	endbr64
   184e4: 41 55                        	pushq	%r13
; 	if (!!target_fd != !!attach_func_name) {
   184e6: 85 f6                        	testl	%esi, %esi
; {
   184e8: 41 54                        	pushq	%r12
   184ea: 49 89 fc                     	movq	%rdi, %r12
   184ed: 48 89 d7                     	movq	%rdx, %rdi
; 	if (!!target_fd != !!attach_func_name) {
   184f0: 0f 95 c2                     	setne	%dl
   184f3: 48 85 ff                     	testq	%rdi, %rdi
; {
   184f6: 55                           	pushq	%rbp
; 	if (!!target_fd != !!attach_func_name) {
   184f7: 0f 95 c0                     	setne	%al
   184fa: 38 c2                        	cmpb	%al, %dl
   184fc: 75 52                        	jne	0x18550 <bpf_program__attach_freplace+0x70>
; 	if (prog->type != BPF_PROG_TYPE_EXT) {
   184fe: 41 83 bc 24 80 00 00 00 1c   	cmpl	$28, 128(%r12)
   18507: 0f 85 8b 00 00 00            	jne	0x18598 <bpf_program__attach_freplace+0xb8>
   1850d: 89 f5                        	movl	%esi, %ebp
; 	if (target_fd) {
   1850f: 85 f6                        	testl	%esi, %esi
   18511: 74 2d                        	je	0x18540 <bpf_program__attach_freplace+0x60>
; 		btf_id = libbpf_find_prog_btf_id(attach_func_name, target_fd);
   18513: e8 b8 24 ff ff               	callq	0xa9d0 <libbpf_find_prog_btf_id>
   18518: 41 89 c5                     	movl	%eax, %r13d
; 		if (btf_id < 0)
   1851b: 85 c0                        	testl	%eax, %eax
   1851d: 78 61                        	js	0x18580 <bpf_program__attach_freplace+0xa0>
; 		return bpf_program__attach_fd(prog, target_fd, btf_id, "freplace");
   1851f: 89 ee                        	movl	%ebp, %esi
   18521: 4c 89 e7                     	movq	%r12, %rdi
; }
   18524: 5d                           	popq	%rbp
; 		return bpf_program__attach_fd(prog, target_fd, btf_id, "freplace");
   18525: 89 c2                        	movl	%eax, %edx
; }
   18527: 41 5c                        	popq	%r12
; 		return bpf_program__attach_fd(prog, target_fd, btf_id, "freplace");
   18529: 48 8d 0d a4 9d 01 00         	leaq	105892(%rip), %rcx      # 0x322d4 <_IO_stdin_used+0x22d4>
; }
   18530: 41 5d                        	popq	%r13
; 		return bpf_program__attach_fd(prog, target_fd, btf_id, "freplace");
   18532: e9 89 1f ff ff               	jmp	0xa4c0 <bpf_program__attach_fd>
   18537: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; }
   18540: 5d                           	popq	%rbp
; 	return bpf_program__attach_btf_id(prog, NULL);
   18541: 4c 89 e7                     	movq	%r12, %rdi
   18544: 31 f6                        	xorl	%esi, %esi
; }
   18546: 41 5c                        	popq	%r12
   18548: 41 5d                        	popq	%r13
; 	return bpf_program__attach_btf_id(prog, NULL);
   1854a: e9 11 2b ff ff               	jmp	0xb060 <bpf_program__attach_btf_id>
   1854f: 90                           	nop
; 		pr_warn("prog '%s': supply none or both of target_fd and attach_func_name\n",
   18550: 49 8b 14 24                  	movq	(%r12), %rdx
   18554: 48 8d 35 dd f1 01 00         	leaq	127453(%rip), %rsi      # 0x37738 <strs.2+0x48a8>
; 		pr_warn("prog '%s': only BPF_PROG_TYPE_EXT can attach as freplace",
   1855b: 31 ff                        	xorl	%edi, %edi
   1855d: 31 c0                        	xorl	%eax, %eax
   1855f: e8 6c fb fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   18564: e8 87 d1 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18569: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   1856f: 31 c0                        	xorl	%eax, %eax
   18571: 5d                           	popq	%rbp
   18572: 41 5c                        	popq	%r12
   18574: 41 5d                        	popq	%r13
   18576: c3                           	retq
   18577: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	errno = -err;
   18580: e8 6b d1 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18585: 41 f7 dd                     	negl	%r13d
   18588: 44 89 28                     	movl	%r13d, (%rax)
; }
   1858b: 31 c0                        	xorl	%eax, %eax
   1858d: 5d                           	popq	%rbp
   1858e: 41 5c                        	popq	%r12
   18590: 41 5d                        	popq	%r13
   18592: c3                           	retq
   18593: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("prog '%s': only BPF_PROG_TYPE_EXT can attach as freplace",
   18598: 49 8b 14 24                  	movq	(%r12), %rdx
   1859c: 48 8d 35 e5 f1 01 00         	leaq	127461(%rip), %rsi      # 0x37788 <strs.2+0x48f8>
   185a3: eb b6                        	jmp	0x1855b <bpf_program__attach_freplace+0x7b>
   185a5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

00000000000185b0 <bpf_program__attach_iter>:
; {
   185b0: f3 0f 1e fa                  	endbr64
   185b4: 41 55                        	pushq	%r13
; 	DECLARE_LIBBPF_OPTS(bpf_link_create_opts, link_create_opts);
   185b6: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   185ba: 41 54                        	pushq	%r12
   185bc: 55                           	pushq	%rbp
   185bd: 53                           	pushq	%rbx
   185be: 48 89 fb                     	movq	%rdi, %rbx
   185c1: 48 81 ec 18 01 00 00         	subq	$280, %rsp              # imm = 0x118
   185c8: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   185d1: 48 89 84 24 08 01 00 00      	movq	%rax, 264(%rsp)
   185d9: 31 c0                        	xorl	%eax, %eax
; 	DECLARE_LIBBPF_OPTS(bpf_link_create_opts, link_create_opts);
   185db: 0f 11 44 24 48               	movups	%xmm0, 72(%rsp)
   185e0: 0f 11 44 24 58               	movups	%xmm0, 88(%rsp)
   185e5: 66 0f 6f 54 24 50            	movdqa	80(%rsp), %xmm2
   185eb: 0f 11 44 24 68               	movups	%xmm0, 104(%rsp)
   185f0: 66 0f 6f 5c 24 60            	movdqa	96(%rsp), %xmm3
   185f6: 48 c7 44 24 78 00 00 00 00   	movq	$0, 120(%rsp)
   185ff: 66 0f 6f 64 24 70            	movdqa	112(%rsp), %xmm4
   18605: 48 c7 44 24 40 40 00 00 00   	movq	$64, 64(%rsp)
   1860e: 66 0f 6f 4c 24 40            	movdqa	64(%rsp), %xmm1
   18614: 0f 29 54 24 10               	movaps	%xmm2, 16(%rsp)
   18619: 0f 29 0c 24                  	movaps	%xmm1, (%rsp)
   1861d: 0f 29 5c 24 20               	movaps	%xmm3, 32(%rsp)
   18622: 0f 29 64 24 30               	movaps	%xmm4, 48(%rsp)
; 	if (!OPTS_VALID(opts, bpf_iter_attach_opts))
   18627: 48 85 f6                     	testq	%rsi, %rsi
   1862a: 74 64                        	je	0x18690 <bpf_program__attach_iter+0xe0>
   1862c: 48 8b 0e                     	movq	(%rsi), %rcx
; 	if (user_sz < sizeof(size_t)) {
   1862f: 48 83 f9 07                  	cmpq	$7, %rcx
   18633: 0f 86 07 01 00 00            	jbe	0x18740 <bpf_program__attach_iter+0x190>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   18639: 48 8d 51 ec                  	leaq	-20(%rcx), %rdx
   1863d: 48 8d 46 14                  	leaq	20(%rsi), %rax
; 	while (len > 0) {
   18641: 48 85 d2                     	testq	%rdx, %rdx
   18644: 0f 8e ce 00 00 00            	jle	0x18718 <bpf_program__attach_iter+0x168>
   1864a: 48 8d 14 0e                  	leaq	(%rsi,%rcx), %rdx
   1864e: eb 0d                        	jmp	0x1865d <bpf_program__attach_iter+0xad>
; 		p++;
   18650: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   18654: 48 39 d0                     	cmpq	%rdx, %rax
   18657: 0f 84 bb 00 00 00            	je	0x18718 <bpf_program__attach_iter+0x168>
; 		if (*p)
   1865d: 80 38 00                     	cmpb	$0, (%rax)
   18660: 74 ee                        	je	0x18650 <bpf_program__attach_iter+0xa0>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   18662: 48 8d 15 74 9c 01 00         	leaq	105588(%rip), %rdx      # 0x322dd <_IO_stdin_used+0x22dd>
   18669: 48 8d 35 a0 b9 01 00         	leaq	113056(%rip), %rsi      # 0x34010 <strs.2+0x1180>
   18670: 31 ff                        	xorl	%edi, %edi
   18672: 31 c0                        	xorl	%eax, %eax
   18674: e8 57 fa fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   18679: e8 72 d0 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   1867e: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   18681: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
   18687: eb 61                        	jmp	0x186ea <bpf_program__attach_iter+0x13a>
   18689: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	link_create_opts.iter_info_len = OPTS_GET(opts, link_info_len, 0);
   18690: 31 c0                        	xorl	%eax, %eax
   18692: 89 44 24 18                  	movl	%eax, 24(%rsp)
; 	if (!prog)
   18696: 48 85 db                     	testq	%rbx, %rbx
   18699: 0f 84 3d 01 00 00            	je	0x187dc <bpf_program__attach_iter+0x22c>
; 	if (prog->fd < 0)
   1869f: 8b 6b 78                     	movl	120(%rbx), %ebp
   186a2: 85 ed                        	testl	%ebp, %ebp
   186a4: 0f 88 02 01 00 00            	js	0x187ac <bpf_program__attach_iter+0x1fc>
; 	link = calloc(1, sizeof(*link));
   186aa: be 20 00 00 00               	movl	$32, %esi
   186af: bf 01 00 00 00               	movl	$1, %edi
   186b4: e8 d7 d2 fe ff               	callq	0x5990 <.plt.sec+0x320>
   186b9: 49 89 c4                     	movq	%rax, %r12
; 	if (!link)
   186bc: 48 85 c0                     	testq	%rax, %rax
   186bf: 0f 84 2c 01 00 00            	je	0x187f1 <bpf_program__attach_iter+0x241>
; 	link->detach = &bpf_link__detach_fd;
   186c5: 48 8d 05 04 f2 fe ff         	leaq	-69116(%rip), %rax      # 0x78d0 <bpf_link__detach_fd>
; 	link_fd = bpf_link_create(prog_fd, target_fd, BPF_TRACE_ITER,
   186cc: 31 f6                        	xorl	%esi, %esi
   186ce: 48 89 e1                     	movq	%rsp, %rcx
   186d1: 89 ef                        	movl	%ebp, %edi
; 	link->detach = &bpf_link__detach_fd;
   186d3: 49 89 04 24                  	movq	%rax, (%r12)
; 	link_fd = bpf_link_create(prog_fd, target_fd, BPF_TRACE_ITER,
   186d7: ba 1c 00 00 00               	movl	$28, %edx
   186dc: e8 6f f6 00 00               	callq	0x27d50 <bpf_link_create>
; 	if (link_fd < 0) {
   186e1: 85 c0                        	testl	%eax, %eax
   186e3: 78 7b                        	js	0x18760 <bpf_program__attach_iter+0x1b0>
; 	link->fd = link_fd;
   186e5: 41 89 44 24 18               	movl	%eax, 24(%r12)
; }
   186ea: 48 8b 84 24 08 01 00 00      	movq	264(%rsp), %rax
   186f2: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   186fb: 0f 85 eb 00 00 00            	jne	0x187ec <bpf_program__attach_iter+0x23c>
   18701: 48 81 c4 18 01 00 00         	addq	$280, %rsp              # imm = 0x118
   18708: 4c 89 e0                     	movq	%r12, %rax
   1870b: 5b                           	popq	%rbx
   1870c: 5d                           	popq	%rbp
   1870d: 41 5c                        	popq	%r12
   1870f: 41 5d                        	popq	%r13
   18711: c3                           	retq
   18712: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	link_create_opts.iter_info = OPTS_GET(opts, link_info, (void *)0);
   18718: 31 c0                        	xorl	%eax, %eax
   1871a: 48 83 f9 0f                  	cmpq	$15, %rcx
   1871e: 76 04                        	jbe	0x18724 <bpf_program__attach_iter+0x174>
   18720: 48 8b 46 08                  	movq	8(%rsi), %rax
   18724: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	link_create_opts.iter_info_len = OPTS_GET(opts, link_info_len, 0);
   18729: 48 83 f9 13                  	cmpq	$19, %rcx
   1872d: 0f 86 5d ff ff ff            	jbe	0x18690 <bpf_program__attach_iter+0xe0>
   18733: 8b 46 10                     	movl	16(%rsi), %eax
   18736: e9 57 ff ff ff               	jmp	0x18692 <bpf_program__attach_iter+0xe2>
   1873b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   18740: 48 8d 15 96 9b 01 00         	leaq	105366(%rip), %rdx      # 0x322dd <_IO_stdin_used+0x22dd>
   18747: 48 8d 35 6a b8 01 00         	leaq	112746(%rip), %rsi      # 0x33fb8 <strs.2+0x1128>
   1874e: 31 ff                        	xorl	%edi, %edi
   18750: 31 c0                        	xorl	%eax, %eax
   18752: e8 79 f9 fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   18757: e9 1d ff ff ff               	jmp	0x18679 <bpf_program__attach_iter+0xc9>
   1875c: 0f 1f 40 00                  	nopl	(%rax)
; 		link_fd = -errno;
   18760: e8 8b cf fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		free(link);
   18765: 4c 89 e7                     	movq	%r12, %rdi
; 		return libbpf_err_ptr(link_fd);
   18768: 45 31 e4                     	xorl	%r12d, %r12d
; 		link_fd = -errno;
   1876b: 44 8b 28                     	movl	(%rax), %r13d
   1876e: 48 89 c5                     	movq	%rax, %rbp
; 		free(link);
   18771: e8 4a cf fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		pr_warn("prog '%s': failed to attach to iterator: %s\n",
   18776: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
   1877e: ba 80 00 00 00               	movl	$128, %edx
; 		link_fd = -errno;
   18783: 44 89 ef                     	movl	%r13d, %edi
   18786: f7 df                        	negl	%edi
; 		pr_warn("prog '%s': failed to attach to iterator: %s\n",
   18788: e8 43 52 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1878d: 48 8b 13                     	movq	(%rbx), %rdx
   18790: 48 8d 35 39 f0 01 00         	leaq	127033(%rip), %rsi      # 0x377d0 <strs.2+0x4940>
   18797: 31 ff                        	xorl	%edi, %edi
   18799: 48 89 c1                     	movq	%rax, %rcx
   1879c: 31 c0                        	xorl	%eax, %eax
   1879e: e8 2d f9 fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   187a3: 44 89 6d 00                  	movl	%r13d, (%rbp)
; 		return libbpf_err_ptr(link_fd);
   187a7: e9 3e ff ff ff               	jmp	0x186ea <bpf_program__attach_iter+0x13a>
; 		errno = -ret;
   187ac: e8 3f cf fe ff               	callq	0x56f0 <.plt.sec+0x80>
   187b1: c7 00 02 00 00 00            	movl	$2, (%rax)
   187b7: 48 89 c5                     	movq	%rax, %rbp
; 		pr_warn("prog '%s': can't attach before loaded\n", prog->name);
   187ba: 48 8b 13                     	movq	(%rbx), %rdx
   187bd: 48 8d 35 74 b4 01 00         	leaq	111732(%rip), %rsi      # 0x33c38 <strs.2+0xda8>
   187c4: 31 ff                        	xorl	%edi, %edi
   187c6: 31 c0                        	xorl	%eax, %eax
; 		return libbpf_err_ptr(-EINVAL);
   187c8: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_warn("prog '%s': can't attach before loaded\n", prog->name);
   187cb: e8 00 f9 fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   187d0: c7 45 00 16 00 00 00         	movl	$22, (%rbp)
; 		return libbpf_err_ptr(-EINVAL);
   187d7: e9 0e ff ff ff               	jmp	0x186ea <bpf_program__attach_iter+0x13a>
; 		errno = -ret;
   187dc: e8 0f cf fe ff               	callq	0x56f0 <.plt.sec+0x80>
   187e1: c7 00 16 00 00 00            	movl	$22, (%rax)
   187e7: 48 89 c5                     	movq	%rax, %rbp
   187ea: eb ce                        	jmp	0x187ba <bpf_program__attach_iter+0x20a>
; }
   187ec: e8 0f d0 fe ff               	callq	0x5800 <.plt.sec+0x190>
; 	errno = -err;
   187f1: e8 fa ce fe ff               	callq	0x56f0 <.plt.sec+0x80>
   187f6: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err_ptr(-ENOMEM);
   187fc: e9 e9 fe ff ff               	jmp	0x186ea <bpf_program__attach_iter+0x13a>
   18801: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1880c: 0f 1f 40 00                  	nopl	(%rax)

0000000000018810 <attach_iter>:
; {
   18810: f3 0f 1e fa                  	endbr64
   18814: 55                           	pushq	%rbp
; 	*link = bpf_program__attach_iter(prog, NULL);
   18815: 31 f6                        	xorl	%esi, %esi
; {
   18817: 48 89 d5                     	movq	%rdx, %rbp
   1881a: 53                           	pushq	%rbx
   1881b: 48 83 ec 08                  	subq	$8, %rsp
; 	*link = bpf_program__attach_iter(prog, NULL);
   1881f: e8 8c fd ff ff               	callq	0x185b0 <bpf_program__attach_iter>
   18824: 48 89 45 00                  	movq	%rax, (%rbp)
   18828: 48 89 c3                     	movq	%rax, %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
   1882b: 48 85 c0                     	testq	%rax, %rax
   1882e: 74 18                        	je	0x18848 <attach_iter+0x38>
   18830: 31 c0                        	xorl	%eax, %eax
   18832: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   18839: 77 0d                        	ja	0x18848 <attach_iter+0x38>
; }
   1883b: 48 83 c4 08                  	addq	$8, %rsp
   1883f: 5b                           	popq	%rbx
   18840: 5d                           	popq	%rbp
   18841: c3                           	retq
   18842: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
   18848: e8 a3 ce fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1884d: 48 89 c2                     	movq	%rax, %rdx
; 	if (IS_ERR(ptr))
   18850: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   18857: 76 17                        	jbe	0x18870 <attach_iter+0x60>
; 		errno = -PTR_ERR(ptr);
   18859: 89 d8                        	movl	%ebx, %eax
   1885b: f7 d8                        	negl	%eax
   1885d: 89 02                        	movl	%eax, (%rdx)
; 	return -errno;
   1885f: f7 d8                        	negl	%eax
; }
   18861: 48 83 c4 08                  	addq	$8, %rsp
   18865: 5b                           	popq	%rbx
   18866: 5d                           	popq	%rbp
   18867: c3                           	retq
   18868: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	return -errno;
   18870: 8b 00                        	movl	(%rax), %eax
   18872: f7 d8                        	negl	%eax
   18874: eb eb                        	jmp	0x18861 <attach_iter+0x51>
   18876: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000018880 <bpf_program__attach>:
; {
   18880: f3 0f 1e fa                  	endbr64
   18884: 41 54                        	pushq	%r12
   18886: 53                           	pushq	%rbx
   18887: 48 83 ec 18                  	subq	$24, %rsp
   1888b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   18894: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   18899: 31 c0                        	xorl	%eax, %eax
; 	if (!prog->sec_def || !prog->sec_def->prog_attach_fn)
   1889b: 48 8b 47 18                  	movq	24(%rdi), %rax
; 	struct bpf_link *link = NULL;
   1889f: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
; 	if (!prog->sec_def || !prog->sec_def->prog_attach_fn)
   188a7: 48 85 c0                     	testq	%rax, %rax
   188aa: 74 44                        	je	0x188f0 <bpf_program__attach+0x70>
   188ac: 48 8b 48 30                  	movq	48(%rax), %rcx
   188b0: 48 85 c9                     	testq	%rcx, %rcx
   188b3: 74 3b                        	je	0x188f0 <bpf_program__attach+0x70>
; 	err = prog->sec_def->prog_attach_fn(prog, prog->sec_def->cookie, &link);
   188b5: 48 8b 70 10                  	movq	16(%rax), %rsi
   188b9: 48 89 e2                     	movq	%rsp, %rdx
   188bc: ff d1                        	callq	*%rcx
   188be: 89 c3                        	movl	%eax, %ebx
; 	if (err)
   188c0: 85 c0                        	testl	%eax, %eax
   188c2: 75 3c                        	jne	0x18900 <bpf_program__attach+0x80>
; 	if (!link)
   188c4: 4c 8b 24 24                  	movq	(%rsp), %r12
   188c8: 4d 85 e4                     	testq	%r12, %r12
   188cb: 74 43                        	je	0x18910 <bpf_program__attach+0x90>
; }
   188cd: 48 8b 44 24 08               	movq	8(%rsp), %rax
   188d2: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   188db: 75 40                        	jne	0x1891d <bpf_program__attach+0x9d>
   188dd: 48 83 c4 18                  	addq	$24, %rsp
   188e1: 4c 89 e0                     	movq	%r12, %rax
   188e4: 5b                           	popq	%rbx
   188e5: 41 5c                        	popq	%r12
   188e7: c3                           	retq
   188e8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	errno = -err;
   188f0: e8 fb cd fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EOPNOTSUPP);
   188f5: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   188f8: c7 00 5f 00 00 00            	movl	$95, (%rax)
; 		return libbpf_err_ptr(-EOPNOTSUPP);
   188fe: eb cd                        	jmp	0x188cd <bpf_program__attach+0x4d>
; 	errno = -err;
   18900: e8 eb cd fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18905: f7 db                        	negl	%ebx
; 		return libbpf_err_ptr(err);
   18907: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   1890a: 89 18                        	movl	%ebx, (%rax)
; 		return libbpf_err_ptr(err);
   1890c: eb bf                        	jmp	0x188cd <bpf_program__attach+0x4d>
   1890e: 66 90                        	nop
; 	errno = -err;
   18910: e8 db cd fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18915: c7 00 5f 00 00 00            	movl	$95, (%rax)
; 		return libbpf_err_ptr(-EOPNOTSUPP);
   1891b: eb b0                        	jmp	0x188cd <bpf_program__attach+0x4d>
; }
   1891d: e8 de ce fe ff               	callq	0x5800 <.plt.sec+0x190>
   18922: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1892d: 0f 1f 00                     	nopl	(%rax)

0000000000018930 <bpf_map__attach_struct_ops>:
; {
   18930: f3 0f 1e fa                  	endbr64
   18934: 41 57                        	pushq	%r15
   18936: 41 56                        	pushq	%r14
   18938: 41 55                        	pushq	%r13
   1893a: 41 54                        	pushq	%r12
   1893c: 55                           	pushq	%rbp
   1893d: 53                           	pushq	%rbx
   1893e: 48 83 ec 28                  	subq	$40, %rsp
   18942: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1894b: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   18950: 31 c0                        	xorl	%eax, %eax
; 	if (!bpf_map__is_struct_ops(map) || map->fd == -1)
   18952: 83 7f 30 1a                  	cmpl	$26, 48(%rdi)
; 	__u32 i, zero = 0;
   18956: c7 44 24 14 00 00 00 00      	movl	$0, 20(%rsp)
; 	if (!bpf_map__is_struct_ops(map) || map->fd == -1)
   1895e: 0f 85 cc 00 00 00            	jne	0x18a30 <bpf_map__attach_struct_ops+0x100>
   18964: 44 8b 77 18                  	movl	24(%rdi), %r14d
   18968: 48 89 fd                     	movq	%rdi, %rbp
   1896b: 41 83 fe ff                  	cmpl	$-1, %r14d
   1896f: 0f 84 bb 00 00 00            	je	0x18a30 <bpf_map__attach_struct_ops+0x100>
; 	link = calloc(1, sizeof(*link));
   18975: be 20 00 00 00               	movl	$32, %esi
   1897a: bf 01 00 00 00               	movl	$1, %edi
   1897f: e8 0c d0 fe ff               	callq	0x5990 <.plt.sec+0x320>
   18984: 49 89 c4                     	movq	%rax, %r12
; 	if (!link)
   18987: 48 85 c0                     	testq	%rax, %rax
   1898a: 0f 84 e6 00 00 00            	je	0x18a76 <bpf_map__attach_struct_ops+0x146>
; 	st_ops = map->st_ops;
   18990: 4c 8b 6d 68                  	movq	104(%rbp), %r13
; 	for (i = 0; i < btf_vlen(st_ops->type); i++) {
   18994: 49 8b 75 08                  	movq	8(%r13), %rsi
; 	err = bpf_map_update_elem(map->fd, &zero, st_ops->kern_vdata, 0);
   18998: 4d 8b 7d 28                  	movq	40(%r13), %r15
; 	for (i = 0; i < btf_vlen(st_ops->type); i++) {
   1899c: 8b 4e 04                     	movl	4(%rsi), %ecx
   1899f: 66 85 c9                     	testw	%cx, %cx
   189a2: 74 3b                        	je	0x189df <bpf_map__attach_struct_ops+0xaf>
; 		struct bpf_program *prog = st_ops->progs[i];
   189a4: 4d 8b 75 10                  	movq	16(%r13), %r14
   189a8: 31 db                        	xorl	%ebx, %ebx
   189aa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   189b0: 49 8b 04 de                  	movq	(%r14,%rbx,8), %rax
; 		if (!prog)
   189b4: 48 85 c0                     	testq	%rax, %rax
   189b7: 74 17                        	je	0x189d0 <bpf_map__attach_struct_ops+0xa0>
; 	if (prog->fd < 0)
   189b9: 48 63 40 78                  	movslq	120(%rax), %rax
   189bd: 85 c0                        	testl	%eax, %eax
   189bf: 0f 88 88 00 00 00            	js	0x18a4d <bpf_map__attach_struct_ops+0x11d>
; 		kern_data = st_ops->kern_vdata + st_ops->kern_func_off[i];
   189c5: 49 8b 55 18                  	movq	24(%r13), %rdx
   189c9: 8b 14 9a                     	movl	(%rdx,%rbx,4), %edx
; 		*(unsigned long *)kern_data = prog_fd;
   189cc: 49 89 04 17                  	movq	%rax, (%r15,%rdx)
; 	for (i = 0; i < btf_vlen(st_ops->type); i++) {
   189d0: 48 83 c3 01                  	addq	$1, %rbx
   189d4: 0f b7 c1                     	movzwl	%cx, %eax
   189d7: 39 d8                        	cmpl	%ebx, %eax
   189d9: 77 d5                        	ja	0x189b0 <bpf_map__attach_struct_ops+0x80>
; 	err = bpf_map_update_elem(map->fd, &zero, st_ops->kern_vdata, 0);
   189db: 44 8b 75 18                  	movl	24(%rbp), %r14d
   189df: 31 c9                        	xorl	%ecx, %ecx
   189e1: 48 8d 74 24 14               	leaq	20(%rsp), %rsi
   189e6: 4c 89 fa                     	movq	%r15, %rdx
   189e9: 44 89 f7                     	movl	%r14d, %edi
   189ec: e8 ff d9 00 00               	callq	0x263f0 <bpf_map_update_elem>
; 	if (err) {
   189f1: 85 c0                        	testl	%eax, %eax
   189f3: 75 4b                        	jne	0x18a40 <bpf_map__attach_struct_ops+0x110>
; 	link->detach = bpf_link__detach_struct_ops;
   189f5: 48 8d 05 64 eb fe ff         	leaq	-70812(%rip), %rax      # 0x7560 <bpf_link__detach_struct_ops>
   189fc: 49 89 04 24                  	movq	%rax, (%r12)
; 	link->fd = map->fd;
   18a00: 8b 45 18                     	movl	24(%rbp), %eax
   18a03: 41 89 44 24 18               	movl	%eax, 24(%r12)
; }
   18a08: 48 8b 44 24 18               	movq	24(%rsp), %rax
   18a0d: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   18a16: 75 59                        	jne	0x18a71 <bpf_map__attach_struct_ops+0x141>
   18a18: 48 83 c4 28                  	addq	$40, %rsp
   18a1c: 4c 89 e0                     	movq	%r12, %rax
   18a1f: 5b                           	popq	%rbx
   18a20: 5d                           	popq	%rbp
   18a21: 41 5c                        	popq	%r12
   18a23: 41 5d                        	popq	%r13
   18a25: 41 5e                        	popq	%r14
   18a27: 41 5f                        	popq	%r15
   18a29: c3                           	retq
   18a2a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	errno = -err;
   18a30: e8 bb cc fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   18a35: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   18a38: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
   18a3e: eb c8                        	jmp	0x18a08 <bpf_map__attach_struct_ops+0xd8>
; 		free(link);
   18a40: 4c 89 e7                     	movq	%r12, %rdi
; 		return libbpf_err_ptr(err);
   18a43: 45 31 e4                     	xorl	%r12d, %r12d
; 		free(link);
   18a46: e8 75 cc fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		return libbpf_err_ptr(err);
   18a4b: eb bb                        	jmp	0x18a08 <bpf_map__attach_struct_ops+0xd8>
   18a4d: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 		errno = -ret;
   18a52: e8 99 cc fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18a57: 48 8b 74 24 08               	movq	8(%rsp), %rsi
   18a5c: c7 00 02 00 00 00            	movl	$2, (%rax)
   18a62: 48 c7 c0 fe ff ff ff         	movq	$-2, %rax
   18a69: 8b 4e 04                     	movl	4(%rsi), %ecx
   18a6c: e9 54 ff ff ff               	jmp	0x189c5 <bpf_map__attach_struct_ops+0x95>
; }
   18a71: e8 8a cd fe ff               	callq	0x5800 <.plt.sec+0x190>
; 	errno = -err;
   18a76: e8 75 cc fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18a7b: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
   18a81: eb 85                        	jmp	0x18a08 <bpf_map__attach_struct_ops+0xd8>
   18a83: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   18a8e: 66 90                        	nop

0000000000018a90 <perf_buffer__free>:
; {
   18a90: f3 0f 1e fa                  	endbr64
; 	if (IS_ERR_OR_NULL(pb))
   18a94: 48 85 ff                     	testq	%rdi, %rdi
   18a97: 0f 84 8b 00 00 00            	je	0x18b28 <perf_buffer__free+0x98>
; {
   18a9d: 41 54                        	pushq	%r12
   18a9f: 55                           	pushq	%rbp
   18aa0: 48 89 fd                     	movq	%rdi, %rbp
   18aa3: 53                           	pushq	%rbx
; 	if (IS_ERR_OR_NULL(pb))
   18aa4: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   18aab: 77 73                        	ja	0x18b20 <perf_buffer__free+0x90>
; 	if (pb->cpu_bufs) {
   18aad: 48 8b 7f 30                  	movq	48(%rdi), %rdi
   18ab1: 48 85 ff                     	testq	%rdi, %rdi
   18ab4: 74 3d                        	je	0x18af3 <perf_buffer__free+0x63>
; 		for (i = 0; i < pb->cpu_cnt; i++) {
   18ab6: 8b 45 40                     	movl	64(%rbp), %eax
   18ab9: 85 c0                        	testl	%eax, %eax
   18abb: 7e 31                        	jle	0x18aee <perf_buffer__free+0x5e>
   18abd: 31 db                        	xorl	%ebx, %ebx
   18abf: 90                           	nop
; 			struct perf_cpu_buf *cpu_buf = pb->cpu_bufs[i];
   18ac0: 4c 8b 24 df                  	movq	(%rdi,%rbx,8), %r12
; 			if (!cpu_buf)
   18ac4: 4d 85 e4                     	testq	%r12, %r12
   18ac7: 74 1c                        	je	0x18ae5 <perf_buffer__free+0x55>
; 			bpf_map_delete_elem(pb->map_fd, &cpu_buf->map_key);
   18ac9: 8b 7d 48                     	movl	72(%rbp), %edi
   18acc: 49 8d 74 24 28               	leaq	40(%r12), %rsi
   18ad1: e8 ea db 00 00               	callq	0x266c0 <bpf_map_delete_elem>
; 			perf_buffer__free_cpu_buf(pb, cpu_buf);
   18ad6: 48 89 ef                     	movq	%rbp, %rdi
   18ad9: 4c 89 e6                     	movq	%r12, %rsi
   18adc: e8 af 16 ff ff               	callq	0xa190 <perf_buffer__free_cpu_buf>
; 		free(pb->cpu_bufs);
   18ae1: 48 8b 7d 30                  	movq	48(%rbp), %rdi
; 		for (i = 0; i < pb->cpu_cnt; i++) {
   18ae5: 48 83 c3 01                  	addq	$1, %rbx
   18ae9: 39 5d 40                     	cmpl	%ebx, 64(%rbp)
   18aec: 7f d2                        	jg	0x18ac0 <perf_buffer__free+0x30>
; 		free(pb->cpu_bufs);
   18aee: e8 cd cb fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (pb->epoll_fd >= 0)
   18af3: 8b 7d 44                     	movl	68(%rbp), %edi
   18af6: 85 ff                        	testl	%edi, %edi
   18af8: 79 16                        	jns	0x18b10 <perf_buffer__free+0x80>
; 	free(pb->events);
   18afa: 48 8b 7d 38                  	movq	56(%rbp), %rdi
   18afe: e8 bd cb fe ff               	callq	0x56c0 <.plt.sec+0x50>
; }
   18b03: 5b                           	popq	%rbx
; 	free(pb);
   18b04: 48 89 ef                     	movq	%rbp, %rdi
; }
   18b07: 5d                           	popq	%rbp
   18b08: 41 5c                        	popq	%r12
; 	free(pb);
   18b0a: e9 b1 cb fe ff               	jmp	0x56c0 <.plt.sec+0x50>
   18b0f: 90                           	nop
; 		close(pb->epoll_fd);
   18b10: e8 eb cd fe ff               	callq	0x5900 <.plt.sec+0x290>
   18b15: eb e3                        	jmp	0x18afa <perf_buffer__free+0x6a>
   18b17: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; }
   18b20: 5b                           	popq	%rbx
   18b21: 5d                           	popq	%rbp
   18b22: 41 5c                        	popq	%r12
   18b24: c3                           	retq
   18b25: 0f 1f 00                     	nopl	(%rax)
   18b28: c3                           	retq
   18b29: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000018b30 <perf_buffer__epoll_fd>:
; {
   18b30: f3 0f 1e fa                  	endbr64
; 	return pb->epoll_fd;
   18b34: 8b 47 44                     	movl	68(%rdi), %eax
; }
   18b37: c3                           	retq
   18b38: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000018b40 <perf_buffer__poll>:
; {
   18b40: f3 0f 1e fa                  	endbr64
   18b44: 41 56                        	pushq	%r14
   18b46: 89 f1                        	movl	%esi, %ecx
   18b48: 41 55                        	pushq	%r13
   18b4a: 41 54                        	pushq	%r12
   18b4c: 49 89 fc                     	movq	%rdi, %r12
   18b4f: 55                           	pushq	%rbp
   18b50: 53                           	pushq	%rbx
; 	cnt = epoll_wait(pb->epoll_fd, pb->events, pb->cpu_cnt, timeout_ms);
   18b51: 8b 57 40                     	movl	64(%rdi), %edx
   18b54: 48 8b 77 38                  	movq	56(%rdi), %rsi
   18b58: 8b 7f 44                     	movl	68(%rdi), %edi
   18b5b: e8 f0 cf fe ff               	callq	0x5b50 <.plt.sec+0x4e0>
; 	if (cnt < 0)
   18b60: 85 c0                        	testl	%eax, %eax
   18b62: 78 6c                        	js	0x18bd0 <perf_buffer__poll+0x90>
   18b64: 41 89 c6                     	movl	%eax, %r14d
; 	for (i = 0; i < cnt; i++) {
   18b67: 74 58                        	je	0x18bc1 <perf_buffer__poll+0x81>
   18b69: 48 98                        	cltq
   18b6b: 31 ed                        	xorl	%ebp, %ebp
   18b6d: 4c 8d 2c 40                  	leaq	(%rax,%rax,2), %r13
   18b71: 49 c1 e5 02                  	shlq	$2, %r13
   18b75: eb 12                        	jmp	0x18b89 <perf_buffer__poll+0x49>
   18b77: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
   18b80: 48 83 c5 0c                  	addq	$12, %rbp
   18b84: 4c 39 ed                     	cmpq	%r13, %rbp
   18b87: 74 38                        	je	0x18bc1 <perf_buffer__poll+0x81>
; 		struct perf_cpu_buf *cpu_buf = pb->events[i].data.ptr;
   18b89: 49 8b 44 24 38               	movq	56(%r12), %rax
; 		err = perf_buffer__process_records(pb, cpu_buf);
   18b8e: 49 8b 74 24 28               	movq	40(%r12), %rsi
   18b93: 49 8b 7c 24 20               	movq	32(%r12), %rdi
   18b98: 48 8b 54 28 04               	movq	4(%rax,%rbp), %rdx
   18b9d: e8 7e 16 ff ff               	callq	0xa220 <perf_buffer__process_records.isra.0>
   18ba2: 89 c3                        	movl	%eax, %ebx
; 		if (err) {
   18ba4: 85 c0                        	testl	%eax, %eax
   18ba6: 74 d8                        	je	0x18b80 <perf_buffer__poll+0x40>
; 			pr_warn("error while processing records: %d\n", err);
   18ba8: 89 c2                        	movl	%eax, %edx
   18baa: 48 8d 35 57 ec 01 00         	leaq	126039(%rip), %rsi      # 0x37808 <strs.2+0x4978>
   18bb1: 31 ff                        	xorl	%edi, %edi
   18bb3: 31 c0                        	xorl	%eax, %eax
   18bb5: e8 16 f5 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   18bba: 41 89 de                     	movl	%ebx, %r14d
   18bbd: 85 db                        	testl	%ebx, %ebx
   18bbf: 78 2f                        	js	0x18bf0 <perf_buffer__poll+0xb0>
; }
   18bc1: 5b                           	popq	%rbx
   18bc2: 44 89 f0                     	movl	%r14d, %eax
   18bc5: 5d                           	popq	%rbp
   18bc6: 41 5c                        	popq	%r12
   18bc8: 41 5d                        	popq	%r13
   18bca: 41 5e                        	popq	%r14
   18bcc: c3                           	retq
   18bcd: 0f 1f 00                     	nopl	(%rax)
; 		return -errno;
   18bd0: e8 1b cb fe ff               	callq	0x56f0 <.plt.sec+0x80>
; }
   18bd5: 5b                           	popq	%rbx
   18bd6: 5d                           	popq	%rbp
; 		return -errno;
   18bd7: 44 8b 30                     	movl	(%rax), %r14d
; }
   18bda: 41 5c                        	popq	%r12
   18bdc: 41 5d                        	popq	%r13
; 		return -errno;
   18bde: 41 f7 de                     	negl	%r14d
; }
   18be1: 44 89 f0                     	movl	%r14d, %eax
   18be4: 41 5e                        	popq	%r14
   18be6: c3                           	retq
   18be7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		errno = -ret;
   18bf0: e8 fb ca fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18bf5: 89 da                        	movl	%ebx, %edx
   18bf7: f7 da                        	negl	%edx
   18bf9: 89 10                        	movl	%edx, (%rax)
; }
   18bfb: 44 89 f0                     	movl	%r14d, %eax
   18bfe: 5b                           	popq	%rbx
   18bff: 5d                           	popq	%rbp
   18c00: 41 5c                        	popq	%r12
   18c02: 41 5d                        	popq	%r13
   18c04: 41 5e                        	popq	%r14
   18c06: c3                           	retq
   18c07: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000018c10 <perf_buffer__buffer_cnt>:
; {
   18c10: f3 0f 1e fa                  	endbr64
; 	return pb->cpu_cnt;
   18c14: 48 63 47 40                  	movslq	64(%rdi), %rax
; }
   18c18: c3                           	retq
   18c19: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000018c20 <perf_buffer__buffer_fd>:
; {
   18c20: f3 0f 1e fa                  	endbr64
   18c24: 48 83 ec 08                  	subq	$8, %rsp
; 	if (buf_idx >= pb->cpu_cnt)
   18c28: 48 63 47 40                  	movslq	64(%rdi), %rax
   18c2c: 48 39 f0                     	cmpq	%rsi, %rax
   18c2f: 76 15                        	jbe	0x18c46 <perf_buffer__buffer_fd+0x26>
; 	cpu_buf = pb->cpu_bufs[buf_idx];
   18c31: 48 8b 47 30                  	movq	48(%rdi), %rax
   18c35: 48 8b 04 f0                  	movq	(%rax,%rsi,8), %rax
; 	if (!cpu_buf)
   18c39: 48 85 c0                     	testq	%rax, %rax
   18c3c: 74 1a                        	je	0x18c58 <perf_buffer__buffer_fd+0x38>
; 	return cpu_buf->fd;
   18c3e: 8b 40 20                     	movl	32(%rax), %eax
; }
   18c41: 48 83 c4 08                  	addq	$8, %rsp
   18c45: c3                           	retq
; 		errno = -ret;
   18c46: e8 a5 ca fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18c4b: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   18c51: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   18c56: eb e9                        	jmp	0x18c41 <perf_buffer__buffer_fd+0x21>
; 		errno = -ret;
   18c58: e8 93 ca fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18c5d: c7 00 02 00 00 00            	movl	$2, (%rax)
; 		return libbpf_err(-ENOENT);
   18c63: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
   18c68: eb d7                        	jmp	0x18c41 <perf_buffer__buffer_fd+0x21>
   18c6a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

0000000000018c70 <perf_buffer__buffer>:
; {
   18c70: f3 0f 1e fa                  	endbr64
   18c74: 48 83 ec 08                  	subq	$8, %rsp
; 	if (buf_idx >= pb->cpu_cnt)
   18c78: 39 77 40                     	cmpl	%esi, 64(%rdi)
   18c7b: 7e 25                        	jle	0x18ca2 <perf_buffer__buffer+0x32>
; 	cpu_buf = pb->cpu_bufs[buf_idx];
   18c7d: 48 8b 47 30                  	movq	48(%rdi), %rax
   18c81: 48 63 f6                     	movslq	%esi, %rsi
   18c84: 48 8b 04 f0                  	movq	(%rax,%rsi,8), %rax
; 	if (!cpu_buf)
   18c88: 48 85 c0                     	testq	%rax, %rax
   18c8b: 74 27                        	je	0x18cb4 <perf_buffer__buffer+0x44>
; 	*buf = cpu_buf->base;
   18c8d: 48 8b 40 08                  	movq	8(%rax), %rax
   18c91: 48 89 02                     	movq	%rax, (%rdx)
; 	*buf_size = pb->mmap_size;
   18c94: 48 8b 47 28                  	movq	40(%rdi), %rax
   18c98: 48 89 01                     	movq	%rax, (%rcx)
; 	return 0;
   18c9b: 31 c0                        	xorl	%eax, %eax
; }
   18c9d: 48 83 c4 08                  	addq	$8, %rsp
   18ca1: c3                           	retq
; 		errno = -ret;
   18ca2: e8 49 ca fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18ca7: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   18cad: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   18cb2: eb e9                        	jmp	0x18c9d <perf_buffer__buffer+0x2d>
; 		errno = -ret;
   18cb4: e8 37 ca fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18cb9: c7 00 02 00 00 00            	movl	$2, (%rax)
; 		return libbpf_err(-ENOENT);
   18cbf: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
   18cc4: eb d7                        	jmp	0x18c9d <perf_buffer__buffer+0x2d>
   18cc6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000018cd0 <perf_buffer__consume_buffer>:
; {
   18cd0: f3 0f 1e fa                  	endbr64
   18cd4: 48 83 ec 08                  	subq	$8, %rsp
; 	if (buf_idx >= pb->cpu_cnt)
   18cd8: 48 63 47 40                  	movslq	64(%rdi), %rax
   18cdc: 48 39 f0                     	cmpq	%rsi, %rax
   18cdf: 76 1e                        	jbe	0x18cff <perf_buffer__consume_buffer+0x2f>
; 	cpu_buf = pb->cpu_bufs[buf_idx];
   18ce1: 48 8b 47 30                  	movq	48(%rdi), %rax
   18ce5: 48 8b 14 f0                  	movq	(%rax,%rsi,8), %rdx
; 	if (!cpu_buf)
   18ce9: 48 85 d2                     	testq	%rdx, %rdx
   18cec: 74 26                        	je	0x18d14 <perf_buffer__consume_buffer+0x44>
; 	return perf_buffer__process_records(pb, cpu_buf);
   18cee: 48 8b 77 28                  	movq	40(%rdi), %rsi
   18cf2: 48 8b 7f 20                  	movq	32(%rdi), %rdi
; }
   18cf6: 48 83 c4 08                  	addq	$8, %rsp
; 	return perf_buffer__process_records(pb, cpu_buf);
   18cfa: e9 21 15 ff ff               	jmp	0xa220 <perf_buffer__process_records.isra.0>
; 		errno = -ret;
   18cff: e8 ec c9 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18d04: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   18d0a: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   18d0f: 48 83 c4 08                  	addq	$8, %rsp
   18d13: c3                           	retq
; 		errno = -ret;
   18d14: e8 d7 c9 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18d19: c7 00 02 00 00 00            	movl	$2, (%rax)
; 		return libbpf_err(-ENOENT);
   18d1f: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
   18d24: eb e9                        	jmp	0x18d0f <perf_buffer__consume_buffer+0x3f>
   18d26: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000018d30 <perf_buffer__consume>:
; {
   18d30: f3 0f 1e fa                  	endbr64
   18d34: 41 55                        	pushq	%r13
   18d36: 41 54                        	pushq	%r12
   18d38: 55                           	pushq	%rbp
   18d39: 53                           	pushq	%rbx
   18d3a: 48 83 ec 08                  	subq	$8, %rsp
; 	for (i = 0; i < pb->cpu_cnt; i++) {
   18d3e: 8b 47 40                     	movl	64(%rdi), %eax
   18d41: 85 c0                        	testl	%eax, %eax
   18d43: 7e 35                        	jle	0x18d7a <perf_buffer__consume+0x4a>
   18d45: 48 89 fd                     	movq	%rdi, %rbp
   18d48: 31 db                        	xorl	%ebx, %ebx
   18d4a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		struct perf_cpu_buf *cpu_buf = pb->cpu_bufs[i];
   18d50: 48 8b 45 30                  	movq	48(%rbp), %rax
   18d54: 48 8b 14 d8                  	movq	(%rax,%rbx,8), %rdx
; 		if (!cpu_buf)
   18d58: 48 85 d2                     	testq	%rdx, %rdx
   18d5b: 74 14                        	je	0x18d71 <perf_buffer__consume+0x41>
; 		err = perf_buffer__process_records(pb, cpu_buf);
   18d5d: 48 8b 75 28                  	movq	40(%rbp), %rsi
   18d61: 48 8b 7d 20                  	movq	32(%rbp), %rdi
   18d65: e8 b6 14 ff ff               	callq	0xa220 <perf_buffer__process_records.isra.0>
   18d6a: 41 89 c4                     	movl	%eax, %r12d
; 		if (err) {
   18d6d: 85 c0                        	testl	%eax, %eax
   18d6f: 75 1f                        	jne	0x18d90 <perf_buffer__consume+0x60>
; 	for (i = 0; i < pb->cpu_cnt; i++) {
   18d71: 48 83 c3 01                  	addq	$1, %rbx
   18d75: 39 5d 40                     	cmpl	%ebx, 64(%rbp)
   18d78: 7f d6                        	jg	0x18d50 <perf_buffer__consume+0x20>
; 	return 0;
   18d7a: 45 31 e4                     	xorl	%r12d, %r12d
; }
   18d7d: 48 83 c4 08                  	addq	$8, %rsp
   18d81: 44 89 e0                     	movl	%r12d, %eax
   18d84: 5b                           	popq	%rbx
   18d85: 5d                           	popq	%rbp
   18d86: 41 5c                        	popq	%r12
   18d88: 41 5d                        	popq	%r13
   18d8a: c3                           	retq
   18d8b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			pr_warn("perf_buffer: failed to process records in buffer #%d: %d\n", i, err);
   18d90: 89 c1                        	movl	%eax, %ecx
   18d92: 31 ff                        	xorl	%edi, %edi
   18d94: 31 c0                        	xorl	%eax, %eax
   18d96: 89 da                        	movl	%ebx, %edx
   18d98: 48 8d 35 99 ea 01 00         	leaq	125593(%rip), %rsi      # 0x37838 <strs.2+0x49a8>
   18d9f: e8 2c f3 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   18da4: 45 85 e4                     	testl	%r12d, %r12d
   18da7: 79 d4                        	jns	0x18d7d <perf_buffer__consume+0x4d>
; 		errno = -ret;
   18da9: e8 42 c9 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   18dae: 44 89 e2                     	movl	%r12d, %edx
   18db1: f7 da                        	negl	%edx
   18db3: 89 10                        	movl	%edx, (%rax)
; }
   18db5: 48 83 c4 08                  	addq	$8, %rsp
   18db9: 44 89 e0                     	movl	%r12d, %eax
   18dbc: 5b                           	popq	%rbx
   18dbd: 5d                           	popq	%rbp
   18dbe: 41 5c                        	popq	%r12
   18dc0: 41 5d                        	popq	%r13
   18dc2: c3                           	retq
   18dc3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   18dce: 66 90                        	nop

0000000000018dd0 <bpf_program__set_attach_target>:
; {
   18dd0: f3 0f 1e fa                  	endbr64
   18dd4: 41 57                        	pushq	%r15
   18dd6: 41 56                        	pushq	%r14
   18dd8: 41 55                        	pushq	%r13
   18dda: 41 54                        	pushq	%r12
   18ddc: 55                           	pushq	%rbp
   18ddd: 53                           	pushq	%rbx
   18dde: 48 81 ec b8 00 00 00         	subq	$184, %rsp
   18de5: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   18dee: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
   18df6: 31 c0                        	xorl	%eax, %eax
; 	int btf_obj_fd = 0, btf_id = 0, err;
   18df8: c7 44 24 18 00 00 00 00      	movl	$0, 24(%rsp)
   18e00: c7 44 24 1c 00 00 00 00      	movl	$0, 28(%rsp)
; 	if (!prog || attach_prog_fd < 0)
   18e08: 48 85 ff                     	testq	%rdi, %rdi
   18e0b: 0f 84 bf 02 00 00            	je	0x190d0 <bpf_program__set_attach_target+0x300>
   18e11: 85 f6                        	testl	%esi, %esi
   18e13: 0f 88 b7 02 00 00            	js	0x190d0 <bpf_program__set_attach_target+0x300>
; 	if (prog->obj->loaded)
   18e19: 4c 8b 77 70                  	movq	112(%rdi), %r14
   18e1d: 48 89 fd                     	movq	%rdi, %rbp
   18e20: 41 80 be 98 00 00 00 00      	cmpb	$0, 152(%r14)
   18e28: 0f 85 a2 02 00 00            	jne	0x190d0 <bpf_program__set_attach_target+0x300>
   18e2e: 49 89 d4                     	movq	%rdx, %r12
; 	if (attach_prog_fd && !attach_func_name) {
   18e31: 85 f6                        	testl	%esi, %esi
   18e33: 74 7b                        	je	0x18eb0 <bpf_program__set_attach_target+0xe0>
   18e35: 48 85 d2                     	testq	%rdx, %rdx
   18e38: 75 36                        	jne	0x18e70 <bpf_program__set_attach_target+0xa0>
; 		prog->attach_prog_fd = attach_prog_fd;
   18e3a: 89 b7 94 00 00 00            	movl	%esi, 148(%rdi)
; 		return 0;
   18e40: 45 31 ed                     	xorl	%r13d, %r13d
; }
   18e43: 48 8b 84 24 a8 00 00 00      	movq	168(%rsp), %rax
   18e4b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   18e54: 0f 85 99 02 00 00            	jne	0x190f3 <bpf_program__set_attach_target+0x323>
   18e5a: 48 81 c4 b8 00 00 00         	addq	$184, %rsp
   18e61: 44 89 e8                     	movl	%r13d, %eax
   18e64: 5b                           	popq	%rbx
   18e65: 5d                           	popq	%rbp
   18e66: 41 5c                        	popq	%r12
   18e68: 41 5d                        	popq	%r13
   18e6a: 41 5e                        	popq	%r14
   18e6c: 41 5f                        	popq	%r15
   18e6e: c3                           	retq
   18e6f: 90                           	nop
; 	if (attach_prog_fd) {
   18e70: 85 f6                        	testl	%esi, %esi
   18e72: 74 3c                        	je	0x18eb0 <bpf_program__set_attach_target+0xe0>
; 		btf_id = libbpf_find_prog_btf_id(attach_func_name,
   18e74: 48 89 d7                     	movq	%rdx, %rdi
   18e77: 89 f3                        	movl	%esi, %ebx
   18e79: e8 52 1b ff ff               	callq	0xa9d0 <libbpf_find_prog_btf_id>
   18e7e: 41 89 c5                     	movl	%eax, %r13d
   18e81: 89 44 24 1c                  	movl	%eax, 28(%rsp)
; 	prog->attach_btf_obj_fd = btf_obj_fd;
   18e85: 8b 44 24 18                  	movl	24(%rsp), %eax
; 		if (btf_id < 0)
   18e89: 45 85 ed                     	testl	%r13d, %r13d
   18e8c: 0f 88 f6 01 00 00            	js	0x19088 <bpf_program__set_attach_target+0x2b8>
; 	prog->attach_btf_id = btf_id;
   18e92: 44 89 ad 90 00 00 00         	movl	%r13d, 144(%rbp)
; 	return 0;
   18e99: 45 31 ed                     	xorl	%r13d, %r13d
; 	prog->attach_btf_obj_fd = btf_obj_fd;
   18e9c: 89 85 8c 00 00 00            	movl	%eax, 140(%rbp)
; 	prog->attach_prog_fd = attach_prog_fd;
   18ea2: 89 9d 94 00 00 00            	movl	%ebx, 148(%rbp)
; 	return 0;
   18ea8: eb 99                        	jmp	0x18e43 <bpf_program__set_attach_target+0x73>
   18eaa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		if (!attach_func_name)
   18eb0: 4d 85 e4                     	testq	%r12, %r12
   18eb3: 0f 84 17 02 00 00            	je	0x190d0 <bpf_program__set_attach_target+0x300>
; 	if (obj->btf_vmlinux || obj->gen_loader)
   18eb9: 4d 8b ae 20 01 00 00         	movq	288(%r14), %r13
   18ec0: 4d 85 ed                     	testq	%r13, %r13
   18ec3: 0f 84 2f 01 00 00            	je	0x18ff8 <bpf_program__set_attach_target+0x228>
; 		err = find_kernel_btf_id(prog->obj, attach_func_name,
   18ec9: 44 8b bd 84 00 00 00         	movl	132(%rbp), %r15d
; 	switch (attach_type) {
   18ed0: 41 83 ff 1c                  	cmpl	$28, %r15d
   18ed4: 0f 84 06 01 00 00            	je	0x18fe0 <bpf_program__set_attach_target+0x210>
   18eda: 0f 87 d0 00 00 00            	ja	0x18fb0 <bpf_program__set_attach_target+0x1e0>
   18ee0: bb 08 00 00 00               	movl	$8, %ebx
   18ee5: 4c 8d 0d 97 90 01 00         	leaq	102551(%rip), %r9       # 0x31f83 <_IO_stdin_used+0x1f83>
   18eec: 41 83 ff 17                  	cmpl	$23, %r15d
   18ef0: 0f 85 9a 00 00 00            	jne	0x18f90 <bpf_program__set_attach_target+0x1c0>
   18ef6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   18f00: 4c 8d 54 24 20               	leaq	32(%rsp), %r10
   18f05: 48 83 ec 08                  	subq	$8, %rsp
   18f09: b9 80 00 00 00               	movl	$128, %ecx
   18f0e: ba 01 00 00 00               	movl	$1, %edx
   18f13: 41 54                        	pushq	%r12
   18f15: 4c 89 d7                     	movq	%r10, %rdi
   18f18: 31 c0                        	xorl	%eax, %eax
   18f1a: 4c 8d 05 80 90 01 00         	leaq	102528(%rip), %r8       # 0x31fa1 <_IO_stdin_used+0x1fa1>
   18f21: be 80 00 00 00               	movl	$128, %esi
   18f26: 4c 89 54 24 18               	movq	%r10, 24(%rsp)
   18f2b: e8 80 c7 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (ret < 0 || ret >= sizeof(btf_type_name))
   18f30: 5a                           	popq	%rdx
   18f31: 59                           	popq	%rcx
   18f32: 83 f8 7f                     	cmpl	$127, %eax
   18f35: 4c 8b 54 24 08               	movq	8(%rsp), %r10
   18f3a: 0f 87 a6 01 00 00            	ja	0x190e6 <bpf_program__set_attach_target+0x316>
; 	return btf__find_by_name_kind(btf, btf_type_name, kind);
   18f40: 4c 89 ef                     	movq	%r13, %rdi
   18f43: 89 da                        	movl	%ebx, %edx
   18f45: 4c 89 d6                     	movq	%r10, %rsi
   18f48: e8 83 2b 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
   18f4d: 41 89 c5                     	movl	%eax, %r13d
; 	if (ret > 0) {
   18f50: 85 c0                        	testl	%eax, %eax
   18f52: 7f 7c                        	jg	0x18fd0 <bpf_program__set_attach_target+0x200>
; 	if (ret != -ENOENT)
   18f54: 83 f8 fe                     	cmpl	$-2, %eax
   18f57: 75 1b                        	jne	0x18f74 <bpf_program__set_attach_target+0x1a4>
   18f59: 48 8d 4c 24 18               	leaq	24(%rsp), %rcx
   18f5e: 4c 8d 44 24 1c               	leaq	28(%rsp), %r8
   18f63: 44 89 fa                     	movl	%r15d, %edx
   18f66: 4c 89 e6                     	movq	%r12, %rsi
   18f69: 4c 89 f7                     	movq	%r14, %rdi
   18f6c: e8 0f 4b ff ff               	callq	0xda80 <find_kernel_btf_id.part.0>
   18f71: 41 89 c5                     	movl	%eax, %r13d
; 		if (err)
   18f74: 45 85 ed                     	testl	%r13d, %r13d
   18f77: 0f 85 33 01 00 00            	jne	0x190b0 <bpf_program__set_attach_target+0x2e0>
; 	prog->attach_btf_id = btf_id;
   18f7d: 44 8b 6c 24 1c               	movl	28(%rsp), %r13d
; 	prog->attach_btf_obj_fd = btf_obj_fd;
   18f82: 8b 44 24 18                  	movl	24(%rsp), %eax
   18f86: 31 db                        	xorl	%ebx, %ebx
   18f88: e9 05 ff ff ff               	jmp	0x18e92 <bpf_program__set_attach_target+0xc2>
   18f8d: 0f 1f 00                     	nopl	(%rax)
; 	switch (attach_type) {
   18f90: 41 83 ff 1b                  	cmpl	$27, %r15d
   18f94: 4c 8d 0d f3 8f 01 00         	leaq	102387(%rip), %r9       # 0x31f8e <_IO_stdin_used+0x1f8e>
   18f9b: bb 0c 00 00 00               	movl	$12, %ebx
   18fa0: 48 8d 05 b6 8e 01 00         	leaq	102070(%rip), %rax      # 0x31e5d <_IO_stdin_used+0x1e5d>
   18fa7: 4c 0f 45 c8                  	cmovneq	%rax, %r9
   18fab: e9 50 ff ff ff               	jmp	0x18f00 <bpf_program__set_attach_target+0x130>
   18fb0: 41 83 ff 2b                  	cmpl	$43, %r15d
   18fb4: 4c 8d 0d d3 8f 01 00         	leaq	102355(%rip), %r9       # 0x31f8e <_IO_stdin_used+0x1f8e>
   18fbb: bb 0c 00 00 00               	movl	$12, %ebx
   18fc0: 48 8d 05 96 8e 01 00         	leaq	102038(%rip), %rax      # 0x31e5d <_IO_stdin_used+0x1e5d>
   18fc7: 4c 0f 45 c8                  	cmovneq	%rax, %r9
   18fcb: e9 30 ff ff ff               	jmp	0x18f00 <bpf_program__set_attach_target+0x130>
   18fd0: 31 c0                        	xorl	%eax, %eax
   18fd2: 31 db                        	xorl	%ebx, %ebx
   18fd4: e9 b9 fe ff ff               	jmp	0x18e92 <bpf_program__set_attach_target+0xc2>
   18fd9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   18fe0: bb 0c 00 00 00               	movl	$12, %ebx
; 		*prefix = BTF_ITER_PREFIX;
   18fe5: 4c 8d 0d ab 8f 01 00         	leaq	102315(%rip), %r9       # 0x31f97 <_IO_stdin_used+0x1f97>
   18fec: e9 0f ff ff ff               	jmp	0x18f00 <bpf_program__set_attach_target+0x130>
   18ff1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	if (obj->btf_vmlinux || obj->gen_loader)
   18ff8: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   19000: 0f 85 c3 fe ff ff            	jne	0x18ec9 <bpf_program__set_attach_target+0xf9>
; 	obj->btf_vmlinux = btf__load_vmlinux_btf();
   19006: e8 65 4c 01 00               	callq	0x2dc70 <libbpf_find_kernel_btf>
   1900b: 49 89 86 20 01 00 00         	movq	%rax, 288(%r14)
   19012: 48 89 c3                     	movq	%rax, %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
   19015: 48 85 c0                     	testq	%rax, %rax
   19018: 74 1e                        	je	0x19038 <bpf_program__set_attach_target+0x268>
   1901a: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   19020: 77 16                        	ja	0x19038 <bpf_program__set_attach_target+0x268>
; 		err = find_kernel_btf_id(prog->obj, attach_func_name,
   19022: 4c 8b 75 70                  	movq	112(%rbp), %r14
; 	ret = find_attach_btf_id(obj->btf_vmlinux, attach_name, attach_type);
   19026: 4d 8b ae 20 01 00 00         	movq	288(%r14), %r13
   1902d: e9 97 fe ff ff               	jmp	0x18ec9 <bpf_program__set_attach_target+0xf9>
   19032: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -ret;
   19038: e8 b3 c6 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1903d: 49 89 c7                     	movq	%rax, %r15
; 	if (IS_ERR(ptr))
   19040: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   19047: 77 57                        	ja	0x190a0 <bpf_program__set_attach_target+0x2d0>
; 	return -errno;
   19049: 8b 18                        	movl	(%rax), %ebx
   1904b: 41 89 dd                     	movl	%ebx, %r13d
   1904e: 41 f7 dd                     	negl	%r13d
; 	if (err) {
   19051: 85 db                        	testl	%ebx, %ebx
   19053: 74 cd                        	je	0x19022 <bpf_program__set_attach_target+0x252>
; 		pr_warn("Error loading vmlinux BTF: %d\n", err);
   19055: 44 89 ea                     	movl	%r13d, %edx
   19058: 48 8d 35 21 e8 01 00         	leaq	124961(%rip), %rsi      # 0x37880 <strs.2+0x49f0>
   1905f: 31 ff                        	xorl	%edi, %edi
   19061: 31 c0                        	xorl	%eax, %eax
   19063: e8 68 f0 fe ff               	callq	0x80d0 <libbpf_print>
; 		obj->btf_vmlinux = NULL;
   19068: 49 c7 86 20 01 00 00 00 00 00 00     	movq	$0, 288(%r14)
; 	if (ret < 0)
   19073: 85 db                        	testl	%ebx, %ebx
   19075: 0f 8e c8 fd ff ff            	jle	0x18e43 <bpf_program__set_attach_target+0x73>
; 		errno = -ret;
   1907b: 41 89 1f                     	movl	%ebx, (%r15)
   1907e: e9 c0 fd ff ff               	jmp	0x18e43 <bpf_program__set_attach_target+0x73>
   19083: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   19088: e8 63 c6 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1908d: 44 89 ea                     	movl	%r13d, %edx
   19090: f7 da                        	negl	%edx
   19092: 89 10                        	movl	%edx, (%rax)
   19094: e9 aa fd ff ff               	jmp	0x18e43 <bpf_program__set_attach_target+0x73>
   19099: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
   190a0: f7 db                        	negl	%ebx
   190a2: 89 18                        	movl	%ebx, (%rax)
   190a4: eb a5                        	jmp	0x1904b <bpf_program__set_attach_target+0x27b>
   190a6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	if (ret < 0)
   190b0: 0f 89 8d fd ff ff            	jns	0x18e43 <bpf_program__set_attach_target+0x73>
; 		errno = -ret;
   190b6: 44 89 eb                     	movl	%r13d, %ebx
   190b9: f7 db                        	negl	%ebx
   190bb: e8 30 c6 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   190c0: 89 18                        	movl	%ebx, (%rax)
   190c2: e9 7c fd ff ff               	jmp	0x18e43 <bpf_program__set_attach_target+0x73>
   190c7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
   190d0: e8 1b c6 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			return libbpf_err(-EINVAL);
   190d5: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   190db: c7 00 16 00 00 00            	movl	$22, (%rax)
   190e1: e9 5d fd ff ff               	jmp	0x18e43 <bpf_program__set_attach_target+0x73>
; 	if (ret < 0)
   190e6: bb 24 00 00 00               	movl	$36, %ebx
; 		return -ENAMETOOLONG;
   190eb: 41 bd dc ff ff ff            	movl	$4294967260, %r13d      # imm = 0xFFFFFFDC
   190f1: eb c8                        	jmp	0x190bb <bpf_program__set_attach_target+0x2eb>
; }
   190f3: e8 08 c7 fe ff               	callq	0x5800 <.plt.sec+0x190>
   190f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000019100 <parse_cpu_mask_str>:
; {
   19100: f3 0f 1e fa                  	endbr64
   19104: 41 56                        	pushq	%r14
   19106: 49 89 fe                     	movq	%rdi, %r14
   19109: 41 55                        	pushq	%r13
   1910b: 4c 8d 2d f9 91 01 00         	leaq	102905(%rip), %r13      # 0x3230b <_IO_stdin_used+0x230b>
   19112: 41 54                        	pushq	%r12
   19114: 49 89 d4                     	movq	%rdx, %r12
   19117: 55                           	pushq	%rbp
   19118: 48 89 f5                     	movq	%rsi, %rbp
   1911b: 53                           	pushq	%rbx
   1911c: 48 83 ec 20                  	subq	$32, %rsp
   19120: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   19129: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1912e: 31 c0                        	xorl	%eax, %eax
; 	*mask = NULL;
   19130: 48 c7 06 00 00 00 00         	movq	$0, (%rsi)
; 	*mask_sz = 0;
   19137: c7 02 00 00 00 00            	movl	$0, (%rdx)
; 	while (*s) {
   1913d: 0f b6 07                     	movzbl	(%rdi), %eax
; 	int err = 0, n, len, start, end = -1;
   19140: c7 44 24 14 ff ff ff ff      	movl	$4294967295, 20(%rsp)   # imm = 0xFFFFFFFF
; 	while (*s) {
   19148: 84 c0                        	testb	%al, %al
   1914a: 0f 85 c4 00 00 00            	jne	0x19214 <parse_cpu_mask_str+0x114>
   19150: e9 68 01 00 00               	jmp	0x192bd <parse_cpu_mask_str+0x1bd>
   19155: 0f 1f 00                     	nopl	(%rax)
; 		n = sscanf(s, "%d%n-%d%n", &start, &len, &end, &len);
   19158: 48 8d 4c 24 0c               	leaq	12(%rsp), %rcx
   1915d: 48 8d 54 24 10               	leaq	16(%rsp), %rdx
   19162: 4c 89 ee                     	movq	%r13, %rsi
   19165: 4c 89 f7                     	movq	%r14, %rdi
   19168: 49 89 c9                     	movq	%rcx, %r9
   1916b: 4c 8d 44 24 14               	leaq	20(%rsp), %r8
   19170: 31 c0                        	xorl	%eax, %eax
   19172: e8 49 c9 fe ff               	callq	0x5ac0 <.plt.sec+0x450>
; 		if (n <= 0 || n > 2) {
   19177: 8d 50 ff                     	leal	-1(%rax), %edx
   1917a: 83 fa 01                     	cmpl	$1, %edx
   1917d: 0f 87 1d 01 00 00            	ja	0x192a0 <parse_cpu_mask_str+0x1a0>
; 			end = start;
   19183: 8b 54 24 10                  	movl	16(%rsp), %edx
; 		} else if (n == 1) {
   19187: 83 f8 01                     	cmpl	$1, %eax
   1918a: 0f 84 b0 00 00 00            	je	0x19240 <parse_cpu_mask_str+0x140>
; 		if (start < 0 || start > end) {
   19190: 8b 4c 24 14                  	movl	20(%rsp), %ecx
   19194: 85 d2                        	testl	%edx, %edx
   19196: 0f 88 b4 00 00 00            	js	0x19250 <parse_cpu_mask_str+0x150>
   1919c: 39 ca                        	cmpl	%ecx, %edx
   1919e: 0f 8f ac 00 00 00            	jg	0x19250 <parse_cpu_mask_str+0x150>
; 		tmp = realloc(*mask, end + 1);
   191a4: 83 c1 01                     	addl	$1, %ecx
   191a7: 48 8b 7d 00                  	movq	(%rbp), %rdi
   191ab: 48 63 f1                     	movslq	%ecx, %rsi
   191ae: e8 6d c9 fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
   191b3: 48 89 c3                     	movq	%rax, %rbx
; 		if (!tmp) {
   191b6: 48 85 c0                     	testq	%rax, %rax
   191b9: 0f 84 16 01 00 00            	je	0x192d5 <parse_cpu_mask_str+0x1d5>
; 		memset(tmp + *mask_sz, 0, start - *mask_sz);
   191bf: 49 63 3c 24                  	movslq	(%r12), %rdi
   191c3: 8b 54 24 10                  	movl	16(%rsp), %edx
; 		*mask = tmp;
   191c7: 48 89 45 00                  	movq	%rax, (%rbp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   191cb: 31 f6                        	xorl	%esi, %esi
; 		memset(tmp + *mask_sz, 0, start - *mask_sz);
   191cd: 29 fa                        	subl	%edi, %edx
   191cf: 48 01 c7                     	addq	%rax, %rdi
   191d2: 48 63 d2                     	movslq	%edx, %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
   191d5: e8 e6 c6 fe ff               	callq	0x58c0 <.plt.sec+0x250>
; 		memset(tmp + start, 1, end - start + 1);
   191da: 48 63 44 24 10               	movslq	16(%rsp), %rax
   191df: 8b 54 24 14                  	movl	20(%rsp), %edx
;   return __builtin___memset_chk (__dest, __ch, __len,
   191e3: be 01 00 00 00               	movl	$1, %esi
; 		memset(tmp + start, 1, end - start + 1);
   191e8: 29 c2                        	subl	%eax, %edx
   191ea: 48 8d 3c 03                  	leaq	(%rbx,%rax), %rdi
   191ee: 83 c2 01                     	addl	$1, %edx
   191f1: 48 63 d2                     	movslq	%edx, %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
   191f4: e8 c7 c6 fe ff               	callq	0x58c0 <.plt.sec+0x250>
; 		*mask_sz = end + 1;
   191f9: 8b 44 24 14                  	movl	20(%rsp), %eax
   191fd: 83 c0 01                     	addl	$1, %eax
   19200: 41 89 04 24                  	movl	%eax, (%r12)
; 		s += len;
   19204: 48 63 44 24 0c               	movslq	12(%rsp), %rax
   19209: 49 01 c6                     	addq	%rax, %r14
; 	while (*s) {
   1920c: 41 0f b6 06                  	movzbl	(%r14), %eax
   19210: 84 c0                        	testb	%al, %al
   19212: 74 19                        	je	0x1922d <parse_cpu_mask_str+0x12d>
; 		if (*s == ',' || *s == '\n') {
   19214: 3c 2c                        	cmpb	$44, %al
   19216: 74 08                        	je	0x19220 <parse_cpu_mask_str+0x120>
   19218: 3c 0a                        	cmpb	$10, %al
   1921a: 0f 85 38 ff ff ff            	jne	0x19158 <parse_cpu_mask_str+0x58>
; 	while (*s) {
   19220: 41 0f b6 46 01               	movzbl	1(%r14), %eax
; 			s++;
   19225: 49 83 c6 01                  	addq	$1, %r14
; 	while (*s) {
   19229: 84 c0                        	testb	%al, %al
   1922b: 75 e7                        	jne	0x19214 <parse_cpu_mask_str+0x114>
; 	if (!*mask_sz) {
   1922d: 41 8b 04 24                  	movl	(%r12), %eax
   19231: 85 c0                        	testl	%eax, %eax
   19233: 0f 84 84 00 00 00            	je	0x192bd <parse_cpu_mask_str+0x1bd>
; 	return 0;
   19239: 45 31 e4                     	xorl	%r12d, %r12d
   1923c: eb 3c                        	jmp	0x1927a <parse_cpu_mask_str+0x17a>
   1923e: 66 90                        	nop
; 			end = start;
   19240: 89 54 24 14                  	movl	%edx, 20(%rsp)
; 		if (start < 0 || start > end) {
   19244: 89 d1                        	movl	%edx, %ecx
   19246: 85 d2                        	testl	%edx, %edx
   19248: 0f 89 56 ff ff ff            	jns	0x191a4 <parse_cpu_mask_str+0xa4>
   1924e: 66 90                        	nop
; 			pr_warn("Invalid CPU range [%d,%d] in %s\n",
   19250: 4d 89 f0                     	movq	%r14, %r8
   19253: 48 8d 35 76 e6 01 00         	leaq	124534(%rip), %rsi      # 0x378d0 <strs.2+0x4a40>
   1925a: 31 ff                        	xorl	%edi, %edi
   1925c: 31 c0                        	xorl	%eax, %eax
   1925e: e8 6d ee fe ff               	callq	0x80d0 <libbpf_print>
; 			err = -EINVAL;
   19263: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 	free(*mask);
   19269: 48 8b 7d 00                  	movq	(%rbp), %rdi
   1926d: e8 4e c4 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	*mask = NULL;
   19272: 48 c7 45 00 00 00 00 00      	movq	$0, (%rbp)
; }
   1927a: 48 8b 44 24 18               	movq	24(%rsp), %rax
   1927f: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   19288: 75 53                        	jne	0x192dd <parse_cpu_mask_str+0x1dd>
   1928a: 48 83 c4 20                  	addq	$32, %rsp
   1928e: 44 89 e0                     	movl	%r12d, %eax
   19291: 5b                           	popq	%rbx
   19292: 5d                           	popq	%rbp
   19293: 41 5c                        	popq	%r12
   19295: 41 5d                        	popq	%r13
   19297: 41 5e                        	popq	%r14
   19299: c3                           	retq
   1929a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			pr_warn("Failed to get CPU range %s: %d\n", s, n);
   192a0: 89 c1                        	movl	%eax, %ecx
   192a2: 4c 89 f2                     	movq	%r14, %rdx
   192a5: 48 8d 35 fc e5 01 00         	leaq	124412(%rip), %rsi      # 0x378a8 <strs.2+0x4a18>
   192ac: 31 ff                        	xorl	%edi, %edi
   192ae: 31 c0                        	xorl	%eax, %eax
; 			err = -EINVAL;
   192b0: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("Failed to get CPU range %s: %d\n", s, n);
   192b6: e8 15 ee fe ff               	callq	0x80d0 <libbpf_print>
; 			goto cleanup;
   192bb: eb ac                        	jmp	0x19269 <parse_cpu_mask_str+0x169>
; 		pr_warn("Empty CPU range\n");
   192bd: 48 8d 35 2e 90 01 00         	leaq	102446(%rip), %rsi      # 0x322f2 <_IO_stdin_used+0x22f2>
   192c4: 31 ff                        	xorl	%edi, %edi
   192c6: 31 c0                        	xorl	%eax, %eax
; 		return -EINVAL;
   192c8: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("Empty CPU range\n");
   192ce: e8 fd ed fe ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   192d3: eb a5                        	jmp	0x1927a <parse_cpu_mask_str+0x17a>
; 			err = -ENOMEM;
   192d5: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
   192db: eb 8c                        	jmp	0x19269 <parse_cpu_mask_str+0x169>
; }
   192dd: e8 1e c5 fe ff               	callq	0x5800 <.plt.sec+0x190>
   192e2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   192ed: 0f 1f 00                     	nopl	(%rax)

00000000000192f0 <parse_cpu_mask_file>:
; {
   192f0: f3 0f 1e fa                  	endbr64
   192f4: 41 57                        	pushq	%r15
   192f6: 41 56                        	pushq	%r14
   192f8: 49 89 d6                     	movq	%rdx, %r14
   192fb: 41 55                        	pushq	%r13
   192fd: 49 89 f5                     	movq	%rsi, %r13
;       return __open_alias (__path, __oflag, __va_arg_pack ());
   19300: be 00 00 08 00               	movl	$524288, %esi           # imm = 0x80000
; {
   19305: 41 54                        	pushq	%r12
   19307: 49 89 fc                     	movq	%rdi, %r12
   1930a: 55                           	pushq	%rbp
   1930b: 53                           	pushq	%rbx
   1930c: 48 81 ec 98 00 00 00         	subq	$152, %rsp
   19313: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1931c: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
   19324: 31 c0                        	xorl	%eax, %eax
;       return __open_alias (__path, __oflag, __va_arg_pack ());
   19326: e8 35 c8 fe ff               	callq	0x5b60 <.plt.sec+0x4f0>
; 	if (fd < 0) {
   1932b: 85 c0                        	testl	%eax, %eax
   1932d: 78 71                        	js	0x193a0 <parse_cpu_mask_file+0xb0>
;   return __glibc_fortify (read, __nbytes, sizeof (char),
   1932f: 49 89 e7                     	movq	%rsp, %r15
   19332: 89 c7                        	movl	%eax, %edi
   19334: ba 80 00 00 00               	movl	$128, %edx
   19339: 89 c5                        	movl	%eax, %ebp
   1933b: 4c 89 fe                     	movq	%r15, %rsi
   1933e: e8 1d c6 fe ff               	callq	0x5960 <.plt.sec+0x2f0>
; 	close(fd);
   19343: 89 ef                        	movl	%ebp, %edi
;   return __glibc_fortify (read, __nbytes, sizeof (char),
   19345: 48 89 c3                     	movq	%rax, %rbx
; 	close(fd);
   19348: e8 b3 c5 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (len <= 0) {
   1934d: 85 db                        	testl	%ebx, %ebx
   1934f: 7e 77                        	jle	0x193c8 <parse_cpu_mask_file+0xd8>
; 	if (len >= sizeof(buf)) {
   19351: 83 fb 7f                     	cmpl	$127, %ebx
   19354: 0f 87 9c 00 00 00            	ja	0x193f6 <parse_cpu_mask_file+0x106>
; 	return parse_cpu_mask_str(buf, mask, mask_sz);
   1935a: 4c 89 ee                     	movq	%r13, %rsi
; 	buf[len] = '\0';
   1935d: 48 63 db                     	movslq	%ebx, %rbx
; 	return parse_cpu_mask_str(buf, mask, mask_sz);
   19360: 4c 89 f2                     	movq	%r14, %rdx
   19363: 4c 89 ff                     	movq	%r15, %rdi
; 	buf[len] = '\0';
   19366: c6 04 1c 00                  	movb	$0, (%rsp,%rbx)
; 	return parse_cpu_mask_str(buf, mask, mask_sz);
   1936a: e8 91 fd ff ff               	callq	0x19100 <parse_cpu_mask_str>
   1936f: 41 89 c5                     	movl	%eax, %r13d
; }
   19372: 48 8b 84 24 88 00 00 00      	movq	136(%rsp), %rax
   1937a: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   19383: 0f 85 8b 00 00 00            	jne	0x19414 <parse_cpu_mask_file+0x124>
   19389: 48 81 c4 98 00 00 00         	addq	$152, %rsp
   19390: 44 89 e8                     	movl	%r13d, %eax
   19393: 5b                           	popq	%rbx
   19394: 5d                           	popq	%rbp
   19395: 41 5c                        	popq	%r12
   19397: 41 5d                        	popq	%r13
   19399: 41 5e                        	popq	%r14
   1939b: 41 5f                        	popq	%r15
   1939d: c3                           	retq
   1939e: 66 90                        	nop
; 		err = -errno;
   193a0: e8 4b c3 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("Failed to open cpu mask file %s: %d\n", fcpu, err);
   193a5: 4c 89 e2                     	movq	%r12, %rdx
   193a8: 48 8d 35 51 e5 01 00         	leaq	124241(%rip), %rsi      # 0x37900 <strs.2+0x4a70>
   193af: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
   193b1: 44 8b 28                     	movl	(%rax), %r13d
; 		pr_warn("Failed to open cpu mask file %s: %d\n", fcpu, err);
   193b4: 31 c0                        	xorl	%eax, %eax
; 		err = -errno;
   193b6: 41 f7 dd                     	negl	%r13d
; 		pr_warn("Failed to open cpu mask file %s: %d\n", fcpu, err);
   193b9: 44 89 e9                     	movl	%r13d, %ecx
   193bc: e8 0f ed fe ff               	callq	0x80d0 <libbpf_print>
; 		return err;
   193c1: eb af                        	jmp	0x19372 <parse_cpu_mask_file+0x82>
   193c3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		err = len ? -errno : -EINVAL;
   193c8: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
   193ce: 74 0b                        	je	0x193db <parse_cpu_mask_file+0xeb>
   193d0: e8 1b c3 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   193d5: 44 8b 28                     	movl	(%rax), %r13d
   193d8: 41 f7 dd                     	negl	%r13d
; 		pr_warn("Failed to read cpu mask from %s: %d\n", fcpu, err);
   193db: 44 89 e9                     	movl	%r13d, %ecx
   193de: 4c 89 e2                     	movq	%r12, %rdx
   193e1: 48 8d 35 48 e5 01 00         	leaq	124232(%rip), %rsi      # 0x37930 <strs.2+0x4aa0>
   193e8: 31 ff                        	xorl	%edi, %edi
   193ea: 31 c0                        	xorl	%eax, %eax
   193ec: e8 df ec fe ff               	callq	0x80d0 <libbpf_print>
; 		return err;
   193f1: e9 7c ff ff ff               	jmp	0x19372 <parse_cpu_mask_file+0x82>
; 		pr_warn("CPU mask is too big in file %s\n", fcpu);
   193f6: 4c 89 e2                     	movq	%r12, %rdx
   193f9: 48 8d 35 60 e5 01 00         	leaq	124256(%rip), %rsi      # 0x37960 <strs.2+0x4ad0>
   19400: 31 ff                        	xorl	%edi, %edi
   19402: 31 c0                        	xorl	%eax, %eax
   19404: e8 c7 ec fe ff               	callq	0x80d0 <libbpf_print>
; 		return -E2BIG;
   19409: 41 bd f9 ff ff ff            	movl	$4294967289, %r13d      # imm = 0xFFFFFFF9
   1940f: e9 5e ff ff ff               	jmp	0x19372 <parse_cpu_mask_file+0x82>
; }
   19414: e8 e7 c3 fe ff               	callq	0x5800 <.plt.sec+0x190>
   19419: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000019420 <libbpf_num_possible_cpus.part.0>:
; int libbpf_num_possible_cpus(void)
   19420: 41 54                        	pushq	%r12
; 	err = parse_cpu_mask_file(fcpu, &mask, &n);
   19422: 48 8d 3d 5f e5 01 00         	leaq	124255(%rip), %rdi      # 0x37988 <strs.2+0x4af8>
; int libbpf_num_possible_cpus(void)
   19429: 48 83 ec 20                  	subq	$32, %rsp
   1942d: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   19436: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1943b: 31 c0                        	xorl	%eax, %eax
; 	err = parse_cpu_mask_file(fcpu, &mask, &n);
   1943d: 48 8d 54 24 0c               	leaq	12(%rsp), %rdx
   19442: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
   19447: e8 a4 fe ff ff               	callq	0x192f0 <parse_cpu_mask_file>
   1944c: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
   1944f: 85 c0                        	testl	%eax, %eax
   19451: 75 5d                        	jne	0x194b0 <libbpf_num_possible_cpus.part.0+0x90>
; 	for (i = 0; i < n; i++) {
   19453: 8b 54 24 0c                  	movl	12(%rsp), %edx
; 	free(mask);
   19457: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
; 	for (i = 0; i < n; i++) {
   1945c: 85 d2                        	testl	%edx, %edx
   1945e: 7e 20                        	jle	0x19480 <libbpf_num_possible_cpus.part.0+0x60>
   19460: 83 ea 01                     	subl	$1, %edx
   19463: 48 89 f8                     	movq	%rdi, %rax
   19466: 48 8d 54 17 01               	leaq	1(%rdi,%rdx), %rdx
   1946b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			tmp_cpus++;
   19470: 80 38 01                     	cmpb	$1, (%rax)
   19473: 41 83 dc ff                  	sbbl	$-1, %r12d
; 	for (i = 0; i < n; i++) {
   19477: 48 83 c0 01                  	addq	$1, %rax
   1947b: 48 39 d0                     	cmpq	%rdx, %rax
   1947e: 75 f0                        	jne	0x19470 <libbpf_num_possible_cpus.part.0+0x50>
; 	free(mask);
   19480: e8 3b c2 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	WRITE_ONCE(cpus, tmp_cpus);
   19485: 44 89 25 94 dd 02 00         	movl	%r12d, 187796(%rip)     # 0x47220 <cpus.16>
; }
   1948c: 48 8b 44 24 18               	movq	24(%rsp), %rax
   19491: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1949a: 75 24                        	jne	0x194c0 <libbpf_num_possible_cpus.part.0+0xa0>
   1949c: 48 83 c4 20                  	addq	$32, %rsp
   194a0: 44 89 e0                     	movl	%r12d, %eax
   194a3: 41 5c                        	popq	%r12
   194a5: c3                           	retq
   194a6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	if (ret < 0)
   194b0: 79 da                        	jns	0x1948c <libbpf_num_possible_cpus.part.0+0x6c>
; 		errno = -ret;
   194b2: e8 39 c2 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   194b7: 44 89 e2                     	movl	%r12d, %edx
   194ba: f7 da                        	negl	%edx
   194bc: 89 10                        	movl	%edx, (%rax)
   194be: eb cc                        	jmp	0x1948c <libbpf_num_possible_cpus.part.0+0x6c>
; }
   194c0: e8 3b c3 fe ff               	callq	0x5800 <.plt.sec+0x190>
   194c5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

00000000000194d0 <bpf_object__create_maps>:
; {
   194d0: 41 57                        	pushq	%r15
   194d2: 41 56                        	pushq	%r14
   194d4: 41 55                        	pushq	%r13
   194d6: 41 54                        	pushq	%r12
   194d8: 55                           	pushq	%rbp
   194d9: 53                           	pushq	%rbx
   194da: 48 81 ec 18 01 00 00         	subq	$280, %rsp              # imm = 0x118
   194e1: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   194ea: 48 89 84 24 08 01 00 00      	movq	%rax, 264(%rsp)
   194f2: 31 c0                        	xorl	%eax, %eax
; 	for (i = 0; i < obj->nr_maps; i++) {
   194f4: 48 83 7f 70 00               	cmpq	$0, 112(%rdi)
   194f9: 0f 84 21 04 00 00            	je	0x19920 <bpf_object__create_maps+0x450>
   194ff: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
   19507: 49 89 fc                     	movq	%rdi, %r12
   1950a: 31 c0                        	xorl	%eax, %eax
; 		map = &obj->maps[i];
   1950c: 4c 8d 14 80                  	leaq	(%rax,%rax,4), %r10
   19510: 49 c1 e2 05                  	shlq	$5, %r10
   19514: 4d 03 54 24 68               	addq	104(%r12), %r10
; 		if (bpf_map__is_internal(map) && !kernel_supports(obj, FEAT_GLOBAL_DATA))
   19519: 41 8b 7a 58                  	movl	88(%r10), %edi
; 		map = &obj->maps[i];
   1951d: 4d 89 d7                     	movq	%r10, %r15
; 		if (bpf_map__is_internal(map) && !kernel_supports(obj, FEAT_GLOBAL_DATA))
   19520: 85 ff                        	testl	%edi, %edi
   19522: 0f 85 b0 03 00 00            	jne	0x198d8 <bpf_object__create_maps+0x408>
; 		if (!map->autocreate) {
   19528: 41 80 bf 92 00 00 00 00      	cmpb	$0, 146(%r15)
   19530: 0f 84 bf 03 00 00            	je	0x198f5 <bpf_object__create_maps+0x425>
; 	if (map->def.type == BPF_MAP_TYPE_PERF_EVENT_ARRAY && !map->def.max_entries) {
   19536: 41 83 7f 30 04               	cmpl	$4, 48(%r15)
   1953b: 0f 84 9f 02 00 00            	je	0x197e0 <bpf_object__create_maps+0x310>
; retry:
   19541: 31 db                        	xorl	%ebx, %ebx
   19543: e9 e7 00 00 00               	jmp	0x1962f <bpf_object__create_maps+0x15f>
   19548: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	pin_fd = bpf_obj_get(map->pin_path);
   19550: e8 bb d4 00 00               	callq	0x26a10 <bpf_obj_get>
   19555: 89 c5                        	movl	%eax, %ebp
; 	if (pin_fd < 0) {
   19557: 85 c0                        	testl	%eax, %eax
   19559: 0f 89 c1 02 00 00            	jns	0x19820 <bpf_object__create_maps+0x350>
; 		err = -errno;
   1955f: e8 8c c1 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   19564: 44 8b 30                     	movl	(%rax), %r14d
; 		if (err == -ENOENT) {
   19567: 41 83 fe 02                  	cmpl	$2, %r14d
   1956b: 0f 84 8f 04 00 00            	je	0x19a00 <bpf_object__create_maps+0x530>
; 		cp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));
   19571: 48 8d ac 24 80 00 00 00      	leaq	128(%rsp), %rbp
   19579: ba 80 00 00 00               	movl	$128, %edx
   1957e: 44 89 f7                     	movl	%r14d, %edi
   19581: 48 89 ee                     	movq	%rbp, %rsi
   19584: e8 47 44 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("couldn't retrieve pinned map '%s': %s\n",
   19589: 49 8b 97 88 00 00 00         	movq	136(%r15), %rdx
   19590: 31 ff                        	xorl	%edi, %edi
   19592: 48 8d 35 9f e4 01 00         	leaq	124063(%rip), %rsi      # 0x37a38 <strs.2+0x4ba8>
; 		cp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));
   19599: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("couldn't retrieve pinned map '%s': %s\n",
   1959c: 31 c0                        	xorl	%eax, %eax
   1959e: e8 2d eb fe ff               	callq	0x80d0 <libbpf_print>
; 			if (err) {
   195a3: 45 85 f6                     	testl	%r14d, %r14d
   195a6: 0f 85 63 07 00 00            	jne	0x19d0f <bpf_object__create_maps+0x83f>
; 			if (retried && map->fd < 0) {
   195ac: 41 8b 4f 18                  	movl	24(%r15), %ecx
   195b0: 84 db                        	testb	%bl, %bl
   195b2: 0f 84 8b 00 00 00            	je	0x19643 <bpf_object__create_maps+0x173>
   195b8: 85 c9                        	testl	%ecx, %ecx
   195ba: 0f 88 e1 06 00 00            	js	0x19ca1 <bpf_object__create_maps+0x7d1>
; 			pr_debug("map '%s': skipping creation (preset fd=%d)\n",
   195c0: 49 8b 57 08                  	movq	8(%r15), %rdx
   195c4: 48 8d 35 9d e5 01 00         	leaq	124317(%rip), %rsi      # 0x37b68 <strs.2+0x4cd8>
   195cb: bf 02 00 00 00               	movl	$2, %edi
   195d0: 31 c0                        	xorl	%eax, %eax
   195d2: e8 f9 ea fe ff               	callq	0x80d0 <libbpf_print>
; 		if (map->pin_path && !map->pinned) {
   195d7: 49 83 bf 88 00 00 00 00      	cmpq	$0, 136(%r15)
   195df: 0f 84 27 03 00 00            	je	0x1990c <bpf_object__create_maps+0x43c>
   195e5: 41 80 bf 90 00 00 00 00      	cmpb	$0, 144(%r15)
   195ed: 0f 85 19 03 00 00            	jne	0x1990c <bpf_object__create_maps+0x43c>
; 			err = bpf_map__pin(map, NULL);
   195f3: 31 f6                        	xorl	%esi, %esi
   195f5: 4c 89 ff                     	movq	%r15, %rdi
   195f8: e8 53 74 ff ff               	callq	0x10a50 <bpf_map__pin>
   195fd: 41 89 c6                     	movl	%eax, %r14d
; 			if (err) {
   19600: 85 c0                        	testl	%eax, %eax
   19602: 0f 84 04 03 00 00            	je	0x1990c <bpf_object__create_maps+0x43c>
; 				zclose(map->fd);
   19608: 41 8b 7f 18                  	movl	24(%r15), %edi
   1960c: 85 ff                        	testl	%edi, %edi
   1960e: 78 05                        	js	0x19615 <bpf_object__create_maps+0x145>
   19610: e8 eb c2 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 				if (!retried && err == -EEXIST) {
   19615: 83 f3 01                     	xorl	$1, %ebx
   19618: 41 83 fe ef                  	cmpl	$-17, %r14d
; 				zclose(map->fd);
   1961c: 41 c7 47 18 ff ff ff ff      	movl	$4294967295, 24(%r15)   # imm = 0xFFFFFFFF
; 				if (!retried && err == -EEXIST) {
   19624: 0f 94 c0                     	sete	%al
   19627: 20 c3                        	andb	%al, %bl
   19629: 0f 84 11 05 00 00            	je	0x19b40 <bpf_object__create_maps+0x670>
; 		if (map->pin_path) {
   1962f: 49 8b bf 88 00 00 00         	movq	136(%r15), %rdi
   19636: 48 85 ff                     	testq	%rdi, %rdi
   19639: 0f 85 11 ff ff ff            	jne	0x19550 <bpf_object__create_maps+0x80>
   1963f: 41 8b 4f 18                  	movl	24(%r15), %ecx
; 		if (map->fd >= 0) {
   19643: 85 c9                        	testl	%ecx, %ecx
   19645: 0f 89 75 ff ff ff            	jns	0x195c0 <bpf_object__create_maps+0xf0>
; 			err = bpf_object__create_map(obj, map, false);
   1964b: 31 d2                        	xorl	%edx, %edx
   1964d: 4c 89 fe                     	movq	%r15, %rsi
   19650: 4c 89 e7                     	movq	%r12, %rdi
   19653: e8 a8 33 ff ff               	callq	0xca00 <bpf_object__create_map>
   19658: 41 89 c6                     	movl	%eax, %r14d
; 			if (err)
   1965b: 85 c0                        	testl	%eax, %eax
   1965d: 0f 85 f8 05 00 00            	jne	0x19c5b <bpf_object__create_maps+0x78b>
; 			pr_debug("map '%s': created successfully, fd=%d\n",
   19663: 41 8b 4f 18                  	movl	24(%r15), %ecx
   19667: 49 8b 57 08                  	movq	8(%r15), %rdx
   1966b: bf 02 00 00 00               	movl	$2, %edi
   19670: 31 c0                        	xorl	%eax, %eax
   19672: 48 8d 35 27 e5 01 00         	leaq	124199(%rip), %rsi      # 0x37ba0 <strs.2+0x4d10>
   19679: e8 52 ea fe ff               	callq	0x80d0 <libbpf_print>
; 	return map->libbpf_type != LIBBPF_MAP_UNSPEC;
   1967e: 41 8b 6f 58                  	movl	88(%r15), %ebp
; 			if (bpf_map__is_internal(map)) {
   19682: 85 ed                        	testl	%ebp, %ebp
   19684: 0f 85 06 03 00 00            	jne	0x19990 <bpf_object__create_maps+0x4c0>
; 			if (map->init_slots_sz && map->def.type != BPF_MAP_TYPE_PROG_ARRAY) {
   1968a: 41 8b 8f 80 00 00 00         	movl	128(%r15), %ecx
   19691: 85 c9                        	testl	%ecx, %ecx
   19693: 0f 84 3e ff ff ff            	je	0x195d7 <bpf_object__create_maps+0x107>
   19699: 41 83 7f 30 03               	cmpl	$3, 48(%r15)
   1969e: 0f 84 33 ff ff ff            	je	0x195d7 <bpf_object__create_maps+0x107>
; 						    targ_map - obj->maps);
   196a4: 88 5c 24 0f                  	movb	%bl, 15(%rsp)
; 		if (!map->init_slots[i])
   196a8: 49 8b 7f 78                  	movq	120(%r15), %rdi
; 	for (i = 0; i < map->init_slots_sz; i++) {
   196ac: 31 d2                        	xorl	%edx, %edx
; 			err = bpf_map_update_elem(map->fd, &i, &fd, 0);
   196ae: 4c 8d 74 24 1c               	leaq	28(%rsp), %r14
; 	for (i = 0; i < map->init_slots_sz; i++) {
   196b3: c7 44 24 18 00 00 00 00      	movl	$0, 24(%rsp)
; 			err = bpf_map_update_elem(map->fd, &i, &fd, 0);
   196bb: 4c 8d 6c 24 18               	leaq	24(%rsp), %r13
; 						    targ_map - obj->maps);
   196c0: 4c 89 fb                     	movq	%r15, %rbx
   196c3: 48 bd cd cc cc cc cc cc cc cc	movabsq	$-3689348814741910323, %rbp # imm = 0xCCCCCCCCCCCCCCCD
   196cd: eb 63                        	jmp	0x19732 <bpf_object__create_maps+0x262>
   196cf: 90                           	nop
   196d0: 4c 89 f9                     	movq	%r15, %rcx
; 						    map - obj->maps, i,
   196d3: 48 89 de                     	movq	%rbx, %rsi
; 						    targ_map - obj->maps);
   196d6: 49 2b 4c 24 68               	subq	104(%r12), %rcx
; 						    map - obj->maps, i,
   196db: 49 2b 74 24 68               	subq	104(%r12), %rsi
; 						    targ_map - obj->maps);
   196e0: 48 c1 f9 05                  	sarq	$5, %rcx
; 						    map - obj->maps, i,
   196e4: 48 c1 fe 05                  	sarq	$5, %rsi
; 			bpf_gen__populate_outer_map(obj->gen_loader,
   196e8: 0f af cd                     	imull	%ebp, %ecx
   196eb: 0f af f5                     	imull	%ebp, %esi
   196ee: e8 9d 74 00 00               	callq	0x20b90 <bpf_gen__populate_outer_map>
; 		pr_debug("map '%s': slot [%d] set to map '%s' fd=%d\n",
   196f3: 48 8b 53 08                  	movq	8(%rbx), %rdx
   196f7: 44 8b 4c 24 1c               	movl	28(%rsp), %r9d
   196fc: bf 02 00 00 00               	movl	$2, %edi
   19701: 31 c0                        	xorl	%eax, %eax
   19703: 4d 8b 47 08                  	movq	8(%r15), %r8
   19707: 8b 4c 24 18                  	movl	24(%rsp), %ecx
   1970b: 48 8d 35 76 e5 01 00         	leaq	124278(%rip), %rsi      # 0x37c88 <strs.2+0x4df8>
   19712: e8 b9 e9 fe ff               	callq	0x80d0 <libbpf_print>
; 	zfree(&map->init_slots);
   19717: 48 8b 7b 78                  	movq	120(%rbx), %rdi
; 	for (i = 0; i < map->init_slots_sz; i++) {
   1971b: 8b 44 24 18                  	movl	24(%rsp), %eax
   1971f: 8d 50 01                     	leal	1(%rax), %edx
   19722: 89 54 24 18                  	movl	%edx, 24(%rsp)
   19726: 3b 93 80 00 00 00            	cmpl	128(%rbx), %edx
   1972c: 0f 83 e6 03 00 00            	jae	0x19b18 <bpf_object__create_maps+0x648>
; 		if (!map->init_slots[i])
   19732: 89 d0                        	movl	%edx, %eax
   19734: 4c 8b 3c c7                  	movq	(%rdi,%rax,8), %r15
   19738: 4d 85 ff                     	testq	%r15, %r15
   1973b: 74 de                        	je	0x1971b <bpf_object__create_maps+0x24b>
; 		fd = bpf_map__fd(targ_map);
   1973d: 41 8b 47 18                  	movl	24(%r15), %eax
; 		if (obj->gen_loader) {
   19741: 49 8b bc 24 a0 00 00 00      	movq	160(%r12), %rdi
; 		fd = bpf_map__fd(targ_map);
   19749: 89 44 24 1c                  	movl	%eax, 28(%rsp)
; 		if (obj->gen_loader) {
   1974d: 48 85 ff                     	testq	%rdi, %rdi
   19750: 0f 85 7a ff ff ff            	jne	0x196d0 <bpf_object__create_maps+0x200>
; 			err = bpf_map_update_elem(map->fd, &i, &fd, 0);
   19756: 8b 7b 18                     	movl	24(%rbx), %edi
   19759: 31 c9                        	xorl	%ecx, %ecx
   1975b: 4c 89 f2                     	movq	%r14, %rdx
   1975e: 4c 89 ee                     	movq	%r13, %rsi
   19761: e8 8a cc 00 00               	callq	0x263f0 <bpf_map_update_elem>
; 		if (err) {
   19766: 85 c0                        	testl	%eax, %eax
   19768: 74 89                        	je	0x196f3 <bpf_object__create_maps+0x223>
; 			err = -errno;
   1976a: e8 81 bf fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1976f: 4d 89 fd                     	movq	%r15, %r13
; 			pr_warn("map '%s': failed to initialize slot [%d] to map '%s' fd=%d: %d\n",
   19772: 48 83 ec 08                  	subq	$8, %rsp
; 			err = -errno;
   19776: 49 89 df                     	movq	%rbx, %r15
   19779: 8b 28                        	movl	(%rax), %ebp
   1977b: 0f b6 5c 24 17               	movzbl	23(%rsp), %ebx
; 			pr_warn("map '%s': failed to initialize slot [%d] to map '%s' fd=%d: %d\n",
   19780: 31 c0                        	xorl	%eax, %eax
   19782: 48 8d 35 b7 e4 01 00         	leaq	124087(%rip), %rsi      # 0x37c40 <strs.2+0x4db0>
   19789: 49 8b 57 08                  	movq	8(%r15), %rdx
   1978d: 4d 8b 45 08                  	movq	8(%r13), %r8
   19791: 31 ff                        	xorl	%edi, %edi
; 			err = -errno;
   19793: 41 89 ee                     	movl	%ebp, %r14d
   19796: 41 f7 de                     	negl	%r14d
; 			pr_warn("map '%s': failed to initialize slot [%d] to map '%s' fd=%d: %d\n",
   19799: 41 56                        	pushq	%r14
   1979b: 44 8b 4c 24 2c               	movl	44(%rsp), %r9d
   197a0: 8b 4c 24 28                  	movl	40(%rsp), %ecx
   197a4: e8 27 e9 fe ff               	callq	0x80d0 <libbpf_print>
; 				if (err < 0) {
   197a9: 58                           	popq	%rax
   197aa: 5a                           	popq	%rdx
   197ab: 85 ed                        	testl	%ebp, %ebp
   197ad: 0f 8e 24 fe ff ff            	jle	0x195d7 <bpf_object__create_maps+0x107>
; 					zclose(map->fd);
   197b3: 41 8b 7f 18                  	movl	24(%r15), %edi
   197b7: 4d 89 fd                     	movq	%r15, %r13
   197ba: 85 ff                        	testl	%edi, %edi
   197bc: 0f 89 09 05 00 00            	jns	0x19ccb <bpf_object__create_maps+0x7fb>
   197c2: 41 c7 45 18 ff ff ff ff      	movl	$4294967295, 24(%r13)   # imm = 0xFFFFFFFF
; 					goto err_out;
   197ca: 4c 8d bc 24 80 00 00 00      	leaq	128(%rsp), %r15
   197d2: e9 92 03 00 00               	jmp	0x19b69 <bpf_object__create_maps+0x699>
   197d7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	if (map->def.type == BPF_MAP_TYPE_PERF_EVENT_ARRAY && !map->def.max_entries) {
   197e0: 41 8b 77 3c                  	movl	60(%r15), %esi
   197e4: 85 f6                        	testl	%esi, %esi
   197e6: 0f 85 55 fd ff ff            	jne	0x19541 <bpf_object__create_maps+0x71>
; 	tmp_cpus = READ_ONCE(cpus);
   197ec: 44 8b 35 2d da 02 00         	movl	186925(%rip), %r14d     # 0x47220 <cpus.16>
; 	if (tmp_cpus > 0)
   197f3: 45 85 f6                     	testl	%r14d, %r14d
   197f6: 0f 8e 6f 04 00 00            	jle	0x19c6b <bpf_object__create_maps+0x79b>
; 		pr_debug("map '%s': setting size to %d\n", map->name, nr_cpus);
   197fc: 49 8b 57 08                  	movq	8(%r15), %rdx
   19800: 44 89 f1                     	movl	%r14d, %ecx
   19803: 48 8d 35 d6 e1 01 00         	leaq	123350(%rip), %rsi      # 0x379e0 <strs.2+0x4b50>
   1980a: 31 c0                        	xorl	%eax, %eax
   1980c: bf 02 00 00 00               	movl	$2, %edi
   19811: e8 ba e8 fe ff               	callq	0x80d0 <libbpf_print>
; 		map->def.max_entries = nr_cpus;
   19816: 45 89 77 3c                  	movl	%r14d, 60(%r15)
; 		if (err)
   1981a: e9 22 fd ff ff               	jmp	0x19541 <bpf_object__create_maps+0x71>
   1981f: 90                           	nop
;   return __builtin___memset_chk (__dest, __ch, __len,
   19820: 4c 8d 6c 24 20               	leaq	32(%rsp), %r13
   19825: 31 c0                        	xorl	%eax, %eax
   19827: b9 0b 00 00 00               	movl	$11, %ecx
; 	__u32 map_info_len = sizeof(map_info);
   1982c: c7 44 24 1c 58 00 00 00      	movl	$88, 28(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   19834: 4c 89 ef                     	movq	%r13, %rdi
; 	err = bpf_obj_get_info_by_fd(map_fd, &map_info, &map_info_len);
   19837: 48 8d 54 24 1c               	leaq	28(%rsp), %rdx
   1983c: 4c 89 ee                     	movq	%r13, %rsi
;   return __builtin___memset_chk (__dest, __ch, __len,
   1983f: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	err = bpf_obj_get_info_by_fd(map_fd, &map_info, &map_info_len);
   19842: 89 ef                        	movl	%ebp, %edi
   19844: e8 77 e3 00 00               	callq	0x27bc0 <bpf_obj_get_info_by_fd>
; 	if (err && errno == EINVAL)
   19849: 85 c0                        	testl	%eax, %eax
   1984b: 0f 84 19 01 00 00            	je	0x1996a <bpf_object__create_maps+0x49a>
   19851: e8 9a be fe ff               	callq	0x56f0 <.plt.sec+0x80>
   19856: 8b 38                        	movl	(%rax), %edi
   19858: 49 89 c6                     	movq	%rax, %r14
   1985b: 83 ff 16                     	cmpl	$22, %edi
   1985e: 0f 84 f4 00 00 00            	je	0x19958 <bpf_object__create_maps+0x488>
   19864: 4d 89 fd                     	movq	%r15, %r13
; 		pr_warn("failed to get map info for map FD %d: %s\n", map_fd,
   19867: 4c 8d bc 24 80 00 00 00      	leaq	128(%rsp), %r15
   1986f: ba 80 00 00 00               	movl	$128, %edx
   19874: 4c 89 fe                     	movq	%r15, %rsi
   19877: e8 54 41 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1987c: 89 ea                        	movl	%ebp, %edx
   1987e: 48 8d 35 e3 e1 01 00         	leaq	123363(%rip), %rsi      # 0x37a68 <strs.2+0x4bd8>
   19885: 31 ff                        	xorl	%edi, %edi
   19887: 48 89 c1                     	movq	%rax, %rcx
   1988a: 31 c0                        	xorl	%eax, %eax
   1988c: e8 3f e8 fe ff               	callq	0x80d0 <libbpf_print>
; 		pr_warn("couldn't reuse pinned map at '%s': parameter mismatch\n",
   19891: 49 8b 95 88 00 00 00         	movq	136(%r13), %rdx
   19898: 48 8d 35 01 e2 01 00         	leaq	123393(%rip), %rsi      # 0x37aa0 <strs.2+0x4c10>
   1989f: 31 ff                        	xorl	%edi, %edi
   198a1: 31 c0                        	xorl	%eax, %eax
; 		return -EINVAL;
   198a3: 41 be ea ff ff ff            	movl	$4294967274, %r14d      # imm = 0xFFFFFFEA
; 		pr_warn("couldn't reuse pinned map at '%s': parameter mismatch\n",
   198a9: e8 22 e8 fe ff               	callq	0x80d0 <libbpf_print>
; 		close(pin_fd);
   198ae: 89 ef                        	movl	%ebp, %edi
   198b0: e8 4b c0 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 			if (err) {
   198b5: 0f 1f 00                     	nopl	(%rax)
; 				pr_warn("map '%s': error reusing pinned map\n",
   198b8: 49 8b 55 08                  	movq	8(%r13), %rdx
   198bc: 48 8d 35 45 e2 01 00         	leaq	123461(%rip), %rsi      # 0x37b08 <strs.2+0x4c78>
   198c3: 31 ff                        	xorl	%edi, %edi
   198c5: 31 c0                        	xorl	%eax, %eax
   198c7: e8 04 e8 fe ff               	callq	0x80d0 <libbpf_print>
; 				goto err_out;
   198cc: e9 98 02 00 00               	jmp	0x19b69 <bpf_object__create_maps+0x699>
   198d1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (bpf_map__is_internal(map) && !kernel_supports(obj, FEAT_GLOBAL_DATA))
   198d8: be 01 00 00 00               	movl	$1, %esi
   198dd: 4c 89 e7                     	movq	%r12, %rdi
   198e0: e8 2b 2b ff ff               	callq	0xc410 <kernel_supports>
   198e5: 84 c0                        	testb	%al, %al
   198e7: 0f 85 3b fc ff ff            	jne	0x19528 <bpf_object__create_maps+0x58>
; 			map->autocreate = false;
   198ed: 41 c6 87 92 00 00 00 00      	movb	$0, 146(%r15)
; 			pr_debug("map '%s': skipped auto-creating...\n", map->name);
   198f5: 49 8b 57 08                  	movq	8(%r15), %rdx
   198f9: 48 8d 35 b0 e0 01 00         	leaq	123056(%rip), %rsi      # 0x379b0 <strs.2+0x4b20>
   19900: bf 02 00 00 00               	movl	$2, %edi
   19905: 31 c0                        	xorl	%eax, %eax
   19907: e8 c4 e7 fe ff               	callq	0x80d0 <libbpf_print>
; 	for (i = 0; i < obj->nr_maps; i++) {
   1990c: 83 44 24 08 01               	addl	$1, 8(%rsp)
   19911: 8b 44 24 08                  	movl	8(%rsp), %eax
   19915: 49 3b 44 24 70               	cmpq	112(%r12), %rax
   1991a: 0f 82 ec fb ff ff            	jb	0x1950c <bpf_object__create_maps+0x3c>
; 	return 0;
   19920: 45 31 f6                     	xorl	%r14d, %r14d
   19923: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; }
   19928: 48 8b 84 24 08 01 00 00      	movq	264(%rsp), %rax
   19930: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   19939: 0f 85 c0 03 00 00            	jne	0x19cff <bpf_object__create_maps+0x82f>
   1993f: 48 81 c4 18 01 00 00         	addq	$280, %rsp              # imm = 0x118
   19946: 44 89 f0                     	movl	%r14d, %eax
   19949: 5b                           	popq	%rbx
   1994a: 5d                           	popq	%rbp
   1994b: 41 5c                        	popq	%r12
   1994d: 41 5d                        	popq	%r13
   1994f: 41 5e                        	popq	%r14
   19951: 41 5f                        	popq	%r15
   19953: c3                           	retq
   19954: 0f 1f 40 00                  	nopl	(%rax)
; 		err = bpf_get_map_info_from_fdinfo(map_fd, &map_info);
   19958: 4c 89 ee                     	movq	%r13, %rsi
   1995b: 89 ef                        	movl	%ebp, %edi
   1995d: e8 5e e8 fe ff               	callq	0x81c0 <bpf_get_map_info_from_fdinfo>
; 	if (err) {
   19962: 85 c0                        	testl	%eax, %eax
   19964: 0f 85 9a 03 00 00            	jne	0x19d04 <bpf_object__create_maps+0x834>
; 		map_info.map_flags == map->def.map_flags &&
   1996a: 41 8b 47 30                  	movl	48(%r15), %eax
   1996e: 39 44 24 20                  	cmpl	%eax, 32(%rsp)
   19972: 0f 84 a8 00 00 00            	je	0x19a20 <bpf_object__create_maps+0x550>
   19978: 4d 89 fd                     	movq	%r15, %r13
   1997b: 4c 8d bc 24 80 00 00 00      	leaq	128(%rsp), %r15
   19983: e9 09 ff ff ff               	jmp	0x19891 <bpf_object__create_maps+0x3c1>
   19988: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (obj->gen_loader) {
   19990: 49 8b bc 24 a0 00 00 00      	movq	160(%r12), %rdi
; 		bpf_gen__map_update_elem(obj->gen_loader, map - obj->maps,
   19998: 49 8b 57 60                  	movq	96(%r15), %rdx
; 	int err, zero = 0;
   1999c: c7 44 24 1c 00 00 00 00      	movl	$0, 28(%rsp)
; 	if (obj->gen_loader) {
   199a4: 48 85 ff                     	testq	%rdi, %rdi
   199a7: 0f 84 f3 00 00 00            	je	0x19aa0 <bpf_object__create_maps+0x5d0>
; 		bpf_gen__map_update_elem(obj->gen_loader, map - obj->maps,
   199ad: 4c 89 fe                     	movq	%r15, %rsi
   199b0: 49 2b 74 24 68               	subq	104(%r12), %rsi
   199b5: 41 8b 4f 38                  	movl	56(%r15), %ecx
; 		if (map_type == LIBBPF_MAP_RODATA || map_type == LIBBPF_MAP_KCONFIG)
   199b9: 83 ed 03                     	subl	$3, %ebp
; 		bpf_gen__map_update_elem(obj->gen_loader, map - obj->maps,
   199bc: 49 bd cd cc cc cc cc cc cc cc	movabsq	$-3689348814741910323, %r13 # imm = 0xCCCCCCCCCCCCCCCD
   199c6: 48 c1 fe 05                  	sarq	$5, %rsi
   199ca: 41 0f af f5                  	imull	%r13d, %esi
   199ce: e8 cd 6f 00 00               	callq	0x209a0 <bpf_gen__map_update_elem>
; 		if (map_type == LIBBPF_MAP_RODATA || map_type == LIBBPF_MAP_KCONFIG)
   199d3: 83 fd 01                     	cmpl	$1, %ebp
   199d6: 0f 87 ae fc ff ff            	ja	0x1968a <bpf_object__create_maps+0x1ba>
; 			bpf_gen__map_freeze(obj->gen_loader, map - obj->maps);
   199dc: 4c 89 fe                     	movq	%r15, %rsi
   199df: 49 2b 74 24 68               	subq	104(%r12), %rsi
   199e4: 49 8b bc 24 a0 00 00 00      	movq	160(%r12), %rdi
   199ec: 48 c1 fe 05                  	sarq	$5, %rsi
   199f0: 41 0f af f5                  	imull	%r13d, %esi
   199f4: e8 c7 72 00 00               	callq	0x20cc0 <bpf_gen__map_freeze>
; 				if (err < 0) {
   199f9: e9 8c fc ff ff               	jmp	0x1968a <bpf_object__create_maps+0x1ba>
   199fe: 66 90                        	nop
; 			pr_debug("found no pinned map to reuse at '%s'\n",
   19a00: 49 8b 97 88 00 00 00         	movq	136(%r15), %rdx
   19a07: 48 8d 35 fa df 01 00         	leaq	122874(%rip), %rsi      # 0x37a08 <strs.2+0x4b78>
   19a0e: bf 02 00 00 00               	movl	$2, %edi
   19a13: 31 c0                        	xorl	%eax, %eax
   19a15: e8 b6 e6 fe ff               	callq	0x80d0 <libbpf_print>
; 			if (err) {
   19a1a: e9 8d fb ff ff               	jmp	0x195ac <bpf_object__create_maps+0xdc>
   19a1f: 90                           	nop
; 	return (map_info.type == map->def.type &&
   19a20: 41 8b 47 34                  	movl	52(%r15), %eax
   19a24: 39 44 24 28                  	cmpl	%eax, 40(%rsp)
   19a28: 0f 85 4a ff ff ff            	jne	0x19978 <bpf_object__create_maps+0x4a8>
; 		map_info.key_size == map->def.key_size &&
   19a2e: 41 8b 47 38                  	movl	56(%r15), %eax
   19a32: 39 44 24 2c                  	cmpl	%eax, 44(%rsp)
   19a36: 0f 85 3c ff ff ff            	jne	0x19978 <bpf_object__create_maps+0x4a8>
; 		map_info.value_size == map->def.value_size &&
   19a3c: 41 8b 47 3c                  	movl	60(%r15), %eax
   19a40: 39 44 24 30                  	cmpl	%eax, 48(%rsp)
   19a44: 0f 85 2e ff ff ff            	jne	0x19978 <bpf_object__create_maps+0x4a8>
; 		map_info.max_entries == map->def.max_entries &&
   19a4a: 41 8b 47 40                  	movl	64(%r15), %eax
   19a4e: 39 44 24 34                  	cmpl	%eax, 52(%rsp)
   19a52: 0f 85 20 ff ff ff            	jne	0x19978 <bpf_object__create_maps+0x4a8>
; 		map_info.map_flags == map->def.map_flags &&
   19a58: 49 8b 87 98 00 00 00         	movq	152(%r15), %rax
   19a5f: 48 39 44 24 70               	cmpq	%rax, 112(%rsp)
   19a64: 0f 85 0e ff ff ff            	jne	0x19978 <bpf_object__create_maps+0x4a8>
; 	err = bpf_map__reuse_fd(map, pin_fd);
   19a6a: 4c 89 ff                     	movq	%r15, %rdi
   19a6d: 89 ee                        	movl	%ebp, %esi
   19a6f: e8 ec 26 ff ff               	callq	0xc160 <bpf_map__reuse_fd>
; 	close(pin_fd);
   19a74: 89 ef                        	movl	%ebp, %edi
; 	err = bpf_map__reuse_fd(map, pin_fd);
   19a76: 41 89 c6                     	movl	%eax, %r14d
; 	close(pin_fd);
   19a79: e8 82 be fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (err) {
   19a7e: 45 85 f6                     	testl	%r14d, %r14d
   19a81: 0f 84 51 02 00 00            	je	0x19cd8 <bpf_object__create_maps+0x808>
   19a87: 4d 89 fd                     	movq	%r15, %r13
   19a8a: 4c 8d bc 24 80 00 00 00      	leaq	128(%rsp), %r15
   19a92: e9 21 fe ff ff               	jmp	0x198b8 <bpf_object__create_maps+0x3e8>
   19a97: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	err = bpf_map_update_elem(map->fd, &zero, map->mmaped, 0);
   19aa0: 41 8b 7f 18                  	movl	24(%r15), %edi
   19aa4: 31 c9                        	xorl	%ecx, %ecx
   19aa6: 48 8d 74 24 1c               	leaq	28(%rsp), %rsi
   19aab: e8 40 c9 00 00               	callq	0x263f0 <bpf_map_update_elem>
; 	if (err) {
   19ab0: 85 c0                        	testl	%eax, %eax
   19ab2: 0f 85 40 01 00 00            	jne	0x19bf8 <bpf_object__create_maps+0x728>
; 	if (map_type == LIBBPF_MAP_RODATA || map_type == LIBBPF_MAP_KCONFIG) {
   19ab8: 83 ed 03                     	subl	$3, %ebp
   19abb: 83 fd 01                     	cmpl	$1, %ebp
   19abe: 0f 87 c6 fb ff ff            	ja	0x1968a <bpf_object__create_maps+0x1ba>
; 		err = bpf_map_freeze(map->fd);
   19ac4: 41 8b 7f 18                  	movl	24(%r15), %edi
   19ac8: e8 93 cd 00 00               	callq	0x26860 <bpf_map_freeze>
; 		if (err) {
   19acd: 85 c0                        	testl	%eax, %eax
   19acf: 0f 84 b5 fb ff ff            	je	0x1968a <bpf_object__create_maps+0x1ba>
; 			err = -errno;
   19ad5: e8 16 bc fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19ada: 48 8d ac 24 80 00 00 00      	leaq	128(%rsp), %rbp
   19ae2: ba 80 00 00 00               	movl	$128, %edx
; 			err = -errno;
   19ae7: 44 8b 30                     	movl	(%rax), %r14d
; 			cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19aea: 48 89 ee                     	movq	%rbp, %rsi
; 			err = -errno;
   19aed: 41 f7 de                     	negl	%r14d
; 			cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19af0: 44 89 f7                     	movl	%r14d, %edi
   19af3: e8 d8 3e 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 			pr_warn("Error freezing map(%s) as read-only: %s\n",
   19af8: 49 8b 57 08                  	movq	8(%r15), %rdx
   19afc: 48 8d 35 05 e1 01 00         	leaq	123141(%rip), %rsi      # 0x37c08 <strs.2+0x4d78>
   19b03: 31 ff                        	xorl	%edi, %edi
; 			cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19b05: 48 89 c1                     	movq	%rax, %rcx
; 			pr_warn("Error freezing map(%s) as read-only: %s\n",
   19b08: 31 c0                        	xorl	%eax, %eax
   19b0a: e8 c1 e5 fe ff               	callq	0x80d0 <libbpf_print>
; 			return err;
   19b0f: e9 1e 01 00 00               	jmp	0x19c32 <bpf_object__create_maps+0x762>
   19b14: 0f 1f 40 00                  	nopl	(%rax)
; 	zfree(&map->init_slots);
   19b18: 49 89 df                     	movq	%rbx, %r15
   19b1b: 0f b6 5c 24 0f               	movzbl	15(%rsp), %ebx
   19b20: e8 9b bb fe ff               	callq	0x56c0 <.plt.sec+0x50>
   19b25: 49 c7 47 78 00 00 00 00      	movq	$0, 120(%r15)
; 	map->init_slots_sz = 0;
   19b2d: 41 c7 87 80 00 00 00 00 00 00 00     	movl	$0, 128(%r15)
; 				if (err < 0) {
   19b38: e9 9a fa ff ff               	jmp	0x195d7 <bpf_object__create_maps+0x107>
   19b3d: 0f 1f 00                     	nopl	(%rax)
; 				pr_warn("map '%s': failed to auto-pin at '%s': %d\n",
   19b40: 49 8b 8f 88 00 00 00         	movq	136(%r15), %rcx
   19b47: 49 8b 57 08                  	movq	8(%r15), %rdx
   19b4b: 45 89 f0                     	movl	%r14d, %r8d
   19b4e: 31 ff                        	xorl	%edi, %edi
   19b50: 48 8d 35 69 e1 01 00         	leaq	123241(%rip), %rsi      # 0x37cc0 <strs.2+0x4e30>
   19b57: 31 c0                        	xorl	%eax, %eax
   19b59: 4d 89 fd                     	movq	%r15, %r13
   19b5c: e8 6f e5 fe ff               	callq	0x80d0 <libbpf_print>
; 				goto err_out;
   19b61: 4c 8d bc 24 80 00 00 00      	leaq	128(%rsp), %r15
; 	cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19b69: ba 80 00 00 00               	movl	$128, %edx
   19b6e: 4c 89 fe                     	movq	%r15, %rsi
   19b71: 44 89 f7                     	movl	%r14d, %edi
   19b74: e8 57 3e 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 	pr_warn("map '%s': failed to create: %s(%d)\n", map->name, cp, err);
   19b79: 49 8b 55 08                  	movq	8(%r13), %rdx
   19b7d: 45 89 f0                     	movl	%r14d, %r8d
   19b80: 31 ff                        	xorl	%edi, %edi
; 	cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19b82: 48 89 c1                     	movq	%rax, %rcx
; 	pr_warn("map '%s': failed to create: %s(%d)\n", map->name, cp, err);
   19b85: 48 8d 35 6c e1 01 00         	leaq	123244(%rip), %rsi      # 0x37cf8 <strs.2+0x4e68>
   19b8c: 31 c0                        	xorl	%eax, %eax
   19b8e: e8 3d e5 fe ff               	callq	0x80d0 <libbpf_print>
; 	pr_perm_msg(err);
   19b93: 44 89 f7                     	movl	%r14d, %edi
   19b96: e8 e5 fe fe ff               	callq	0x9a80 <pr_perm_msg>
; 	for (j = 0; j < i; j++)
   19b9b: 8b 44 24 08                  	movl	8(%rsp), %eax
   19b9f: 85 c0                        	testl	%eax, %eax
   19ba1: 0f 84 81 fd ff ff            	je	0x19928 <bpf_object__create_maps+0x458>
   19ba7: 48 8d 2c 80                  	leaq	(%rax,%rax,4), %rbp
; 		zclose(obj->maps[j].fd);
   19bab: 49 8b 54 24 68               	movq	104(%r12), %rdx
   19bb0: 31 db                        	xorl	%ebx, %ebx
   19bb2: 48 c1 e5 05                  	shlq	$5, %rbp
   19bb6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   19bc0: 48 8d 04 1a                  	leaq	(%rdx,%rbx), %rax
   19bc4: 8b 78 18                     	movl	24(%rax), %edi
   19bc7: 85 ff                        	testl	%edi, %edi
   19bc9: 78 0e                        	js	0x19bd9 <bpf_object__create_maps+0x709>
   19bcb: e8 30 bd fe ff               	callq	0x5900 <.plt.sec+0x290>
   19bd0: 49 8b 54 24 68               	movq	104(%r12), %rdx
   19bd5: 48 8d 04 1a                  	leaq	(%rdx,%rbx), %rax
; 	for (j = 0; j < i; j++)
   19bd9: 48 81 c3 a0 00 00 00         	addq	$160, %rbx
; 		zclose(obj->maps[j].fd);
   19be0: c7 40 18 ff ff ff ff         	movl	$4294967295, 24(%rax)   # imm = 0xFFFFFFFF
; 	for (j = 0; j < i; j++)
   19be7: 48 39 dd                     	cmpq	%rbx, %rbp
   19bea: 75 d4                        	jne	0x19bc0 <bpf_object__create_maps+0x6f0>
   19bec: e9 37 fd ff ff               	jmp	0x19928 <bpf_object__create_maps+0x458>
   19bf1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		err = -errno;
   19bf8: e8 f3 ba fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19bfd: 48 8d ac 24 80 00 00 00      	leaq	128(%rsp), %rbp
   19c05: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   19c0a: 44 8b 30                     	movl	(%rax), %r14d
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19c0d: 48 89 ee                     	movq	%rbp, %rsi
; 		err = -errno;
   19c10: 41 f7 de                     	negl	%r14d
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19c13: 44 89 f7                     	movl	%r14d, %edi
   19c16: e8 b5 3d 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("Error setting initial map(%s) contents: %s\n",
   19c1b: 49 8b 57 08                  	movq	8(%r15), %rdx
   19c1f: 48 8d 35 aa df 01 00         	leaq	122794(%rip), %rsi      # 0x37bd0 <strs.2+0x4d40>
   19c26: 31 ff                        	xorl	%edi, %edi
; 		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
   19c28: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("Error setting initial map(%s) contents: %s\n",
   19c2b: 31 c0                        	xorl	%eax, %eax
   19c2d: e8 9e e4 fe ff               	callq	0x80d0 <libbpf_print>
; 				if (err < 0) {
   19c32: 45 85 f6                     	testl	%r14d, %r14d
   19c35: 0f 89 4f fa ff ff            	jns	0x1968a <bpf_object__create_maps+0x1ba>
; 					zclose(map->fd);
   19c3b: 4d 89 fd                     	movq	%r15, %r13
   19c3e: 49 89 ef                     	movq	%rbp, %r15
   19c41: 41 8b 7d 18                  	movl	24(%r13), %edi
   19c45: 85 ff                        	testl	%edi, %edi
   19c47: 78 05                        	js	0x19c4e <bpf_object__create_maps+0x77e>
   19c49: e8 b2 bc fe ff               	callq	0x5900 <.plt.sec+0x290>
   19c4e: 41 c7 45 18 ff ff ff ff      	movl	$4294967295, 24(%r13)   # imm = 0xFFFFFFFF
; 					goto err_out;
   19c56: e9 0e ff ff ff               	jmp	0x19b69 <bpf_object__create_maps+0x699>
   19c5b: 4d 89 fd                     	movq	%r15, %r13
   19c5e: 4c 8d bc 24 80 00 00 00      	leaq	128(%rsp), %r15
   19c66: e9 fe fe ff ff               	jmp	0x19b69 <bpf_object__create_maps+0x699>
   19c6b: e8 b0 f7 ff ff               	callq	0x19420 <libbpf_num_possible_cpus.part.0>
   19c70: 41 89 c6                     	movl	%eax, %r14d
; 		if (nr_cpus < 0) {
   19c73: 85 c0                        	testl	%eax, %eax
   19c75: 0f 89 81 fb ff ff            	jns	0x197fc <bpf_object__create_maps+0x32c>
; 			pr_warn("map '%s': failed to determine number of system CPUs: %d\n",
   19c7b: 49 8b 57 08                  	movq	8(%r15), %rdx
   19c7f: 89 c1                        	movl	%eax, %ecx
   19c81: 48 8d 35 a0 e0 01 00         	leaq	123040(%rip), %rsi      # 0x37d28 <strs.2+0x4e98>
   19c88: 31 ff                        	xorl	%edi, %edi
   19c8a: 31 c0                        	xorl	%eax, %eax
   19c8c: 4d 89 fd                     	movq	%r15, %r13
   19c8f: 4c 8d bc 24 80 00 00 00      	leaq	128(%rsp), %r15
   19c97: e8 34 e4 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   19c9c: e9 c8 fe ff ff               	jmp	0x19b69 <bpf_object__create_maps+0x699>
; 				pr_warn("map '%s': cannot find pinned map\n",
   19ca1: 49 8b 57 08                  	movq	8(%r15), %rdx
   19ca5: 48 8d 35 8c de 01 00         	leaq	122508(%rip), %rsi      # 0x37b38 <strs.2+0x4ca8>
   19cac: 31 ff                        	xorl	%edi, %edi
   19cae: 31 c0                        	xorl	%eax, %eax
   19cb0: 4d 89 fd                     	movq	%r15, %r13
; 				err = -ENOENT;
   19cb3: 41 be fe ff ff ff            	movl	$4294967294, %r14d      # imm = 0xFFFFFFFE
   19cb9: 4c 8d bc 24 80 00 00 00      	leaq	128(%rsp), %r15
; 				pr_warn("map '%s': cannot find pinned map\n",
   19cc1: e8 0a e4 fe ff               	callq	0x80d0 <libbpf_print>
; 				goto err_out;
   19cc6: e9 9e fe ff ff               	jmp	0x19b69 <bpf_object__create_maps+0x699>
; 					zclose(map->fd);
   19ccb: e8 30 bc fe ff               	callq	0x5900 <.plt.sec+0x290>
   19cd0: e9 ed fa ff ff               	jmp	0x197c2 <bpf_object__create_maps+0x2f2>
   19cd5: 0f 1f 00                     	nopl	(%rax)
; 	map->pinned = true;
   19cd8: 41 c6 87 90 00 00 00 01      	movb	$1, 144(%r15)
; 	pr_debug("reused pinned map at '%s'\n", map->pin_path);
   19ce0: 49 8b 97 88 00 00 00         	movq	136(%r15), %rdx
   19ce7: 48 8d 35 f2 dd 01 00         	leaq	122354(%rip), %rsi      # 0x37ae0 <strs.2+0x4c50>
   19cee: 31 c0                        	xorl	%eax, %eax
   19cf0: bf 02 00 00 00               	movl	$2, %edi
   19cf5: e8 d6 e3 fe ff               	callq	0x80d0 <libbpf_print>
; 			if (err) {
   19cfa: e9 ad f8 ff ff               	jmp	0x195ac <bpf_object__create_maps+0xdc>
; }
   19cff: e8 fc ba fe ff               	callq	0x5800 <.plt.sec+0x190>
; 		pr_warn("failed to get map info for map FD %d: %s\n", map_fd,
   19d04: 41 8b 3e                     	movl	(%r14), %edi
   19d07: 4d 89 fd                     	movq	%r15, %r13
   19d0a: e9 58 fb ff ff               	jmp	0x19867 <bpf_object__create_maps+0x397>
   19d0f: 4d 89 fd                     	movq	%r15, %r13
; 		err = -errno;
   19d12: 41 f7 de                     	negl	%r14d
   19d15: 49 89 ef                     	movq	%rbp, %r15
   19d18: e9 9b fb ff ff               	jmp	0x198b8 <bpf_object__create_maps+0x3e8>
   19d1d: 0f 1f 00                     	nopl	(%rax)

0000000000019d20 <bpf_object_load.constprop.0>:
; static int bpf_object_load(struct bpf_object *obj, int extra_log_level, const char *target_btf_path)
   19d20: 41 57                        	pushq	%r15
   19d22: 41 56                        	pushq	%r14
   19d24: 41 55                        	pushq	%r13
   19d26: 41 54                        	pushq	%r12
   19d28: 55                           	pushq	%rbp
   19d29: 53                           	pushq	%rbx
   19d2a: 48 81 ec 78 01 00 00         	subq	$376, %rsp              # imm = 0x178
   19d31: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   19d3a: 48 89 84 24 68 01 00 00      	movq	%rax, 360(%rsp)
   19d42: 31 c0                        	xorl	%eax, %eax
; 	if (!obj)
   19d44: 48 85 ff                     	testq	%rdi, %rdi
   19d47: 0f 84 86 25 00 00            	je	0x1c2d3 <bpf_object_load.constprop.0+0x25b3>
; 	if (obj->loaded) {
   19d4d: 0f b6 87 98 00 00 00         	movzbl	152(%rdi), %eax
   19d54: 49 89 fe                     	movq	%rdi, %r14
   19d57: 88 04 24                     	movb	%al, (%rsp)
   19d5a: 84 c0                        	testb	%al, %al
   19d5c: 0f 85 5e 25 00 00            	jne	0x1c2c0 <bpf_object_load.constprop.0+0x25a0>
; 	if (obj->gen_loader)
   19d62: 48 8b bf a0 00 00 00         	movq	160(%rdi), %rdi
   19d69: 48 85 ff                     	testq	%rdi, %rdi
   19d6c: 0f 84 de 17 00 00            	je	0x1b550 <bpf_object_load.constprop.0+0x1830>
; 		bpf_gen__init(obj->gen_loader, extra_log_level, obj->nr_programs, obj->nr_maps);
   19d72: 41 8b 4e 70                  	movl	112(%r14), %ecx
   19d76: 41 8b 56 60                  	movl	96(%r14), %edx
   19d7a: 31 f6                        	xorl	%esi, %esi
   19d7c: e8 8f 56 00 00               	callq	0x1f410 <bpf_gen__init>
; 	if (obj->gen_loader)
   19d81: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
; 	struct bpf_insn insns[] = {
   19d89: 48 c7 84 24 d0 00 00 00 b7 00 00 00  	movq	$183, 208(%rsp)
   19d95: 48 c7 84 24 d8 00 00 00 95 00 00 00  	movq	$149, 216(%rsp)
; 	if (obj->gen_loader)
   19da1: 0f 84 c1 17 00 00            	je	0x1b568 <bpf_object_load.constprop.0+0x1848>
; 	err = err ? : bpf_object__resolve_externs(obj, obj->kconfig);
   19da7: 49 8b 86 80 00 00 00         	movq	128(%r14), %rax
   19dae: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	if (obj->nr_extern == 0)
   19db3: 41 8b 86 90 00 00 00         	movl	144(%r14), %eax
   19dba: 85 c0                        	testl	%eax, %eax
   19dbc: 0f 84 a4 01 00 00            	je	0x19f66 <bpf_object_load.constprop.0+0x246>
; 	void *kcfg_data = NULL;
   19dc2: 48 c7 44 24 08 00 00 00 00   	movq	$0, 8(%rsp)
; 	if (obj->kconfig_map_idx >= 0)
   19dcb: 49 63 96 94 00 00 00         	movslq	148(%r14), %rdx
   19dd2: 85 d2                        	testl	%edx, %edx
   19dd4: 78 15                        	js	0x19deb <bpf_object_load.constprop.0+0xcb>
; 		kcfg_data = obj->maps[obj->kconfig_map_idx].mmaped;
   19dd6: 48 8d 14 92                  	leaq	(%rdx,%rdx,4), %rdx
   19dda: 48 c1 e2 05                  	shlq	$5, %rdx
   19dde: 49 03 56 68                  	addq	104(%r14), %rdx
   19de2: 48 8b 4a 60                  	movq	96(%rdx), %rcx
   19de6: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
; 	for (i = 0; i < obj->nr_extern; i++) {
   19deb: 85 c0                        	testl	%eax, %eax
   19ded: 0f 8e 20 01 00 00            	jle	0x19f13 <bpf_object_load.constprop.0+0x1f3>
; 	bool need_config = false, need_kallsyms = false;
   19df3: c6 44 24 18 00               	movb	$0, 24(%rsp)
; 	for (i = 0; i < obj->nr_extern; i++) {
   19df8: 31 ed                        	xorl	%ebp, %ebp
; 			if (str_has_pfx(ext->name, "CONFIG_")) {
   19dfa: 4c 8d 2d 72 7f 01 00         	leaq	98162(%rip), %r13       # 0x31d73 <_IO_stdin_used+0x1d73>
; 	bool need_vmlinux_btf = false;
   19e01: c6 44 24 10 00               	movb	$0, 16(%rsp)
   19e06: e9 b7 00 00 00               	jmp	0x19ec2 <bpf_object_load.constprop.0+0x1a2>
   19e0b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			if (strcmp(ext->name, "LINUX_KERNEL_VERSION") == 0) {
   19e10: 48 8d 35 fe 84 01 00         	leaq	99582(%rip), %rsi       # 0x32315 <_IO_stdin_used+0x2315>
   19e17: 4c 89 ff                     	movq	%r15, %rdi
   19e1a: e8 91 bb fe ff               	callq	0x59b0 <.plt.sec+0x340>
   19e1f: 85 c0                        	testl	%eax, %eax
   19e21: 0f 84 79 04 00 00            	je	0x1a2a0 <bpf_object_load.constprop.0+0x580>
; 			} else if (strcmp(ext->name, "LINUX_HAS_BPF_COOKIE") == 0) {
   19e27: 48 8d 35 fc 84 01 00         	leaq	99580(%rip), %rsi       # 0x3232a <_IO_stdin_used+0x232a>
   19e2e: 4c 89 ff                     	movq	%r15, %rdi
   19e31: e8 7a bb fe ff               	callq	0x59b0 <.plt.sec+0x340>
   19e36: 85 c0                        	testl	%eax, %eax
   19e38: 0f 84 92 04 00 00            	je	0x1a2d0 <bpf_object_load.constprop.0+0x5b0>
; 			} else if (strcmp(ext->name, "LINUX_HAS_SYSCALL_WRAPPER") == 0) {
   19e3e: 48 8d 35 fa 84 01 00         	leaq	99578(%rip), %rsi       # 0x3233f <_IO_stdin_used+0x233f>
   19e45: 4c 89 ff                     	movq	%r15, %rdi
   19e48: e8 63 bb fe ff               	callq	0x59b0 <.plt.sec+0x340>
   19e4d: 85 c0                        	testl	%eax, %eax
   19e4f: 0f 84 ad 0f 00 00            	je	0x1ae02 <bpf_object_load.constprop.0+0x10e2>
; 			} else if (!str_has_pfx(ext->name, "LINUX_") || !ext->is_weak) {
   19e55: ba 06 00 00 00               	movl	$6, %edx
   19e5a: 48 8d 35 f8 84 01 00         	leaq	99576(%rip), %rsi       # 0x32359 <_IO_stdin_used+0x2359>
   19e61: 4c 89 ff                     	movq	%r15, %rdi
   19e64: e8 b7 b8 fe ff               	callq	0x5720 <.plt.sec+0xb0>
   19e69: 85 c0                        	testl	%eax, %eax
   19e6b: 0f 85 b7 20 00 00            	jne	0x1bf28 <bpf_object_load.constprop.0+0x2208>
   19e71: 80 7b 19 00                  	cmpb	$0, 25(%rbx)
   19e75: 0f 84 ad 20 00 00            	je	0x1bf28 <bpf_object_load.constprop.0+0x2208>
; 			__u64 value = 0;
   19e7b: 45 31 ff                     	xorl	%r15d, %r15d
; 			void *ext_ptr = kcfg_data + ext->kcfg.data_off;
   19e7e: 49 63 f4                     	movslq	%r12d, %rsi
; 			err = set_kcfg_value_num(ext, ext_ptr, value);
   19e81: 4c 89 fa                     	movq	%r15, %rdx
; 			void *ext_ptr = kcfg_data + ext->kcfg.data_off;
   19e84: 48 03 74 24 08               	addq	8(%rsp), %rsi
; 			err = set_kcfg_value_num(ext, ext_ptr, value);
   19e89: 48 89 df                     	movq	%rbx, %rdi
   19e8c: e8 3f f3 fe ff               	callq	0x91d0 <set_kcfg_value_num>
; 			if (err)
   19e91: 85 c0                        	testl	%eax, %eax
   19e93: 0f 85 e9 1f 00 00            	jne	0x1be82 <bpf_object_load.constprop.0+0x2162>
; 			pr_debug("extern (kcfg) '%s': set to 0x%llx\n",
   19e99: 48 8b 53 10                  	movq	16(%rbx), %rdx
   19e9d: 4c 89 f9                     	movq	%r15, %rcx
   19ea0: bf 02 00 00 00               	movl	$2, %edi
   19ea5: 48 8d 35 8c e0 01 00         	leaq	123020(%rip), %rsi      # 0x37f38 <strs.2+0x50a8>
   19eac: e8 1f e2 fe ff               	callq	0x80d0 <libbpf_print>
; 	for (i = 0; i < obj->nr_extern; i++) {
   19eb1: 48 83 c5 01                  	addq	$1, %rbp
   19eb5: 41 39 ae 90 00 00 00         	cmpl	%ebp, 144(%r14)
   19ebc: 0f 8e 5e 1c 00 00            	jle	0x1bb20 <bpf_object_load.constprop.0+0x1e00>
; 		ext = &obj->externs[i];
   19ec2: 49 8b 96 88 00 00 00         	movq	136(%r14), %rdx
   19ec9: 48 8d 04 ed 00 00 00 00      	leaq	(,%rbp,8), %rax
   19ed1: 48 29 e8                     	subq	%rbp, %rax
   19ed4: 48 8d 1c c2                  	leaq	(%rdx,%rax,8), %rbx
; 		if (ext->type == EXT_KSYM) {
   19ed8: 8b 03                        	movl	(%rbx), %eax
   19eda: 83 f8 02                     	cmpl	$2, %eax
   19edd: 0f 84 8d 03 00 00            	je	0x1a270 <bpf_object_load.constprop.0+0x550>
; 			if (str_has_pfx(ext->name, "CONFIG_")) {
   19ee3: 4c 8b 7b 10                  	movq	16(%rbx), %r15
; 		} else if (ext->type == EXT_KCFG) {
   19ee7: 83 f8 01                     	cmpl	$1, %eax
   19eea: 0f 85 c7 1d 00 00            	jne	0x1bcb7 <bpf_object_load.constprop.0+0x1f97>
; 			if (str_has_pfx(ext->name, "CONFIG_")) {
   19ef0: ba 07 00 00 00               	movl	$7, %edx
   19ef5: 4c 89 ee                     	movq	%r13, %rsi
   19ef8: 4c 89 ff                     	movq	%r15, %rdi
; 			void *ext_ptr = kcfg_data + ext->kcfg.data_off;
   19efb: 44 8b 63 2c                  	movl	44(%rbx), %r12d
; 			if (str_has_pfx(ext->name, "CONFIG_")) {
   19eff: e8 1c b8 fe ff               	callq	0x5720 <.plt.sec+0xb0>
   19f04: 85 c0                        	testl	%eax, %eax
   19f06: 0f 85 04 ff ff ff            	jne	0x19e10 <bpf_object_load.constprop.0+0xf0>
; 				need_config = true;
   19f0c: c6 44 24 18 01               	movb	$1, 24(%rsp)
   19f11: eb 9e                        	jmp	0x19eb1 <bpf_object_load.constprop.0+0x191>
; 	for (i = 0; i < obj->nr_extern; i++) {
   19f13: 31 db                        	xorl	%ebx, %ebx
; 			pr_debug("extern '%s' (weak): not resolved, defaulting to zero\n",
   19f15: 48 8d 2d c4 e2 01 00         	leaq	123588(%rip), %rbp      # 0x381e0 <strs.2+0x5350>
; 	for (i = 0; i < obj->nr_extern; i++) {
   19f1c: 85 c0                        	testl	%eax, %eax
   19f1e: 7e 46                        	jle	0x19f66 <bpf_object_load.constprop.0+0x246>
; 		ext = &obj->externs[i];
   19f20: 49 8b 96 88 00 00 00         	movq	136(%r14), %rdx
   19f27: 48 8d 04 dd 00 00 00 00      	leaq	(,%rbx,8), %rax
   19f2f: 48 29 d8                     	subq	%rbx, %rax
   19f32: 48 8d 04 c2                  	leaq	(%rdx,%rax,8), %rax
; 		if (!ext->is_set && !ext->is_weak) {
   19f36: 80 78 18 00                  	cmpb	$0, 24(%rax)
   19f3a: 75 1d                        	jne	0x19f59 <bpf_object_load.constprop.0+0x239>
   19f3c: 80 78 19 00                  	cmpb	$0, 25(%rax)
; 			pr_warn("extern '%s' (strong): not resolved\n", ext->name);
   19f40: 48 8b 50 10                  	movq	16(%rax), %rdx
; 		if (!ext->is_set && !ext->is_weak) {
   19f44: 0f 84 fc 1f 00 00            	je	0x1bf46 <bpf_object_load.constprop.0+0x2226>
; 			pr_debug("extern '%s' (weak): not resolved, defaulting to zero\n",
   19f4a: 48 89 ee                     	movq	%rbp, %rsi
   19f4d: bf 02 00 00 00               	movl	$2, %edi
   19f52: 31 c0                        	xorl	%eax, %eax
   19f54: e8 77 e1 fe ff               	callq	0x80d0 <libbpf_print>
; 	for (i = 0; i < obj->nr_extern; i++) {
   19f59: 48 83 c3 01                  	addq	$1, %rbx
   19f5d: 41 39 9e 90 00 00 00         	cmpl	%ebx, 144(%r14)
   19f64: 7f ba                        	jg	0x19f20 <bpf_object_load.constprop.0+0x200>
; 	struct btf *kern_btf = obj->btf;
   19f66: 49 8b 86 10 01 00 00         	movq	272(%r14), %rax
   19f6d: 48 89 04 24                  	movq	%rax, (%rsp)
; 	if (!obj->btf)
   19f71: 48 85 c0                     	testq	%rax, %rax
   19f74: 0f 84 c2 03 00 00            	je	0x1a33c <bpf_object_load.constprop.0+0x61c>
; 	if (!kernel_supports(obj, FEAT_BTF)) {
   19f7a: be 02 00 00 00               	movl	$2, %esi
   19f7f: 4c 89 f7                     	movq	%r14, %rdi
   19f82: e8 89 24 ff ff               	callq	0xc410 <kernel_supports>
   19f87: 84 c0                        	testb	%al, %al
   19f89: 0f 84 51 17 00 00            	je	0x1b6e0 <bpf_object_load.constprop.0+0x19c0>
; 	for (i = 0; i < obj->nr_programs; i++) {
   19f8f: 49 8b 76 60                  	movq	96(%r14), %rsi
   19f93: 45 31 ed                     	xorl	%r13d, %r13d
   19f96: 48 85 f6                     	testq	%rsi, %rsi
   19f99: 75 12                        	jne	0x19fad <bpf_object_load.constprop.0+0x28d>
   19f9b: e9 c4 00 00 00               	jmp	0x1a064 <bpf_object_load.constprop.0+0x344>
   19fa0: 49 83 c5 01                  	addq	$1, %r13
   19fa4: 4c 39 ee                     	cmpq	%r13, %rsi
   19fa7: 0f 86 b7 00 00 00            	jbe	0x1a064 <bpf_object_load.constprop.0+0x344>
; 		struct bpf_program *prog = &obj->programs[i];
   19fad: 4b 8d 5c 6d 00               	leaq	(%r13,%r13,2), %rbx
   19fb2: 48 c1 e3 06                  	shlq	$6, %rbx
   19fb6: 49 03 5e 58                  	addq	88(%r14), %rbx
; 		if (!prog->mark_btf_static || !prog_is_subprog(obj, prog))
   19fba: 80 7b 7e 00                  	cmpb	$0, 126(%rbx)
   19fbe: 74 e0                        	je	0x19fa0 <bpf_object_load.constprop.0+0x280>
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   19fc0: 49 63 86 04 01 00 00         	movslq	260(%r14), %rax
   19fc7: 48 39 43 10                  	cmpq	%rax, 16(%rbx)
   19fcb: 75 d3                        	jne	0x19fa0 <bpf_object_load.constprop.0+0x280>
   19fcd: 48 83 fe 01                  	cmpq	$1, %rsi
   19fd1: 74 cd                        	je	0x19fa0 <bpf_object_load.constprop.0+0x280>
; 		n = btf__type_cnt(obj->btf);
   19fd3: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
; 		for (j = 1; j < n; j++) {
   19fda: 41 bf 01 00 00 00            	movl	$1, %r15d
; 		n = btf__type_cnt(obj->btf);
   19fe0: e8 5b ff 00 00               	callq	0x29f40 <btf__type_cnt>
   19fe5: 41 89 c4                     	movl	%eax, %r12d
; 		for (j = 1; j < n; j++) {
   19fe8: 83 f8 01                     	cmpl	$1, %eax
   19feb: 7f 18                        	jg	0x1a005 <bpf_object_load.constprop.0+0x2e5>
   19fed: e9 1f 1d 00 00               	jmp	0x1bd11 <bpf_object_load.constprop.0+0x1ff1>
   19ff2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   19ff8: 41 83 c7 01                  	addl	$1, %r15d
   19ffc: 45 39 fc                     	cmpl	%r15d, %r12d
   19fff: 0f 84 0c 1d 00 00            	je	0x1bd11 <bpf_object_load.constprop.0+0x1ff1>
; 			t = btf_type_by_id(obj->btf, j);
   1a005: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1a00c: 44 89 fe                     	movl	%r15d, %esi
   1a00f: e8 4c ff 00 00               	callq	0x29f60 <btf_type_by_id>
; 	return BTF_INFO_KIND(t->info);
   1a014: 8b 50 04                     	movl	4(%rax), %edx
; 			t = btf_type_by_id(obj->btf, j);
   1a017: 48 89 c5                     	movq	%rax, %rbp
; 	return BTF_INFO_KIND(t->info);
   1a01a: 89 d0                        	movl	%edx, %eax
   1a01c: c1 e8 18                     	shrl	$24, %eax
   1a01f: 83 e0 1f                     	andl	$31, %eax
; 			if (!btf_is_func(t) || btf_func_linkage(t) != BTF_FUNC_GLOBAL)
   1a022: 66 83 f8 0c                  	cmpw	$12, %ax
   1a026: 75 d0                        	jne	0x19ff8 <bpf_object_load.constprop.0+0x2d8>
   1a028: 66 83 fa 01                  	cmpw	$1, %dx
   1a02c: 75 ca                        	jne	0x19ff8 <bpf_object_load.constprop.0+0x2d8>
; 			name = btf__str_by_offset(obj->btf, t->name_off);
   1a02e: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1a035: 8b 75 00                     	movl	(%rbp), %esi
   1a038: e8 b3 12 01 00               	callq	0x2b2f0 <btf__str_by_offset>
; 			if (strcmp(name, prog->name) != 0)
   1a03d: 48 8b 33                     	movq	(%rbx), %rsi
; 			name = btf__str_by_offset(obj->btf, t->name_off);
   1a040: 48 89 c7                     	movq	%rax, %rdi
; 			if (strcmp(name, prog->name) != 0)
   1a043: e8 68 b9 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   1a048: 85 c0                        	testl	%eax, %eax
   1a04a: 75 ac                        	jne	0x19ff8 <bpf_object_load.constprop.0+0x2d8>
; 			t->info = btf_type_info(BTF_KIND_FUNC, BTF_FUNC_STATIC, 0);
   1a04c: 49 8b 76 60                  	movq	96(%r14), %rsi
; 	for (i = 0; i < obj->nr_programs; i++) {
   1a050: 49 83 c5 01                  	addq	$1, %r13
; 			t->info = btf_type_info(BTF_KIND_FUNC, BTF_FUNC_STATIC, 0);
   1a054: c7 45 04 00 00 00 0c         	movl	$201326592, 4(%rbp)     # imm = 0xC000000
; 	for (i = 0; i < obj->nr_programs; i++) {
   1a05b: 4c 39 ee                     	cmpq	%r13, %rsi
   1a05e: 0f 87 49 ff ff ff            	ja	0x19fad <bpf_object_load.constprop.0+0x28d>
; 	bool has_func_global = kernel_supports(obj, FEAT_BTF_GLOBAL_FUNC);
   1a064: be 05 00 00 00               	movl	$5, %esi
   1a069: 4c 89 f7                     	movq	%r14, %rdi
   1a06c: e8 9f 23 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_datasec = kernel_supports(obj, FEAT_BTF_DATASEC);
   1a071: be 04 00 00 00               	movl	$4, %esi
   1a076: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_func_global = kernel_supports(obj, FEAT_BTF_GLOBAL_FUNC);
   1a079: 89 c3                        	movl	%eax, %ebx
; 	bool has_datasec = kernel_supports(obj, FEAT_BTF_DATASEC);
   1a07b: e8 90 23 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_float = kernel_supports(obj, FEAT_BTF_FLOAT);
   1a080: be 0b 00 00 00               	movl	$11, %esi
   1a085: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_datasec = kernel_supports(obj, FEAT_BTF_DATASEC);
   1a088: 89 c5                        	movl	%eax, %ebp
; 	bool has_float = kernel_supports(obj, FEAT_BTF_FLOAT);
   1a08a: e8 81 23 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_func = kernel_supports(obj, FEAT_BTF_FUNC);
   1a08f: be 03 00 00 00               	movl	$3, %esi
   1a094: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_float = kernel_supports(obj, FEAT_BTF_FLOAT);
   1a097: 41 89 c5                     	movl	%eax, %r13d
; 	bool has_func = kernel_supports(obj, FEAT_BTF_FUNC);
   1a09a: e8 71 23 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_decl_tag = kernel_supports(obj, FEAT_BTF_DECL_TAG);
   1a09f: be 0d 00 00 00               	movl	$13, %esi
   1a0a4: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_func = kernel_supports(obj, FEAT_BTF_FUNC);
   1a0a7: 41 89 c7                     	movl	%eax, %r15d
; 	bool has_decl_tag = kernel_supports(obj, FEAT_BTF_DECL_TAG);
   1a0aa: e8 61 23 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_type_tag = kernel_supports(obj, FEAT_BTF_TYPE_TAG);
   1a0af: be 0e 00 00 00               	movl	$14, %esi
   1a0b4: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_decl_tag = kernel_supports(obj, FEAT_BTF_DECL_TAG);
   1a0b7: 88 44 24 08                  	movb	%al, 8(%rsp)
; 	bool has_type_tag = kernel_supports(obj, FEAT_BTF_TYPE_TAG);
   1a0bb: e8 50 23 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_enum64 = kernel_supports(obj, FEAT_BTF_ENUM64);
   1a0c0: be 11 00 00 00               	movl	$17, %esi
   1a0c5: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_type_tag = kernel_supports(obj, FEAT_BTF_TYPE_TAG);
   1a0c8: 41 89 c4                     	movl	%eax, %r12d
; 	bool has_enum64 = kernel_supports(obj, FEAT_BTF_ENUM64);
   1a0cb: e8 40 23 ff ff               	callq	0xc410 <kernel_supports>
; 	       !has_decl_tag || !has_type_tag || !has_enum64;
   1a0d0: 40 84 ed                     	testb	%bpl, %bpl
   1a0d3: 74 1d                        	je	0x1a0f2 <bpf_object_load.constprop.0+0x3d2>
   1a0d5: 45 84 ff                     	testb	%r15b, %r15b
   1a0d8: 74 18                        	je	0x1a0f2 <bpf_object_load.constprop.0+0x3d2>
; 	return !has_func || !has_datasec || !has_func_global || !has_float ||
   1a0da: 84 db                        	testb	%bl, %bl
   1a0dc: 74 14                        	je	0x1a0f2 <bpf_object_load.constprop.0+0x3d2>
   1a0de: 45 84 ed                     	testb	%r13b, %r13b
   1a0e1: 74 0f                        	je	0x1a0f2 <bpf_object_load.constprop.0+0x3d2>
; 	       !has_decl_tag || !has_type_tag || !has_enum64;
   1a0e3: 44 84 64 24 08               	testb	%r12b, 8(%rsp)
   1a0e8: 74 08                        	je	0x1a0f2 <bpf_object_load.constprop.0+0x3d2>
   1a0ea: 84 c0                        	testb	%al, %al
   1a0ec: 0f 85 37 1d 00 00            	jne	0x1be29 <bpf_object_load.constprop.0+0x2109>
; 		raw_data = btf__raw_data(obj->btf, &sz);
   1a0f2: 48 8d 84 24 a0 00 00 00      	leaq	160(%rsp), %rax
   1a0fa: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1a101: 48 89 c6                     	movq	%rax, %rsi
   1a104: 48 89 44 24 38               	movq	%rax, 56(%rsp)
   1a109: e8 42 11 01 00               	callq	0x2b250 <btf__raw_data>
; 		kern_btf = btf__new(raw_data, sz);
   1a10e: 8b b4 24 a0 00 00 00         	movl	160(%rsp), %esi
; 		raw_data = btf__raw_data(obj->btf, &sz);
   1a115: 48 89 c7                     	movq	%rax, %rdi
; 		kern_btf = btf__new(raw_data, sz);
   1a118: e8 93 0d 01 00               	callq	0x2aeb0 <btf__new>
   1a11d: 49 89 c7                     	movq	%rax, %r15
; 	if (!IS_ERR_OR_NULL(ptr))
   1a120: 48 85 c0                     	testq	%rax, %rax
   1a123: 0f 84 78 1f 00 00            	je	0x1c0a1 <bpf_object_load.constprop.0+0x2381>
   1a129: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   1a12f: 0f 87 6c 1f 00 00            	ja	0x1c0a1 <bpf_object_load.constprop.0+0x2381>
; 		btf__set_pointer_size(obj->btf, 8);
   1a135: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1a13c: be 08 00 00 00               	movl	$8, %esi
; 	for (i = 1; i < btf__type_cnt(btf); i++) {
   1a141: bb 01 00 00 00               	movl	$1, %ebx
; 	int enum64_placeholder_id = 0;
   1a146: 45 31 e4                     	xorl	%r12d, %r12d
; 		btf__set_pointer_size(obj->btf, 8);
   1a149: e8 02 05 01 00               	callq	0x2a650 <btf__set_pointer_size>
; 	bool has_func_global = kernel_supports(obj, FEAT_BTF_GLOBAL_FUNC);
   1a14e: be 05 00 00 00               	movl	$5, %esi
   1a153: 4c 89 f7                     	movq	%r14, %rdi
   1a156: e8 b5 22 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_datasec = kernel_supports(obj, FEAT_BTF_DATASEC);
   1a15b: be 04 00 00 00               	movl	$4, %esi
   1a160: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_func_global = kernel_supports(obj, FEAT_BTF_GLOBAL_FUNC);
   1a163: 88 44 24 20                  	movb	%al, 32(%rsp)
; 	bool has_datasec = kernel_supports(obj, FEAT_BTF_DATASEC);
   1a167: e8 a4 22 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_float = kernel_supports(obj, FEAT_BTF_FLOAT);
   1a16c: be 0b 00 00 00               	movl	$11, %esi
   1a171: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_datasec = kernel_supports(obj, FEAT_BTF_DATASEC);
   1a174: 89 c5                        	movl	%eax, %ebp
; 	bool has_float = kernel_supports(obj, FEAT_BTF_FLOAT);
   1a176: e8 95 22 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_func = kernel_supports(obj, FEAT_BTF_FUNC);
   1a17b: be 03 00 00 00               	movl	$3, %esi
   1a180: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_float = kernel_supports(obj, FEAT_BTF_FLOAT);
   1a183: 88 44 24 10                  	movb	%al, 16(%rsp)
; 	bool has_func = kernel_supports(obj, FEAT_BTF_FUNC);
   1a187: e8 84 22 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_decl_tag = kernel_supports(obj, FEAT_BTF_DECL_TAG);
   1a18c: be 0d 00 00 00               	movl	$13, %esi
   1a191: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_func = kernel_supports(obj, FEAT_BTF_FUNC);
   1a194: 88 04 24                     	movb	%al, (%rsp)
; 	bool has_decl_tag = kernel_supports(obj, FEAT_BTF_DECL_TAG);
   1a197: e8 74 22 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_type_tag = kernel_supports(obj, FEAT_BTF_TYPE_TAG);
   1a19c: be 0e 00 00 00               	movl	$14, %esi
   1a1a1: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_decl_tag = kernel_supports(obj, FEAT_BTF_DECL_TAG);
   1a1a4: 88 44 24 08                  	movb	%al, 8(%rsp)
; 	bool has_type_tag = kernel_supports(obj, FEAT_BTF_TYPE_TAG);
   1a1a8: e8 63 22 ff ff               	callq	0xc410 <kernel_supports>
; 	bool has_enum64 = kernel_supports(obj, FEAT_BTF_ENUM64);
   1a1ad: be 11 00 00 00               	movl	$17, %esi
   1a1b2: 4c 89 f7                     	movq	%r14, %rdi
; 	bool has_type_tag = kernel_supports(obj, FEAT_BTF_TYPE_TAG);
   1a1b5: 88 44 24 28                  	movb	%al, 40(%rsp)
; 	bool has_enum64 = kernel_supports(obj, FEAT_BTF_ENUM64);
   1a1b9: e8 52 22 ff ff               	callq	0xc410 <kernel_supports>
   1a1be: 4c 89 74 24 18               	movq	%r14, 24(%rsp)
   1a1c3: 88 44 24 30                  	movb	%al, 48(%rsp)
; 	for (i = 1; i < btf__type_cnt(btf); i++) {
   1a1c7: eb 56                        	jmp	0x1a21f <bpf_object_load.constprop.0+0x4ff>
; 	return BTF_INFO_KIND(t->info);
   1a1c9: 0f b6 40 07                  	movzbl	7(%rax), %eax
   1a1cd: 83 e0 1f                     	andl	$31, %eax
; 		if ((!has_datasec && btf_is_var(t)) || (!has_decl_tag && btf_is_decl_tag(t))) {
   1a1d0: 66 83 f8 0e                  	cmpw	$14, %ax
   1a1d4: 74 7f                        	je	0x1a255 <bpf_object_load.constprop.0+0x535>
   1a1d6: 80 7c 24 08 00               	cmpb	$0, 8(%rsp)
   1a1db: 75 06                        	jne	0x1a1e3 <bpf_object_load.constprop.0+0x4c3>
   1a1dd: 66 83 f8 11                  	cmpw	$17, %ax
   1a1e1: 74 72                        	je	0x1a255 <bpf_object_load.constprop.0+0x535>
; 		} else if (!has_datasec && btf_is_datasec(t)) {
   1a1e3: 66 83 f8 0f                  	cmpw	$15, %ax
   1a1e7: 0f 84 a4 1f 00 00            	je	0x1c191 <bpf_object_load.constprop.0+0x2471>
; 		} else if (!has_func && btf_is_func_proto(t)) {
   1a1ed: 80 3c 24 00                  	cmpb	$0, (%rsp)
   1a1f1: 0f 84 09 1c 00 00            	je	0x1be00 <bpf_object_load.constprop.0+0x20e0>
; 		} else if (!has_func_global && btf_is_func(t)) {
   1a1f7: 80 7c 24 20 00               	cmpb	$0, 32(%rsp)
   1a1fc: 0f 85 56 1b 00 00            	jne	0x1bd58 <bpf_object_load.constprop.0+0x2038>
; 	return BTF_INFO_KIND(t->info);
   1a202: 41 0f b6 45 07               	movzbl	7(%r13), %eax
   1a207: 83 e0 1f                     	andl	$31, %eax
; 		} else if (!has_func_global && btf_is_func(t)) {
   1a20a: 66 83 f8 0c                  	cmpw	$12, %ax
   1a20e: 0f 85 44 1b 00 00            	jne	0x1bd58 <bpf_object_load.constprop.0+0x2038>
; 			t->info = BTF_INFO_ENC(BTF_KIND_FUNC, 0, 0);
   1a214: 41 c7 45 04 00 00 00 0c      	movl	$201326592, 4(%r13)     # imm = 0xC000000
; 	for (i = 1; i < btf__type_cnt(btf); i++) {
   1a21c: 83 c3 01                     	addl	$1, %ebx
   1a21f: 4c 89 ff                     	movq	%r15, %rdi
   1a222: e8 19 fd 00 00               	callq	0x29f40 <btf__type_cnt>
   1a227: 39 d8                        	cmpl	%ebx, %eax
   1a229: 0f 86 bc 1e 00 00            	jbe	0x1c0eb <bpf_object_load.constprop.0+0x23cb>
; 		t = (struct btf_type *)btf__type_by_id(btf, i);
   1a22f: 89 de                        	movl	%ebx, %esi
   1a231: 4c 89 ff                     	movq	%r15, %rdi
   1a234: e8 67 fd 00 00               	callq	0x29fa0 <btf__type_by_id>
   1a239: 49 89 c5                     	movq	%rax, %r13
; 		if ((!has_datasec && btf_is_var(t)) || (!has_decl_tag && btf_is_decl_tag(t))) {
   1a23c: 40 84 ed                     	testb	%bpl, %bpl
   1a23f: 74 88                        	je	0x1a1c9 <bpf_object_load.constprop.0+0x4a9>
   1a241: 80 7c 24 08 00               	cmpb	$0, 8(%rsp)
   1a246: 75 a5                        	jne	0x1a1ed <bpf_object_load.constprop.0+0x4cd>
; 	return BTF_INFO_KIND(t->info);
   1a248: 0f b6 40 07                  	movzbl	7(%rax), %eax
   1a24c: 83 e0 1f                     	andl	$31, %eax
; 		if ((!has_datasec && btf_is_var(t)) || (!has_decl_tag && btf_is_decl_tag(t))) {
   1a24f: 66 83 f8 11                  	cmpw	$17, %ax
   1a253: 75 98                        	jne	0x1a1ed <bpf_object_load.constprop.0+0x4cd>
; 			t->info = BTF_INFO_ENC(BTF_KIND_INT, 0, 0);
   1a255: 48 b8 00 00 00 01 01 00 00 00	movabsq	$4311744512, %rax       # imm = 0x101000000
; 			*(int *)(t + 1) = BTF_INT_ENC(0, 0, 8);
   1a25f: 41 c7 45 0c 08 00 00 00      	movl	$8, 12(%r13)
; 			t->info = BTF_INFO_ENC(BTF_KIND_INT, 0, 0);
   1a267: 49 89 45 04                  	movq	%rax, 4(%r13)
; 			*(int *)(t + 1) = BTF_INT_ENC(0, 0, 8);
   1a26b: eb af                        	jmp	0x1a21c <bpf_object_load.constprop.0+0x4fc>
   1a26d: 0f 1f 00                     	nopl	(%rax)
; 				need_kallsyms = true;
   1a270: 44 8b 7b 30                  	movl	48(%rbx), %r15d
   1a274: 0f b6 0c 24                  	movzbl	(%rsp), %ecx
   1a278: b8 01 00 00 00               	movl	$1, %eax
   1a27d: 45 85 ff                     	testl	%r15d, %r15d
   1a280: 0f 44 c8                     	cmovel	%eax, %ecx
   1a283: 88 0c 24                     	movb	%cl, (%rsp)
   1a286: 0f b6 4c 24 10               	movzbl	16(%rsp), %ecx
   1a28b: 0f 45 c8                     	cmovnel	%eax, %ecx
   1a28e: 88 4c 24 10                  	movb	%cl, 16(%rsp)
   1a292: e9 1a fc ff ff               	jmp	0x19eb1 <bpf_object_load.constprop.0+0x191>
   1a297: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 				value = get_kernel_version();
   1a2a0: e8 8b 11 ff ff               	callq	0xb430 <get_kernel_version>
   1a2a5: 41 89 c7                     	movl	%eax, %r15d
; 				if (!value) {
   1a2a8: 4d 85 ff                     	testq	%r15, %r15
   1a2ab: 0f 85 cd fb ff ff            	jne	0x19e7e <bpf_object_load.constprop.0+0x15e>
; 					pr_warn("extern (kcfg) '%s': failed to get kernel version\n", ext->name);
   1a2b1: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1a2b5: 48 8d 35 fc db 01 00         	leaq	121852(%rip), %rsi      # 0x37eb8 <strs.2+0x5028>
   1a2bc: 31 ff                        	xorl	%edi, %edi
   1a2be: 31 c0                        	xorl	%eax, %eax
; 					return -EINVAL;
   1a2c0: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 					pr_warn("extern (kcfg) '%s': failed to get kernel version\n", ext->name);
   1a2c6: e8 05 de fe ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__init_kern_struct_ops_maps(obj);
   1a2cb: e9 e0 04 00 00               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 				value = kernel_supports(obj, FEAT_BPF_COOKIE);
   1a2d0: be 10 00 00 00               	movl	$16, %esi
   1a2d5: 4c 89 f7                     	movq	%r14, %rdi
   1a2d8: e8 33 21 ff ff               	callq	0xc410 <kernel_supports>
   1a2dd: 44 0f b6 f8                  	movzbl	%al, %r15d
   1a2e1: e9 98 fb ff ff               	jmp	0x19e7e <bpf_object_load.constprop.0+0x15e>
; 		err = btf_load_into_kernel(kern_btf, obj->log_buf, obj->log_size,
   1a2e6: 45 8b 86 68 01 00 00         	movl	360(%r14), %r8d
   1a2ed: 31 c9                        	xorl	%ecx, %ecx
   1a2ef: 48 8b 3c 24                  	movq	(%rsp), %rdi
   1a2f3: 49 8b 96 60 01 00 00         	movq	352(%r14), %rdx
   1a2fa: 49 8b b6 58 01 00 00         	movq	344(%r14), %rsi
   1a301: 45 85 c0                     	testl	%r8d, %r8d
   1a304: 0f 95 c1                     	setne	%cl
   1a307: e8 34 0c 01 00               	callq	0x2af40 <btf_load_into_kernel>
   1a30c: 41 89 c4                     	movl	%eax, %r12d
; 	if (err) {
   1a30f: 85 c0                        	testl	%eax, %eax
   1a311: 74 29                        	je	0x1a33c <bpf_object_load.constprop.0+0x61c>
; 		pr_warn("Error loading .BTF into kernel: %d. %s\n", err,
   1a313: 41 8b be 0c 01 00 00         	movl	268(%r14), %edi
   1a31a: 85 ff                        	testl	%edi, %edi
   1a31c: 0f 89 d4 13 00 00            	jns	0x1b6f6 <bpf_object_load.constprop.0+0x19d6>
   1a322: 48 8d 0d 5a 80 01 00         	leaq	98394(%rip), %rcx       # 0x32383 <_IO_stdin_used+0x2383>
   1a329: 44 89 e2                     	movl	%r12d, %edx
   1a32c: 31 ff                        	xorl	%edi, %edi
   1a32e: 31 c0                        	xorl	%eax, %eax
   1a330: 48 8d 35 89 e6 01 00         	leaq	124553(%rip), %rsi      # 0x389c0 <strs.2+0x5b30>
   1a337: e8 94 dd fe ff               	callq	0x80d0 <libbpf_print>
; 		return obj->maps;
   1a33c: 49 8b 6e 68                  	movq	104(%r14), %rbp
; 	bpf_object__for_each_map(m, obj) {
   1a340: 48 85 ed                     	testq	%rbp, %rbp
   1a343: 74 3a                        	je	0x1a37f <bpf_object_load.constprop.0+0x65f>
   1a345: 0f 1f 00                     	nopl	(%rax)
; 		if (!bpf_map__is_internal(m))
   1a348: 8b 75 58                     	movl	88(%rbp), %esi
   1a34b: 85 f6                        	testl	%esi, %esi
   1a34d: 74 18                        	je	0x1a367 <bpf_object_load.constprop.0+0x647>
; 		if (!kernel_supports(obj, FEAT_ARRAY_MMAP))
   1a34f: be 06 00 00 00               	movl	$6, %esi
   1a354: 4c 89 f7                     	movq	%r14, %rdi
   1a357: e8 b4 20 ff ff               	callq	0xc410 <kernel_supports>
   1a35c: 84 c0                        	testb	%al, %al
   1a35e: 75 07                        	jne	0x1a367 <bpf_object_load.constprop.0+0x647>
; 			m->def.map_flags ^= BPF_F_MMAPABLE;
   1a360: 81 75 40 00 04 00 00         	xorl	$1024, 64(%rbp)         # imm = 0x400
; 	return __bpf_map__iter(prev, obj, 1);
   1a367: 48 89 ef                     	movq	%rbp, %rdi
   1a36a: ba 01 00 00 00               	movl	$1, %edx
   1a36f: 4c 89 f6                     	movq	%r14, %rsi
   1a372: e8 79 fa fe ff               	callq	0x9df0 <__bpf_map__iter>
   1a377: 48 89 c5                     	movq	%rax, %rbp
; 	bpf_object__for_each_map(m, obj) {
   1a37a: 48 85 c0                     	testq	%rax, %rax
   1a37d: 75 c9                        	jne	0x1a348 <bpf_object_load.constprop.0+0x628>
; 	for (i = 0; i < obj->nr_maps; i++) {
   1a37f: 48 c7 44 24 08 00 00 00 00   	movq	$0, 8(%rsp)
   1a388: 49 83 7e 70 00               	cmpq	$0, 112(%r14)
   1a38d: 0f 84 ed 05 00 00            	je	0x1a980 <bpf_object_load.constprop.0+0xc60>
   1a393: 4c 89 74 24 18               	movq	%r14, 24(%rsp)
   1a398: eb 20                        	jmp	0x1a3ba <bpf_object_load.constprop.0+0x69a>
   1a39a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   1a3a0: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   1a3a5: 48 83 44 24 08 01            	addq	$1, 8(%rsp)
   1a3ab: 48 8b 44 24 08               	movq	8(%rsp), %rax
   1a3b0: 48 3b 41 70                  	cmpq	112(%rcx), %rax
   1a3b4: 0f 83 c3 05 00 00            	jae	0x1a97d <bpf_object_load.constprop.0+0xc5d>
; 		map = &obj->maps[i];
   1a3ba: 48 8b 44 24 08               	movq	8(%rsp), %rax
   1a3bf: 48 8b 4c 24 18               	movq	24(%rsp), %rcx
   1a3c4: 48 8d 04 80                  	leaq	(%rax,%rax,4), %rax
   1a3c8: 48 c1 e0 05                  	shlq	$5, %rax
   1a3cc: 48 03 41 68                  	addq	104(%rcx), %rax
; 		if (!bpf_map__is_struct_ops(map))
   1a3d0: 83 78 30 1a                  	cmpl	$26, 48(%rax)
; 		map = &obj->maps[i];
   1a3d4: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 		if (!bpf_map__is_struct_ops(map))
   1a3d9: 75 c5                        	jne	0x1a3a0 <bpf_object_load.constprop.0+0x680>
; 						    obj->btf_vmlinux);
   1a3db: 48 8b 44 24 18               	movq	24(%rsp), %rax
; 	kern_type_id = btf__find_by_name_kind(btf, tname, BTF_KIND_STRUCT);
   1a3e0: ba 04 00 00 00               	movl	$4, %edx
; 						    obj->btf_vmlinux);
   1a3e5: 48 8b 98 20 01 00 00         	movq	288(%rax), %rbx
; 		err = bpf_map__init_kern_struct_ops(map, obj->btf,
   1a3ec: 48 8b 80 10 01 00 00         	movq	272(%rax), %rax
   1a3f3: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	st_ops = map->st_ops;
   1a3f8: 48 8b 44 24 20               	movq	32(%rsp), %rax
; 	kern_type_id = btf__find_by_name_kind(btf, tname, BTF_KIND_STRUCT);
   1a3fd: 48 89 df                     	movq	%rbx, %rdi
; 	st_ops = map->st_ops;
   1a400: 48 8b 40 68                  	movq	104(%rax), %rax
; 	tname = st_ops->tname;
   1a404: 4c 8b 38                     	movq	(%rax), %r15
; 	type = st_ops->type;
   1a407: 48 8b 48 08                  	movq	8(%rax), %rcx
; 	st_ops = map->st_ops;
   1a40b: 48 89 44 24 60               	movq	%rax, 96(%rsp)
; 	kern_type_id = btf__find_by_name_kind(btf, tname, BTF_KIND_STRUCT);
   1a410: 4c 89 fe                     	movq	%r15, %rsi
; 	type = st_ops->type;
   1a413: 48 89 4c 24 28               	movq	%rcx, 40(%rsp)
; 	kern_type_id = btf__find_by_name_kind(btf, tname, BTF_KIND_STRUCT);
   1a418: e8 b3 16 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
   1a41d: 41 89 c4                     	movl	%eax, %r12d
; 	if (kern_type_id < 0) {
   1a420: 85 c0                        	testl	%eax, %eax
   1a422: 0f 88 37 09 00 00            	js	0x1ad5f <bpf_object_load.constprop.0+0x103f>
; 	kern_type = btf__type_by_id(btf, kern_type_id);
   1a428: 89 c6                        	movl	%eax, %esi
   1a42a: 48 89 df                     	movq	%rbx, %rdi
   1a42d: 89 84 24 88 00 00 00         	movl	%eax, 136(%rsp)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1a434: 4c 8d a4 24 e0 00 00 00      	leaq	224(%rsp), %r12
; 	kern_type = btf__type_by_id(btf, kern_type_id);
   1a43c: e8 5f fb 00 00               	callq	0x29fa0 <btf__type_by_id>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1a441: 48 83 ec 08                  	subq	$8, %rsp
   1a445: 4c 89 e7                     	movq	%r12, %rdi
   1a448: b9 80 00 00 00               	movl	$128, %ecx
   1a44d: 41 57                        	pushq	%r15
   1a44f: ba 01 00 00 00               	movl	$1, %edx
; 	kern_type = btf__type_by_id(btf, kern_type_id);
   1a454: 48 89 c5                     	movq	%rax, %rbp
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1a457: be 80 00 00 00               	movl	$128, %esi
   1a45c: 4c 8d 0d 10 7f 01 00         	leaq	98064(%rip), %r9        # 0x32373 <_IO_stdin_used+0x2373>
   1a463: 4c 8d 05 37 7b 01 00         	leaq	97079(%rip), %r8        # 0x31fa1 <_IO_stdin_used+0x1fa1>
   1a46a: 31 c0                        	xorl	%eax, %eax
   1a46c: e8 3f b2 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (ret < 0 || ret >= sizeof(btf_type_name))
   1a471: 5a                           	popq	%rdx
   1a472: 59                           	popq	%rcx
   1a473: 83 f8 7f                     	cmpl	$127, %eax
   1a476: 0f 87 4f 1c 00 00            	ja	0x1c0cb <bpf_object_load.constprop.0+0x23ab>
; 	return btf__find_by_name_kind(btf, btf_type_name, kind);
   1a47c: 4c 89 e6                     	movq	%r12, %rsi
   1a47f: ba 04 00 00 00               	movl	$4, %edx
   1a484: 48 89 df                     	movq	%rbx, %rdi
   1a487: e8 44 16 01 00               	callq	0x2bad0 <btf__find_by_name_kind>
   1a48c: 41 89 c4                     	movl	%eax, %r12d
; 	if (kern_vtype_id < 0) {
   1a48f: 85 c0                        	testl	%eax, %eax
   1a491: 0f 88 a9 11 00 00            	js	0x1b640 <bpf_object_load.constprop.0+0x1920>
; 	kern_vtype = btf__type_by_id(btf, kern_vtype_id);
   1a497: 89 c6                        	movl	%eax, %esi
   1a499: 48 89 df                     	movq	%rbx, %rdi
   1a49c: e8 ff fa 00 00               	callq	0x29fa0 <btf__type_by_id>
   1a4a1: 0f b7 50 04                  	movzwl	4(%rax), %edx
   1a4a5: 49 89 c6                     	movq	%rax, %r14
; 	return (struct btf_member *)(t + 1);
   1a4a8: 4c 8d 68 0c                  	leaq	12(%rax), %r13
; 	for (i = 0; i < btf_vlen(kern_vtype); i++, kern_data_member++) {
   1a4ac: 85 d2                        	testl	%edx, %edx
   1a4ae: 0f 84 7e 08 00 00            	je	0x1ad32 <bpf_object_load.constprop.0+0x1012>
   1a4b4: 8b 8c 24 88 00 00 00         	movl	136(%rsp), %ecx
   1a4bb: 31 c0                        	xorl	%eax, %eax
   1a4bd: eb 10                        	jmp	0x1a4cf <bpf_object_load.constprop.0+0x7af>
   1a4bf: 90                           	nop
   1a4c0: 83 c0 01                     	addl	$1, %eax
   1a4c3: 49 83 c5 0c                  	addq	$12, %r13
   1a4c7: 39 d0                        	cmpl	%edx, %eax
   1a4c9: 0f 84 63 08 00 00            	je	0x1ad32 <bpf_object_load.constprop.0+0x1012>
; 		if (kern_data_member->type == kern_type_id)
   1a4cf: 41 3b 4d 04                  	cmpl	4(%r13), %ecx
   1a4d3: 75 eb                        	jne	0x1a4c0 <bpf_object_load.constprop.0+0x7a0>
; 	pr_debug("struct_ops init_kern %s: type_id:%u kern_type_id:%u kern_vtype_id:%u\n",
   1a4d5: 4c 8b 7c 24 20               	movq	32(%rsp), %r15
   1a4da: 48 8b 4c 24 60               	movq	96(%rsp), %rcx
   1a4df: 45 89 e1                     	movl	%r12d, %r9d
   1a4e2: 31 c0                        	xorl	%eax, %eax
   1a4e4: 44 8b 84 24 88 00 00 00      	movl	136(%rsp), %r8d
   1a4ec: 48 8d 35 fd dd 01 00         	leaq	122365(%rip), %rsi      # 0x382f0 <strs.2+0x5460>
   1a4f3: bf 02 00 00 00               	movl	$2, %edi
   1a4f8: 8b 49 30                     	movl	48(%rcx), %ecx
   1a4fb: 49 8b 57 08                  	movq	8(%r15), %rdx
   1a4ff: e8 cc db fe ff               	callq	0x80d0 <libbpf_print>
; 	map->def.value_size = kern_vtype->size;
   1a504: 41 8b 76 08                  	movl	8(%r14), %esi
; 	map->btf_vmlinux_value_type_id = kern_vtype_id;
   1a508: 45 89 67 54                  	movl	%r12d, 84(%r15)
; 	st_ops->kern_vdata = calloc(1, kern_vtype->size);
   1a50c: bf 01 00 00 00               	movl	$1, %edi
; 	map->def.value_size = kern_vtype->size;
   1a511: 41 89 77 38                  	movl	%esi, 56(%r15)
; 	st_ops->kern_vdata = calloc(1, kern_vtype->size);
   1a515: e8 76 b4 fe ff               	callq	0x5990 <.plt.sec+0x320>
   1a51a: 48 8b 4c 24 60               	movq	96(%rsp), %rcx
   1a51f: 48 89 44 24 70               	movq	%rax, 112(%rsp)
   1a524: 48 89 41 28                  	movq	%rax, 40(%rcx)
; 	if (!st_ops->kern_vdata)
   1a528: 48 85 c0                     	testq	%rax, %rax
   1a52b: 0f 84 aa 1b 00 00            	je	0x1c0db <bpf_object_load.constprop.0+0x23bb>
; 	data = st_ops->data;
   1a531: 48 8b 44 24 60               	movq	96(%rsp), %rax
   1a536: 48 8b 40 20                  	movq	32(%rax), %rax
   1a53a: 48 89 44 24 78               	movq	%rax, 120(%rsp)
; 	kern_data_off = kern_data_member->offset / 8;
   1a53f: 41 8b 45 08                  	movl	8(%r13), %eax
   1a543: c1 e8 03                     	shrl	$3, %eax
   1a546: 89 84 24 8c 00 00 00         	movl	%eax, 140(%rsp)
; 	kern_data = st_ops->kern_vdata + kern_data_off;
   1a54d: 48 89 84 24 80 00 00 00      	movq	%rax, 128(%rsp)
; 	return (struct btf_member *)(t + 1);
   1a555: 48 8b 44 24 28               	movq	40(%rsp), %rax
; 	for (i = 0; i < btf_vlen(type); i++, member++) {
   1a55a: 66 83 78 04 00               	cmpw	$0, 4(%rax)
; 	return (struct btf_member *)(t + 1);
   1a55f: 4c 8d 68 0c                  	leaq	12(%rax), %r13
; 	for (i = 0; i < btf_vlen(type); i++, member++) {
   1a563: 0f 84 37 fe ff ff            	je	0x1a3a0 <bpf_object_load.constprop.0+0x680>
; 	return (struct btf_member *)(t + 1);
   1a569: 48 8d 45 0c                  	leaq	12(%rbp), %rax
; 	for (i = 0; i < btf_vlen(type); i++, member++) {
   1a56d: c7 04 24 00 00 00 00         	movl	$0, (%rsp)
; 	return (struct btf_member *)(t + 1);
   1a574: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 		mtype = skip_mods_and_typedefs(btf, member->type, &mtype_id);
   1a579: 48 8d 84 24 98 00 00 00      	leaq	152(%rsp), %rax
; 	return (struct btf_member *)(t + 1);
   1a581: 48 c7 44 24 48 00 00 00 00   	movq	$0, 72(%rsp)
; 		mtype = skip_mods_and_typedefs(btf, member->type, &mtype_id);
   1a58a: 48 89 44 24 68               	movq	%rax, 104(%rsp)
   1a58f: 90                           	nop
; 		mname = btf__name_by_offset(btf, member->name_off);
   1a590: 41 8b 75 00                  	movl	(%r13), %esi
   1a594: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   1a599: e8 52 15 01 00               	callq	0x2baf0 <btf__name_by_offset>
; 	for (i = 0, m = btf_members(t); i < btf_vlen(t); i++, m++) {
   1a59e: 66 83 7d 04 00               	cmpw	$0, 4(%rbp)
; 		mname = btf__name_by_offset(btf, member->name_off);
   1a5a3: 49 89 c7                     	movq	%rax, %r15
; 	for (i = 0, m = btf_members(t); i < btf_vlen(t); i++, m++) {
   1a5a6: 0f 84 d4 01 00 00            	je	0x1a780 <bpf_object_load.constprop.0+0xa60>
   1a5ac: 4c 8b 74 24 30               	movq	48(%rsp), %r14
   1a5b1: 45 31 e4                     	xorl	%r12d, %r12d
   1a5b4: eb 1f                        	jmp	0x1a5d5 <bpf_object_load.constprop.0+0x8b5>
   1a5b6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   1a5c0: 0f b7 45 04                  	movzwl	4(%rbp), %eax
   1a5c4: 41 83 c4 01                  	addl	$1, %r12d
   1a5c8: 49 83 c6 0c                  	addq	$12, %r14
   1a5cc: 41 39 c4                     	cmpl	%eax, %r12d
   1a5cf: 0f 8d ab 01 00 00            	jge	0x1a780 <bpf_object_load.constprop.0+0xa60>
; 		if (!strcmp(btf__name_by_offset(btf, m->name_off), name))
   1a5d5: 41 8b 36                     	movl	(%r14), %esi
   1a5d8: 48 89 df                     	movq	%rbx, %rdi
   1a5db: e8 10 15 01 00               	callq	0x2baf0 <btf__name_by_offset>
   1a5e0: 4c 89 fe                     	movq	%r15, %rsi
   1a5e3: 48 89 c7                     	movq	%rax, %rdi
   1a5e6: e8 c5 b3 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   1a5eb: 85 c0                        	testl	%eax, %eax
   1a5ed: 75 d1                        	jne	0x1a5c0 <bpf_object_load.constprop.0+0x8a0>
; 		kern_member_idx = kern_member - btf_members(kern_type);
   1a5ef: 48 b9 ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rcx # imm = 0xAAAAAAAAAAAAAAAB
   1a5f9: 4c 89 f0                     	movq	%r14, %rax
   1a5fc: 48 2b 44 24 30               	subq	48(%rsp), %rax
   1a601: 48 c1 f8 02                  	sarq	$2, %rax
   1a605: 48 0f af c1                  	imulq	%rcx, %rax
   1a609: 48 89 44 24 50               	movq	%rax, 80(%rsp)
; 	return kflag ? BTF_MEMBER_BITFIELD_SIZE(m->offset) : 0;
   1a60e: 48 8b 44 24 28               	movq	40(%rsp), %rax
   1a613: 8b 50 04                     	movl	4(%rax), %edx
   1a616: 85 d2                        	testl	%edx, %edx
   1a618: 79 0b                        	jns	0x1a625 <bpf_object_load.constprop.0+0x905>
; 		if (btf_member_bitfield_size(type, i) ||
   1a61a: 41 80 7d 0b 00               	cmpb	$0, 11(%r13)
   1a61f: 0f 85 c2 13 00 00            	jne	0x1b9e7 <bpf_object_load.constprop.0+0x1cc7>
; 	return kflag ? BTF_MEMBER_BITFIELD_SIZE(m->offset) : 0;
   1a625: 8b 45 04                     	movl	4(%rbp), %eax
   1a628: 85 c0                        	testl	%eax, %eax
   1a62a: 79 14                        	jns	0x1a640 <bpf_object_load.constprop.0+0x920>
; 	const struct btf_member *m = btf_members(t) + member_idx;
   1a62c: 8b 44 24 50                  	movl	80(%rsp), %eax
; 	return kflag ? BTF_MEMBER_BITFIELD_SIZE(m->offset) : 0;
   1a630: 48 8d 44 40 03               	leaq	3(%rax,%rax,2), %rax
; 		if (btf_member_bitfield_size(type, i) ||
   1a635: 80 7c 85 0b 00               	cmpb	$0, 11(%rbp,%rax,4)
   1a63a: 0f 85 a7 13 00 00            	jne	0x1b9e7 <bpf_object_load.constprop.0+0x1cc7>
; 		kern_moff = kern_member->offset / 8;
   1a640: 41 8b 46 08                  	movl	8(%r14), %eax
; 		mtype = skip_mods_and_typedefs(btf, member->type, &mtype_id);
   1a644: 41 8b 75 04                  	movl	4(%r13), %esi
   1a648: 48 8b 54 24 68               	movq	104(%rsp), %rdx
   1a64d: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
; 		kern_moff = kern_member->offset / 8;
   1a652: c1 e8 03                     	shrl	$3, %eax
; 		moff = member->offset / 8;
   1a655: 45 8b 65 08                  	movl	8(%r13), %r12d
; 		kern_moff = kern_member->offset / 8;
   1a659: 89 44 24 5c                  	movl	%eax, 92(%rsp)
; 		mtype = skip_mods_and_typedefs(btf, member->type, &mtype_id);
   1a65d: e8 0e 0f ff ff               	callq	0xb570 <skip_mods_and_typedefs>
; 		kern_mtype = skip_mods_and_typedefs(kern_btf, kern_member->type,
   1a662: 41 8b 76 04                  	movl	4(%r14), %esi
   1a666: 48 89 df                     	movq	%rbx, %rdi
; 		moff = member->offset / 8;
   1a669: 41 c1 ec 03                  	shrl	$3, %r12d
; 		kern_mtype = skip_mods_and_typedefs(kern_btf, kern_member->type,
   1a66d: 48 8d 94 24 a0 00 00 00      	leaq	160(%rsp), %rdx
; 		mtype = skip_mods_and_typedefs(btf, member->type, &mtype_id);
   1a675: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 		kern_mtype = skip_mods_and_typedefs(kern_btf, kern_member->type,
   1a67a: 48 89 54 24 38               	movq	%rdx, 56(%rsp)
   1a67f: e8 ec 0e ff ff               	callq	0xb570 <skip_mods_and_typedefs>
; 		if (BTF_INFO_KIND(mtype->info) !=
   1a684: 4c 8b 44 24 40               	movq	64(%rsp), %r8
   1a689: 48 8b 54 24 38               	movq	56(%rsp), %rdx
; 		    BTF_INFO_KIND(kern_mtype->info)) {
   1a68e: 44 0f b6 48 07               	movzbl	7(%rax), %r9d
; 		if (BTF_INFO_KIND(mtype->info) !=
   1a693: 45 0f b6 40 07               	movzbl	7(%r8), %r8d
   1a698: 44 89 c1                     	movl	%r8d, %ecx
   1a69b: 44 31 c9                     	xorl	%r9d, %ecx
   1a69e: 83 e1 1f                     	andl	$31, %ecx
   1a6a1: 0f 85 12 13 00 00            	jne	0x1b9b9 <bpf_object_load.constprop.0+0x1c99>
; 	return BTF_INFO_KIND(t->info);
   1a6a7: 41 83 e0 1f                  	andl	$31, %r8d
; 		if (btf_is_ptr(mtype)) {
   1a6ab: 66 41 83 f8 02               	cmpw	$2, %r8w
   1a6b0: 0f 85 22 02 00 00            	jne	0x1a8d8 <bpf_object_load.constprop.0+0xbb8>
; 			prog = st_ops->progs[i];
   1a6b6: 48 8b 4c 24 60               	movq	96(%rsp), %rcx
   1a6bb: 48 8b 74 24 48               	movq	72(%rsp), %rsi
   1a6c0: 48 8b 49 10                  	movq	16(%rcx), %rcx
   1a6c4: 4c 8b 34 71                  	movq	(%rcx,%rsi,2), %r14
; 			if (!prog)
   1a6c8: 4d 85 f6                     	testq	%r14, %r14
   1a6cb: 0f 84 80 00 00 00            	je	0x1a751 <bpf_object_load.constprop.0+0xa31>
; 							    kern_mtype->type,
   1a6d1: 8b 70 08                     	movl	8(%rax), %esi
; 			kern_mtype = skip_mods_and_typedefs(kern_btf,
   1a6d4: 48 89 df                     	movq	%rbx, %rdi
   1a6d7: e8 94 0e ff ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	return BTF_INFO_KIND(t->info);
   1a6dc: 0f b6 40 07                  	movzbl	7(%rax), %eax
   1a6e0: 83 e0 1f                     	andl	$31, %eax
; 			if (!btf_is_func_proto(kern_mtype)) {
   1a6e3: 66 83 f8 0d                  	cmpw	$13, %ax
   1a6e7: 0f 85 93 13 00 00            	jne	0x1ba80 <bpf_object_load.constprop.0+0x1d60>
; 			st_ops->kern_func_off[i] = kern_data_off + kern_moff;
   1a6ed: 8b 4c 24 5c                  	movl	92(%rsp), %ecx
   1a6f1: 48 8b 74 24 48               	movq	72(%rsp), %rsi
; 			pr_debug("struct_ops init_kern %s: func ptr %s is set to prog %s from data(+%u) to kern_data(+%u)\n",
   1a6f6: 48 83 ec 08                  	subq	$8, %rsp
   1a6fa: 45 89 e1                     	movl	%r12d, %r9d
; 			prog->attach_btf_id = kern_type_id;
   1a6fd: 8b 84 24 90 00 00 00         	movl	144(%rsp), %eax
; 			pr_debug("struct_ops init_kern %s: func ptr %s is set to prog %s from data(+%u) to kern_data(+%u)\n",
   1a704: 4d 8b 06                     	movq	(%r14), %r8
   1a707: bf 02 00 00 00               	movl	$2, %edi
; 			st_ops->kern_func_off[i] = kern_data_off + kern_moff;
   1a70c: 8b 94 24 94 00 00 00         	movl	148(%rsp), %edx
; 			prog->attach_btf_id = kern_type_id;
   1a713: 41 89 86 90 00 00 00         	movl	%eax, 144(%r14)
; 		kern_member_idx = kern_member - btf_members(kern_type);
   1a71a: 8b 44 24 58                  	movl	88(%rsp), %eax
; 			st_ops->kern_func_off[i] = kern_data_off + kern_moff;
   1a71e: 01 ca                        	addl	%ecx, %edx
; 		kern_member_idx = kern_member - btf_members(kern_type);
   1a720: 41 89 86 84 00 00 00         	movl	%eax, 132(%r14)
; 			st_ops->kern_func_off[i] = kern_data_off + kern_moff;
   1a727: 48 8b 44 24 68               	movq	104(%rsp), %rax
   1a72c: 48 8b 40 18                  	movq	24(%rax), %rax
   1a730: 89 14 30                     	movl	%edx, (%rax,%rsi)
; 			pr_debug("struct_ops init_kern %s: func ptr %s is set to prog %s from data(+%u) to kern_data(+%u)\n",
   1a733: 48 8b 44 24 28               	movq	40(%rsp), %rax
   1a738: 48 8d 35 29 dd 01 00         	leaq	122153(%rip), %rsi      # 0x38468 <strs.2+0x55d8>
   1a73f: 48 8b 50 08                  	movq	8(%rax), %rdx
   1a743: 51                           	pushq	%rcx
   1a744: 31 c0                        	xorl	%eax, %eax
   1a746: 4c 89 f9                     	movq	%r15, %rcx
   1a749: e8 82 d9 fe ff               	callq	0x80d0 <libbpf_print>
; 			continue;
   1a74e: 41 5f                        	popq	%r15
   1a750: 58                           	popq	%rax
; 	for (i = 0; i < btf_vlen(type); i++, member++) {
   1a751: 48 8b 44 24 28               	movq	40(%rsp), %rax
   1a756: 83 04 24 01                  	addl	$1, (%rsp)
   1a75a: 49 83 c5 0c                  	addq	$12, %r13
   1a75e: 8b 0c 24                     	movl	(%rsp), %ecx
   1a761: 48 83 44 24 48 04            	addq	$4, 72(%rsp)
   1a767: 0f b7 40 04                  	movzwl	4(%rax), %eax
   1a76b: 39 c1                        	cmpl	%eax, %ecx
   1a76d: 0f 82 1d fe ff ff            	jb	0x1a590 <bpf_object_load.constprop.0+0x870>
   1a773: e9 28 fc ff ff               	jmp	0x1a3a0 <bpf_object_load.constprop.0+0x680>
   1a778: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 			pr_warn("struct_ops init_kern %s: Cannot find member %s in kernel BTF\n",
   1a780: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1a785: 4c 89 f9                     	movq	%r15, %rcx
   1a788: 31 ff                        	xorl	%edi, %edi
   1a78a: 4c 8b 74 24 18               	movq	24(%rsp), %r14
   1a78f: 48 8d 35 ba e1 01 00         	leaq	123322(%rip), %rsi      # 0x38950 <strs.2+0x5ac0>
   1a796: 48 8b 50 08                  	movq	8(%rax), %rdx
   1a79a: 31 c0                        	xorl	%eax, %eax
   1a79c: e8 2f d9 fe ff               	callq	0x80d0 <libbpf_print>
; 			return -ENOTSUP;
   1a7a1: 41 bc a1 ff ff ff            	movl	$4294967201, %r12d      # imm = 0xFFFFFFA1
   1a7a7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	if (obj->gen_loader) {
   1a7b0: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1a7b8: 74 50                        	je	0x1a80a <bpf_object_load.constprop.0+0xaea>
; 		if (obj->btf)
   1a7ba: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1a7c1: 48 85 ff                     	testq	%rdi, %rdi
   1a7c4: 74 0a                        	je	0x1a7d0 <bpf_object_load.constprop.0+0xab0>
; 			btf__set_fd(obj->btf, -1);
   1a7c6: be ff ff ff ff               	movl	$4294967295, %esi       # imm = 0xFFFFFFFF
   1a7cb: e8 70 0a 01 00               	callq	0x2b240 <btf__set_fd>
; 		for (i = 0; i < obj->nr_maps; i++)
   1a7d0: 49 8b 56 70                  	movq	112(%r14), %rdx
   1a7d4: 48 85 d2                     	testq	%rdx, %rdx
   1a7d7: 74 28                        	je	0x1a801 <bpf_object_load.constprop.0+0xae1>
; 			obj->maps[i].fd = -1;
   1a7d9: 49 8b 76 68                  	movq	104(%r14), %rsi
   1a7dd: 48 8d 0c 92                  	leaq	(%rdx,%rdx,4), %rcx
   1a7e1: 48 c1 e1 05                  	shlq	$5, %rcx
   1a7e5: 48 8d 46 18                  	leaq	24(%rsi), %rax
   1a7e9: 48 8d 4c 0e 18               	leaq	24(%rsi,%rcx), %rcx
   1a7ee: 66 90                        	nop
   1a7f0: c7 00 ff ff ff ff            	movl	$4294967295, (%rax)     # imm = 0xFFFFFFFF
; 		for (i = 0; i < obj->nr_maps; i++)
   1a7f6: 48 05 a0 00 00 00            	addq	$160, %rax
   1a7fc: 48 39 c1                     	cmpq	%rax, %rcx
   1a7ff: 75 ef                        	jne	0x1a7f0 <bpf_object_load.constprop.0+0xad0>
; 		if (!err)
   1a801: 45 85 e4                     	testl	%r12d, %r12d
   1a804: 0f 84 5a 0e 00 00            	je	0x1b664 <bpf_object_load.constprop.0+0x1944>
; 	zfree(&obj->fd_array);
   1a80a: 49 8b be 70 01 00 00         	movq	368(%r14), %rdi
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
   1a811: 31 db                        	xorl	%ebx, %ebx
; 	zfree(&obj->fd_array);
   1a813: e8 a8 ae fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
   1a818: 49 83 be 48 01 00 00 00      	cmpq	$0, 328(%r14)
; 	zfree(&obj->fd_array);
   1a820: 49 c7 86 70 01 00 00 00 00 00 00     	movq	$0, 368(%r14)
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
   1a82b: 74 48                        	je	0x1a875 <bpf_object_load.constprop.0+0xb55>
   1a82d: 0f 1f 00                     	nopl	(%rax)
; 		close(obj->btf_modules[i].fd);
   1a830: 49 8b 86 38 01 00 00         	movq	312(%r14), %rax
   1a837: 48 89 dd                     	movq	%rbx, %rbp
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
   1a83a: 48 83 c3 01                  	addq	$1, %rbx
   1a83e: 48 c1 e5 05                  	shlq	$5, %rbp
; 		close(obj->btf_modules[i].fd);
   1a842: 8b 7c 28 14                  	movl	20(%rax,%rbp), %edi
   1a846: e8 b5 b0 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 		btf__free(obj->btf_modules[i].btf);
   1a84b: 49 8b 86 38 01 00 00         	movq	312(%r14), %rax
   1a852: 48 8b 3c 28                  	movq	(%rax,%rbp), %rdi
   1a856: e8 95 ff 00 00               	callq	0x2a7f0 <btf__free>
; 		free(obj->btf_modules[i].name);
   1a85b: 49 8b 86 38 01 00 00         	movq	312(%r14), %rax
   1a862: 48 8b 7c 28 08               	movq	8(%rax,%rbp), %rdi
   1a867: e8 54 ae fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	for (i = 0; i < obj->btf_module_cnt; i++) {
   1a86c: 49 39 9e 48 01 00 00         	cmpq	%rbx, 328(%r14)
   1a873: 77 bb                        	ja	0x1a830 <bpf_object_load.constprop.0+0xb10>
; 	free(obj->btf_modules);
   1a875: 49 8b be 38 01 00 00         	movq	312(%r14), %rdi
   1a87c: e8 3f ae fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	btf__free(obj->btf_vmlinux);
   1a881: 49 8b be 20 01 00 00         	movq	288(%r14), %rdi
   1a888: e8 63 ff 00 00               	callq	0x2a7f0 <btf__free>
; 	obj->loaded = true; /* doesn't matter if successfully or not */
   1a88d: 41 c6 86 98 00 00 00 01      	movb	$1, 152(%r14)
; 	obj->btf_vmlinux = NULL;
   1a895: 49 c7 86 20 01 00 00 00 00 00 00     	movq	$0, 288(%r14)
; 	if (err)
   1a8a0: 45 85 e4                     	testl	%r12d, %r12d
   1a8a3: 0f 85 d3 04 00 00            	jne	0x1ad7c <bpf_object_load.constprop.0+0x105c>
; }
   1a8a9: 48 8b 84 24 68 01 00 00      	movq	360(%rsp), %rax
   1a8b1: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1a8ba: 0f 85 92 1b 00 00            	jne	0x1c452 <bpf_object_load.constprop.0+0x2732>
   1a8c0: 48 81 c4 78 01 00 00         	addq	$376, %rsp              # imm = 0x178
   1a8c7: 44 89 e0                     	movl	%r12d, %eax
   1a8ca: 5b                           	popq	%rbx
   1a8cb: 5d                           	popq	%rbp
   1a8cc: 41 5c                        	popq	%r12
   1a8ce: 41 5d                        	popq	%r13
   1a8d0: 41 5e                        	popq	%r14
   1a8d2: 41 5f                        	popq	%r15
   1a8d4: c3                           	retq
   1a8d5: 0f 1f 00                     	nopl	(%rax)
; 		msize = btf__resolve_size(btf, mtype_id);
   1a8d8: 8b b4 24 98 00 00 00         	movl	152(%rsp), %esi
   1a8df: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   1a8e4: e8 d7 0b 01 00               	callq	0x2b4c0 <btf__resolve_size>
; 		kern_msize = btf__resolve_size(kern_btf, kern_mtype_id);
   1a8e9: 8b b4 24 a0 00 00 00         	movl	160(%rsp), %esi
   1a8f0: 48 89 df                     	movq	%rbx, %rdi
; 		msize = btf__resolve_size(btf, mtype_id);
   1a8f3: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 		kern_msize = btf__resolve_size(kern_btf, kern_mtype_id);
   1a8f8: e8 c3 0b 01 00               	callq	0x2b4c0 <btf__resolve_size>
; 		if (msize < 0 || kern_msize < 0 || msize != kern_msize) {
   1a8fd: 4c 8b 54 24 38               	movq	56(%rsp), %r10
   1a902: 4c 89 d1                     	movq	%r10, %rcx
   1a905: 48 09 c1                     	orq	%rax, %rcx
   1a908: 0f 88 ff 10 00 00            	js	0x1ba0d <bpf_object_load.constprop.0+0x1ced>
   1a90e: 49 39 c2                     	cmpq	%rax, %r10
   1a911: 0f 85 f6 10 00 00            	jne	0x1ba0d <bpf_object_load.constprop.0+0x1ced>
; 		pr_debug("struct_ops init_kern %s: copy %s %u bytes from data(+%u) to kern_data(+%u)\n",
   1a917: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1a91c: 48 83 ec 08                  	subq	$8, %rsp
   1a920: 45 89 e1                     	movl	%r12d, %r9d
   1a923: 45 89 d0                     	movl	%r10d, %r8d
   1a926: 44 8b 74 24 64               	movl	100(%rsp), %r14d
   1a92b: 4c 89 f9                     	movq	%r15, %rcx
   1a92e: bf 02 00 00 00               	movl	$2, %edi
   1a933: 48 8d 35 ee db 01 00         	leaq	121838(%rip), %rsi      # 0x38528 <strs.2+0x5698>
   1a93a: 48 8b 50 08                  	movq	8(%rax), %rdx
   1a93e: 31 c0                        	xorl	%eax, %eax
   1a940: 41 56                        	pushq	%r14
   1a942: 4c 89 54 24 48               	movq	%r10, 72(%rsp)
   1a947: e8 84 d7 fe ff               	callq	0x80d0 <libbpf_print>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1a94c: 48 8b 54 24 48               	movq	72(%rsp), %rdx
; 		kern_mdata = kern_data + kern_moff;
   1a951: 44 89 f7                     	movl	%r14d, %edi
; 		mdata = data + moff;
   1a954: 44 89 e6                     	movl	%r12d, %esi
; 		kern_mdata = kern_data + kern_moff;
   1a957: 48 03 bc 24 90 00 00 00      	addq	144(%rsp), %rdi
; 		mdata = data + moff;
   1a95f: 48 03 b4 24 88 00 00 00      	addq	136(%rsp), %rsi
; 		kern_mdata = kern_data + kern_moff;
   1a967: 48 03 bc 24 80 00 00 00      	addq	128(%rsp), %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1a96f: e8 cc b0 fe ff               	callq	0x5a40 <.plt.sec+0x3d0>
   1a974: 41 5c                        	popq	%r12
   1a976: 41 5e                        	popq	%r14
   1a978: e9 d4 fd ff ff               	jmp	0x1a751 <bpf_object_load.constprop.0+0xa31>
   1a97d: 49 89 ce                     	movq	%rcx, %r14
; 	err = err ? : bpf_object__create_maps(obj);
   1a980: 4c 89 f7                     	movq	%r14, %rdi
   1a983: e8 48 eb ff ff               	callq	0x194d0 <bpf_object__create_maps>
; 	err = err ? : bpf_object__relocate(obj, obj->btf_custom_path ? : target_btf_path);
   1a988: 85 c0                        	testl	%eax, %eax
   1a98a: 0f 85 f2 14 00 00            	jne	0x1be82 <bpf_object_load.constprop.0+0x2162>
   1a990: 49 8b be 28 01 00 00         	movq	296(%r14), %rdi
; 	if (obj->btf_ext) {
   1a997: 49 8b 86 18 01 00 00         	movq	280(%r14), %rax
; 	err = err ? : bpf_object__relocate(obj, obj->btf_custom_path ? : target_btf_path);
   1a99e: 48 85 ff                     	testq	%rdi, %rdi
   1a9a1: 0f 84 f9 0f 00 00            	je	0x1b9a0 <bpf_object_load.constprop.0+0x1c80>
; 	if (obj->btf_ext) {
   1a9a7: 48 85 c0                     	testq	%rax, %rax
   1a9aa: 0f 84 60 02 00 00            	je	0x1ac10 <bpf_object_load.constprop.0+0xef0>
; 	if (obj->btf_ext->core_relo_info.len == 0)
   1a9b0: 8b 58 54                     	movl	84(%rax), %ebx
   1a9b3: 85 db                        	testl	%ebx, %ebx
   1a9b5: 0f 84 7e 0e 00 00            	je	0x1b839 <bpf_object_load.constprop.0+0x1b19>
; 		obj->btf_vmlinux_override = btf__parse(targ_btf_path, NULL);
   1a9bb: 31 f6                        	xorl	%esi, %esi
   1a9bd: e8 de 31 01 00               	callq	0x2dba0 <btf__parse>
   1a9c2: 49 89 86 30 01 00 00         	movq	%rax, 304(%r14)
   1a9c9: 48 89 c3                     	movq	%rax, %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
   1a9cc: 48 85 c0                     	testq	%rax, %rax
   1a9cf: 0f 84 e4 0d 00 00            	je	0x1b7b9 <bpf_object_load.constprop.0+0x1a99>
   1a9d5: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   1a9db: 0f 87 d8 0d 00 00            	ja	0x1b7b9 <bpf_object_load.constprop.0+0x1a99>
; 	cand_cache = hashmap__new(bpf_core_hash_fn, bpf_core_equal_fn, NULL);
   1a9e1: 31 d2                        	xorl	%edx, %edx
   1a9e3: 48 8d 35 e6 bb fe ff         	leaq	-82970(%rip), %rsi      # 0x65d0 <bpf_core_equal_fn>
   1a9ea: 48 8d 3d cf bb fe ff         	leaq	-82993(%rip), %rdi      # 0x65c0 <bpf_core_hash_fn>
   1a9f1: e8 da 39 00 00               	callq	0x1e3d0 <hashmap__new>
   1a9f6: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	if (IS_ERR(cand_cache)) {
   1a9fb: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   1aa01: 0f 87 0d 0e 00 00            	ja	0x1b814 <bpf_object_load.constprop.0+0x1af4>
; 	seg = &obj->btf_ext->core_relo_info;
   1aa07: 49 8b 86 18 01 00 00         	movq	280(%r14), %rax
; 	for_each_btf_ext_sec(seg, sec) {
   1aa0e: 48 8b 48 48                  	movq	72(%rax), %rcx
; 	seg = &obj->btf_ext->core_relo_info;
   1aa12: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	for_each_btf_ext_sec(seg, sec) {
   1aa17: 8b 40 54                     	movl	84(%rax), %eax
   1aa1a: 48 89 0c 24                  	movq	%rcx, (%rsp)
   1aa1e: 48 01 c8                     	addq	%rcx, %rax
   1aa21: 48 39 c1                     	cmpq	%rax, %rcx
   1aa24: 0f 83 a3 14 00 00            	jae	0x1becd <bpf_object_load.constprop.0+0x21ad>
   1aa2a: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
; 		sec_idx = seg->sec_idxs[sec_num];
   1aa33: 48 8b 44 24 08               	movq	8(%rsp), %rax
   1aa38: 48 8b 4c 24 38               	movq	56(%rsp), %rcx
; 		sec_name = btf__name_by_offset(obj->btf, sec->sec_name_off);
   1aa3d: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
; 		sec_idx = seg->sec_idxs[sec_num];
   1aa44: 48 8b 40 58                  	movq	88(%rax), %rax
   1aa48: 8b 04 08                     	movl	(%rax,%rcx), %eax
   1aa4b: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 		sec_name = btf__name_by_offset(obj->btf, sec->sec_name_off);
   1aa4f: 48 8b 04 24                  	movq	(%rsp), %rax
   1aa53: 8b 30                        	movl	(%rax), %esi
   1aa55: e8 96 10 01 00               	callq	0x2baf0 <btf__name_by_offset>
   1aa5a: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	return !s || !s[0];
   1aa5f: 48 85 c0                     	testq	%rax, %rax
   1aa62: 0f 84 c4 0c 00 00            	je	0x1b72c <bpf_object_load.constprop.0+0x1a0c>
   1aa68: 80 38 00                     	cmpb	$0, (%rax)
   1aa6b: 0f 84 bb 0c 00 00            	je	0x1b72c <bpf_object_load.constprop.0+0x1a0c>
; 		pr_debug("sec '%s': found %d CO-RE relocations\n", sec_name, sec->num_info);
   1aa71: 48 8b 1c 24                  	movq	(%rsp), %rbx
   1aa75: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   1aa7a: 31 c0                        	xorl	%eax, %eax
   1aa7c: bf 02 00 00 00               	movl	$2, %edi
   1aa81: 48 8d 35 98 de 01 00         	leaq	122520(%rip), %rsi      # 0x38920 <strs.2+0x5a90>
   1aa88: 8b 4b 04                     	movl	4(%rbx), %ecx
   1aa8b: e8 40 d6 fe ff               	callq	0x80d0 <libbpf_print>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   1aa90: 48 89 d8                     	movq	%rbx, %rax
   1aa93: 48 8d 5b 08                  	leaq	8(%rbx), %rbx
   1aa97: 8b 48 04                     	movl	4(%rax), %ecx
   1aa9a: 85 c9                        	testl	%ecx, %ecx
   1aa9c: 0f 84 a6 19 00 00            	je	0x1c448 <bpf_object_load.constprop.0+0x2728>
   1aaa2: 45 31 ff                     	xorl	%r15d, %r15d
   1aaa5: eb 2b                        	jmp	0x1aad2 <bpf_object_load.constprop.0+0xdb2>
   1aaa7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
   1aab0: 48 8b 44 24 08               	movq	8(%rsp), %rax
   1aab5: 48 8b 0c 24                  	movq	(%rsp), %rcx
   1aab9: 41 83 c7 01                  	addl	$1, %r15d
   1aabd: 8b 50 50                     	movl	80(%rax), %edx
   1aac0: 48 89 d0                     	movq	%rdx, %rax
   1aac3: 48 01 d3                     	addq	%rdx, %rbx
   1aac6: 8b 51 04                     	movl	4(%rcx), %edx
   1aac9: 44 39 fa                     	cmpl	%r15d, %edx
   1aacc: 0f 86 d1 13 00 00            	jbe	0x1bea3 <bpf_object_load.constprop.0+0x2183>
; 			if (rec->insn_off % BPF_INSN_SZ)
   1aad2: 44 8b 1b                     	movl	(%rbx), %r11d
   1aad5: 41 f6 c3 07                  	testb	$7, %r11b
   1aad9: 0f 85 14 12 00 00            	jne	0x1bcf3 <bpf_object_load.constprop.0+0x1fd3>
; 			prog = find_prog_by_sec_insn(obj, sec_idx, insn_idx);
   1aadf: 48 63 74 24 10               	movslq	16(%rsp), %rsi
; 			insn_idx = rec->insn_off / BPF_INSN_SZ;
   1aae4: 41 c1 eb 03                  	shrl	$3, %r11d
; 			prog = find_prog_by_sec_insn(obj, sec_idx, insn_idx);
   1aae8: 4c 89 f7                     	movq	%r14, %rdi
   1aaeb: 44 89 da                     	movl	%r11d, %edx
   1aaee: e8 2d ba fe ff               	callq	0x6520 <find_prog_by_sec_insn>
   1aaf3: 49 89 c4                     	movq	%rax, %r12
; 			if (!prog) {
   1aaf6: 48 85 c0                     	testq	%rax, %rax
   1aaf9: 0f 84 f2 0c 00 00            	je	0x1b7f1 <bpf_object_load.constprop.0+0x1ad1>
; 			if (!prog->autoload)
   1aaff: 80 78 7c 00                  	cmpb	$0, 124(%rax)
   1ab03: 74 ab                        	je	0x1aab0 <bpf_object_load.constprop.0+0xd90>
; 			insn_idx = insn_idx - prog->sec_insn_off;
   1ab05: 44 2b 58 20                  	subl	32(%rax), %r11d
   1ab09: 49 63 eb                     	movslq	%r11d, %rbp
; 			if (insn_idx >= prog->insns_cnt)
   1ab0c: 48 3b 68 40                  	cmpq	64(%rax), %rbp
   1ab10: 0f 83 dd 11 00 00            	jae	0x1bcf3 <bpf_object_load.constprop.0+0x1fd3>
; 			insn = &prog->insns[insn_idx];
   1ab16: 48 8b 40 38                  	movq	56(%rax), %rax
; 	relos = libbpf_reallocarray(prog->reloc_desc,
   1ab1a: 49 8b 7c 24 48               	movq	72(%r12), %rdi
; 			insn = &prog->insns[insn_idx];
   1ab1f: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 				    prog->nr_reloc + 1, sizeof(*relos));
   1ab24: 41 8b 44 24 50               	movl	80(%r12), %eax
   1ab29: 83 c0 01                     	addl	$1, %eax
; 	relos = libbpf_reallocarray(prog->reloc_desc,
   1ab2c: 48 98                        	cltq
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   1ab2e: 48 89 c6                     	movq	%rax, %rsi
   1ab31: 48 c1 e6 04                  	shlq	$4, %rsi
   1ab35: 48 c1 e8 3c                  	shrq	$60, %rax
   1ab39: 0f 85 fa 0e 00 00            	jne	0x1ba39 <bpf_object_load.constprop.0+0x1d19>
; 	return realloc(ptr, total);
   1ab3f: e8 dc af fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 	if (!relos)
   1ab44: 48 85 c0                     	testq	%rax, %rax
   1ab47: 0f 84 ec 0e 00 00            	je	0x1ba39 <bpf_object_load.constprop.0+0x1d19>
; 	relo = &relos[prog->nr_reloc];
   1ab4d: 49 63 54 24 50               	movslq	80(%r12), %rdx
   1ab52: 48 89 d1                     	movq	%rdx, %rcx
   1ab55: 48 c1 e2 04                  	shlq	$4, %rdx
   1ab59: 48 01 c2                     	addq	%rax, %rdx
; 	prog->nr_reloc++;
   1ab5c: 83 c1 01                     	addl	$1, %ecx
; 	relo->type = RELO_CORE;
   1ab5f: c7 02 06 00 00 00            	movl	$6, (%rdx)
; 	relo->insn_idx = insn_idx;
   1ab65: 89 6a 04                     	movl	%ebp, 4(%rdx)
; 	relo->core_relo = core_relo;
   1ab68: 48 89 5a 08                  	movq	%rbx, 8(%rdx)
; 	prog->reloc_desc = relos;
   1ab6c: 49 89 44 24 48               	movq	%rax, 72(%r12)
; 			if (prog->obj->gen_loader)
   1ab71: 49 8b 44 24 70               	movq	112(%r12), %rax
; 	prog->nr_reloc++;
   1ab76: 41 89 4c 24 50               	movl	%ecx, 80(%r12)
; 			if (prog->obj->gen_loader)
   1ab7b: 48 83 b8 a0 00 00 00 00      	cmpq	$0, 160(%rax)
   1ab83: 0f 85 27 ff ff ff            	jne	0x1aab0 <bpf_object_load.constprop.0+0xd90>
; 			err = bpf_core_resolve_relo(prog, rec, i, obj->btf, cand_cache, &targ_res);
   1ab89: 49 8b 8e 10 01 00 00         	movq	272(%r14), %rcx
   1ab90: 44 89 fa                     	movl	%r15d, %edx
   1ab93: 48 89 de                     	movq	%rbx, %rsi
   1ab96: 4c 89 e7                     	movq	%r12, %rdi
   1ab99: 4c 8b 44 24 20               	movq	32(%rsp), %r8
   1ab9e: 4c 8d 8c 24 a0 00 00 00      	leaq	160(%rsp), %r9
   1aba6: 4c 89 4c 24 28               	movq	%r9, 40(%rsp)
   1abab: e8 f0 36 ff ff               	callq	0xe2a0 <bpf_core_resolve_relo>
; 			if (err) {
   1abb0: 4c 8b 4c 24 28               	movq	40(%rsp), %r9
   1abb5: 85 c0                        	testl	%eax, %eax
   1abb7: 0f 85 2f 18 00 00            	jne	0x1c3ec <bpf_object_load.constprop.0+0x26cc>
; 			insn = &prog->insns[insn_idx];
   1abbd: 48 8b 44 24 18               	movq	24(%rsp), %rax
; 			err = bpf_core_patch_insn(prog->name, insn, insn_idx, rec, i, &targ_res);
   1abc2: 49 8b 3c 24                  	movq	(%r12), %rdi
   1abc6: 45 89 f8                     	movl	%r15d, %r8d
   1abc9: 48 89 d9                     	movq	%rbx, %rcx
   1abcc: 89 ea                        	movl	%ebp, %edx
; 			insn = &prog->insns[insn_idx];
   1abce: 48 8d 34 e8                  	leaq	(%rax,%rbp,8), %rsi
; 			err = bpf_core_patch_insn(prog->name, insn, insn_idx, rec, i, &targ_res);
   1abd2: e8 19 75 00 00               	callq	0x220f0 <bpf_core_patch_insn>
; 			if (err) {
   1abd7: 85 c0                        	testl	%eax, %eax
   1abd9: 0f 84 d1 fe ff ff            	je	0x1aab0 <bpf_object_load.constprop.0+0xd90>
; 				pr_warn("prog '%s': relo #%d: failed to patch insn #%u: %d\n",
   1abdf: 4d 89 e5                     	movq	%r12, %r13
   1abe2: 41 89 c1                     	movl	%eax, %r9d
   1abe5: 41 89 c4                     	movl	%eax, %r12d
   1abe8: 41 89 e8                     	movl	%ebp, %r8d
   1abeb: 49 8b 55 00                  	movq	(%r13), %rdx
   1abef: 44 89 f9                     	movl	%r15d, %ecx
   1abf2: 48 8d 35 8f da 01 00         	leaq	121487(%rip), %rsi      # 0x38688 <strs.2+0x57f8>
   1abf9: 31 ff                        	xorl	%edi, %edi
   1abfb: 31 c0                        	xorl	%eax, %eax
   1abfd: e8 ce d4 fe ff               	callq	0x80d0 <libbpf_print>
; 				goto out;
   1ac02: e9 2b 0b 00 00               	jmp	0x1b732 <bpf_object_load.constprop.0+0x1a12>
   1ac07: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	for (i = 0; i < obj->nr_programs; i++) {
   1ac10: 49 8b 76 60                  	movq	96(%r14), %rsi
   1ac14: 48 85 f6                     	testq	%rsi, %rsi
   1ac17: 0f 84 12 05 00 00            	je	0x1b12f <bpf_object_load.constprop.0+0x140f>
; 		prog = &obj->programs[i];
   1ac1d: 4d 8b 46 58                  	movq	88(%r14), %r8
   1ac21: 4c 8d 1c 76                  	leaq	(%rsi,%rsi,2), %r11
   1ac25: 49 c1 e3 06                  	shlq	$6, %r11
   1ac29: 4d 8d 50 38                  	leaq	56(%r8), %r10
   1ac2d: 4d 01 d3                     	addq	%r10, %r11
; 		for (j = 0; j < prog->nr_reloc; j++) {
   1ac30: 49 63 4a 18                  	movslq	24(%r10), %rcx
   1ac34: 48 85 c9                     	testq	%rcx, %rcx
   1ac37: 74 3a                        	je	0x1ac73 <bpf_object_load.constprop.0+0xf53>
   1ac39: 49 8b 42 10                  	movq	16(%r10), %rax
   1ac3d: 48 c1 e1 04                  	shlq	$4, %rcx
; 			struct bpf_insn *insn = &prog->insns[relo->insn_idx];
   1ac41: 4d 8b 0a                     	movq	(%r10), %r9
   1ac44: 48 01 c1                     	addq	%rax, %rcx
   1ac47: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 			if (relo->type == RELO_SUBPROG_ADDR)
   1ac50: 83 38 05                     	cmpl	$5, (%rax)
   1ac53: 75 15                        	jne	0x1ac6a <bpf_object_load.constprop.0+0xf4a>
; 			struct bpf_insn *insn = &prog->insns[relo->insn_idx];
   1ac55: 48 63 78 04                  	movslq	4(%rax), %rdi
; 				insn[0].src_reg = BPF_PSEUDO_FUNC;
   1ac59: 41 0f b6 54 f9 01            	movzbl	1(%r9,%rdi,8), %edx
   1ac5f: 83 e2 0f                     	andl	$15, %edx
   1ac62: 83 ca 40                     	orl	$64, %edx
   1ac65: 41 88 54 f9 01               	movb	%dl, 1(%r9,%rdi,8)
; 		for (j = 0; j < prog->nr_reloc; j++) {
   1ac6a: 48 83 c0 10                  	addq	$16, %rax
   1ac6e: 48 39 c1                     	cmpq	%rax, %rcx
   1ac71: 75 dd                        	jne	0x1ac50 <bpf_object_load.constprop.0+0xf30>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1ac73: 49 81 c2 c0 00 00 00         	addq	$192, %r10
   1ac7a: 4d 39 d3                     	cmpq	%r10, %r11
   1ac7d: 75 b1                        	jne	0x1ac30 <bpf_object_load.constprop.0+0xf10>
   1ac7f: 31 ed                        	xorl	%ebp, %ebp
   1ac81: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		prog = &obj->programs[i];
   1ac88: 48 8d 5c 6d 00               	leaq	(%rbp,%rbp,2), %rbx
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   1ac8d: 49 63 96 04 01 00 00         	movslq	260(%r14), %rdx
; 		prog = &obj->programs[i];
   1ac94: 48 c1 e3 06                  	shlq	$6, %rbx
   1ac98: 4c 01 c3                     	addq	%r8, %rbx
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   1ac9b: 48 83 fe 01                  	cmpq	$1, %rsi
   1ac9f: 0f 95 c1                     	setne	%cl
   1aca2: 48 39 53 10                  	cmpq	%rdx, 16(%rbx)
   1aca6: 75 04                        	jne	0x1acac <bpf_object_load.constprop.0+0xf8c>
   1aca8: 84 c9                        	testb	%cl, %cl
   1acaa: 75 51                        	jne	0x1acfd <bpf_object_load.constprop.0+0xfdd>
; 		if (!prog->autoload)
   1acac: 80 7b 7c 00                  	cmpb	$0, 124(%rbx)
   1acb0: 74 4b                        	je	0x1acfd <bpf_object_load.constprop.0+0xfdd>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1acb2: 48 8d 34 76                  	leaq	(%rsi,%rsi,2), %rsi
   1acb6: 49 8d 40 10                  	leaq	16(%r8), %rax
   1acba: 48 c1 e6 06                  	shlq	$6, %rsi
   1acbe: 49 8d 74 30 10               	leaq	16(%r8,%rsi), %rsi
   1acc3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   1acc8: 48 39 10                     	cmpq	%rdx, (%rax)
   1accb: 75 0c                        	jne	0x1acd9 <bpf_object_load.constprop.0+0xfb9>
   1accd: 84 c9                        	testb	%cl, %cl
   1accf: 74 08                        	je	0x1acd9 <bpf_object_load.constprop.0+0xfb9>
; 		subprog->sub_insn_off = 0;
   1acd1: 48 c7 40 20 00 00 00 00      	movq	$0, 32(%rax)
; 	for (i = 0; i < obj->nr_programs; i++) {
   1acd9: 48 05 c0 00 00 00            	addq	$192, %rax
   1acdf: 48 39 c6                     	cmpq	%rax, %rsi
   1ace2: 75 e4                        	jne	0x1acc8 <bpf_object_load.constprop.0+0xfa8>
; 	err = bpf_object__reloc_code(obj, prog, prog);
   1ace4: 48 89 da                     	movq	%rbx, %rdx
   1ace7: 48 89 de                     	movq	%rbx, %rsi
   1acea: 4c 89 f7                     	movq	%r14, %rdi
   1aced: e8 ae 17 ff ff               	callq	0xc4a0 <bpf_object__reloc_code>
   1acf2: 41 89 c4                     	movl	%eax, %r12d
; 	if (err)
   1acf5: 85 c0                        	testl	%eax, %eax
   1acf7: 75 1f                        	jne	0x1ad18 <bpf_object_load.constprop.0+0xff8>
   1acf9: 49 8b 76 60                  	movq	96(%r14), %rsi
; 	for (i = 0; i < obj->nr_programs; i++) {
   1acfd: 48 83 c5 01                  	addq	$1, %rbp
   1ad01: 48 39 ee                     	cmpq	%rbp, %rsi
   1ad04: 0f 86 0e 01 00 00            	jbe	0x1ae18 <bpf_object_load.constprop.0+0x10f8>
; 		prog = &obj->programs[i];
   1ad0a: 4d 8b 46 58                  	movq	88(%r14), %r8
   1ad0e: e9 75 ff ff ff               	jmp	0x1ac88 <bpf_object_load.constprop.0+0xf68>
   1ad13: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			pr_warn("prog '%s': failed to relocate calls: %d\n",
   1ad18: 48 8b 13                     	movq	(%rbx), %rdx
   1ad1b: 89 c1                        	movl	%eax, %ecx
   1ad1d: 48 8d 35 dc d9 01 00         	leaq	121308(%rip), %rsi      # 0x38700 <strs.2+0x5870>
   1ad24: 31 ff                        	xorl	%edi, %edi
   1ad26: 31 c0                        	xorl	%eax, %eax
   1ad28: e8 a3 d3 fe ff               	callq	0x80d0 <libbpf_print>
; 			return err;
   1ad2d: e9 7e fa ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 		pr_warn("struct_ops init_kern: struct %s data is not found in struct %s%s\n",
   1ad32: 4d 89 f8                     	movq	%r15, %r8
   1ad35: 48 8d 0d 37 76 01 00         	leaq	95799(%rip), %rcx       # 0x32373 <_IO_stdin_used+0x2373>
   1ad3c: 4c 89 fa                     	movq	%r15, %rdx
   1ad3f: 31 ff                        	xorl	%edi, %edi
   1ad41: 48 8d 35 f8 d5 01 00         	leaq	120312(%rip), %rsi      # 0x38340 <strs.2+0x54b0>
   1ad48: 31 c0                        	xorl	%eax, %eax
   1ad4a: 4c 8b 74 24 18               	movq	24(%rsp), %r14
; 		return -EINVAL;
   1ad4f: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("struct_ops init_kern: struct %s data is not found in struct %s%s\n",
   1ad55: e8 76 d3 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
   1ad5a: e9 51 fa ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 		pr_warn("struct_ops init_kern: struct %s is not found in kernel BTF\n",
   1ad5f: 4c 89 fa                     	movq	%r15, %rdx
   1ad62: 48 8d 35 f7 d4 01 00         	leaq	120055(%rip), %rsi      # 0x38260 <strs.2+0x53d0>
   1ad69: 31 ff                        	xorl	%edi, %edi
   1ad6b: 31 c0                        	xorl	%eax, %eax
   1ad6d: 4c 8b 74 24 18               	movq	24(%rsp), %r14
   1ad72: e8 59 d3 fe ff               	callq	0x80d0 <libbpf_print>
; 		return kern_type_id;
   1ad77: e9 34 fa ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 	for (i = 0; i < obj->nr_maps; i++)
   1ad7c: 31 db                        	xorl	%ebx, %ebx
   1ad7e: 49 83 7e 70 00               	cmpq	$0, 112(%r14)
   1ad83: 75 15                        	jne	0x1ad9a <bpf_object_load.constprop.0+0x107a>
   1ad85: eb 42                        	jmp	0x1adc9 <bpf_object_load.constprop.0+0x10a9>
   1ad87: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
   1ad90: 48 83 c3 01                  	addq	$1, %rbx
   1ad94: 49 39 5e 70                  	cmpq	%rbx, 112(%r14)
   1ad98: 76 2f                        	jbe	0x1adc9 <bpf_object_load.constprop.0+0x10a9>
; 		if (obj->maps[i].pinned && !obj->maps[i].reused)
   1ad9a: 48 8d 3c 9b                  	leaq	(%rbx,%rbx,4), %rdi
   1ad9e: 48 c1 e7 05                  	shlq	$5, %rdi
   1ada2: 49 03 7e 68                  	addq	104(%r14), %rdi
   1ada6: 80 bf 90 00 00 00 00         	cmpb	$0, 144(%rdi)
   1adad: 74 e1                        	je	0x1ad90 <bpf_object_load.constprop.0+0x1070>
   1adaf: 80 bf 91 00 00 00 00         	cmpb	$0, 145(%rdi)
   1adb6: 75 d8                        	jne	0x1ad90 <bpf_object_load.constprop.0+0x1070>
; 			bpf_map__unpin(&obj->maps[i], NULL);
   1adb8: 31 f6                        	xorl	%esi, %esi
; 	for (i = 0; i < obj->nr_maps; i++)
   1adba: 48 83 c3 01                  	addq	$1, %rbx
; 			bpf_map__unpin(&obj->maps[i], NULL);
   1adbe: e8 1d 5f ff ff               	callq	0x10ce0 <bpf_map__unpin>
; 	for (i = 0; i < obj->nr_maps; i++)
   1adc3: 49 39 5e 70                  	cmpq	%rbx, 112(%r14)
   1adc7: 77 d1                        	ja	0x1ad9a <bpf_object_load.constprop.0+0x107a>
; 	if (!obj)
   1adc9: 4c 89 f7                     	movq	%r14, %rdi
   1adcc: e8 1f cc fe ff               	callq	0x79f0 <bpf_object_unload.part.0.isra.0>
; 	pr_warn("failed to load object '%s'\n", obj->path);
   1add1: 31 ff                        	xorl	%edi, %edi
   1add3: 31 c0                        	xorl	%eax, %eax
   1add5: 49 8d 96 90 01 00 00         	leaq	400(%r14), %rdx
   1addc: 48 8d 35 15 db 01 00         	leaq	121621(%rip), %rsi      # 0x388f8 <strs.2+0x5a68>
   1ade3: e8 e8 d2 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   1ade8: 45 85 e4                     	testl	%r12d, %r12d
   1adeb: 0f 89 b8 fa ff ff            	jns	0x1a8a9 <bpf_object_load.constprop.0+0xb89>
; 		errno = -ret;
   1adf1: e8 fa a8 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1adf6: 44 89 e2                     	movl	%r12d, %edx
   1adf9: f7 da                        	negl	%edx
   1adfb: 89 10                        	movl	%edx, (%rax)
   1adfd: e9 a7 fa ff ff               	jmp	0x1a8a9 <bpf_object_load.constprop.0+0xb89>
; 				value = kernel_supports(obj, FEAT_SYSCALL_WRAPPER);
   1ae02: be 12 00 00 00               	movl	$18, %esi
   1ae07: 4c 89 f7                     	movq	%r14, %rdi
   1ae0a: e8 01 16 ff ff               	callq	0xc410 <kernel_supports>
   1ae0f: 44 0f b6 f8                  	movzbl	%al, %r15d
   1ae13: e9 66 f0 ff ff               	jmp	0x19e7e <bpf_object_load.constprop.0+0x15e>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1ae18: 48 85 f6                     	testq	%rsi, %rsi
   1ae1b: 0f 84 0e 03 00 00            	je	0x1b12f <bpf_object_load.constprop.0+0x140f>
   1ae21: 45 31 ed                     	xorl	%r13d, %r13d
; 		switch (relo->type) {
   1ae24: 4c 8d 15 85 7f 01 00         	leaq	98181(%rip), %r10       # 0x32db0 <_IO_stdin_used+0x2db0>
; 	pr_debug("prog '%s': relo #%d: poisoning insn #%d that loads map #%d '%s'\n",
   1ae2b: 4c 8d 3d 06 d9 01 00         	leaq	121094(%rip), %r15      # 0x38738 <strs.2+0x58a8>
   1ae32: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		prog = &obj->programs[i];
   1ae38: 4b 8d 5c 6d 00               	leaq	(%r13,%r13,2), %rbx
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   1ae3d: 49 63 86 04 01 00 00         	movslq	260(%r14), %rax
; 		prog = &obj->programs[i];
   1ae44: 48 c1 e3 06                  	shlq	$6, %rbx
   1ae48: 49 03 5e 58                  	addq	88(%r14), %rbx
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   1ae4c: 48 39 43 10                  	cmpq	%rax, 16(%rbx)
   1ae50: 75 06                        	jne	0x1ae58 <bpf_object_load.constprop.0+0x1138>
   1ae52: 48 83 fe 01                  	cmpq	$1, %rsi
   1ae56: 75 78                        	jne	0x1aed0 <bpf_object_load.constprop.0+0x11b0>
; 		if (!prog->autoload)
   1ae58: 80 7b 7c 00                  	cmpb	$0, 124(%rbx)
   1ae5c: 74 72                        	je	0x1aed0 <bpf_object_load.constprop.0+0x11b0>
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1ae5e: 8b 7b 50                     	movl	80(%rbx), %edi
   1ae61: 31 ed                        	xorl	%ebp, %ebp
   1ae63: 85 ff                        	testl	%edi, %edi
   1ae65: 7e 69                        	jle	0x1aed0 <bpf_object_load.constprop.0+0x11b0>
   1ae67: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		struct reloc_desc *relo = &prog->reloc_desc[i];
   1ae70: 48 89 e8                     	movq	%rbp, %rax
; 		struct bpf_insn *insn = &prog->insns[relo->insn_idx];
   1ae73: 48 8b 53 38                  	movq	56(%rbx), %rdx
   1ae77: 89 e9                        	movl	%ebp, %ecx
; 		struct reloc_desc *relo = &prog->reloc_desc[i];
   1ae79: 48 c1 e0 04                  	shlq	$4, %rax
   1ae7d: 48 03 43 48                  	addq	72(%rbx), %rax
; 		struct bpf_insn *insn = &prog->insns[relo->insn_idx];
   1ae81: 48 63 70 04                  	movslq	4(%rax), %rsi
   1ae85: 4c 8d 24 f2                  	leaq	(%rdx,%rsi,8), %r12
; 		switch (relo->type) {
   1ae89: 8b 10                        	movl	(%rax), %edx
; 		struct bpf_insn *insn = &prog->insns[relo->insn_idx];
   1ae8b: 49 89 f0                     	movq	%rsi, %r8
; 		switch (relo->type) {
   1ae8e: 83 fa 06                     	cmpl	$6, %edx
   1ae91: 0f 87 79 05 00 00            	ja	0x1b410 <bpf_object_load.constprop.0+0x16f0>
   1ae97: 49 63 14 92                  	movslq	(%r10,%rdx,4), %rdx
   1ae9b: 4c 01 d2                     	addq	%r10, %rdx
   1ae9e: 3e ff e2                     	jmpq	*%rdx
   1aea1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			if (insn[0].src_reg != BPF_PSEUDO_FUNC) {
   1aea8: 41 0f b6 44 24 01            	movzbl	1(%r12), %eax
   1aeae: 83 e0 f0                     	andl	$-16, %eax
   1aeb1: 3c 40                        	cmpb	$64, %al
   1aeb3: 0f 85 6a 0e 00 00            	jne	0x1bd23 <bpf_object_load.constprop.0+0x2003>
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1aeb9: 48 83 c5 01                  	addq	$1, %rbp
   1aebd: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1aec0: 7f ae                        	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1aec2: 49 8b 76 60                  	movq	96(%r14), %rsi
   1aec6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	for (i = 0; i < obj->nr_programs; i++) {
   1aed0: 49 83 c5 01                  	addq	$1, %r13
   1aed4: 4c 39 ee                     	cmpq	%r13, %rsi
   1aed7: 0f 87 5b ff ff ff            	ja	0x1ae38 <bpf_object_load.constprop.0+0x1118>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1aedd: 48 85 f6                     	testq	%rsi, %rsi
   1aee0: 0f 84 49 02 00 00            	je	0x1b12f <bpf_object_load.constprop.0+0x140f>
   1aee6: 45 31 ed                     	xorl	%r13d, %r13d
   1aee9: eb 12                        	jmp	0x1aefd <bpf_object_load.constprop.0+0x11dd>
   1aeeb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   1aef0: 49 83 c5 01                  	addq	$1, %r13
   1aef4: 49 39 f5                     	cmpq	%rsi, %r13
   1aef7: 0f 83 a4 00 00 00            	jae	0x1afa1 <bpf_object_load.constprop.0+0x1281>
; 	if (obj->gen_loader)
   1aefd: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1af05: 75 e9                        	jne	0x1aef0 <bpf_object_load.constprop.0+0x11d0>
; 		prog = &obj->programs[i];
   1af07: 4f 8d 64 6d 00               	leaq	(%r13,%r13,2), %r12
   1af0c: 49 c1 e4 06                  	shlq	$6, %r12
   1af10: 4d 03 66 58                  	addq	88(%r14), %r12
; 	for (i = 0; i < prog->insns_cnt; i++, insn++) {
   1af14: 49 83 7c 24 40 00            	cmpq	$0, 64(%r12)
   1af1a: 74 d4                        	je	0x1aef0 <bpf_object_load.constprop.0+0x11d0>
; 	struct bpf_insn *insn = prog->insns;
   1af1c: 49 8b 5c 24 38               	movq	56(%r12), %rbx
   1af21: 31 ed                        	xorl	%ebp, %ebp
   1af23: eb 12                        	jmp	0x1af37 <bpf_object_load.constprop.0+0x1217>
   1af25: 0f 1f 00                     	nopl	(%rax)
; 	for (i = 0; i < prog->insns_cnt; i++, insn++) {
   1af28: 48 83 c3 08                  	addq	$8, %rbx
   1af2c: 48 83 c5 01                  	addq	$1, %rbp
   1af30: 49 39 6c 24 40               	cmpq	%rbp, 64(%r12)
   1af35: 76 59                        	jbe	0x1af90 <bpf_object_load.constprop.0+0x1270>
; 	if (BPF_CLASS(insn->code) == BPF_JMP &&
   1af37: 0f b6 03                     	movzbl	(%rbx), %eax
   1af3a: 89 c2                        	movl	%eax, %edx
   1af3c: 83 e2 f7                     	andl	$-9, %edx
   1af3f: 80 fa 85                     	cmpb	$-123, %dl
   1af42: 75 e4                        	jne	0x1af28 <bpf_object_load.constprop.0+0x1208>
; 	    BPF_OP(insn->code) == BPF_CALL &&
   1af44: a8 08                        	testb	$8, %al
   1af46: 75 e0                        	jne	0x1af28 <bpf_object_load.constprop.0+0x1208>
; 	    insn->src_reg == 0 &&
   1af48: 80 7b 01 00                  	cmpb	$0, 1(%rbx)
   1af4c: 75 da                        	jne	0x1af28 <bpf_object_load.constprop.0+0x1208>
; 		    *func_id = insn->imm;
   1af4e: 8b 43 04                     	movl	4(%rbx), %eax
; 		switch (func_id) {
   1af51: 83 f8 71                     	cmpl	$113, %eax
   1af54: 0f 8f 7e 04 00 00            	jg	0x1b3d8 <bpf_object_load.constprop.0+0x16b8>
   1af5a: 83 f8 6f                     	cmpl	$111, %eax
   1af5d: 7e c9                        	jle	0x1af28 <bpf_object_load.constprop.0+0x1208>
; 	if (obj && obj->gen_loader)
   1af5f: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1af67: 75 bf                        	jne	0x1af28 <bpf_object_load.constprop.0+0x1208>
   1af69: bf 08 00 00 00               	movl	$8, %edi
   1af6e: e8 dd f4 fe ff               	callq	0xa450 <kernel_supports.part.0>
; 			if (!kernel_supports(obj, FEAT_PROBE_READ_KERN))
   1af73: 84 c0                        	testb	%al, %al
   1af75: 75 b1                        	jne	0x1af28 <bpf_object_load.constprop.0+0x1208>
; 				insn->imm = BPF_FUNC_probe_read;
   1af77: c7 43 04 04 00 00 00         	movl	$4, 4(%rbx)
; 	for (i = 0; i < prog->insns_cnt; i++, insn++) {
   1af7e: 48 83 c5 01                  	addq	$1, %rbp
   1af82: 48 83 c3 08                  	addq	$8, %rbx
   1af86: 49 39 6c 24 40               	cmpq	%rbp, 64(%r12)
   1af8b: 77 aa                        	ja	0x1af37 <bpf_object_load.constprop.0+0x1217>
   1af8d: 0f 1f 00                     	nopl	(%rax)
   1af90: 49 8b 76 60                  	movq	96(%r14), %rsi
; 	for (i = 0; i < obj->nr_programs; i++) {
   1af94: 49 83 c5 01                  	addq	$1, %r13
   1af98: 49 39 f5                     	cmpq	%rsi, %r13
   1af9b: 0f 82 5c ff ff ff            	jb	0x1aefd <bpf_object_load.constprop.0+0x11dd>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1afa1: 48 85 f6                     	testq	%rsi, %rsi
   1afa4: 0f 84 85 01 00 00            	je	0x1b12f <bpf_object_load.constprop.0+0x140f>
; 					   obj->license, obj->kern_version, &prog->fd);
   1afaa: 49 8d 46 10                  	leaq	16(%r14), %rax
; 	for (i = 0; i < obj->nr_programs; i++) {
   1afae: 31 ed                        	xorl	%ebp, %ebp
; 			bpf_gen__record_relo_core(obj->gen_loader, &cr);
   1afb0: 48 8d 9c 24 a0 00 00 00      	leaq	160(%rsp), %rbx
; 					   obj->license, obj->kern_version, &prog->fd);
   1afb8: 48 89 04 24                  	movq	%rax, (%rsp)
   1afbc: 0f 1f 40 00                  	nopl	(%rax)
; 		prog = &obj->programs[i];
   1afc0: 4c 8d 6c 6d 00               	leaq	(%rbp,%rbp,2), %r13
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   1afc5: 49 63 86 04 01 00 00         	movslq	260(%r14), %rax
; 		prog = &obj->programs[i];
   1afcc: 49 c1 e5 06                  	shlq	$6, %r13
   1afd0: 4d 03 6e 58                  	addq	88(%r14), %r13
; 	return prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;
   1afd4: 49 39 45 10                  	cmpq	%rax, 16(%r13)
   1afd8: 75 0a                        	jne	0x1afe4 <bpf_object_load.constprop.0+0x12c4>
   1afda: 48 83 fe 01                  	cmpq	$1, %rsi
   1afde: 0f 85 07 01 00 00            	jne	0x1b0eb <bpf_object_load.constprop.0+0x13cb>
; 		if (!prog->autoload) {
   1afe4: 41 80 7d 7c 00               	cmpb	$0, 124(%r13)
   1afe9: 0f 84 7b 09 00 00            	je	0x1b96a <bpf_object_load.constprop.0+0x1c4a>
; 		if (obj->gen_loader)
   1afef: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1aff7: 0f 84 bb 00 00 00            	je	0x1b0b8 <bpf_object_load.constprop.0+0x1398>
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1affd: 41 8b 4d 50                  	movl	80(%r13), %ecx
; 	struct bpf_object *obj = prog->obj;
   1b001: 4d 8b 7d 70                  	movq	112(%r13), %r15
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b005: 85 c9                        	testl	%ecx, %ecx
   1b007: 0f 8e ab 00 00 00            	jle	0x1b0b8 <bpf_object_load.constprop.0+0x1398>
   1b00d: 45 31 e4                     	xorl	%r12d, %r12d
   1b010: eb 1d                        	jmp	0x1b02f <bpf_object_load.constprop.0+0x130f>
   1b012: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		switch (relo->type) {
   1b018: 83 fa 03                     	cmpl	$3, %edx
   1b01b: 0f 84 97 08 00 00            	je	0x1b8b8 <bpf_object_load.constprop.0+0x1b98>
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b021: 49 83 c4 01                  	addq	$1, %r12
   1b025: 45 39 65 50                  	cmpl	%r12d, 80(%r13)
   1b029: 0f 8e 89 00 00 00            	jle	0x1b0b8 <bpf_object_load.constprop.0+0x1398>
; 		struct reloc_desc *relo = &prog->reloc_desc[i];
   1b02f: 4c 89 e0                     	movq	%r12, %rax
   1b032: 48 c1 e0 04                  	shlq	$4, %rax
   1b036: 49 03 45 48                  	addq	72(%r13), %rax
; 		struct extern_desc *ext = &obj->externs[relo->sym_off];
   1b03a: 48 63 48 0c                  	movslq	12(%rax), %rcx
   1b03e: 48 8d 14 cd 00 00 00 00      	leaq	(,%rcx,8), %rdx
   1b046: 48 29 ca                     	subq	%rcx, %rdx
   1b049: 49 8b 8f 88 00 00 00         	movq	136(%r15), %rcx
   1b050: 48 8d 0c d1                  	leaq	(%rcx,%rdx,8), %rcx
; 		switch (relo->type) {
   1b054: 8b 10                        	movl	(%rax), %edx
   1b056: 83 fa 04                     	cmpl	$4, %edx
   1b059: 0f 84 31 08 00 00            	je	0x1b890 <bpf_object_load.constprop.0+0x1b70>
   1b05f: 83 fa 06                     	cmpl	$6, %edx
   1b062: 75 b4                        	jne	0x1b018 <bpf_object_load.constprop.0+0x12f8>
; 				.insn_off = relo->insn_idx * 8,
   1b064: 8b 48 04                     	movl	4(%rax), %ecx
; 				.type_id = relo->core_relo->type_id,
   1b067: 48 8b 40 08                  	movq	8(%rax), %rax
; 			bpf_gen__record_relo_core(obj->gen_loader, &cr);
   1b06b: 48 89 de                     	movq	%rbx, %rsi
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b06e: 49 83 c4 01                  	addq	$1, %r12
; 			bpf_gen__record_relo_core(obj->gen_loader, &cr);
   1b072: 49 8b bf a0 00 00 00         	movq	160(%r15), %rdi
; 				.insn_off = relo->insn_idx * 8,
   1b079: 8d 14 cd 00 00 00 00         	leal	(,%rcx,8), %edx
; 			struct bpf_core_relo cr = {
   1b080: 89 94 24 a0 00 00 00         	movl	%edx, 160(%rsp)
; 				.type_id = relo->core_relo->type_id,
   1b087: 8b 50 04                     	movl	4(%rax), %edx
; 			struct bpf_core_relo cr = {
   1b08a: 89 94 24 a4 00 00 00         	movl	%edx, 164(%rsp)
; 				.access_str_off = relo->core_relo->access_str_off,
   1b091: 8b 50 08                     	movl	8(%rax), %edx
; 				.kind = relo->core_relo->kind,
   1b094: 8b 40 0c                     	movl	12(%rax), %eax
; 			struct bpf_core_relo cr = {
   1b097: 89 94 24 a8 00 00 00         	movl	%edx, 168(%rsp)
   1b09e: 89 84 24 ac 00 00 00         	movl	%eax, 172(%rsp)
; 			bpf_gen__record_relo_core(obj->gen_loader, &cr);
   1b0a5: e8 76 4c 00 00               	callq	0x1fd20 <bpf_gen__record_relo_core>
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b0aa: 45 39 65 50                  	cmpl	%r12d, 80(%r13)
   1b0ae: 0f 8f 7b ff ff ff            	jg	0x1b02f <bpf_object_load.constprop.0+0x130f>
   1b0b4: 0f 1f 40 00                  	nopl	(%rax)
; 		err = bpf_object_load_prog(obj, prog, prog->insns, prog->insns_cnt,
   1b0b8: 48 83 ec 08                  	subq	$8, %rsp
   1b0bc: 49 8d 45 78                  	leaq	120(%r13), %rax
   1b0c0: 49 8b 4d 40                  	movq	64(%r13), %rcx
   1b0c4: 49 8b 55 38                  	movq	56(%r13), %rdx
   1b0c8: 50                           	pushq	%rax
   1b0c9: 45 8b 4e 50                  	movl	80(%r14), %r9d
   1b0cd: 4c 89 ee                     	movq	%r13, %rsi
   1b0d0: 4c 89 f7                     	movq	%r14, %rdi
   1b0d3: 4c 8b 44 24 10               	movq	16(%rsp), %r8
   1b0d8: e8 a3 1c ff ff               	callq	0xcd80 <bpf_object_load_prog>
; 		if (err) {
   1b0dd: 5e                           	popq	%rsi
   1b0de: 5f                           	popq	%rdi
   1b0df: 85 c0                        	testl	%eax, %eax
   1b0e1: 0f 85 ee 0b 00 00            	jne	0x1bcd5 <bpf_object_load.constprop.0+0x1fb5>
   1b0e7: 49 8b 76 60                  	movq	96(%r14), %rsi
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b0eb: 48 83 c5 01                  	addq	$1, %rbp
   1b0ef: 48 39 ee                     	cmpq	%rbp, %rsi
   1b0f2: 0f 87 c8 fe ff ff            	ja	0x1afc0 <bpf_object_load.constprop.0+0x12a0>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b0f8: 48 85 f6                     	testq	%rsi, %rsi
   1b0fb: 74 32                        	je	0x1b12f <bpf_object_load.constprop.0+0x140f>
   1b0fd: 31 ed                        	xorl	%ebp, %ebp
   1b0ff: 90                           	nop
; 		prog = &obj->programs[i];
   1b100: 48 8d 5c 6d 00               	leaq	(%rbp,%rbp,2), %rbx
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b105: 48 83 c5 01                  	addq	$1, %rbp
; 		prog = &obj->programs[i];
   1b109: 48 c1 e3 06                  	shlq	$6, %rbx
   1b10d: 49 03 5e 58                  	addq	88(%r14), %rbx
; 		zfree(&prog->reloc_desc);
   1b111: 48 8b 7b 48                  	movq	72(%rbx), %rdi
   1b115: e8 a6 a5 fe ff               	callq	0x56c0 <.plt.sec+0x50>
   1b11a: 48 c7 43 48 00 00 00 00      	movq	$0, 72(%rbx)
; 		prog->nr_reloc = 0;
   1b122: c7 43 50 00 00 00 00         	movl	$0, 80(%rbx)
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b129: 49 39 6e 60                  	cmpq	%rbp, 96(%r14)
   1b12d: 77 d1                        	ja	0x1b100 <bpf_object_load.constprop.0+0x13e0>
; 	for (i = 0; i < obj->nr_maps; i++) {
   1b12f: 31 db                        	xorl	%ebx, %ebx
; 		err = bpf_map_update_elem(map->fd, &i, &fd, 0);
   1b131: 48 8d 84 24 98 00 00 00      	leaq	152(%rsp), %rax
; 	for (i = 0; i < obj->nr_maps; i++) {
   1b139: 49 83 7e 70 00               	cmpq	$0, 112(%r14)
; 		err = bpf_map_update_elem(map->fd, &i, &fd, 0);
   1b13e: 4c 8d ac 24 a0 00 00 00      	leaq	160(%rsp), %r13
   1b146: 48 89 c5                     	movq	%rax, %rbp
; 	for (i = 0; i < obj->nr_maps; i++) {
   1b149: 75 13                        	jne	0x1b15e <bpf_object_load.constprop.0+0x143e>
   1b14b: e9 f6 00 00 00               	jmp	0x1b246 <bpf_object_load.constprop.0+0x1526>
   1b150: 48 83 c3 01                  	addq	$1, %rbx
   1b154: 49 39 5e 70                  	cmpq	%rbx, 112(%r14)
   1b158: 0f 86 e8 00 00 00            	jbe	0x1b246 <bpf_object_load.constprop.0+0x1526>
; 		map = &obj->maps[i];
   1b15e: 4c 8d 3c 9b                  	leaq	(%rbx,%rbx,4), %r15
; 	if (obj->gen_loader)
   1b162: 49 8b 86 a0 00 00 00         	movq	160(%r14), %rax
; 		map = &obj->maps[i];
   1b169: 49 c1 e7 05                  	shlq	$5, %r15
   1b16d: 4d 03 7e 68                  	addq	104(%r14), %r15
; 		if (!map->init_slots_sz || map->def.type != BPF_MAP_TYPE_PROG_ARRAY)
   1b171: 45 8b 97 80 00 00 00         	movl	128(%r15), %r10d
   1b178: 45 85 d2                     	testl	%r10d, %r10d
   1b17b: 74 d3                        	je	0x1b150 <bpf_object_load.constprop.0+0x1430>
   1b17d: 41 83 7f 30 03               	cmpl	$3, 48(%r15)
   1b182: 75 cc                        	jne	0x1b150 <bpf_object_load.constprop.0+0x1430>
; 	if (obj->gen_loader)
   1b184: 48 85 c0                     	testq	%rax, %rax
   1b187: 0f 85 e9 0d 00 00            	jne	0x1bf76 <bpf_object_load.constprop.0+0x2256>
; 	for (i = 0; i < map->init_slots_sz; i++) {
   1b18d: c7 84 24 98 00 00 00 00 00 00 00     	movl	$0, 152(%rsp)
; 		if (!map->init_slots[i])
   1b198: 49 8b 7f 78                  	movq	120(%r15), %rdi
   1b19c: 0f 1f 40 00                  	nopl	(%rax)
   1b1a0: 89 c0                        	movl	%eax, %eax
   1b1a2: 4c 8b 24 c7                  	movq	(%rdi,%rax,8), %r12
   1b1a6: 4d 85 e4                     	testq	%r12, %r12
   1b1a9: 74 5b                        	je	0x1b206 <bpf_object_load.constprop.0+0x14e6>
; 	if (prog->fd < 0)
   1b1ab: 41 8b 44 24 78               	movl	120(%r12), %eax
   1b1b0: 85 c0                        	testl	%eax, %eax
   1b1b2: 0f 88 a9 0d 00 00            	js	0x1bf61 <bpf_object_load.constprop.0+0x2241>
; 		fd = bpf_program__fd(targ_prog);
   1b1b8: 89 84 24 a0 00 00 00         	movl	%eax, 160(%rsp)
; 		err = bpf_map_update_elem(map->fd, &i, &fd, 0);
   1b1bf: 41 8b 7f 18                  	movl	24(%r15), %edi
   1b1c3: 31 c9                        	xorl	%ecx, %ecx
   1b1c5: 4c 89 ea                     	movq	%r13, %rdx
   1b1c8: 48 89 ee                     	movq	%rbp, %rsi
   1b1cb: e8 20 b2 00 00               	callq	0x263f0 <bpf_map_update_elem>
; 		if (err) {
   1b1d0: 85 c0                        	testl	%eax, %eax
   1b1d2: 0f 85 1b 07 00 00            	jne	0x1b8f3 <bpf_object_load.constprop.0+0x1bd3>
; 		pr_debug("map '%s': slot [%d] set to prog '%s' fd=%d\n",
   1b1d8: 49 8b 57 08                  	movq	8(%r15), %rdx
   1b1dc: 4d 8b 04 24                  	movq	(%r12), %r8
   1b1e0: bf 02 00 00 00               	movl	$2, %edi
   1b1e5: 31 c0                        	xorl	%eax, %eax
   1b1e7: 44 8b 8c 24 a0 00 00 00      	movl	160(%rsp), %r9d
   1b1ef: 8b 8c 24 98 00 00 00         	movl	152(%rsp), %ecx
   1b1f6: 48 8d 35 c3 d6 01 00         	leaq	120515(%rip), %rsi      # 0x388c0 <strs.2+0x5a30>
   1b1fd: e8 ce ce fe ff               	callq	0x80d0 <libbpf_print>
; 	zfree(&map->init_slots);
   1b202: 49 8b 7f 78                  	movq	120(%r15), %rdi
; 	for (i = 0; i < map->init_slots_sz; i++) {
   1b206: 8b 84 24 98 00 00 00         	movl	152(%rsp), %eax
   1b20d: 83 c0 01                     	addl	$1, %eax
   1b210: 89 84 24 98 00 00 00         	movl	%eax, 152(%rsp)
   1b217: 41 3b 87 80 00 00 00         	cmpl	128(%r15), %eax
   1b21e: 72 80                        	jb	0x1b1a0 <bpf_object_load.constprop.0+0x1480>
; 	zfree(&map->init_slots);
   1b220: e8 9b a4 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	for (i = 0; i < obj->nr_maps; i++) {
   1b225: 48 83 c3 01                  	addq	$1, %rbx
; 	zfree(&map->init_slots);
   1b229: 49 c7 47 78 00 00 00 00      	movq	$0, 120(%r15)
; 	map->init_slots_sz = 0;
   1b231: 41 c7 87 80 00 00 00 00 00 00 00     	movl	$0, 128(%r15)
; 	for (i = 0; i < obj->nr_maps; i++) {
   1b23c: 49 39 5e 70                  	cmpq	%rbx, 112(%r14)
   1b240: 0f 87 18 ff ff ff            	ja	0x1b15e <bpf_object_load.constprop.0+0x143e>
; 	return 0;
   1b246: 45 31 e4                     	xorl	%r12d, %r12d
   1b249: e9 62 f5 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1b24e: 66 90                        	nop
; 			if (obj->gen_loader) {
   1b250: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
; 			map = &obj->maps[relo->map_idx];
   1b258: 49 8b 56 68                  	movq	104(%r14), %rdx
   1b25c: 44 8b 48 08                  	movl	8(%rax), %r9d
; 			if (obj->gen_loader) {
   1b260: 0f 84 52 02 00 00            	je	0x1b4b8 <bpf_object_load.constprop.0+0x1798>
; 				insn[0].src_reg = BPF_PSEUDO_MAP_IDX;
   1b266: 41 0f b6 44 24 01            	movzbl	1(%r12), %eax
; 				insn[0].imm = relo->map_idx;
   1b26c: 45 89 4c 24 04               	movl	%r9d, 4(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b271: 48 83 c5 01                  	addq	$1, %rbp
; 				insn[0].src_reg = BPF_PSEUDO_MAP_IDX;
   1b275: 83 e0 0f                     	andl	$15, %eax
   1b278: 83 c8 50                     	orl	$80, %eax
   1b27b: 41 88 44 24 01               	movb	%al, 1(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b280: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b283: 0f 8f e7 fb ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b289: e9 34 fc ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b28e: 66 90                        	nop
; 			ext = &obj->externs[relo->sym_off];
   1b290: 48 63 50 0c                  	movslq	12(%rax), %rdx
   1b294: 48 8d 04 d5 00 00 00 00      	leaq	(,%rdx,8), %rax
   1b29c: 48 29 d0                     	subq	%rdx, %rax
   1b29f: 49 8b 96 88 00 00 00         	movq	136(%r14), %rdx
   1b2a6: 48 8d 14 c2                  	leaq	(%rdx,%rax,8), %rdx
; 			insn[0].src_reg = BPF_PSEUDO_KFUNC_CALL;
   1b2aa: 41 0f b6 44 24 01            	movzbl	1(%r12), %eax
   1b2b0: 83 e0 0f                     	andl	$15, %eax
   1b2b3: 83 c8 20                     	orl	$32, %eax
; 			if (ext->is_set) {
   1b2b6: 80 7a 18 00                  	cmpb	$0, 24(%rdx)
; 			insn[0].src_reg = BPF_PSEUDO_KFUNC_CALL;
   1b2ba: 41 88 44 24 01               	movb	%al, 1(%r12)
; 			if (ext->is_set) {
   1b2bf: 0f 84 84 01 00 00            	je	0x1b449 <bpf_object_load.constprop.0+0x1729>
; 				insn[0].imm = ext->ksym.kernel_btf_id;
   1b2c5: 8b 42 2c                     	movl	44(%rdx), %eax
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b2c8: 48 83 c5 01                  	addq	$1, %rbp
; 				insn[0].imm = ext->ksym.kernel_btf_id;
   1b2cc: 41 89 44 24 04               	movl	%eax, 4(%r12)
; 				insn[0].off = ext->ksym.btf_fd_idx;
   1b2d1: 0f b7 42 34                  	movzwl	52(%rdx), %eax
   1b2d5: 66 41 89 44 24 02            	movw	%ax, 2(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b2db: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b2de: 0f 8f 8c fb ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b2e4: e9 d9 fb ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b2e9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			ext = &obj->externs[relo->sym_off];
   1b2f0: 48 63 50 0c                  	movslq	12(%rax), %rdx
   1b2f4: 48 8d 04 d5 00 00 00 00      	leaq	(,%rdx,8), %rax
   1b2fc: 48 29 d0                     	subq	%rdx, %rax
   1b2ff: 49 8b 96 88 00 00 00         	movq	136(%r14), %rdx
   1b306: 48 8d 04 c2                  	leaq	(%rdx,%rax,8), %rax
; 			if (ext->type == EXT_KCFG) {
   1b30a: 83 38 01                     	cmpl	$1, (%rax)
   1b30d: 0f 84 5d 01 00 00            	je	0x1b470 <bpf_object_load.constprop.0+0x1750>
; 				if (ext->ksym.type_id && ext->is_set) { /* typed ksyms */
   1b313: 44 8b 48 30                  	movl	48(%rax), %r9d
   1b317: 45 85 c9                     	testl	%r9d, %r9d
   1b31a: 0f 84 90 00 00 00            	je	0x1b3b0 <bpf_object_load.constprop.0+0x1690>
   1b320: 80 78 18 00                  	cmpb	$0, 24(%rax)
   1b324: 0f 84 86 00 00 00            	je	0x1b3b0 <bpf_object_load.constprop.0+0x1690>
; 					insn[0].src_reg = BPF_PSEUDO_BTF_ID;
   1b32a: 41 0f b6 54 24 01            	movzbl	1(%r12), %edx
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b330: 48 83 c5 01                  	addq	$1, %rbp
; 					insn[0].src_reg = BPF_PSEUDO_BTF_ID;
   1b334: 83 e2 0f                     	andl	$15, %edx
   1b337: 83 ca 30                     	orl	$48, %edx
   1b33a: 41 88 54 24 01               	movb	%dl, 1(%r12)
; 					insn[0].imm = ext->ksym.kernel_btf_id;
   1b33f: 8b 50 2c                     	movl	44(%rax), %edx
; 					insn[1].imm = ext->ksym.kernel_btf_obj_fd;
   1b342: 8b 40 28                     	movl	40(%rax), %eax
; 					insn[0].imm = ext->ksym.kernel_btf_id;
   1b345: 41 89 54 24 04               	movl	%edx, 4(%r12)
; 					insn[1].imm = ext->ksym.kernel_btf_obj_fd;
   1b34a: 41 89 44 24 0c               	movl	%eax, 12(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b34f: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b352: 0f 8f 18 fb ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b358: e9 65 fb ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b35d: 0f 1f 00                     	nopl	(%rax)
; 			map = &obj->maps[relo->map_idx];
   1b360: 44 8b 48 08                  	movl	8(%rax), %r9d
; 			insn[1].imm = insn[0].imm + relo->sym_off;
   1b364: 8b 40 0c                     	movl	12(%rax), %eax
   1b367: 41 03 44 24 04               	addl	4(%r12), %eax
; 			if (obj->gen_loader) {
   1b36c: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
; 			map = &obj->maps[relo->map_idx];
   1b374: 49 8b 56 68                  	movq	104(%r14), %rdx
; 			insn[1].imm = insn[0].imm + relo->sym_off;
   1b378: 41 89 44 24 0c               	movl	%eax, 12(%r12)
; 			if (obj->gen_loader) {
   1b37d: 0f 84 7d 01 00 00            	je	0x1b500 <bpf_object_load.constprop.0+0x17e0>
; 				insn[0].src_reg = BPF_PSEUDO_MAP_IDX_VALUE;
   1b383: 41 0f b6 44 24 01            	movzbl	1(%r12), %eax
; 				insn[0].imm = relo->map_idx;
   1b389: 45 89 4c 24 04               	movl	%r9d, 4(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b38e: 48 83 c5 01                  	addq	$1, %rbp
; 				insn[0].src_reg = BPF_PSEUDO_MAP_IDX_VALUE;
   1b392: 83 e0 0f                     	andl	$15, %eax
   1b395: 83 c8 60                     	orl	$96, %eax
   1b398: 41 88 44 24 01               	movb	%al, 1(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b39d: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b3a0: 0f 8f ca fa ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b3a6: e9 17 fb ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b3ab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 					insn[0].imm = (__u32)ext->ksym.addr;
   1b3b0: 48 8b 40 20                  	movq	32(%rax), %rax
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b3b4: 48 83 c5 01                  	addq	$1, %rbp
; 					insn[0].imm = (__u32)ext->ksym.addr;
   1b3b8: 41 89 44 24 04               	movl	%eax, 4(%r12)
; 					insn[1].imm = ext->ksym.addr >> 32;
   1b3bd: 48 c1 e8 20                  	shrq	$32, %rax
   1b3c1: 41 89 44 24 0c               	movl	%eax, 12(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b3c6: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b3c9: 0f 8f a1 fa ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b3cf: e9 ee fa ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b3d4: 0f 1f 40 00                  	nopl	(%rax)
; 		switch (func_id) {
   1b3d8: 83 e8 72                     	subl	$114, %eax
   1b3db: 83 f8 01                     	cmpl	$1, %eax
   1b3de: 0f 87 44 fb ff ff            	ja	0x1af28 <bpf_object_load.constprop.0+0x1208>
; 	if (obj && obj->gen_loader)
   1b3e4: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1b3ec: 0f 85 36 fb ff ff            	jne	0x1af28 <bpf_object_load.constprop.0+0x1208>
   1b3f2: bf 08 00 00 00               	movl	$8, %edi
   1b3f7: e8 54 f0 fe ff               	callq	0xa450 <kernel_supports.part.0>
; 			if (!kernel_supports(obj, FEAT_PROBE_READ_KERN))
   1b3fc: 84 c0                        	testb	%al, %al
   1b3fe: 0f 85 24 fb ff ff            	jne	0x1af28 <bpf_object_load.constprop.0+0x1208>
; 				insn->imm = BPF_FUNC_probe_read_str;
   1b404: c7 43 04 2d 00 00 00         	movl	$45, 4(%rbx)
   1b40b: e9 18 fb ff ff               	jmp	0x1af28 <bpf_object_load.constprop.0+0x1208>
; 			pr_warn("prog '%s': relo #%d: bad relo type %d\n",
   1b410: 41 89 d0                     	movl	%edx, %r8d
   1b413: 48 8b 13                     	movq	(%rbx), %rdx
   1b416: 48 8d 35 93 d3 01 00         	leaq	119699(%rip), %rsi      # 0x387b0 <strs.2+0x5920>
   1b41d: 31 ff                        	xorl	%edi, %edi
   1b41f: 31 c0                        	xorl	%eax, %eax
   1b421: e8 aa cc fe ff               	callq	0x80d0 <libbpf_print>
; 			pr_warn("prog '%s': failed to relocate data references: %d\n",
   1b426: 48 8b 13                     	movq	(%rbx), %rdx
   1b429: b9 ea ff ff ff               	movl	$4294967274, %ecx       # imm = 0xFFFFFFEA
   1b42e: 31 ff                        	xorl	%edi, %edi
   1b430: 31 c0                        	xorl	%eax, %eax
   1b432: 48 8d 35 a7 d3 01 00         	leaq	119719(%rip), %rsi      # 0x387e0 <strs.2+0x5950>
   1b439: e8 92 cc fe ff               	callq	0x80d0 <libbpf_print>
; 			return err;
   1b43e: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
   1b444: e9 67 f3 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 				insn[0].imm = 0;
   1b449: 41 c7 44 24 04 00 00 00 00   	movl	$0, 4(%r12)
; 				insn[0].off = 0;
   1b452: 45 31 c0                     	xorl	%r8d, %r8d
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b455: 48 83 c5 01                  	addq	$1, %rbp
; 				insn[0].off = 0;
   1b459: 66 45 89 44 24 02            	movw	%r8w, 2(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b45f: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b462: 0f 8f 08 fa ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b468: e9 55 fa ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b46d: 0f 1f 00                     	nopl	(%rax)
; 				if (obj->gen_loader) {
   1b470: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
; 					insn[0].imm = obj->kconfig_map_idx;
   1b478: 49 63 8e 94 00 00 00         	movslq	148(%r14), %rcx
; 					insn[0].src_reg = BPF_PSEUDO_MAP_IDX_VALUE;
   1b47f: 41 0f b6 54 24 01            	movzbl	1(%r12), %edx
; 				if (obj->gen_loader) {
   1b485: 0f 84 d6 05 00 00            	je	0x1ba61 <bpf_object_load.constprop.0+0x1d41>
; 					insn[0].src_reg = BPF_PSEUDO_MAP_IDX_VALUE;
   1b48b: 83 e2 0f                     	andl	$15, %edx
   1b48e: 83 ca 60                     	orl	$96, %edx
   1b491: 41 88 54 24 01               	movb	%dl, 1(%r12)
; 				insn[1].imm = ext->kcfg.data_off;
   1b496: 8b 40 2c                     	movl	44(%rax), %eax
; 					insn[0].imm = obj->kconfig_map_idx;
   1b499: 41 89 4c 24 04               	movl	%ecx, 4(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b49e: 48 83 c5 01                  	addq	$1, %rbp
; 				insn[1].imm = ext->kcfg.data_off;
   1b4a2: 41 89 44 24 0c               	movl	%eax, 12(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b4a7: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b4aa: 0f 8f c0 f9 ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b4b0: e9 0d fa ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b4b5: 0f 1f 00                     	nopl	(%rax)
; 			map = &obj->maps[relo->map_idx];
   1b4b8: 49 63 c1                     	movslq	%r9d, %rax
   1b4bb: 48 8d 04 80                  	leaq	(%rax,%rax,4), %rax
   1b4bf: 48 c1 e0 05                  	shlq	$5, %rax
   1b4c3: 48 01 c2                     	addq	%rax, %rdx
; 			} else if (map->autocreate) {
   1b4c6: 80 ba 92 00 00 00 00         	cmpb	$0, 146(%rdx)
   1b4cd: 0f 84 a9 01 00 00            	je	0x1b67c <bpf_object_load.constprop.0+0x195c>
; 				insn[0].src_reg = BPF_PSEUDO_MAP_FD;
   1b4d3: 41 0f b6 44 24 01            	movzbl	1(%r12), %eax
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b4d9: 48 83 c5 01                  	addq	$1, %rbp
; 				insn[0].src_reg = BPF_PSEUDO_MAP_FD;
   1b4dd: 83 e0 0f                     	andl	$15, %eax
   1b4e0: 83 c8 10                     	orl	$16, %eax
   1b4e3: 41 88 44 24 01               	movb	%al, 1(%r12)
; 				insn[0].imm = map->fd;
   1b4e8: 8b 42 18                     	movl	24(%rdx), %eax
   1b4eb: 41 89 44 24 04               	movl	%eax, 4(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b4f0: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b4f3: 0f 8f 77 f9 ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b4f9: e9 c4 f9 ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b4fe: 66 90                        	nop
; 			map = &obj->maps[relo->map_idx];
   1b500: 49 63 c1                     	movslq	%r9d, %rax
   1b503: 48 8d 04 80                  	leaq	(%rax,%rax,4), %rax
   1b507: 48 c1 e0 05                  	shlq	$5, %rax
   1b50b: 48 01 c2                     	addq	%rax, %rdx
; 			} else if (map->autocreate) {
   1b50e: 80 ba 92 00 00 00 00         	cmpb	$0, 146(%rdx)
   1b515: 0f 84 61 01 00 00            	je	0x1b67c <bpf_object_load.constprop.0+0x195c>
; 				insn[0].src_reg = BPF_PSEUDO_MAP_VALUE;
   1b51b: 41 0f b6 44 24 01            	movzbl	1(%r12), %eax
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b521: 48 83 c5 01                  	addq	$1, %rbp
; 				insn[0].src_reg = BPF_PSEUDO_MAP_VALUE;
   1b525: 83 e0 0f                     	andl	$15, %eax
   1b528: 83 c8 20                     	orl	$32, %eax
   1b52b: 41 88 44 24 01               	movb	%al, 1(%r12)
; 				insn[0].imm = map->fd;
   1b530: 8b 42 18                     	movl	24(%rdx), %eax
   1b533: 41 89 44 24 04               	movl	%eax, 4(%r12)
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b538: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b53b: 0f 8f 2f f9 ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b541: e9 7c f9 ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b546: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	struct bpf_insn insns[] = {
   1b550: 48 c7 84 24 d0 00 00 00 b7 00 00 00  	movq	$183, 208(%rsp)
   1b55c: 48 c7 84 24 d8 00 00 00 95 00 00 00  	movq	$149, 216(%rsp)
; 	ret = bump_rlimit_memlock();
   1b568: e8 a3 a2 00 00               	callq	0x25810 <bump_rlimit_memlock>
; 	if (ret)
   1b56d: 85 c0                        	testl	%eax, %eax
   1b56f: 0f 85 a0 01 00 00            	jne	0x1b715 <bpf_object_load.constprop.0+0x19f5>
; 	ret = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, "GPL", insns, insn_cnt, NULL);
   1b575: bf 01 00 00 00               	movl	$1, %edi
   1b57a: 45 31 c9                     	xorl	%r9d, %r9d
   1b57d: 41 b8 02 00 00 00            	movl	$2, %r8d
   1b583: 31 f6                        	xorl	%esi, %esi
   1b585: 4c 8d ac 24 d0 00 00 00      	leaq	208(%rsp), %r13
   1b58d: 4c 8d 25 a6 66 01 00         	leaq	91814(%rip), %r12       # 0x31c3a <_IO_stdin_used+0x1c3a>
   1b594: 4c 89 e9                     	movq	%r13, %rcx
   1b597: 4c 89 e2                     	movq	%r12, %rdx
   1b59a: e8 b1 a6 00 00               	callq	0x25c50 <bpf_prog_load>
   1b59f: 89 c7                        	movl	%eax, %edi
; 	if (ret < 0)
   1b5a1: 85 c0                        	testl	%eax, %eax
   1b5a3: 0f 88 fd 04 00 00            	js	0x1baa6 <bpf_object_load.constprop.0+0x1d86>
; 	close(ret);
   1b5a9: e8 52 a3 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (obj->btf_vmlinux || obj->gen_loader)
   1b5ae: 49 83 be 20 01 00 00 00      	cmpq	$0, 288(%r14)
   1b5b6: 0f 85 eb e7 ff ff            	jne	0x19da7 <bpf_object_load.constprop.0+0x87>
   1b5bc: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1b5c4: 0f 85 dd e7 ff ff            	jne	0x19da7 <bpf_object_load.constprop.0+0x87>
; 	if (!force && !obj_needs_vmlinux_btf(obj))
   1b5ca: 4c 89 f7                     	movq	%r14, %rdi
   1b5cd: e8 6e 37 ff ff               	callq	0xed40 <obj_needs_vmlinux_btf>
   1b5d2: 84 c0                        	testb	%al, %al
   1b5d4: 0f 84 cd e7 ff ff            	je	0x19da7 <bpf_object_load.constprop.0+0x87>
; 	obj->btf_vmlinux = btf__load_vmlinux_btf();
   1b5da: e8 91 26 01 00               	callq	0x2dc70 <libbpf_find_kernel_btf>
   1b5df: 49 89 86 20 01 00 00         	movq	%rax, 288(%r14)
   1b5e6: 48 89 c3                     	movq	%rax, %rbx
; 	if (!IS_ERR_OR_NULL(ptr))
   1b5e9: 48 85 c0                     	testq	%rax, %rax
   1b5ec: 74 0c                        	je	0x1b5fa <bpf_object_load.constprop.0+0x18da>
   1b5ee: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   1b5f4: 0f 86 ad e7 ff ff            	jbe	0x19da7 <bpf_object_load.constprop.0+0x87>
; 		errno = -ret;
   1b5fa: e8 f1 a0 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
   1b5ff: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   1b606: 0f 87 03 0c 00 00            	ja	0x1c20f <bpf_object_load.constprop.0+0x24ef>
; 	return -errno;
   1b60c: 8b 18                        	movl	(%rax), %ebx
; 	if (err) {
   1b60e: 85 db                        	testl	%ebx, %ebx
   1b610: 0f 84 91 e7 ff ff            	je	0x19da7 <bpf_object_load.constprop.0+0x87>
; 	return -errno;
   1b616: f7 db                        	negl	%ebx
; 		pr_warn("Error loading vmlinux BTF: %d\n", err);
   1b618: 48 8d 35 61 c2 01 00         	leaq	115297(%rip), %rsi      # 0x37880 <strs.2+0x49f0>
   1b61f: 31 ff                        	xorl	%edi, %edi
   1b621: 31 c0                        	xorl	%eax, %eax
   1b623: 89 da                        	movl	%ebx, %edx
; 	return -errno;
   1b625: 41 89 dc                     	movl	%ebx, %r12d
; 		pr_warn("Error loading vmlinux BTF: %d\n", err);
   1b628: e8 a3 ca fe ff               	callq	0x80d0 <libbpf_print>
; 		obj->btf_vmlinux = NULL;
   1b62d: 49 c7 86 20 01 00 00 00 00 00 00     	movq	$0, 288(%r14)
; 		return err;
   1b638: e9 73 f1 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1b63d: 0f 1f 00                     	nopl	(%rax)
   1b640: 4c 8b 74 24 18               	movq	24(%rsp), %r14
; 		pr_warn("struct_ops init_kern: struct %s%s is not found in kernel BTF\n",
   1b645: 4c 89 f9                     	movq	%r15, %rcx
   1b648: 48 8d 15 24 6d 01 00         	leaq	93476(%rip), %rdx       # 0x32373 <_IO_stdin_used+0x2373>
   1b64f: 31 ff                        	xorl	%edi, %edi
   1b651: 31 c0                        	xorl	%eax, %eax
   1b653: 48 8d 35 4e cc 01 00         	leaq	117838(%rip), %rsi      # 0x382a8 <strs.2+0x5418>
   1b65a: e8 71 ca fe ff               	callq	0x80d0 <libbpf_print>
; 		return kern_vtype_id;
   1b65f: e9 4c f1 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 			err = bpf_gen__finish(obj->gen_loader, obj->nr_programs, obj->nr_maps);
   1b664: 49 8b be a0 00 00 00         	movq	160(%r14), %rdi
   1b66b: 41 8b 76 60                  	movl	96(%r14), %esi
   1b66f: e8 2c 3f 00 00               	callq	0x1f5a0 <bpf_gen__finish>
   1b674: 41 89 c4                     	movl	%eax, %r12d
   1b677: e9 8e f1 ff ff               	jmp	0x1a80a <bpf_object_load.constprop.0+0xaea>
; 	pr_debug("prog '%s': relo #%d: poisoning insn #%d that loads map #%d '%s'\n",
   1b67c: 48 83 ec 08                  	subq	$8, %rsp
   1b680: ff 72 08                     	pushq	8(%rdx)
   1b683: 48 8b 13                     	movq	(%rbx), %rdx
   1b686: 4c 89 fe                     	movq	%r15, %rsi
   1b689: bf 02 00 00 00               	movl	$2, %edi
   1b68e: 31 c0                        	xorl	%eax, %eax
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b690: 48 83 c5 01                  	addq	$1, %rbp
; 	pr_debug("prog '%s': relo #%d: poisoning insn #%d that loads map #%d '%s'\n",
   1b694: 44 89 4c 24 10               	movl	%r9d, 16(%rsp)
   1b699: e8 32 ca fe ff               	callq	0x80d0 <libbpf_print>
; 		insn->imm = MAP_LDIMM64_POISON_BASE + map_idx;
   1b69e: 44 8b 4c 24 10               	movl	16(%rsp), %r9d
; 		insn->code = BPF_JMP | BPF_CALL;
   1b6a3: 41 c7 04 24 85 00 00 00      	movl	$133, (%r12)
   1b6ab: 41 c7 44 24 08 85 00 00 00   	movl	$133, 8(%r12)
; 		insn->imm = MAP_LDIMM64_POISON_BASE + map_idx;
   1b6b4: 41 81 c1 40 d6 44 77         	addl	$2001000000, %r9d       # imm = 0x7744D640
   1b6bb: 45 89 4c 24 04               	movl	%r9d, 4(%r12)
   1b6c0: 45 89 4c 24 0c               	movl	%r9d, 12(%r12)
; 	for (i = 0; i < 2; i++) {
   1b6c5: 41 5a                        	popq	%r10
   1b6c7: 4c 8d 15 e2 76 01 00         	leaq	95970(%rip), %r10       # 0x32db0 <_IO_stdin_used+0x2db0>
; 	for (i = 0; i < prog->nr_reloc; i++) {
   1b6ce: 41 5b                        	popq	%r11
   1b6d0: 39 6b 50                     	cmpl	%ebp, 80(%rbx)
   1b6d3: 0f 8f 97 f7 ff ff            	jg	0x1ae70 <bpf_object_load.constprop.0+0x1150>
   1b6d9: e9 e4 f7 ff ff               	jmp	0x1aec2 <bpf_object_load.constprop.0+0x11a2>
   1b6de: 66 90                        	nop
; 		if (kernel_needs_btf(obj)) {
   1b6e0: 45 8b 8e 0c 01 00 00         	movl	268(%r14), %r9d
; 			err = -EOPNOTSUPP;
   1b6e7: 41 bc a1 ff ff ff            	movl	$4294967201, %r12d      # imm = 0xFFFFFFA1
; 		if (kernel_needs_btf(obj)) {
   1b6ed: 45 85 c9                     	testl	%r9d, %r9d
   1b6f0: 0f 88 1a 08 00 00            	js	0x1bf10 <bpf_object_load.constprop.0+0x21f0>
; 		pr_warn("Error loading .BTF into kernel: %d. %s\n", err,
   1b6f6: 48 8d 0d 9b d2 01 00         	leaq	119451(%rip), %rcx      # 0x38998 <strs.2+0x5b08>
   1b6fd: 44 89 e2                     	movl	%r12d, %edx
   1b700: 31 ff                        	xorl	%edi, %edi
   1b702: 31 c0                        	xorl	%eax, %eax
   1b704: 48 8d 35 b5 d2 01 00         	leaq	119477(%rip), %rsi      # 0x389c0 <strs.2+0x5b30>
   1b70b: e8 c0 c9 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (!btf_mandatory)
   1b710: e9 9b f0 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 		pr_warn("Failed to bump RLIMIT_MEMLOCK (err = %d), you might need to do it explicitly!\n", ret);
   1b715: 89 c2                        	movl	%eax, %edx
   1b717: 48 8d 35 8a c6 01 00         	leaq	116362(%rip), %rsi      # 0x37da8 <strs.2+0x4f18>
   1b71e: 31 ff                        	xorl	%edi, %edi
   1b720: 31 c0                        	xorl	%eax, %eax
   1b722: e8 a9 c9 fe ff               	callq	0x80d0 <libbpf_print>
   1b727: e9 49 fe ff ff               	jmp	0x1b575 <bpf_object_load.constprop.0+0x1855>
; 			err = -EINVAL;
   1b72c: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 	btf__free(obj->btf_vmlinux_override);
   1b732: 49 8b be 30 01 00 00         	movq	304(%r14), %rdi
   1b739: e8 b2 f0 00 00               	callq	0x2a7f0 <btf__free>
; 	if (!IS_ERR_OR_NULL(cand_cache)) {
   1b73e: 48 83 7c 24 20 00            	cmpq	$0, 32(%rsp)
; 	obj->btf_vmlinux_override = NULL;
   1b744: 49 c7 86 30 01 00 00 00 00 00 00     	movq	$0, 304(%r14)
; 	if (!IS_ERR_OR_NULL(cand_cache)) {
   1b74f: 0f 84 a4 05 00 00            	je	0x1bcf9 <bpf_object_load.constprop.0+0x1fd9>
; 		hashmap__for_each_entry(cand_cache, entry, i) {
   1b755: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1b75a: 48 83 78 20 00               	cmpq	$0, 32(%rax)
   1b75f: 74 4c                        	je	0x1b7ad <bpf_object_load.constprop.0+0x1a8d>
   1b761: 4c 8b 7c 24 20               	movq	32(%rsp), %r15
   1b766: 45 31 ed                     	xorl	%r13d, %r13d
   1b769: 49 8b 47 18                  	movq	24(%r15), %rax
   1b76d: 4a 8b 1c e8                  	movq	(%rax,%r13,8), %rbx
   1b771: 48 85 db                     	testq	%rbx, %rbx
   1b774: 74 2d                        	je	0x1b7a3 <bpf_object_load.constprop.0+0x1a83>
   1b776: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 			bpf_core_free_cands(entry->value);
   1b780: 48 8b 6b 08                  	movq	8(%rbx), %rbp
; 	if (!cands)
   1b784: 48 85 ed                     	testq	%rbp, %rbp
   1b787: 74 11                        	je	0x1b79a <bpf_object_load.constprop.0+0x1a7a>
; 	free(cands->cands);
   1b789: 48 8b 7d 00                  	movq	(%rbp), %rdi
   1b78d: e8 2e 9f fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(cands);
   1b792: 48 89 ef                     	movq	%rbp, %rdi
   1b795: e8 26 9f fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		hashmap__for_each_entry(cand_cache, entry, i) {
   1b79a: 48 8b 5b 10                  	movq	16(%rbx), %rbx
   1b79e: 48 85 db                     	testq	%rbx, %rbx
   1b7a1: 75 dd                        	jne	0x1b780 <bpf_object_load.constprop.0+0x1a60>
   1b7a3: 49 83 c5 01                  	addq	$1, %r13
   1b7a7: 4d 39 6f 20                  	cmpq	%r13, 32(%r15)
   1b7ab: 77 bc                        	ja	0x1b769 <bpf_object_load.constprop.0+0x1a49>
; 		hashmap__free(cand_cache);
   1b7ad: 48 8b 7c 24 20               	movq	32(%rsp), %rdi
   1b7b2: e8 f9 2c 00 00               	callq	0x1e4b0 <hashmap__free>
   1b7b7: eb 77                        	jmp	0x1b830 <bpf_object_load.constprop.0+0x1b10>
; 		errno = -ret;
   1b7b9: e8 32 9f fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	if (IS_ERR(ptr))
   1b7be: 48 81 fb 00 f0 ff ff         	cmpq	$-4096, %rbx            # imm = 0xF000
   1b7c5: 0f 87 4f 05 00 00            	ja	0x1bd1a <bpf_object_load.constprop.0+0x1ffa>
; 	return -errno;
   1b7cb: 8b 18                        	movl	(%rax), %ebx
; 		if (err) {
   1b7cd: 85 db                        	testl	%ebx, %ebx
   1b7cf: 0f 84 0c f2 ff ff            	je	0x1a9e1 <bpf_object_load.constprop.0+0xcc1>
; 	return -errno;
   1b7d5: f7 db                        	negl	%ebx
; 			pr_warn("failed to parse target BTF: %d\n", err);
   1b7d7: 48 8d 35 a2 cd 01 00         	leaq	118178(%rip), %rsi      # 0x38580 <strs.2+0x56f0>
   1b7de: 31 ff                        	xorl	%edi, %edi
   1b7e0: 31 c0                        	xorl	%eax, %eax
   1b7e2: 89 da                        	movl	%ebx, %edx
; 	return -errno;
   1b7e4: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to parse target BTF: %d\n", err);
   1b7e7: e8 e4 c8 fe ff               	callq	0x80d0 <libbpf_print>
; 			return err;
   1b7ec: e9 08 05 00 00               	jmp	0x1bcf9 <bpf_object_load.constprop.0+0x1fd9>
; 				pr_debug("sec '%s': skipping CO-RE relocation #%d for insn #%d belonging to eliminated weak subprogram\n",
   1b7f1: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   1b7f6: 45 89 d8                     	movl	%r11d, %r8d
   1b7f9: 44 89 f9                     	movl	%r15d, %ecx
   1b7fc: bf 02 00 00 00               	movl	$2, %edi
   1b801: 48 8d 35 a0 cd 01 00         	leaq	118176(%rip), %rsi      # 0x385a8 <strs.2+0x5718>
   1b808: 31 c0                        	xorl	%eax, %eax
   1b80a: e8 c1 c8 fe ff               	callq	0x80d0 <libbpf_print>
; 				continue;
   1b80f: e9 9c f2 ff ff               	jmp	0x1aab0 <bpf_object_load.constprop.0+0xd90>
; 	btf__free(obj->btf_vmlinux_override);
   1b814: 49 8b be 30 01 00 00         	movq	304(%r14), %rdi
; 		err = PTR_ERR(cand_cache);
   1b81b: 44 8b 64 24 20               	movl	32(%rsp), %r12d
; 	btf__free(obj->btf_vmlinux_override);
   1b820: e8 cb ef 00 00               	callq	0x2a7f0 <btf__free>
; 	obj->btf_vmlinux_override = NULL;
   1b825: 49 c7 86 30 01 00 00 00 00 00 00     	movq	$0, 304(%r14)
; 		if (err) {
   1b830: 45 85 e4                     	testl	%r12d, %r12d
   1b833: 0f 85 c0 04 00 00            	jne	0x1bcf9 <bpf_object_load.constprop.0+0x1fd9>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b839: 31 ed                        	xorl	%ebp, %ebp
   1b83b: 49 83 7e 60 00               	cmpq	$0, 96(%r14)
; 		qsort(p->reloc_desc, p->nr_reloc, sizeof(*p->reloc_desc), cmp_relocs);
   1b840: 48 8d 1d f9 b9 fe ff         	leaq	-83463(%rip), %rbx      # 0x7240 <cmp_relocs>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b847: 0f 84 e2 f8 ff ff            	je	0x1b12f <bpf_object_load.constprop.0+0x140f>
   1b84d: 0f 1f 00                     	nopl	(%rax)
; 		struct bpf_program *p = &obj->programs[i];
   1b850: 48 8d 44 6d 00               	leaq	(%rbp,%rbp,2), %rax
   1b855: 48 c1 e0 06                  	shlq	$6, %rax
   1b859: 49 03 46 58                  	addq	88(%r14), %rax
; 		if (!p->nr_reloc)
   1b85d: 8b 50 50                     	movl	80(%rax), %edx
   1b860: 85 d2                        	testl	%edx, %edx
   1b862: 74 14                        	je	0x1b878 <bpf_object_load.constprop.0+0x1b58>
; 		qsort(p->reloc_desc, p->nr_reloc, sizeof(*p->reloc_desc), cmp_relocs);
   1b864: 48 8b 78 48                  	movq	72(%rax), %rdi
   1b868: 48 63 f2                     	movslq	%edx, %rsi
   1b86b: 48 89 d9                     	movq	%rbx, %rcx
   1b86e: ba 10 00 00 00               	movl	$16, %edx
   1b873: e8 e8 9e fe ff               	callq	0x5760 <.plt.sec+0xf0>
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b878: 49 8b 76 60                  	movq	96(%r14), %rsi
   1b87c: 48 83 c5 01                  	addq	$1, %rbp
   1b880: 48 39 ee                     	cmpq	%rbp, %rsi
   1b883: 77 cb                        	ja	0x1b850 <bpf_object_load.constprop.0+0x1b30>
   1b885: e9 8a f3 ff ff               	jmp	0x1ac14 <bpf_object_load.constprop.0+0xef4>
   1b88a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			bpf_gen__record_extern(obj->gen_loader, ext->name,
   1b890: 0f b6 51 19                  	movzbl	25(%rcx), %edx
   1b894: 48 8b 71 10                  	movq	16(%rcx), %rsi
   1b898: 41 b8 0c 00 00 00            	movl	$12, %r8d
   1b89e: 31 c9                        	xorl	%ecx, %ecx
   1b8a0: 49 8b bf a0 00 00 00         	movq	160(%r15), %rdi
   1b8a7: 44 8b 48 04                  	movl	4(%rax), %r9d
   1b8ab: e8 d0 43 00 00               	callq	0x1fc80 <bpf_gen__record_extern>
; 			break;
   1b8b0: e9 6c f7 ff ff               	jmp	0x1b021 <bpf_object_load.constprop.0+0x1301>
   1b8b5: 0f 1f 00                     	nopl	(%rax)
; 			if (ext->type != EXT_KSYM)
   1b8b8: 83 39 02                     	cmpl	$2, (%rcx)
   1b8bb: 0f 85 60 f7 ff ff            	jne	0x1b021 <bpf_object_load.constprop.0+0x1301>
; 			bpf_gen__record_extern(obj->gen_loader, ext->name,
   1b8c1: 8b 51 30                     	movl	48(%rcx), %edx
   1b8c4: 45 31 db                     	xorl	%r11d, %r11d
   1b8c7: 48 8b 71 10                  	movq	16(%rcx), %rsi
   1b8cb: 41 b8 0e 00 00 00            	movl	$14, %r8d
   1b8d1: 49 8b bf a0 00 00 00         	movq	160(%r15), %rdi
   1b8d8: 44 8b 48 04                  	movl	4(%rax), %r9d
   1b8dc: 85 d2                        	testl	%edx, %edx
   1b8de: 0f b6 51 19                  	movzbl	25(%rcx), %edx
   1b8e2: 41 0f 94 c3                  	sete	%r11b
   1b8e6: 44 89 d9                     	movl	%r11d, %ecx
   1b8e9: e8 92 43 00 00               	callq	0x1fc80 <bpf_gen__record_extern>
; 			break;
   1b8ee: e9 2e f7 ff ff               	jmp	0x1b021 <bpf_object_load.constprop.0+0x1301>
; 			err = -errno;
   1b8f3: e8 f8 9d fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("map '%s': failed to initialize slot [%d] to prog '%s' fd=%d: %d\n",
   1b8f8: 48 83 ec 08                  	subq	$8, %rsp
   1b8fc: 49 8b 57 08                  	movq	8(%r15), %rdx
   1b900: 31 ff                        	xorl	%edi, %edi
; 			err = -errno;
   1b902: 44 8b 10                     	movl	(%rax), %r10d
; 			pr_warn("map '%s': failed to initialize slot [%d] to prog '%s' fd=%d: %d\n",
   1b905: 4d 8b 04 24                  	movq	(%r12), %r8
   1b909: 31 c0                        	xorl	%eax, %eax
   1b90b: 48 8d 35 5e cf 01 00         	leaq	118622(%rip), %rsi      # 0x38870 <strs.2+0x59e0>
; 			err = -errno;
   1b912: 45 89 d3                     	movl	%r10d, %r11d
   1b915: 44 89 54 24 10               	movl	%r10d, 16(%rsp)
   1b91a: 41 f7 db                     	negl	%r11d
; 			pr_warn("map '%s': failed to initialize slot [%d] to prog '%s' fd=%d: %d\n",
   1b91d: 41 53                        	pushq	%r11
   1b91f: 44 8b 8c 24 b0 00 00 00      	movl	176(%rsp), %r9d
   1b927: 8b 8c 24 a8 00 00 00         	movl	168(%rsp), %ecx
   1b92e: 44 89 5c 24 10               	movl	%r11d, 16(%rsp)
   1b933: e8 98 c7 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (err < 0) {
   1b938: 41 58                        	popq	%r8
   1b93a: 41 59                        	popq	%r9
   1b93c: 44 8b 54 24 08               	movl	8(%rsp), %r10d
   1b941: 44 8b 1c 24                  	movl	(%rsp), %r11d
   1b945: 45 85 d2                     	testl	%r10d, %r10d
   1b948: 0f 8e 02 f8 ff ff            	jle	0x1b150 <bpf_object_load.constprop.0+0x1430>
   1b94e: 45 89 dc                     	movl	%r11d, %r12d
; 			zclose(map->fd);
   1b951: 41 8b 7f 18                  	movl	24(%r15), %edi
   1b955: 85 ff                        	testl	%edi, %edi
   1b957: 0f 89 de 03 00 00            	jns	0x1bd3b <bpf_object_load.constprop.0+0x201b>
   1b95d: 41 c7 47 18 ff ff ff ff      	movl	$4294967295, 24(%r15)   # imm = 0xFFFFFFFF
; 			return err;
   1b965: e9 46 ee ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 			pr_debug("prog '%s': skipped loading\n", prog->name);
   1b96a: 49 8b 55 00                  	movq	(%r13), %rdx
   1b96e: bf 02 00 00 00               	movl	$2, %edi
   1b973: 31 c0                        	xorl	%eax, %eax
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b975: 48 83 c5 01                  	addq	$1, %rbp
; 			pr_debug("prog '%s': skipped loading\n", prog->name);
   1b979: 48 8d 35 a0 ce 01 00         	leaq	118432(%rip), %rsi      # 0x38820 <strs.2+0x5990>
   1b980: e8 4b c7 fe ff               	callq	0x80d0 <libbpf_print>
; 			continue;
   1b985: 49 8b 76 60                  	movq	96(%r14), %rsi
; 	for (i = 0; i < obj->nr_programs; i++) {
   1b989: 48 39 ee                     	cmpq	%rbp, %rsi
   1b98c: 0f 87 2e f6 ff ff            	ja	0x1afc0 <bpf_object_load.constprop.0+0x12a0>
   1b992: e9 61 f7 ff ff               	jmp	0x1b0f8 <bpf_object_load.constprop.0+0x13d8>
   1b997: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	if (obj->btf_ext) {
   1b9a0: 48 85 c0                     	testq	%rax, %rax
   1b9a3: 0f 84 67 f2 ff ff            	je	0x1ac10 <bpf_object_load.constprop.0+0xef0>
; 	if (obj->btf_ext->core_relo_info.len == 0)
   1b9a9: 8b 68 54                     	movl	84(%rax), %ebp
   1b9ac: 85 ed                        	testl	%ebp, %ebp
   1b9ae: 0f 85 2d f0 ff ff            	jne	0x1a9e1 <bpf_object_load.constprop.0+0xcc1>
   1b9b4: e9 80 fe ff ff               	jmp	0x1b839 <bpf_object_load.constprop.0+0x1b19>
; 			pr_warn("struct_ops init_kern %s: Unmatched member type %s %u != %u(kernel)\n",
   1b9b9: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1b9be: 41 83 e1 1f                  	andl	$31, %r9d
   1b9c2: 41 83 e0 1f                  	andl	$31, %r8d
   1b9c6: 4c 89 f9                     	movq	%r15, %rcx
   1b9c9: 48 8d 35 00 ca 01 00         	leaq	117248(%rip), %rsi      # 0x383d0 <strs.2+0x5540>
   1b9d0: 31 ff                        	xorl	%edi, %edi
   1b9d2: 4c 8b 74 24 18               	movq	24(%rsp), %r14
   1b9d7: 48 8b 50 08                  	movq	8(%rax), %rdx
   1b9db: 31 c0                        	xorl	%eax, %eax
   1b9dd: e8 ee c6 fe ff               	callq	0x80d0 <libbpf_print>
; 			return -ENOTSUP;
   1b9e2: e9 ba ed ff ff               	jmp	0x1a7a1 <bpf_object_load.constprop.0+0xa81>
; 			pr_warn("struct_ops init_kern %s: bitfield %s is not supported\n",
   1b9e7: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1b9ec: 4c 89 f9                     	movq	%r15, %rcx
   1b9ef: 31 ff                        	xorl	%edi, %edi
   1b9f1: 4c 8b 74 24 18               	movq	24(%rsp), %r14
   1b9f6: 48 8d 35 93 c9 01 00         	leaq	117139(%rip), %rsi      # 0x38390 <strs.2+0x5500>
   1b9fd: 48 8b 50 08                  	movq	8(%rax), %rdx
   1ba01: 31 c0                        	xorl	%eax, %eax
   1ba03: e8 c8 c6 fe ff               	callq	0x80d0 <libbpf_print>
; 			return -ENOTSUP;
   1ba08: e9 94 ed ff ff               	jmp	0x1a7a1 <bpf_object_load.constprop.0+0xa81>
; 			pr_warn("struct_ops init_kern %s: Error in size of member %s: %zd != %zd(kernel)\n",
   1ba0d: 49 89 c1                     	movq	%rax, %r9
   1ba10: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1ba15: 4d 89 d0                     	movq	%r10, %r8
   1ba18: 4c 89 f9                     	movq	%r15, %rcx
   1ba1b: 48 8d 35 ae ca 01 00         	leaq	117422(%rip), %rsi      # 0x384d0 <strs.2+0x5640>
   1ba22: 31 ff                        	xorl	%edi, %edi
   1ba24: 4c 8b 74 24 18               	movq	24(%rsp), %r14
   1ba29: 48 8b 50 08                  	movq	8(%rax), %rdx
   1ba2d: 31 c0                        	xorl	%eax, %eax
   1ba2f: e8 9c c6 fe ff               	callq	0x80d0 <libbpf_print>
; 			return -ENOTSUP;
   1ba34: e9 68 ed ff ff               	jmp	0x1a7a1 <bpf_object_load.constprop.0+0xa81>
; 				pr_warn("prog '%s': relo #%d: failed to record relocation: %d\n",
   1ba39: 49 8b 14 24                  	movq	(%r12), %rdx
   1ba3d: 41 b8 f4 ff ff ff            	movl	$4294967284, %r8d       # imm = 0xFFFFFFF4
   1ba43: 44 89 f9                     	movl	%r15d, %ecx
   1ba46: 31 ff                        	xorl	%edi, %edi
   1ba48: 48 8d 35 c1 cb 01 00         	leaq	117697(%rip), %rsi      # 0x38610 <strs.2+0x5780>
   1ba4f: 31 c0                        	xorl	%eax, %eax
; 				goto out;
   1ba51: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
; 				pr_warn("prog '%s': relo #%d: failed to record relocation: %d\n",
   1ba57: e8 74 c6 fe ff               	callq	0x80d0 <libbpf_print>
; 				goto out;
   1ba5c: e9 d1 fc ff ff               	jmp	0x1b732 <bpf_object_load.constprop.0+0x1a12>
; 					insn[0].src_reg = BPF_PSEUDO_MAP_VALUE;
   1ba61: 83 e2 0f                     	andl	$15, %edx
   1ba64: 83 ca 20                     	orl	$32, %edx
   1ba67: 41 88 54 24 01               	movb	%dl, 1(%r12)
; 					insn[0].imm = obj->maps[obj->kconfig_map_idx].fd;
   1ba6c: 48 8d 14 89                  	leaq	(%rcx,%rcx,4), %rdx
   1ba70: 48 c1 e2 05                  	shlq	$5, %rdx
   1ba74: 49 03 56 68                  	addq	104(%r14), %rdx
   1ba78: 8b 4a 18                     	movl	24(%rdx), %ecx
   1ba7b: e9 16 fa ff ff               	jmp	0x1b496 <bpf_object_load.constprop.0+0x1776>
; 				pr_warn("struct_ops init_kern %s: kernel member %s is not a func ptr\n",
   1ba80: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1ba85: 4c 89 f9                     	movq	%r15, %rcx
   1ba88: 31 ff                        	xorl	%edi, %edi
   1ba8a: 4c 8b 74 24 18               	movq	24(%rsp), %r14
   1ba8f: 48 8d 35 8a c9 01 00         	leaq	117130(%rip), %rsi      # 0x38420 <strs.2+0x5590>
   1ba96: 48 8b 50 08                  	movq	8(%rax), %rdx
   1ba9a: 31 c0                        	xorl	%eax, %eax
   1ba9c: e8 2f c6 fe ff               	callq	0x80d0 <libbpf_print>
; 				return -ENOTSUP;
   1baa1: e9 fb ec ff ff               	jmp	0x1a7a1 <bpf_object_load.constprop.0+0xa81>
; 		ret = bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL", insns, insn_cnt, NULL);
   1baa6: bf 05 00 00 00               	movl	$5, %edi
   1baab: 45 31 c9                     	xorl	%r9d, %r9d
   1baae: 41 b8 02 00 00 00            	movl	$2, %r8d
   1bab4: 31 f6                        	xorl	%esi, %esi
   1bab6: 4c 89 e9                     	movq	%r13, %rcx
   1bab9: 4c 89 e2                     	movq	%r12, %rdx
   1babc: e8 8f a1 00 00               	callq	0x25c50 <bpf_prog_load>
   1bac1: 89 c7                        	movl	%eax, %edi
; 	if (ret < 0) {
   1bac3: 85 c0                        	testl	%eax, %eax
   1bac5: 0f 89 de fa ff ff            	jns	0x1b5a9 <bpf_object_load.constprop.0+0x1889>
; 		ret = errno;
   1bacb: e8 20 9c fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
   1bad0: 48 8d b4 24 e0 00 00 00      	leaq	224(%rsp), %rsi
   1bad8: ba 80 00 00 00               	movl	$128, %edx
; 		ret = errno;
   1badd: 8b 18                        	movl	(%rax), %ebx
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
   1badf: 89 df                        	movl	%ebx, %edi
; 		return -ret;
   1bae1: 41 89 dc                     	movl	%ebx, %r12d
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
   1bae4: e8 e7 1e 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
; 		pr_warn("Error in %s():%s(%d). Couldn't load trivial BPF "
   1bae9: 41 89 d8                     	movl	%ebx, %r8d
   1baec: 31 ff                        	xorl	%edi, %edi
; 		return -ret;
   1baee: 41 f7 dc                     	negl	%r12d
; 		cp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));
   1baf1: 48 89 c1                     	movq	%rax, %rcx
; 		pr_warn("Error in %s():%s(%d). Couldn't load trivial BPF "
   1baf4: 48 8d 15 f5 72 01 00         	leaq	94965(%rip), %rdx       # 0x32df0 <__func__.14>
   1bafb: 48 8d 35 fe c2 01 00         	leaq	115454(%rip), %rsi      # 0x37e00 <strs.2+0x4f70>
   1bb02: 31 c0                        	xorl	%eax, %eax
   1bb04: e8 c7 c5 fe ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__load_vmlinux_btf(obj, false);
   1bb09: 85 db                        	testl	%ebx, %ebx
   1bb0b: 0f 85 9f ec ff ff            	jne	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1bb11: e9 98 fa ff ff               	jmp	0x1b5ae <bpf_object_load.constprop.0+0x188e>
   1bb16: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	if (need_config && extra_kconfig) {
   1bb20: 48 8b 74 24 20               	movq	32(%rsp), %rsi
   1bb25: 48 85 f6                     	testq	%rsi, %rsi
   1bb28: 0f 84 17 02 00 00            	je	0x1bd45 <bpf_object_load.constprop.0+0x2025>
   1bb2e: 80 7c 24 18 00               	cmpb	$0, 24(%rsp)
   1bb33: 74 6c                        	je	0x1bba1 <bpf_object_load.constprop.0+0x1e81>
; 		err = bpf_object__read_kconfig_mem(obj, extra_kconfig, kcfg_data);
   1bb35: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   1bb3a: 4c 89 f7                     	movq	%r14, %rdi
   1bb3d: e8 ce db fe ff               	callq	0x9710 <bpf_object__read_kconfig_mem>
; 		if (err)
   1bb42: 85 c0                        	testl	%eax, %eax
   1bb44: 0f 85 f4 f8 ff ff            	jne	0x1b43e <bpf_object_load.constprop.0+0x171e>
; 		for (i = 0; i < obj->nr_extern; i++) {
   1bb4a: 41 8b 96 90 00 00 00         	movl	144(%r14), %edx
   1bb51: 85 d2                        	testl	%edx, %edx
   1bb53: 7e 4c                        	jle	0x1bba1 <bpf_object_load.constprop.0+0x1e81>
   1bb55: 8d 4a ff                     	leal	-1(%rdx), %ecx
   1bb58: 49 8b 86 88 00 00 00         	movq	136(%r14), %rax
   1bb5f: 48 8d 14 cd 00 00 00 00      	leaq	(,%rcx,8), %rdx
   1bb67: 48 29 ca                     	subq	%rcx, %rdx
   1bb6a: 48 8d 54 d0 38               	leaq	56(%rax,%rdx,8), %rdx
   1bb6f: eb 10                        	jmp	0x1bb81 <bpf_object_load.constprop.0+0x1e61>
   1bb71: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   1bb78: 48 83 c0 38                  	addq	$56, %rax
   1bb7c: 48 39 c2                     	cmpq	%rax, %rdx
   1bb7f: 74 20                        	je	0x1bba1 <bpf_object_load.constprop.0+0x1e81>
; 			if (ext->type == EXT_KCFG && !ext->is_set) {
   1bb81: 83 38 01                     	cmpl	$1, (%rax)
   1bb84: 75 f2                        	jne	0x1bb78 <bpf_object_load.constprop.0+0x1e58>
   1bb86: 80 78 18 00                  	cmpb	$0, 24(%rax)
   1bb8a: 75 ec                        	jne	0x1bb78 <bpf_object_load.constprop.0+0x1e58>
; 		err = bpf_object__read_kconfig_file(obj, kcfg_data);
   1bb8c: 48 8b 74 24 08               	movq	8(%rsp), %rsi
   1bb91: 4c 89 f7                     	movq	%r14, %rdi
   1bb94: e8 97 dc fe ff               	callq	0x9830 <bpf_object__read_kconfig_file>
; 		if (err)
   1bb99: 85 c0                        	testl	%eax, %eax
   1bb9b: 0f 85 9d f8 ff ff            	jne	0x1b43e <bpf_object_load.constprop.0+0x171e>
; 	if (need_kallsyms) {
   1bba1: 80 3c 24 00                  	cmpb	$0, (%rsp)
   1bba5: 0f 85 d6 03 00 00            	jne	0x1bf81 <bpf_object_load.constprop.0+0x2261>
; 	if (need_vmlinux_btf) {
   1bbab: 80 7c 24 10 00               	cmpb	$0, 16(%rsp)
; 	for (i = 0; i < obj->nr_extern; i++) {
   1bbb0: 41 8b 86 90 00 00 00         	movl	144(%r14), %eax
; 	if (need_vmlinux_btf) {
   1bbb7: 0f 84 56 e3 ff ff            	je	0x19f13 <bpf_object_load.constprop.0+0x1f3>
; 	kfunc_id = find_ksym_btf_id(obj, ext->name, BTF_KIND_FUNC, &kern_btf, &mod_btf);
   1bbbd: 48 8d 8c 24 98 00 00 00      	leaq	152(%rsp), %rcx
; 	for (i = 0; i < obj->nr_extern; i++) {
   1bbc5: 31 ed                        	xorl	%ebp, %ebp
; 	kfunc_id = find_ksym_btf_id(obj, ext->name, BTF_KIND_FUNC, &kern_btf, &mod_btf);
   1bbc7: 48 89 0c 24                  	movq	%rcx, (%rsp)
   1bbcb: 48 8d 8c 24 a0 00 00 00      	leaq	160(%rsp), %rcx
   1bbd3: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
; 	for (i = 0; i < obj->nr_extern; i++) {
   1bbd8: 85 c0                        	testl	%eax, %eax
   1bbda: 7f 24                        	jg	0x1bc00 <bpf_object_load.constprop.0+0x1ee0>
   1bbdc: e9 85 e3 ff ff               	jmp	0x19f66 <bpf_object_load.constprop.0+0x246>
   1bbe1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			ext->is_set = true;
   1bbe8: c6 43 18 01                  	movb	$1, 24(%rbx)
; 			ext->ksym.kernel_btf_obj_fd = 0;
   1bbec: 48 c7 43 28 00 00 00 00      	movq	$0, 40(%rbx)
; 	for (i = 0; i < obj->nr_extern; i++) {
   1bbf4: 48 83 c5 01                  	addq	$1, %rbp
   1bbf8: 39 e8                        	cmpl	%ebp, %eax
   1bbfa: 0f 8e 13 e3 ff ff            	jle	0x19f13 <bpf_object_load.constprop.0+0x1f3>
; 		ext = &obj->externs[i];
   1bc00: 49 8b 8e 88 00 00 00         	movq	136(%r14), %rcx
   1bc07: 48 8d 14 ed 00 00 00 00      	leaq	(,%rbp,8), %rdx
   1bc0f: 48 29 ea                     	subq	%rbp, %rdx
   1bc12: 48 8d 1c d1                  	leaq	(%rcx,%rdx,8), %rbx
; 		if (ext->type != EXT_KSYM || !ext->ksym.type_id)
   1bc16: 83 3b 02                     	cmpl	$2, (%rbx)
   1bc19: 75 d9                        	jne	0x1bbf4 <bpf_object_load.constprop.0+0x1ed4>
   1bc1b: 44 8b 63 30                  	movl	48(%rbx), %r12d
   1bc1f: 45 85 e4                     	testl	%r12d, %r12d
   1bc22: 74 d0                        	je	0x1bbf4 <bpf_object_load.constprop.0+0x1ed4>
; 		if (obj->gen_loader) {
   1bc24: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1bc2c: 75 ba                        	jne	0x1bbe8 <bpf_object_load.constprop.0+0x1ec8>
; 		t = btf__type_by_id(obj->btf, ext->btf_id);
   1bc2e: 8b 73 08                     	movl	8(%rbx), %esi
   1bc31: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1bc38: e8 63 e3 00 00               	callq	0x29fa0 <btf__type_by_id>
; 	return BTF_INFO_KIND(t->info);
   1bc3d: 0f b6 40 07                  	movzbl	7(%rax), %eax
; 	struct module_btf *mod_btf = NULL;
   1bc41: 48 c7 84 24 98 00 00 00 00 00 00 00  	movq	$0, 152(%rsp)
; 	struct btf *btf = NULL;
   1bc4d: 48 c7 84 24 a0 00 00 00 00 00 00 00  	movq	$0, 160(%rsp)
; 	return BTF_INFO_KIND(t->info);
   1bc59: 83 e0 1f                     	andl	$31, %eax
; 		if (btf_is_var(t))
   1bc5c: 66 83 f8 0e                  	cmpw	$14, %ax
   1bc60: 0f 84 ee 05 00 00            	je	0x1c254 <bpf_object_load.constprop.0+0x2534>
; 	kfunc_id = find_ksym_btf_id(obj, ext->name, BTF_KIND_FUNC, &kern_btf, &mod_btf);
   1bc66: 48 8b 73 10                  	movq	16(%rbx), %rsi
   1bc6a: 4c 8b 04 24                  	movq	(%rsp), %r8
   1bc6e: ba 0c 00 00 00               	movl	$12, %edx
   1bc73: 4c 89 f7                     	movq	%r14, %rdi
   1bc76: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
; 	local_func_proto_id = ext->ksym.type_id;
   1bc7b: 44 8b 63 30                  	movl	48(%rbx), %r12d
; 	kfunc_id = find_ksym_btf_id(obj, ext->name, BTF_KIND_FUNC, &kern_btf, &mod_btf);
   1bc7f: e8 dc 1f ff ff               	callq	0xdc60 <find_ksym_btf_id.constprop.0>
   1bc84: 41 89 c7                     	movl	%eax, %r15d
; 	if (kfunc_id < 0) {
   1bc87: 85 c0                        	testl	%eax, %eax
   1bc89: 0f 89 11 03 00 00            	jns	0x1bfa0 <bpf_object_load.constprop.0+0x2280>
; 		if (kfunc_id == -ESRCH && ext->is_weak)
   1bc8f: 83 f8 fd                     	cmpl	$-3, %eax
   1bc92: 75 0a                        	jne	0x1bc9e <bpf_object_load.constprop.0+0x1f7e>
   1bc94: 80 7b 19 00                  	cmpb	$0, 25(%rbx)
   1bc98: 0f 85 f7 03 00 00            	jne	0x1c095 <bpf_object_load.constprop.0+0x2375>
; 		pr_warn("extern (func ksym) '%s': not found in kernel or module BTFs\n",
   1bc9e: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1bca2: 48 8d 35 cf c3 01 00         	leaq	115663(%rip), %rsi      # 0x38078 <strs.2+0x51e8>
   1bca9: 31 ff                        	xorl	%edi, %edi
   1bcab: 31 c0                        	xorl	%eax, %eax
   1bcad: e8 1e c4 fe ff               	callq	0x80d0 <libbpf_print>
; 		return kfunc_id;
   1bcb2: e9 87 f7 ff ff               	jmp	0x1b43e <bpf_object_load.constprop.0+0x171e>
; 			pr_warn("extern '%s': unrecognized extern kind\n", ext->name);
   1bcb7: 4c 89 fa                     	movq	%r15, %rdx
   1bcba: 48 8d 35 a7 c2 01 00         	leaq	115367(%rip), %rsi      # 0x37f68 <strs.2+0x50d8>
   1bcc1: 31 ff                        	xorl	%edi, %edi
   1bcc3: 31 c0                        	xorl	%eax, %eax
   1bcc5: e8 06 c4 fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   1bcca: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
   1bcd0: e9 db ea ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 			pr_warn("prog '%s': failed to load: %d\n", prog->name, err);
   1bcd5: 49 8b 55 00                  	movq	(%r13), %rdx
   1bcd9: 41 89 c4                     	movl	%eax, %r12d
   1bcdc: 89 c1                        	movl	%eax, %ecx
   1bcde: 48 8d 35 63 cb 01 00         	leaq	117603(%rip), %rsi      # 0x38848 <strs.2+0x59b8>
   1bce5: 31 ff                        	xorl	%edi, %edi
   1bce7: 31 c0                        	xorl	%eax, %eax
   1bce9: e8 e2 c3 fe ff               	callq	0x80d0 <libbpf_print>
; 			return err;
   1bcee: e9 bd ea ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 				return -EINVAL;
   1bcf3: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("failed to perform CO-RE relocations: %d\n",
   1bcf9: 44 89 e2                     	movl	%r12d, %edx
   1bcfc: 48 8d 35 c5 c9 01 00         	leaq	117189(%rip), %rsi      # 0x386c8 <strs.2+0x5838>
   1bd03: 31 ff                        	xorl	%edi, %edi
   1bd05: 31 c0                        	xorl	%eax, %eax
   1bd07: e8 c4 c3 fe ff               	callq	0x80d0 <libbpf_print>
; 			return err;
   1bd0c: e9 9f ea ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1bd11: 49 8b 76 60                  	movq	96(%r14), %rsi
   1bd15: e9 86 e2 ff ff               	jmp	0x19fa0 <bpf_object_load.constprop.0+0x280>
; 		errno = -PTR_ERR(ptr);
   1bd1a: f7 db                        	negl	%ebx
   1bd1c: 89 18                        	movl	%ebx, (%rax)
   1bd1e: e9 aa fa ff ff               	jmp	0x1b7cd <bpf_object_load.constprop.0+0x1aad>
; 				pr_warn("prog '%s': relo #%d: bad insn\n",
   1bd23: 48 8b 13                     	movq	(%rbx), %rdx
   1bd26: 48 8d 35 5b ca 01 00         	leaq	117339(%rip), %rsi      # 0x38788 <strs.2+0x58f8>
   1bd2d: 31 ff                        	xorl	%edi, %edi
   1bd2f: 31 c0                        	xorl	%eax, %eax
   1bd31: e8 9a c3 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (err) {
   1bd36: e9 eb f6 ff ff               	jmp	0x1b426 <bpf_object_load.constprop.0+0x1706>
; 			zclose(map->fd);
   1bd3b: e8 c0 9b fe ff               	callq	0x5900 <.plt.sec+0x290>
   1bd40: e9 18 fc ff ff               	jmp	0x1b95d <bpf_object_load.constprop.0+0x1c3d>
; 	if (need_config) {
   1bd45: 80 7c 24 18 00               	cmpb	$0, 24(%rsp)
   1bd4a: 0f 85 3c fe ff ff            	jne	0x1bb8c <bpf_object_load.constprop.0+0x1e6c>
   1bd50: e9 4c fe ff ff               	jmp	0x1bba1 <bpf_object_load.constprop.0+0x1e81>
   1bd55: 0f 1f 00                     	nopl	(%rax)
; 		} else if (!has_float && btf_is_float(t)) {
   1bd58: 80 7c 24 10 00               	cmpb	$0, 16(%rsp)
   1bd5d: 75 12                        	jne	0x1bd71 <bpf_object_load.constprop.0+0x2051>
; 	return BTF_INFO_KIND(t->info);
   1bd5f: 41 0f b6 45 07               	movzbl	7(%r13), %eax
   1bd64: 83 e0 1f                     	andl	$31, %eax
; 		} else if (!has_float && btf_is_float(t)) {
   1bd67: 66 83 f8 10                  	cmpw	$16, %ax
   1bd6b: 0f 84 fa 03 00 00            	je	0x1c16b <bpf_object_load.constprop.0+0x244b>
; 		} else if (!has_type_tag && btf_is_type_tag(t)) {
   1bd71: 80 7c 24 28 00               	cmpb	$0, 40(%rsp)
   1bd76: 75 12                        	jne	0x1bd8a <bpf_object_load.constprop.0+0x206a>
; 	return BTF_INFO_KIND(t->info);
   1bd78: 41 0f b6 45 07               	movzbl	7(%r13), %eax
   1bd7d: 83 e0 1f                     	andl	$31, %eax
; 		} else if (!has_type_tag && btf_is_type_tag(t)) {
   1bd80: 66 83 f8 12                  	cmpw	$18, %ax
   1bd84: 0f 84 f4 03 00 00            	je	0x1c17e <bpf_object_load.constprop.0+0x245e>
; 		} else if (!has_enum64 && btf_is_enum(t)) {
   1bd8a: 80 7c 24 30 00               	cmpb	$0, 48(%rsp)
   1bd8f: 0f 85 87 e4 ff ff            	jne	0x1a21c <bpf_object_load.constprop.0+0x4fc>
; 	return BTF_INFO_KIND(t->info);
   1bd95: 41 8b 45 04                  	movl	4(%r13), %eax
   1bd99: 89 c2                        	movl	%eax, %edx
   1bd9b: c1 ea 18                     	shrl	$24, %edx
   1bd9e: 83 e2 1f                     	andl	$31, %edx
; 		} else if (!has_enum64 && btf_is_enum(t)) {
   1bda1: 66 83 fa 06                  	cmpw	$6, %dx
   1bda5: 0f 84 f8 04 00 00            	je	0x1c2a3 <bpf_object_load.constprop.0+0x2583>
; 		} else if (!has_enum64 && btf_is_enum64(t)) {
   1bdab: 66 83 fa 13                  	cmpw	$19, %dx
   1bdaf: 0f 85 67 e4 ff ff            	jne	0x1a21c <bpf_object_load.constprop.0+0x4fc>
; 			if (enum64_placeholder_id == 0) {
   1bdb5: 45 85 e4                     	testl	%r12d, %r12d
   1bdb8: 0f 84 f8 05 00 00            	je	0x1c3b6 <bpf_object_load.constprop.0+0x2696>
; 	return (struct btf_member *)(t + 1);
   1bdbe: 0f b7 c0                     	movzwl	%ax, %eax
   1bdc1: 49 8d 55 0c                  	leaq	12(%r13), %rdx
; 			t->info = BTF_INFO_ENC(BTF_KIND_UNION, 0, vlen);
   1bdc5: 89 c1                        	movl	%eax, %ecx
   1bdc7: 81 c9 00 00 00 05            	orl	$83886080, %ecx         # imm = 0x5000000
   1bdcd: 41 89 4d 04                  	movl	%ecx, 4(%r13)
; 			for (j = 0; j < vlen; j++, m++) {
   1bdd1: 85 c0                        	testl	%eax, %eax
   1bdd3: 0f 84 43 e4 ff ff            	je	0x1a21c <bpf_object_load.constprop.0+0x4fc>
   1bdd9: 83 e8 01                     	subl	$1, %eax
   1bddc: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   1bde0: 49 8d 44 85 18               	leaq	24(%r13,%rax,4), %rax
; 				m->type = enum64_placeholder_id;
   1bde5: 44 89 62 04                  	movl	%r12d, 4(%rdx)
; 			for (j = 0; j < vlen; j++, m++) {
   1bde9: 48 83 c2 0c                  	addq	$12, %rdx
; 				m->offset = 0;
   1bded: c7 42 fc 00 00 00 00         	movl	$0, -4(%rdx)
; 			for (j = 0; j < vlen; j++, m++) {
   1bdf4: 48 39 c2                     	cmpq	%rax, %rdx
   1bdf7: 75 ec                        	jne	0x1bde5 <bpf_object_load.constprop.0+0x20c5>
   1bdf9: e9 1e e4 ff ff               	jmp	0x1a21c <bpf_object_load.constprop.0+0x4fc>
   1bdfe: 66 90                        	nop
; 	return BTF_INFO_KIND(t->info);
   1be00: 41 8b 45 04                  	movl	4(%r13), %eax
   1be04: 89 c2                        	movl	%eax, %edx
   1be06: c1 ea 18                     	shrl	$24, %edx
   1be09: 83 e2 1f                     	andl	$31, %edx
; 		} else if (!has_func && btf_is_func_proto(t)) {
   1be0c: 66 83 fa 0d                  	cmpw	$13, %dx
   1be10: 74 78                        	je	0x1be8a <bpf_object_load.constprop.0+0x216a>
; 		} else if (!has_func && btf_is_func(t)) {
   1be12: 66 83 fa 0c                  	cmpw	$12, %dx
   1be16: 0f 85 3c ff ff ff            	jne	0x1bd58 <bpf_object_load.constprop.0+0x2038>
; 			t->info = BTF_INFO_ENC(BTF_KIND_TYPEDEF, 0, 0);
   1be1c: 41 c7 45 04 00 00 00 08      	movl	$134217728, 4(%r13)     # imm = 0x8000000
   1be24: e9 f3 e3 ff ff               	jmp	0x1a21c <bpf_object_load.constprop.0+0x4fc>
; 	if (obj->gen_loader) {
   1be29: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1be31: 0f 84 af e4 ff ff            	je	0x1a2e6 <bpf_object_load.constprop.0+0x5c6>
; 		const void *raw_data = btf__raw_data(kern_btf, &raw_size);
   1be37: 48 8b 3c 24                  	movq	(%rsp), %rdi
   1be3b: 48 8d b4 24 a0 00 00 00      	leaq	160(%rsp), %rsi
; 		__u32 raw_size = 0;
   1be43: c7 84 24 a0 00 00 00 00 00 00 00     	movl	$0, 160(%rsp)
; 		const void *raw_data = btf__raw_data(kern_btf, &raw_size);
   1be4e: e8 fd f3 00 00               	callq	0x2b250 <btf__raw_data>
   1be53: 48 89 c6                     	movq	%rax, %rsi
; 		if (!raw_data)
   1be56: 48 85 c0                     	testq	%rax, %rax
   1be59: 0f 84 81 02 00 00            	je	0x1c0e0 <bpf_object_load.constprop.0+0x23c0>
; 		bpf_gen__load_btf(obj->gen_loader, raw_data, raw_size);
   1be5f: 49 8b be a0 00 00 00         	movq	160(%r14), %rdi
   1be66: 8b 94 24 a0 00 00 00         	movl	160(%rsp), %edx
   1be6d: e8 1e 39 00 00               	callq	0x1f790 <bpf_gen__load_btf>
; 		btf__set_fd(kern_btf, 0);
   1be72: 48 8b 3c 24                  	movq	(%rsp), %rdi
   1be76: 31 f6                        	xorl	%esi, %esi
   1be78: e8 c3 f3 00 00               	callq	0x2b240 <btf__set_fd>
; 	if (sanitize) {
   1be7d: e9 ba e4 ff ff               	jmp	0x1a33c <bpf_object_load.constprop.0+0x61c>
   1be82: 41 89 c4                     	movl	%eax, %r12d
   1be85: e9 26 e9 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 			vlen = btf_vlen(t);
   1be8a: 0f b7 c0                     	movzwl	%ax, %eax
; 			t->size = sizeof(__u32); /* kernel enforced */
   1be8d: 41 c7 45 08 04 00 00 00      	movl	$4, 8(%r13)
; 			t->info = BTF_INFO_ENC(BTF_KIND_ENUM, 0, vlen);
   1be95: 0d 00 00 00 06               	orl	$100663296, %eax        # imm = 0x6000000
   1be9a: 41 89 45 04                  	movl	%eax, 4(%r13)
; 			t->size = sizeof(__u32); /* kernel enforced */
   1be9e: e9 79 e3 ff ff               	jmp	0x1a21c <bpf_object_load.constprop.0+0x4fc>
; 	for_each_btf_ext_sec(seg, sec) {
   1bea3: 0f af c2                     	imull	%edx, %eax
   1bea6: 48 83 c0 08                  	addq	$8, %rax
   1beaa: 48 8b 5c 24 08               	movq	8(%rsp), %rbx
   1beaf: 48 01 04 24                  	addq	%rax, (%rsp)
   1beb3: 48 8b 0c 24                  	movq	(%rsp), %rcx
   1beb7: 48 83 44 24 38 04            	addq	$4, 56(%rsp)
   1bebd: 8b 43 54                     	movl	84(%rbx), %eax
   1bec0: 48 03 43 48                  	addq	72(%rbx), %rax
   1bec4: 48 39 c1                     	cmpq	%rax, %rcx
   1bec7: 0f 82 66 eb ff ff            	jb	0x1aa33 <bpf_object_load.constprop.0+0xd13>
; 	btf__free(obj->btf_vmlinux_override);
   1becd: 49 8b be 30 01 00 00         	movq	304(%r14), %rdi
   1bed4: e8 17 e9 00 00               	callq	0x2a7f0 <btf__free>
; 	if (!IS_ERR_OR_NULL(cand_cache)) {
   1bed9: 48 83 7c 24 20 00            	cmpq	$0, 32(%rsp)
; 	obj->btf_vmlinux_override = NULL;
   1bedf: 49 c7 86 30 01 00 00 00 00 00 00     	movq	$0, 304(%r14)
; 	if (!IS_ERR_OR_NULL(cand_cache)) {
   1beea: 0f 84 49 f9 ff ff            	je	0x1b839 <bpf_object_load.constprop.0+0x1b19>
; 		hashmap__for_each_entry(cand_cache, entry, i) {
   1bef0: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1bef5: 45 31 e4                     	xorl	%r12d, %r12d
   1bef8: 48 83 78 20 00               	cmpq	$0, 32(%rax)
   1befd: 0f 85 5e f8 ff ff            	jne	0x1b761 <bpf_object_load.constprop.0+0x1a41>
; 		hashmap__free(cand_cache);
   1bf03: 48 89 c7                     	movq	%rax, %rdi
   1bf06: e8 a5 25 00 00               	callq	0x1e4b0 <hashmap__free>
; 		if (err) {
   1bf0b: e9 29 f9 ff ff               	jmp	0x1b839 <bpf_object_load.constprop.0+0x1b19>
; 		pr_debug("Kernel doesn't support BTF, skipping uploading it.\n");
   1bf10: 48 8d 35 09 c3 01 00         	leaq	115465(%rip), %rsi      # 0x38220 <strs.2+0x5390>
   1bf17: bf 02 00 00 00               	movl	$2, %edi
   1bf1c: 31 c0                        	xorl	%eax, %eax
   1bf1e: e8 ad c1 fe ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__sanitize_maps(obj);
   1bf23: e9 14 e4 ff ff               	jmp	0x1a33c <bpf_object_load.constprop.0+0x61c>
; 				pr_warn("extern (kcfg) '%s': unrecognized virtual extern\n", ext->name);
   1bf28: 4c 89 fa                     	movq	%r15, %rdx
   1bf2b: 48 8d 35 c6 bf 01 00         	leaq	114630(%rip), %rsi      # 0x37ef8 <strs.2+0x5068>
   1bf32: 31 ff                        	xorl	%edi, %edi
   1bf34: 31 c0                        	xorl	%eax, %eax
   1bf36: e8 95 c1 fe ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
   1bf3b: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
   1bf41: e9 6a e8 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 			pr_warn("extern '%s' (strong): not resolved\n", ext->name);
   1bf46: 48 8d 35 63 c2 01 00         	leaq	115299(%rip), %rsi      # 0x381b0 <strs.2+0x5320>
   1bf4d: 31 ff                        	xorl	%edi, %edi
   1bf4f: 31 c0                        	xorl	%eax, %eax
; 			return -ESRCH;
   1bf51: 41 bc fd ff ff ff            	movl	$4294967293, %r12d      # imm = 0xFFFFFFFD
; 			pr_warn("extern '%s' (strong): not resolved\n", ext->name);
   1bf57: e8 74 c1 fe ff               	callq	0x80d0 <libbpf_print>
; 	err = err ? : bpf_object__init_kern_struct_ops_maps(obj);
   1bf5c: e9 4f e8 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 		errno = -ret;
   1bf61: e8 8a 97 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1bf66: c7 00 02 00 00 00            	movl	$2, (%rax)
; 		return libbpf_err(-ENOENT);
   1bf6c: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
   1bf71: e9 42 f2 ff ff               	jmp	0x1b1b8 <bpf_object_load.constprop.0+0x1498>
; 		return -ENOTSUP;
   1bf76: 41 bc a1 ff ff ff            	movl	$4294967201, %r12d      # imm = 0xFFFFFFA1
   1bf7c: e9 d0 f9 ff ff               	jmp	0x1b951 <bpf_object_load.constprop.0+0x1c31>
; 	return libbpf_kallsyms_parse(kallsyms_cb, obj);
   1bf81: 4c 89 f6                     	movq	%r14, %rsi
   1bf84: 48 8d 3d 05 da fe ff         	leaq	-75259(%rip), %rdi      # 0x9990 <kallsyms_cb>
   1bf8b: e8 00 27 ff ff               	callq	0xe690 <libbpf_kallsyms_parse>
; 		if (err)
   1bf90: 85 c0                        	testl	%eax, %eax
   1bf92: 0f 84 13 fc ff ff            	je	0x1bbab <bpf_object_load.constprop.0+0x1e8b>
   1bf98: e9 a1 f4 ff ff               	jmp	0x1b43e <bpf_object_load.constprop.0+0x171e>
   1bf9d: 0f 1f 00                     	nopl	(%rax)
; 	kern_func = btf__type_by_id(kern_btf, kfunc_id);
   1bfa0: 48 8b bc 24 a0 00 00 00      	movq	160(%rsp), %rdi
   1bfa8: 89 c6                        	movl	%eax, %esi
   1bfaa: e8 f1 df 00 00               	callq	0x29fa0 <btf__type_by_id>
; 	return __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id, 32);
   1bfaf: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1bfb6: 48 8b 94 24 a0 00 00 00      	movq	160(%rsp), %rdx
   1bfbe: 44 89 e6                     	movl	%r12d, %esi
; 	kfunc_proto_id = kern_func->type;
   1bfc1: 44 8b 68 08                  	movl	8(%rax), %r13d
; 	return __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id, 32);
   1bfc5: 41 b8 20 00 00 00            	movl	$32, %r8d
   1bfcb: 44 89 e9                     	movl	%r13d, %ecx
   1bfce: e8 bd 59 00 00               	callq	0x21990 <__bpf_core_types_are_compat>
; 	if (ret <= 0) {
   1bfd3: 85 c0                        	testl	%eax, %eax
   1bfd5: 0f 8e 45 04 00 00            	jle	0x1c420 <bpf_object_load.constprop.0+0x2700>
; 	if (mod_btf && !mod_btf->fd_array_idx) {
   1bfdb: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   1bfe3: 48 85 c0                     	testq	%rax, %rax
   1bfe6: 0f 84 25 04 00 00            	je	0x1c411 <bpf_object_load.constprop.0+0x26f1>
   1bfec: 44 8b 50 18                  	movl	24(%rax), %r10d
   1bff0: 45 85 d2                     	testl	%r10d, %r10d
   1bff3: 75 76                        	jne	0x1c06b <bpf_object_load.constprop.0+0x234b>
; 		if (obj->fd_array_cnt == INT16_MAX) {
   1bff5: 49 8b 86 80 01 00 00         	movq	384(%r14), %rax
   1bffc: 48 3d ff 7f 00 00            	cmpq	$32767, %rax            # imm = 0x7FFF
   1c002: 0f 84 db 04 00 00            	je	0x1c4e3 <bpf_object_load.constprop.0+0x27c3>
; 		ret = libbpf_ensure_mem((void **)&obj->fd_array, &obj->fd_array_cap, sizeof(int),
   1c008: 48 8d 48 01                  	leaq	1(%rax), %rcx
; 		if (!obj->fd_array_cnt)
   1c00c: 48 85 c0                     	testq	%rax, %rax
   1c00f: 75 10                        	jne	0x1c021 <bpf_object_load.constprop.0+0x2301>
; 			obj->fd_array_cnt = 1;
   1c011: 49 c7 86 80 01 00 00 01 00 00 00     	movq	$1, 384(%r14)
   1c01c: b9 02 00 00 00               	movl	$2, %ecx
; 		ret = libbpf_ensure_mem((void **)&obj->fd_array, &obj->fd_array_cap, sizeof(int),
   1c021: 49 8d b6 78 01 00 00         	leaq	376(%r14), %rsi
   1c028: 49 8d be 70 01 00 00         	leaq	368(%r14), %rdi
   1c02f: ba 04 00 00 00               	movl	$4, %edx
   1c034: e8 57 de 00 00               	callq	0x29e90 <libbpf_ensure_mem>
; 		if (ret)
   1c039: 85 c0                        	testl	%eax, %eax
   1c03b: 0f 85 fd f3 ff ff            	jne	0x1b43e <bpf_object_load.constprop.0+0x171e>
; 		mod_btf->fd_array_idx = obj->fd_array_cnt;
   1c041: 49 8b 96 80 01 00 00         	movq	384(%r14), %rdx
   1c048: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
; 		obj->fd_array[obj->fd_array_cnt++] = mod_btf->fd;
   1c050: 49 8b 8e 70 01 00 00         	movq	368(%r14), %rcx
   1c057: 48 8d 72 01                  	leaq	1(%rdx), %rsi
; 		mod_btf->fd_array_idx = obj->fd_array_cnt;
   1c05b: 89 50 18                     	movl	%edx, 24(%rax)
; 		obj->fd_array[obj->fd_array_cnt++] = mod_btf->fd;
   1c05e: 49 89 b6 80 01 00 00         	movq	%rsi, 384(%r14)
   1c065: 8b 70 14                     	movl	20(%rax), %esi
   1c068: 89 34 91                     	movl	%esi, (%rcx,%rdx,4)
; 	ext->is_set = true;
   1c06b: c6 43 18 01                  	movb	$1, 24(%rbx)
; 	ext->ksym.btf_fd_idx = mod_btf ? mod_btf->fd_array_idx : 0;
   1c06f: 0f b7 40 18                  	movzwl	24(%rax), %eax
; 	ext->ksym.kernel_btf_id = kfunc_id;
   1c073: 44 89 7b 2c                  	movl	%r15d, 44(%rbx)
; 	ext->ksym.btf_fd_idx = mod_btf ? mod_btf->fd_array_idx : 0;
   1c077: 66 89 43 34                  	movw	%ax, 52(%rbx)
; 	pr_debug("extern (func ksym) '%s': resolved to kernel [%d]\n",
   1c07b: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1c07f: 44 89 f9                     	movl	%r15d, %ecx
   1c082: bf 02 00 00 00               	movl	$2, %edi
   1c087: 48 8d 35 e2 c0 01 00         	leaq	114914(%rip), %rsi      # 0x38170 <strs.2+0x52e0>
   1c08e: 31 c0                        	xorl	%eax, %eax
   1c090: e8 3b c0 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   1c095: 41 8b 86 90 00 00 00         	movl	144(%r14), %eax
   1c09c: e9 53 fb ff ff               	jmp	0x1bbf4 <bpf_object_load.constprop.0+0x1ed4>
; 		errno = -ret;
   1c0a1: e8 4a 96 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1c0a6: 48 89 c2                     	movq	%rax, %rdx
; 	if (IS_ERR(ptr))
   1c0a9: 49 81 ff 00 f0 ff ff         	cmpq	$-4096, %r15            # imm = 0xF000
   1c0b0: 0f 87 fe 01 00 00            	ja	0x1c2b4 <bpf_object_load.constprop.0+0x2594>
; 	return -errno;
   1c0b6: 8b 00                        	movl	(%rax), %eax
   1c0b8: 41 89 c4                     	movl	%eax, %r12d
   1c0bb: 41 f7 dc                     	negl	%r12d
; 		if (err)
   1c0be: 85 c0                        	testl	%eax, %eax
   1c0c0: 0f 85 ea e6 ff ff            	jne	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1c0c6: e9 6a e0 ff ff               	jmp	0x1a135 <bpf_object_load.constprop.0+0x415>
; 		return -ENAMETOOLONG;
   1c0cb: 4c 8b 74 24 18               	movq	24(%rsp), %r14
   1c0d0: 41 bc dc ff ff ff            	movl	$4294967260, %r12d      # imm = 0xFFFFFFDC
   1c0d6: e9 6a f5 ff ff               	jmp	0x1b645 <bpf_object_load.constprop.0+0x1925>
   1c0db: 4c 8b 74 24 18               	movq	24(%rsp), %r14
; 		return -ENOMEM;
   1c0e0: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
   1c0e6: e9 c5 e6 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1c0eb: 4c 8b 74 24 18               	movq	24(%rsp), %r14
; 	if (obj->gen_loader) {
   1c0f0: 49 83 be a0 00 00 00 00      	cmpq	$0, 160(%r14)
   1c0f8: 0f 84 1a 01 00 00            	je	0x1c218 <bpf_object_load.constprop.0+0x24f8>
; 		const void *raw_data = btf__raw_data(kern_btf, &raw_size);
   1c0fe: 48 8b 74 24 38               	movq	56(%rsp), %rsi
   1c103: 4c 89 ff                     	movq	%r15, %rdi
; 		__u32 raw_size = 0;
   1c106: c7 84 24 a0 00 00 00 00 00 00 00     	movl	$0, 160(%rsp)
; 		const void *raw_data = btf__raw_data(kern_btf, &raw_size);
   1c111: e8 3a f1 00 00               	callq	0x2b250 <btf__raw_data>
   1c116: 48 89 c6                     	movq	%rax, %rsi
; 		if (!raw_data)
   1c119: 48 85 c0                     	testq	%rax, %rax
   1c11c: 74 c2                        	je	0x1c0e0 <bpf_object_load.constprop.0+0x23c0>
; 		bpf_gen__load_btf(obj->gen_loader, raw_data, raw_size);
   1c11e: 49 8b be a0 00 00 00         	movq	160(%r14), %rdi
   1c125: 8b 94 24 a0 00 00 00         	movl	160(%rsp), %edx
   1c12c: e8 5f 36 00 00               	callq	0x1f790 <bpf_gen__load_btf>
; 		btf__set_fd(kern_btf, 0);
   1c131: 31 f6                        	xorl	%esi, %esi
   1c133: 4c 89 ff                     	movq	%r15, %rdi
   1c136: e8 05 f1 00 00               	callq	0x2b240 <btf__set_fd>
; 			btf__set_fd(obj->btf, btf__fd(kern_btf));
   1c13b: 4c 89 ff                     	movq	%r15, %rdi
   1c13e: e8 ed f0 00 00               	callq	0x2b230 <btf__fd>
   1c143: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1c14a: 89 c6                        	movl	%eax, %esi
   1c14c: e8 ef f0 00 00               	callq	0x2b240 <btf__set_fd>
; 			btf__set_fd(kern_btf, -1);
   1c151: 4c 89 ff                     	movq	%r15, %rdi
   1c154: be ff ff ff ff               	movl	$4294967295, %esi       # imm = 0xFFFFFFFF
   1c159: e8 e2 f0 00 00               	callq	0x2b240 <btf__set_fd>
; 		btf__free(kern_btf);
   1c15e: 4c 89 ff                     	movq	%r15, %rdi
   1c161: e8 8a e6 00 00               	callq	0x2a7f0 <btf__free>
; 	if (err) {
   1c166: e9 d1 e1 ff ff               	jmp	0x1a33c <bpf_object_load.constprop.0+0x61c>
; 			t->name_off = 0;
   1c16b: 48 b8 00 00 00 00 00 00 00 04	movabsq	$288230376151711744, %rax # imm = 0x400000000000000
   1c175: 49 89 45 00                  	movq	%rax, (%r13)
; 			t->info = BTF_INFO_ENC(BTF_KIND_STRUCT, 0, 0);
   1c179: e9 9e e0 ff ff               	jmp	0x1a21c <bpf_object_load.constprop.0+0x4fc>
; 			t->name_off = 0;
   1c17e: 48 b8 00 00 00 00 00 00 00 0a	movabsq	$720575940379279360, %rax # imm = 0xA00000000000000
   1c188: 49 89 45 00                  	movq	%rax, (%r13)
; 			t->info = BTF_INFO_ENC(BTF_KIND_CONST, 0, 0);
   1c18c: e9 8b e0 ff ff               	jmp	0x1a21c <bpf_object_load.constprop.0+0x4fc>
; 			name = (char *)btf__name_by_offset(btf, t->name_off);
   1c191: 41 8b 75 00                  	movl	(%r13), %esi
   1c195: 4c 89 ff                     	movq	%r15, %rdi
; 	return (struct btf_var_secinfo *)(t + 1);
   1c198: 4d 8d 75 0c                  	leaq	12(%r13), %r14
; 			name = (char *)btf__name_by_offset(btf, t->name_off);
   1c19c: e8 4f f9 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 			while (*name) {
   1c1a1: 0f b6 08                     	movzbl	(%rax), %ecx
   1c1a4: 84 c9                        	testb	%cl, %cl
   1c1a6: 74 14                        	je	0x1c1bc <bpf_object_load.constprop.0+0x249c>
; 				if (*name == '.')
   1c1a8: 80 f9 2e                     	cmpb	$46, %cl
   1c1ab: 75 03                        	jne	0x1c1b0 <bpf_object_load.constprop.0+0x2490>
; 					*name = '_';
   1c1ad: c6 00 5f                     	movb	$95, (%rax)
; 			while (*name) {
   1c1b0: 0f b6 48 01                  	movzbl	1(%rax), %ecx
; 				name++;
   1c1b4: 48 83 c0 01                  	addq	$1, %rax
; 			while (*name) {
   1c1b8: 84 c9                        	testb	%cl, %cl
   1c1ba: 75 ec                        	jne	0x1c1a8 <bpf_object_load.constprop.0+0x2488>
; 	return BTF_INFO_VLEN(t->info);
   1c1bc: 41 0f b7 45 04               	movzwl	4(%r13), %eax
; 			t->info = BTF_INFO_ENC(BTF_KIND_STRUCT, 0, vlen);
   1c1c1: 89 c1                        	movl	%eax, %ecx
   1c1c3: 81 c9 00 00 00 04            	orl	$67108864, %ecx         # imm = 0x4000000
   1c1c9: 41 89 4d 04                  	movl	%ecx, 4(%r13)
; 			for (j = 0; j < vlen; j++, v++, m++) {
   1c1cd: 85 c0                        	testl	%eax, %eax
   1c1cf: 0f 84 47 e0 ff ff            	je	0x1a21c <bpf_object_load.constprop.0+0x4fc>
   1c1d5: 83 e8 01                     	subl	$1, %eax
   1c1d8: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   1c1dc: 4d 8d 6c 85 18               	leaq	24(%r13,%rax,4), %r13
; 				m->offset = v->offset * 8;
   1c1e1: 41 8b 46 04                  	movl	4(%r14), %eax
; 				m->type = v->type;
   1c1e5: 41 8b 36                     	movl	(%r14), %esi
; 				vt = (void *)btf__type_by_id(btf, v->type);
   1c1e8: 4c 89 ff                     	movq	%r15, %rdi
; 			for (j = 0; j < vlen; j++, v++, m++) {
   1c1eb: 49 83 c6 0c                  	addq	$12, %r14
; 				m->offset = v->offset * 8;
   1c1ef: c1 e0 03                     	shll	$3, %eax
; 				m->type = v->type;
   1c1f2: 41 89 76 f8                  	movl	%esi, -8(%r14)
; 				m->offset = v->offset * 8;
   1c1f6: 41 89 46 fc                  	movl	%eax, -4(%r14)
; 				vt = (void *)btf__type_by_id(btf, v->type);
   1c1fa: e8 a1 dd 00 00               	callq	0x29fa0 <btf__type_by_id>
; 				m->name_off = vt->name_off;
   1c1ff: 8b 00                        	movl	(%rax), %eax
   1c201: 41 89 46 f4                  	movl	%eax, -12(%r14)
; 			for (j = 0; j < vlen; j++, v++, m++) {
   1c205: 4d 39 ee                     	cmpq	%r13, %r14
   1c208: 75 d7                        	jne	0x1c1e1 <bpf_object_load.constprop.0+0x24c1>
   1c20a: e9 0d e0 ff ff               	jmp	0x1a21c <bpf_object_load.constprop.0+0x4fc>
; 		errno = -PTR_ERR(ptr);
   1c20f: f7 db                        	negl	%ebx
   1c211: 89 18                        	movl	%ebx, (%rax)
   1c213: e9 f6 f3 ff ff               	jmp	0x1b60e <bpf_object_load.constprop.0+0x18ee>
; 		err = btf_load_into_kernel(kern_btf, obj->log_buf, obj->log_size,
   1c218: 41 8b 86 68 01 00 00         	movl	360(%r14), %eax
   1c21f: 31 c9                        	xorl	%ecx, %ecx
   1c221: 4c 89 ff                     	movq	%r15, %rdi
   1c224: 49 8b 96 60 01 00 00         	movq	352(%r14), %rdx
   1c22b: 49 8b b6 58 01 00 00         	movq	344(%r14), %rsi
   1c232: 85 c0                        	testl	%eax, %eax
   1c234: 0f 95 c1                     	setne	%cl
   1c237: e8 04 ed 00 00               	callq	0x2af40 <btf_load_into_kernel>
   1c23c: 41 89 c4                     	movl	%eax, %r12d
; 		if (!err) {
   1c23f: 85 c0                        	testl	%eax, %eax
   1c241: 0f 84 f4 fe ff ff            	je	0x1c13b <bpf_object_load.constprop.0+0x241b>
; 		btf__free(kern_btf);
   1c247: 4c 89 ff                     	movq	%r15, %rdi
   1c24a: e8 a1 e5 00 00               	callq	0x2a7f0 <btf__free>
; 	if (err) {
   1c24f: e9 bf e0 ff ff               	jmp	0x1a313 <bpf_object_load.constprop.0+0x5f3>
; 	id = find_ksym_btf_id(obj, ext->name, BTF_KIND_VAR, &btf, &mod_btf);
   1c254: 48 8b 73 10                  	movq	16(%rbx), %rsi
   1c258: 4c 8b 04 24                  	movq	(%rsp), %r8
   1c25c: ba 0e 00 00 00               	movl	$14, %edx
   1c261: 4c 89 f7                     	movq	%r14, %rdi
   1c264: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   1c269: e8 f2 19 ff ff               	callq	0xdc60 <find_ksym_btf_id.constprop.0>
   1c26e: 41 89 c7                     	movl	%eax, %r15d
; 	if (id < 0) {
   1c271: 85 c0                        	testl	%eax, %eax
   1c273: 79 74                        	jns	0x1c2e9 <bpf_object_load.constprop.0+0x25c9>
; 		if (id == -ESRCH && ext->is_weak)
   1c275: 83 f8 fd                     	cmpl	$-3, %eax
   1c278: 75 0a                        	jne	0x1c284 <bpf_object_load.constprop.0+0x2564>
   1c27a: 80 7b 19 00                  	cmpb	$0, 25(%rbx)
   1c27e: 0f 85 11 fe ff ff            	jne	0x1c095 <bpf_object_load.constprop.0+0x2375>
; 		pr_warn("extern (var ksym) '%s': not found in kernel BTF\n",
   1c284: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1c288: 48 8d 35 09 bd 01 00         	leaq	113929(%rip), %rsi      # 0x37f98 <strs.2+0x5108>
   1c28f: 31 ff                        	xorl	%edi, %edi
   1c291: 31 c0                        	xorl	%eax, %eax
; 			return -EINVAL;
   1c293: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("extern (var ksym) '%s': not found in kernel BTF\n",
   1c299: e8 32 be fe ff               	callq	0x80d0 <libbpf_print>
; 		return id;
   1c29e: e9 0d e5 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 	return (kflag << 31) | (kind << 24) | vlen;
   1c2a3: 0f b7 c0                     	movzwl	%ax, %eax
   1c2a6: 0d 00 00 00 06               	orl	$100663296, %eax        # imm = 0x6000000
   1c2ab: 41 89 45 04                  	movl	%eax, 4(%r13)
; 			t->info = btf_type_info(btf_kind(t), btf_vlen(t), false);
   1c2af: e9 68 df ff ff               	jmp	0x1a21c <bpf_object_load.constprop.0+0x4fc>
; 		errno = -PTR_ERR(ptr);
   1c2b4: 44 89 f8                     	movl	%r15d, %eax
   1c2b7: f7 d8                        	negl	%eax
   1c2b9: 89 02                        	movl	%eax, (%rdx)
   1c2bb: e9 f8 fd ff ff               	jmp	0x1c0b8 <bpf_object_load.constprop.0+0x2398>
; 		pr_warn("object '%s': load can't be attempted twice\n", obj->name);
   1c2c0: 48 89 fa                     	movq	%rdi, %rdx
   1c2c3: 48 8d 35 a6 ba 01 00         	leaq	113318(%rip), %rsi      # 0x37d70 <strs.2+0x4ee0>
   1c2ca: 31 ff                        	xorl	%edi, %edi
   1c2cc: 31 c0                        	xorl	%eax, %eax
   1c2ce: e8 fd bd fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   1c2d3: e8 18 94 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   1c2d8: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   1c2de: c7 00 16 00 00 00            	movl	$22, (%rax)
   1c2e4: e9 c0 e5 ff ff               	jmp	0x1a8a9 <bpf_object_load.constprop.0+0xb89>
; 	targ_var = btf__type_by_id(btf, id);
   1c2e9: 48 8b bc 24 a0 00 00 00      	movq	160(%rsp), %rdi
   1c2f1: 89 c6                        	movl	%eax, %esi
; 	local_type_id = ext->ksym.type_id;
   1c2f3: 44 8b 6b 30                  	movl	48(%rbx), %r13d
; 	targ_var = btf__type_by_id(btf, id);
   1c2f7: e8 a4 dc 00 00               	callq	0x29fa0 <btf__type_by_id>
; 	targ_var_name = btf__name_by_offset(btf, targ_var->name_off);
   1c2fc: 48 8b bc 24 a0 00 00 00      	movq	160(%rsp), %rdi
   1c304: 8b 30                        	movl	(%rax), %esi
; 	targ_var = btf__type_by_id(btf, id);
   1c306: 49 89 c4                     	movq	%rax, %r12
; 	targ_var_name = btf__name_by_offset(btf, targ_var->name_off);
   1c309: e8 e2 f7 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 	targ_type = skip_mods_and_typedefs(btf, targ_var->type, &targ_type_id);
   1c30e: 41 8b 74 24 08               	movl	8(%r12), %esi
   1c313: 48 8b bc 24 a0 00 00 00      	movq	160(%rsp), %rdi
   1c31b: 48 8d 94 24 94 00 00 00      	leaq	148(%rsp), %rdx
; 	targ_var_name = btf__name_by_offset(btf, targ_var->name_off);
   1c323: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	targ_type = skip_mods_and_typedefs(btf, targ_var->type, &targ_type_id);
   1c328: e8 43 f2 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	return __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id, 32);
   1c32d: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1c334: 48 8b 94 24 a0 00 00 00      	movq	160(%rsp), %rdx
   1c33c: 44 89 ee                     	movl	%r13d, %esi
; 	targ_type = skip_mods_and_typedefs(btf, targ_var->type, &targ_type_id);
   1c33f: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	err = bpf_core_types_are_compat(obj->btf, local_type_id,
   1c344: 8b 84 24 94 00 00 00         	movl	148(%rsp), %eax
; 	return __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id, 32);
   1c34b: 41 b8 20 00 00 00            	movl	$32, %r8d
   1c351: 89 c1                        	movl	%eax, %ecx
; 	err = bpf_core_types_are_compat(obj->btf, local_type_id,
   1c353: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 	return __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id, 32);
   1c357: e8 34 56 00 00               	callq	0x21990 <__bpf_core_types_are_compat>
; 	if (err <= 0) {
   1c35c: 85 c0                        	testl	%eax, %eax
   1c35e: 0f 8e f3 00 00 00            	jle	0x1c457 <bpf_object_load.constprop.0+0x2737>
; 	ext->ksym.kernel_btf_obj_fd = mod_btf ? mod_btf->fd : 0;
   1c364: 48 8b 94 24 98 00 00 00      	movq	152(%rsp), %rdx
; 	ext->is_set = true;
   1c36c: c6 43 18 01                  	movb	$1, 24(%rbx)
; 	ext->ksym.kernel_btf_obj_fd = mod_btf ? mod_btf->fd : 0;
   1c370: 31 c0                        	xorl	%eax, %eax
   1c372: 48 85 d2                     	testq	%rdx, %rdx
   1c375: 74 03                        	je	0x1c37a <bpf_object_load.constprop.0+0x265a>
   1c377: 8b 42 14                     	movl	20(%rdx), %eax
   1c37a: 89 43 28                     	movl	%eax, 40(%rbx)
; 	return BTF_INFO_KIND(t->info);
   1c37d: 41 0f b6 7c 24 07            	movzbl	7(%r12), %edi
; 	pr_debug("extern (var ksym) '%s': resolved to [%d] %s %s\n",
   1c383: 44 89 f9                     	movl	%r15d, %ecx
   1c386: 48 8d 35 b3 bc 01 00         	leaq	113843(%rip), %rsi      # 0x38040 <strs.2+0x51b0>
; 	ext->ksym.kernel_btf_id = id;
   1c38d: 44 89 7b 2c                  	movl	%r15d, 44(%rbx)
; 	return __btf_kind_str(btf_kind(t));
   1c391: 83 e7 1f                     	andl	$31, %edi
   1c394: e8 f7 9f fe ff               	callq	0x6390 <__btf_kind_str>
; 	pr_debug("extern (var ksym) '%s': resolved to [%d] %s %s\n",
   1c399: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1c39d: 4c 8b 4c 24 10               	movq	16(%rsp), %r9
   1c3a2: bf 02 00 00 00               	movl	$2, %edi
; 	return __btf_kind_str(btf_kind(t));
   1c3a7: 49 89 c0                     	movq	%rax, %r8
; 	pr_debug("extern (var ksym) '%s': resolved to [%d] %s %s\n",
   1c3aa: 31 c0                        	xorl	%eax, %eax
   1c3ac: e8 1f bd fe ff               	callq	0x80d0 <libbpf_print>
   1c3b1: e9 df fc ff ff               	jmp	0x1c095 <bpf_object_load.constprop.0+0x2375>
; 				enum64_placeholder_id = btf__add_int(btf, "enum64_placeholder", 1, 0);
   1c3b6: 31 c9                        	xorl	%ecx, %ecx
   1c3b8: ba 01 00 00 00               	movl	$1, %edx
   1c3bd: 48 8d 35 9c 5f 01 00         	leaq	90012(%rip), %rsi       # 0x32360 <_IO_stdin_used+0x2360>
   1c3c4: 4c 89 ff                     	movq	%r15, %rdi
   1c3c7: e8 54 fe 00 00               	callq	0x2c220 <btf__add_int>
   1c3cc: 41 89 c4                     	movl	%eax, %r12d
; 				if (enum64_placeholder_id < 0)
   1c3cf: 85 c0                        	testl	%eax, %eax
   1c3d1: 0f 88 2d 01 00 00            	js	0x1c504 <bpf_object_load.constprop.0+0x27e4>
; 				t = (struct btf_type *)btf__type_by_id(btf, i);
   1c3d7: 89 de                        	movl	%ebx, %esi
   1c3d9: 4c 89 ff                     	movq	%r15, %rdi
   1c3dc: e8 bf db 00 00               	callq	0x29fa0 <btf__type_by_id>
   1c3e1: 49 89 c5                     	movq	%rax, %r13
; 	return BTF_INFO_VLEN(t->info);
   1c3e4: 8b 40 04                     	movl	4(%rax), %eax
   1c3e7: e9 d2 f9 ff ff               	jmp	0x1bdbe <bpf_object_load.constprop.0+0x209e>
; 				pr_warn("prog '%s': relo #%d: failed to relocate: %d\n",
   1c3ec: 4d 89 e5                     	movq	%r12, %r13
   1c3ef: 41 89 c0                     	movl	%eax, %r8d
   1c3f2: 41 89 c4                     	movl	%eax, %r12d
   1c3f5: 44 89 f9                     	movl	%r15d, %ecx
   1c3f8: 49 8b 55 00                  	movq	(%r13), %rdx
   1c3fc: 48 8d 35 4d c2 01 00         	leaq	115277(%rip), %rsi      # 0x38650 <strs.2+0x57c0>
   1c403: 31 ff                        	xorl	%edi, %edi
   1c405: 31 c0                        	xorl	%eax, %eax
   1c407: e8 c4 bc fe ff               	callq	0x80d0 <libbpf_print>
; 				goto out;
   1c40c: e9 21 f3 ff ff               	jmp	0x1b732 <bpf_object_load.constprop.0+0x1a12>
; 	ext->is_set = true;
   1c411: c6 43 18 01                  	movb	$1, 24(%rbx)
; 	ext->ksym.btf_fd_idx = mod_btf ? mod_btf->fd_array_idx : 0;
   1c415: 31 c0                        	xorl	%eax, %eax
; 	ext->ksym.kernel_btf_id = kfunc_id;
   1c417: 44 89 7b 2c                  	movl	%r15d, 44(%rbx)
; 	ext->ksym.btf_fd_idx = mod_btf ? mod_btf->fd_array_idx : 0;
   1c41b: e9 57 fc ff ff               	jmp	0x1c077 <bpf_object_load.constprop.0+0x2357>
; 		pr_warn("extern (func ksym) '%s': func_proto [%d] incompatible with kernel [%d]\n",
   1c420: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1c424: 44 89 e1                     	movl	%r12d, %ecx
   1c427: 45 89 e8                     	movl	%r13d, %r8d
   1c42a: 31 ff                        	xorl	%edi, %edi
   1c42c: 48 8d 35 8d bc 01 00         	leaq	113805(%rip), %rsi      # 0x380c0 <strs.2+0x5230>
   1c433: 31 c0                        	xorl	%eax, %eax
; 			return -EINVAL;
   1c435: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("extern (func ksym) '%s': func_proto [%d] incompatible with kernel [%d]\n",
   1c43b: e8 90 bc fe ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   1c440: e9 6b e3 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1c445: 0f 1f 00                     	nopl	(%rax)
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   1c448: b8 08 00 00 00               	movl	$8, %eax
   1c44d: e9 58 fa ff ff               	jmp	0x1beaa <bpf_object_load.constprop.0+0x218a>
; }
   1c452: e8 a9 93 fe ff               	callq	0x5800 <.plt.sec+0x190>
; 		local_type = btf__type_by_id(obj->btf, local_type_id);
   1c457: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1c45e: 44 89 ee                     	movl	%r13d, %esi
   1c461: e8 3a db 00 00               	callq	0x29fa0 <btf__type_by_id>
; 		local_name = btf__name_by_offset(obj->btf, local_type->name_off);
   1c466: 49 8b be 10 01 00 00         	movq	272(%r14), %rdi
   1c46d: 8b 30                        	movl	(%rax), %esi
; 		local_type = btf__type_by_id(obj->btf, local_type_id);
   1c46f: 48 89 c5                     	movq	%rax, %rbp
; 		local_name = btf__name_by_offset(obj->btf, local_type->name_off);
   1c472: e8 79 f6 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 		targ_name = btf__name_by_offset(btf, targ_type->name_off);
   1c477: 4c 8b 7c 24 18               	movq	24(%rsp), %r15
   1c47c: 48 8b bc 24 a0 00 00 00      	movq	160(%rsp), %rdi
; 		local_name = btf__name_by_offset(obj->btf, local_type->name_off);
   1c484: 49 89 c4                     	movq	%rax, %r12
; 		targ_name = btf__name_by_offset(btf, targ_type->name_off);
   1c487: 41 8b 37                     	movl	(%r15), %esi
   1c48a: e8 61 f6 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 	return BTF_INFO_KIND(t->info);
   1c48f: 41 0f b6 7f 07               	movzbl	7(%r15), %edi
; 		pr_warn("extern (var ksym) '%s': incompatible types, expected [%d] %s %s, but kernel has [%d] %s %s\n",
   1c494: 4d 89 e1                     	movq	%r12, %r9
; 			return -EINVAL;
   1c497: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		targ_name = btf__name_by_offset(btf, targ_type->name_off);
   1c49d: 48 89 c6                     	movq	%rax, %rsi
; 	return __btf_kind_str(btf_kind(t));
   1c4a0: 83 e7 1f                     	andl	$31, %edi
   1c4a3: e8 e8 9e fe ff               	callq	0x6390 <__btf_kind_str>
; 	return BTF_INFO_KIND(t->info);
   1c4a8: 0f b6 7d 07                  	movzbl	7(%rbp), %edi
; 	return __btf_kind_str(btf_kind(t));
   1c4ac: 48 89 c1                     	movq	%rax, %rcx
   1c4af: 83 e7 1f                     	andl	$31, %edi
   1c4b2: e8 d9 9e fe ff               	callq	0x6390 <__btf_kind_str>
; 		pr_warn("extern (var ksym) '%s': incompatible types, expected [%d] %s %s, but kernel has [%d] %s %s\n",
   1c4b7: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1c4bb: 41 53                        	pushq	%r11
   1c4bd: 31 ff                        	xorl	%edi, %edi
   1c4bf: 56                           	pushq	%rsi
; 	return __btf_kind_str(btf_kind(t));
   1c4c0: 49 89 c0                     	movq	%rax, %r8
; 		pr_warn("extern (var ksym) '%s': incompatible types, expected [%d] %s %s, but kernel has [%d] %s %s\n",
   1c4c3: 48 8d 35 0e bb 01 00         	leaq	113422(%rip), %rsi      # 0x37fd8 <strs.2+0x5148>
   1c4ca: 51                           	pushq	%rcx
   1c4cb: 8b 44 24 38                  	movl	56(%rsp), %eax
   1c4cf: 44 89 e9                     	movl	%r13d, %ecx
   1c4d2: 50                           	pushq	%rax
   1c4d3: 31 c0                        	xorl	%eax, %eax
   1c4d5: e8 f6 bb fe ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   1c4da: 48 83 c4 20                  	addq	$32, %rsp
   1c4de: e9 cd e2 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
; 			pr_warn("extern (func ksym) '%s': module BTF fd index %d too big to fit in bpf_insn offset\n",
   1c4e3: 48 8b 53 10                  	movq	16(%rbx), %rdx
   1c4e7: 31 c9                        	xorl	%ecx, %ecx
   1c4e9: 48 8d 35 20 bc 01 00         	leaq	113696(%rip), %rsi      # 0x38110 <strs.2+0x5280>
   1c4f0: 31 ff                        	xorl	%edi, %edi
   1c4f2: 31 c0                        	xorl	%eax, %eax
; 			return -EINVAL;
   1c4f4: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("extern (func ksym) '%s': module BTF fd index %d too big to fit in bpf_insn offset\n",
   1c4fa: e8 d1 bb fe ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   1c4ff: e9 ac e2 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1c504: 4c 8b 74 24 18               	movq	24(%rsp), %r14
   1c509: e9 a2 e2 ff ff               	jmp	0x1a7b0 <bpf_object_load.constprop.0+0xa90>
   1c50e: 66 90                        	nop

000000000001c510 <bpf_object__load>:
; {
   1c510: f3 0f 1e fa                  	endbr64
; 	return bpf_object_load(obj, 0, NULL);
   1c514: e9 07 d8 ff ff               	jmp	0x19d20 <bpf_object_load.constprop.0>
   1c519: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001c520 <validate_map_op>:
; 	if (map->fd <= 0)
   1c520: 44 8b 47 18                  	movl	24(%rdi), %r8d
   1c524: 45 85 c0                     	testl	%r8d, %r8d
   1c527: 0f 8e f1 00 00 00            	jle	0x1c61e <validate_map_op+0xfe>
; {
   1c52d: 48 83 ec 18                  	subq	$24, %rsp
; 	if (map->def.key_size != key_sz) {
   1c531: 8b 47 34                     	movl	52(%rdi), %eax
   1c534: 49 89 c0                     	movq	%rax, %r8
   1c537: 48 39 f0                     	cmpq	%rsi, %rax
   1c53a: 0f 85 bd 00 00 00            	jne	0x1c5fd <validate_map_op+0xdd>
; 	if (!check_value_sz)
   1c540: 84 c9                        	testb	%cl, %cl
   1c542: 74 1e                        	je	0x1c562 <validate_map_op+0x42>
; 	switch (map->def.type) {
   1c544: 8b 47 30                     	movl	48(%rdi), %eax
   1c547: 83 f8 15                     	cmpl	$21, %eax
   1c54a: 77 0b                        	ja	0x1c557 <validate_map_op+0x37>
   1c54c: b9 60 04 20 00               	movl	$2098272, %ecx          # imm = 0x200460
   1c551: 48 0f a3 c1                  	btq	%rax, %rcx
   1c555: 72 19                        	jb	0x1c570 <validate_map_op+0x50>
; 		if (map->def.value_size != value_sz) {
   1c557: 8b 47 38                     	movl	56(%rdi), %eax
   1c55a: 49 89 c0                     	movq	%rax, %r8
   1c55d: 48 39 c2                     	cmpq	%rax, %rdx
   1c560: 75 77                        	jne	0x1c5d9 <validate_map_op+0xb9>
; 		return 0;
   1c562: 31 c0                        	xorl	%eax, %eax
; }
   1c564: 48 83 c4 18                  	addq	$24, %rsp
   1c568: c3                           	retq
   1c569: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	tmp_cpus = READ_ONCE(cpus);
   1c570: 8b 05 aa ac 02 00            	movl	175274(%rip), %eax      # 0x47220 <cpus.16>
; 	if (tmp_cpus > 0)
   1c576: 85 c0                        	testl	%eax, %eax
   1c578: 7e 46                        	jle	0x1c5c0 <validate_map_op+0xa0>
; 		size_t elem_sz = roundup(map->def.value_size, 8);
   1c57a: 8b 77 38                     	movl	56(%rdi), %esi
; 		if (value_sz != num_cpu * elem_sz) {
   1c57d: 48 63 c8                     	movslq	%eax, %rcx
; 		size_t elem_sz = roundup(map->def.value_size, 8);
   1c580: 44 8d 4e 07                  	leal	7(%rsi), %r9d
   1c584: 41 83 e1 f8                  	andl	$-8, %r9d
; 		if (value_sz != num_cpu * elem_sz) {
   1c588: 49 0f af c9                  	imulq	%r9, %rcx
   1c58c: 48 39 ca                     	cmpq	%rcx, %rdx
   1c58f: 74 d1                        	je	0x1c562 <validate_map_op+0x42>
; 			pr_warn("map '%s': unexpected value size %zu provided for per-CPU map, expected %d * %zu = %zd\n",
   1c591: 48 83 ec 08                  	subq	$8, %rsp
   1c595: 4c 8b 57 08                  	movq	8(%rdi), %r10
   1c599: 31 ff                        	xorl	%edi, %edi
   1c59b: 41 89 c0                     	movl	%eax, %r8d
   1c59e: 51                           	pushq	%rcx
   1c59f: 31 c0                        	xorl	%eax, %eax
   1c5a1: 48 89 d1                     	movq	%rdx, %rcx
   1c5a4: 48 8d 35 8d c4 01 00         	leaq	115853(%rip), %rsi      # 0x38a38 <strs.2+0x5ba8>
   1c5ab: 4c 89 d2                     	movq	%r10, %rdx
   1c5ae: e8 1d bb fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   1c5b3: 58                           	popq	%rax
   1c5b4: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   1c5b9: 5a                           	popq	%rdx
   1c5ba: eb a8                        	jmp	0x1c564 <validate_map_op+0x44>
   1c5bc: 0f 1f 40 00                  	nopl	(%rax)
   1c5c0: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
   1c5c5: 48 89 3c 24                  	movq	%rdi, (%rsp)
   1c5c9: e8 52 ce ff ff               	callq	0x19420 <libbpf_num_possible_cpus.part.0>
   1c5ce: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   1c5d3: 48 8b 3c 24                  	movq	(%rsp), %rdi
   1c5d7: eb a1                        	jmp	0x1c57a <validate_map_op+0x5a>
; 			pr_warn("map '%s': unexpected value size %zu provided, expected %u\n",
   1c5d9: 4c 8b 4f 08                  	movq	8(%rdi), %r9
   1c5dd: 48 89 d1                     	movq	%rdx, %rcx
   1c5e0: 31 c0                        	xorl	%eax, %eax
   1c5e2: 48 8d 35 af c4 01 00         	leaq	115887(%rip), %rsi      # 0x38a98 <strs.2+0x5c08>
   1c5e9: 31 ff                        	xorl	%edi, %edi
   1c5eb: 4c 89 ca                     	movq	%r9, %rdx
   1c5ee: e8 dd ba fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   1c5f3: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   1c5f8: e9 67 ff ff ff               	jmp	0x1c564 <validate_map_op+0x44>
; 		pr_warn("map '%s': unexpected key size %zu provided, expected %u\n",
   1c5fd: 48 8b 57 08                  	movq	8(%rdi), %rdx
   1c601: 48 89 f1                     	movq	%rsi, %rcx
   1c604: 31 c0                        	xorl	%eax, %eax
   1c606: 48 8d 35 e3 c3 01 00         	leaq	115683(%rip), %rsi      # 0x389f0 <strs.2+0x5b60>
   1c60d: 31 ff                        	xorl	%edi, %edi
   1c60f: e8 bc ba fe ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   1c614: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   1c619: e9 46 ff ff ff               	jmp	0x1c564 <validate_map_op+0x44>
; 		return -ENOENT;
   1c61e: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
; }
   1c623: c3                           	retq
   1c624: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1c62f: 90                           	nop

000000000001c630 <bpf_map__lookup_elem>:
; {
   1c630: f3 0f 1e fa                  	endbr64
   1c634: 41 56                        	pushq	%r14
   1c636: 4d 89 ce                     	movq	%r9, %r14
   1c639: 41 55                        	pushq	%r13
   1c63b: 49 89 cd                     	movq	%rcx, %r13
; 	err = validate_map_op(map, key_sz, value_sz, true);
   1c63e: b9 01 00 00 00               	movl	$1, %ecx
; {
   1c643: 41 54                        	pushq	%r12
   1c645: 55                           	pushq	%rbp
   1c646: 48 89 f5                     	movq	%rsi, %rbp
   1c649: 48 89 d6                     	movq	%rdx, %rsi
   1c64c: 4c 89 c2                     	movq	%r8, %rdx
   1c64f: 53                           	pushq	%rbx
   1c650: 48 89 fb                     	movq	%rdi, %rbx
; 	err = validate_map_op(map, key_sz, value_sz, true);
   1c653: e8 c8 fe ff ff               	callq	0x1c520 <validate_map_op>
; 	if (err)
   1c658: 85 c0                        	testl	%eax, %eax
   1c65a: 74 34                        	je	0x1c690 <bpf_map__lookup_elem+0x60>
   1c65c: 41 89 c4                     	movl	%eax, %r12d
; 	if (ret < 0)
   1c65f: 78 0f                        	js	0x1c670 <bpf_map__lookup_elem+0x40>
; }
   1c661: 5b                           	popq	%rbx
   1c662: 44 89 e0                     	movl	%r12d, %eax
   1c665: 5d                           	popq	%rbp
   1c666: 41 5c                        	popq	%r12
   1c668: 41 5d                        	popq	%r13
   1c66a: 41 5e                        	popq	%r14
   1c66c: c3                           	retq
   1c66d: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
   1c670: e8 7b 90 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1c675: 44 89 e2                     	movl	%r12d, %edx
   1c678: f7 da                        	negl	%edx
   1c67a: 89 10                        	movl	%edx, (%rax)
; }
   1c67c: 44 89 e0                     	movl	%r12d, %eax
   1c67f: 5b                           	popq	%rbx
   1c680: 5d                           	popq	%rbp
   1c681: 41 5c                        	popq	%r12
   1c683: 41 5d                        	popq	%r13
   1c685: 41 5e                        	popq	%r14
   1c687: c3                           	retq
   1c688: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	return bpf_map_lookup_elem_flags(map->fd, key, value, flags);
   1c690: 8b 7b 18                     	movl	24(%rbx), %edi
   1c693: 4c 89 f1                     	movq	%r14, %rcx
; }
   1c696: 5b                           	popq	%rbx
; 	return bpf_map_lookup_elem_flags(map->fd, key, value, flags);
   1c697: 4c 89 ea                     	movq	%r13, %rdx
   1c69a: 48 89 ee                     	movq	%rbp, %rsi
; }
   1c69d: 5d                           	popq	%rbp
   1c69e: 41 5c                        	popq	%r12
   1c6a0: 41 5d                        	popq	%r13
   1c6a2: 41 5e                        	popq	%r14
; 	return bpf_map_lookup_elem_flags(map->fd, key, value, flags);
   1c6a4: e9 67 9e 00 00               	jmp	0x26510 <bpf_map_lookup_elem_flags>
   1c6a9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001c6b0 <bpf_map__update_elem>:
; {
   1c6b0: f3 0f 1e fa                  	endbr64
   1c6b4: 41 56                        	pushq	%r14
   1c6b6: 4d 89 ce                     	movq	%r9, %r14
   1c6b9: 41 55                        	pushq	%r13
   1c6bb: 49 89 cd                     	movq	%rcx, %r13
; 	err = validate_map_op(map, key_sz, value_sz, true);
   1c6be: b9 01 00 00 00               	movl	$1, %ecx
; {
   1c6c3: 41 54                        	pushq	%r12
   1c6c5: 55                           	pushq	%rbp
   1c6c6: 48 89 f5                     	movq	%rsi, %rbp
   1c6c9: 48 89 d6                     	movq	%rdx, %rsi
   1c6cc: 4c 89 c2                     	movq	%r8, %rdx
   1c6cf: 53                           	pushq	%rbx
   1c6d0: 48 89 fb                     	movq	%rdi, %rbx
; 	err = validate_map_op(map, key_sz, value_sz, true);
   1c6d3: e8 48 fe ff ff               	callq	0x1c520 <validate_map_op>
; 	if (err)
   1c6d8: 85 c0                        	testl	%eax, %eax
   1c6da: 74 34                        	je	0x1c710 <bpf_map__update_elem+0x60>
   1c6dc: 41 89 c4                     	movl	%eax, %r12d
; 	if (ret < 0)
   1c6df: 78 0f                        	js	0x1c6f0 <bpf_map__update_elem+0x40>
; }
   1c6e1: 5b                           	popq	%rbx
   1c6e2: 44 89 e0                     	movl	%r12d, %eax
   1c6e5: 5d                           	popq	%rbp
   1c6e6: 41 5c                        	popq	%r12
   1c6e8: 41 5d                        	popq	%r13
   1c6ea: 41 5e                        	popq	%r14
   1c6ec: c3                           	retq
   1c6ed: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
   1c6f0: e8 fb 8f fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1c6f5: 44 89 e2                     	movl	%r12d, %edx
   1c6f8: f7 da                        	negl	%edx
   1c6fa: 89 10                        	movl	%edx, (%rax)
; }
   1c6fc: 44 89 e0                     	movl	%r12d, %eax
   1c6ff: 5b                           	popq	%rbx
   1c700: 5d                           	popq	%rbp
   1c701: 41 5c                        	popq	%r12
   1c703: 41 5d                        	popq	%r13
   1c705: 41 5e                        	popq	%r14
   1c707: c3                           	retq
   1c708: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	return bpf_map_update_elem(map->fd, key, value, flags);
   1c710: 8b 7b 18                     	movl	24(%rbx), %edi
   1c713: 4c 89 f1                     	movq	%r14, %rcx
; }
   1c716: 5b                           	popq	%rbx
; 	return bpf_map_update_elem(map->fd, key, value, flags);
   1c717: 4c 89 ea                     	movq	%r13, %rdx
   1c71a: 48 89 ee                     	movq	%rbp, %rsi
; }
   1c71d: 5d                           	popq	%rbp
   1c71e: 41 5c                        	popq	%r12
   1c720: 41 5d                        	popq	%r13
   1c722: 41 5e                        	popq	%r14
; 	return bpf_map_update_elem(map->fd, key, value, flags);
   1c724: e9 c7 9c 00 00               	jmp	0x263f0 <bpf_map_update_elem>
   1c729: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001c730 <bpf_map__delete_elem>:
; {
   1c730: f3 0f 1e fa                  	endbr64
   1c734: 41 55                        	pushq	%r13
   1c736: 49 89 cd                     	movq	%rcx, %r13
; 	err = validate_map_op(map, key_sz, 0, false /* check_value_sz */);
   1c739: 31 c9                        	xorl	%ecx, %ecx
; {
   1c73b: 41 54                        	pushq	%r12
   1c73d: 55                           	pushq	%rbp
   1c73e: 48 89 f5                     	movq	%rsi, %rbp
   1c741: 48 89 d6                     	movq	%rdx, %rsi
; 	err = validate_map_op(map, key_sz, 0, false /* check_value_sz */);
   1c744: 31 d2                        	xorl	%edx, %edx
; {
   1c746: 53                           	pushq	%rbx
   1c747: 48 89 fb                     	movq	%rdi, %rbx
   1c74a: 48 83 ec 08                  	subq	$8, %rsp
; 	err = validate_map_op(map, key_sz, 0, false /* check_value_sz */);
   1c74e: e8 cd fd ff ff               	callq	0x1c520 <validate_map_op>
; 	if (err)
   1c753: 85 c0                        	testl	%eax, %eax
   1c755: 74 39                        	je	0x1c790 <bpf_map__delete_elem+0x60>
   1c757: 41 89 c4                     	movl	%eax, %r12d
; 	if (ret < 0)
   1c75a: 78 14                        	js	0x1c770 <bpf_map__delete_elem+0x40>
; }
   1c75c: 48 83 c4 08                  	addq	$8, %rsp
   1c760: 44 89 e0                     	movl	%r12d, %eax
   1c763: 5b                           	popq	%rbx
   1c764: 5d                           	popq	%rbp
   1c765: 41 5c                        	popq	%r12
   1c767: 41 5d                        	popq	%r13
   1c769: c3                           	retq
   1c76a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -ret;
   1c770: e8 7b 8f fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1c775: 44 89 e2                     	movl	%r12d, %edx
   1c778: f7 da                        	negl	%edx
   1c77a: 89 10                        	movl	%edx, (%rax)
; }
   1c77c: 48 83 c4 08                  	addq	$8, %rsp
   1c780: 44 89 e0                     	movl	%r12d, %eax
   1c783: 5b                           	popq	%rbx
   1c784: 5d                           	popq	%rbp
   1c785: 41 5c                        	popq	%r12
   1c787: 41 5d                        	popq	%r13
   1c789: c3                           	retq
   1c78a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return bpf_map_delete_elem_flags(map->fd, key, flags);
   1c790: 8b 7b 18                     	movl	24(%rbx), %edi
; }
   1c793: 48 83 c4 08                  	addq	$8, %rsp
; 	return bpf_map_delete_elem_flags(map->fd, key, flags);
   1c797: 4c 89 ea                     	movq	%r13, %rdx
   1c79a: 48 89 ee                     	movq	%rbp, %rsi
; }
   1c79d: 5b                           	popq	%rbx
   1c79e: 5d                           	popq	%rbp
   1c79f: 41 5c                        	popq	%r12
   1c7a1: 41 5d                        	popq	%r13
; 	return bpf_map_delete_elem_flags(map->fd, key, flags);
   1c7a3: e9 98 9f 00 00               	jmp	0x26740 <bpf_map_delete_elem_flags>
   1c7a8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000001c7b0 <bpf_map__lookup_and_delete_elem>:
; {
   1c7b0: f3 0f 1e fa                  	endbr64
   1c7b4: 41 56                        	pushq	%r14
   1c7b6: 4d 89 ce                     	movq	%r9, %r14
   1c7b9: 41 55                        	pushq	%r13
   1c7bb: 49 89 cd                     	movq	%rcx, %r13
; 	err = validate_map_op(map, key_sz, value_sz, true);
   1c7be: b9 01 00 00 00               	movl	$1, %ecx
; {
   1c7c3: 41 54                        	pushq	%r12
   1c7c5: 55                           	pushq	%rbp
   1c7c6: 48 89 f5                     	movq	%rsi, %rbp
   1c7c9: 48 89 d6                     	movq	%rdx, %rsi
   1c7cc: 4c 89 c2                     	movq	%r8, %rdx
   1c7cf: 53                           	pushq	%rbx
   1c7d0: 48 89 fb                     	movq	%rdi, %rbx
; 	err = validate_map_op(map, key_sz, value_sz, true);
   1c7d3: e8 48 fd ff ff               	callq	0x1c520 <validate_map_op>
; 	if (err)
   1c7d8: 85 c0                        	testl	%eax, %eax
   1c7da: 74 34                        	je	0x1c810 <bpf_map__lookup_and_delete_elem+0x60>
   1c7dc: 41 89 c4                     	movl	%eax, %r12d
; 	if (ret < 0)
   1c7df: 78 0f                        	js	0x1c7f0 <bpf_map__lookup_and_delete_elem+0x40>
; }
   1c7e1: 5b                           	popq	%rbx
   1c7e2: 44 89 e0                     	movl	%r12d, %eax
   1c7e5: 5d                           	popq	%rbp
   1c7e6: 41 5c                        	popq	%r12
   1c7e8: 41 5d                        	popq	%r13
   1c7ea: 41 5e                        	popq	%r14
   1c7ec: c3                           	retq
   1c7ed: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
   1c7f0: e8 fb 8e fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1c7f5: 44 89 e2                     	movl	%r12d, %edx
   1c7f8: f7 da                        	negl	%edx
   1c7fa: 89 10                        	movl	%edx, (%rax)
; }
   1c7fc: 44 89 e0                     	movl	%r12d, %eax
   1c7ff: 5b                           	popq	%rbx
   1c800: 5d                           	popq	%rbp
   1c801: 41 5c                        	popq	%r12
   1c803: 41 5d                        	popq	%r13
   1c805: 41 5e                        	popq	%r14
   1c807: c3                           	retq
   1c808: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	return bpf_map_lookup_and_delete_elem_flags(map->fd, key, value, flags);
   1c810: 8b 7b 18                     	movl	24(%rbx), %edi
   1c813: 4c 89 f1                     	movq	%r14, %rcx
; }
   1c816: 5b                           	popq	%rbx
; 	return bpf_map_lookup_and_delete_elem_flags(map->fd, key, value, flags);
   1c817: 4c 89 ea                     	movq	%r13, %rdx
   1c81a: 48 89 ee                     	movq	%rbp, %rsi
; }
   1c81d: 5d                           	popq	%rbp
   1c81e: 41 5c                        	popq	%r12
   1c820: 41 5d                        	popq	%r13
   1c822: 41 5e                        	popq	%r14
; 	return bpf_map_lookup_and_delete_elem_flags(map->fd, key, value, flags);
   1c824: e9 07 9e 00 00               	jmp	0x26630 <bpf_map_lookup_and_delete_elem_flags>
   1c829: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001c830 <bpf_map__get_next_key>:
; {
   1c830: f3 0f 1e fa                  	endbr64
   1c834: 41 55                        	pushq	%r13
   1c836: 49 89 d5                     	movq	%rdx, %r13
; 	err = validate_map_op(map, key_sz, 0, false /* check_value_sz */);
   1c839: 31 d2                        	xorl	%edx, %edx
; {
   1c83b: 41 54                        	pushq	%r12
   1c83d: 55                           	pushq	%rbp
   1c83e: 48 89 f5                     	movq	%rsi, %rbp
   1c841: 48 89 ce                     	movq	%rcx, %rsi
; 	err = validate_map_op(map, key_sz, 0, false /* check_value_sz */);
   1c844: 31 c9                        	xorl	%ecx, %ecx
; {
   1c846: 53                           	pushq	%rbx
   1c847: 48 89 fb                     	movq	%rdi, %rbx
   1c84a: 48 83 ec 08                  	subq	$8, %rsp
; 	err = validate_map_op(map, key_sz, 0, false /* check_value_sz */);
   1c84e: e8 cd fc ff ff               	callq	0x1c520 <validate_map_op>
; 	if (err)
   1c853: 85 c0                        	testl	%eax, %eax
   1c855: 74 39                        	je	0x1c890 <bpf_map__get_next_key+0x60>
   1c857: 41 89 c4                     	movl	%eax, %r12d
; 	if (ret < 0)
   1c85a: 78 14                        	js	0x1c870 <bpf_map__get_next_key+0x40>
; }
   1c85c: 48 83 c4 08                  	addq	$8, %rsp
   1c860: 44 89 e0                     	movl	%r12d, %eax
   1c863: 5b                           	popq	%rbx
   1c864: 5d                           	popq	%rbp
   1c865: 41 5c                        	popq	%r12
   1c867: 41 5d                        	popq	%r13
   1c869: c3                           	retq
   1c86a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -ret;
   1c870: e8 7b 8e fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1c875: 44 89 e2                     	movl	%r12d, %edx
   1c878: f7 da                        	negl	%edx
   1c87a: 89 10                        	movl	%edx, (%rax)
; }
   1c87c: 48 83 c4 08                  	addq	$8, %rsp
   1c880: 44 89 e0                     	movl	%r12d, %eax
   1c883: 5b                           	popq	%rbx
   1c884: 5d                           	popq	%rbp
   1c885: 41 5c                        	popq	%r12
   1c887: 41 5d                        	popq	%r13
   1c889: c3                           	retq
   1c88a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return bpf_map_get_next_key(map->fd, cur_key, next_key);
   1c890: 8b 7b 18                     	movl	24(%rbx), %edi
; }
   1c893: 48 83 c4 08                  	addq	$8, %rsp
; 	return bpf_map_get_next_key(map->fd, cur_key, next_key);
   1c897: 4c 89 ea                     	movq	%r13, %rdx
   1c89a: 48 89 ee                     	movq	%rbp, %rsi
; }
   1c89d: 5b                           	popq	%rbx
   1c89e: 5d                           	popq	%rbp
   1c89f: 41 5c                        	popq	%r12
   1c8a1: 41 5d                        	popq	%r13
; 	return bpf_map_get_next_key(map->fd, cur_key, next_key);
   1c8a3: e9 28 9f 00 00               	jmp	0x267d0 <bpf_map_get_next_key>
   1c8a8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000001c8b0 <__perf_buffer__new>:
; {
   1c8b0: 41 57                        	pushq	%r15
   1c8b2: 41 56                        	pushq	%r14
   1c8b4: 41 55                        	pushq	%r13
   1c8b6: 41 54                        	pushq	%r12
   1c8b8: 49 89 f4                     	movq	%rsi, %r12
   1c8bb: 55                           	pushq	%rbp
   1c8bc: 53                           	pushq	%rbx
   1c8bd: 48 81 ec 28 01 00 00         	subq	$296, %rsp              # imm = 0x128
   1c8c4: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1c8cd: 48 89 84 24 18 01 00 00      	movq	%rax, 280(%rsp)
   1c8d5: 31 c0                        	xorl	%eax, %eax
; 	bool *online = NULL;
   1c8d7: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	if (page_cnt == 0 || (page_cnt & (page_cnt - 1))) {
   1c8e0: 48 85 f6                     	testq	%rsi, %rsi
   1c8e3: 74 09                        	je	0x1c8ee <__perf_buffer__new+0x3e>
   1c8e5: 48 8d 5e ff                  	leaq	-1(%rsi), %rbx
   1c8e9: 48 21 f3                     	andq	%rsi, %rbx
   1c8ec: 74 4a                        	je	0x1c938 <__perf_buffer__new+0x88>
; 		pr_warn("page count should be power of two, but is %zu\n",
   1c8ee: 4c 89 e2                     	movq	%r12, %rdx
   1c8f1: 48 8d 35 e8 c1 01 00         	leaq	115176(%rip), %rsi      # 0x38ae0 <strs.2+0x5c50>
   1c8f8: 31 ff                        	xorl	%edi, %edi
   1c8fa: 31 c0                        	xorl	%eax, %eax
   1c8fc: e8 cf b7 fe ff               	callq	0x80d0 <libbpf_print>
; 		return ERR_PTR(-EINVAL);
   1c901: 49 c7 c7 ea ff ff ff         	movq	$-22, %r15
; }
   1c908: 48 8b 84 24 18 01 00 00      	movq	280(%rsp), %rax
   1c910: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1c919: 0f 85 8c 05 00 00            	jne	0x1ceab <__perf_buffer__new+0x5fb>
   1c91f: 48 81 c4 28 01 00 00         	addq	$296, %rsp              # imm = 0x128
   1c926: 4c 89 f8                     	movq	%r15, %rax
   1c929: 5b                           	popq	%rbx
   1c92a: 5d                           	popq	%rbp
   1c92b: 41 5c                        	popq	%r12
   1c92d: 41 5d                        	popq	%r13
   1c92f: 41 5e                        	popq	%r14
   1c931: 41 5f                        	popq	%r15
   1c933: c3                           	retq
   1c934: 0f 1f 40 00                  	nopl	(%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1c938: 48 8d 74 24 30               	leaq	48(%rsp), %rsi
   1c93d: 41 89 fd                     	movl	%edi, %r13d
   1c940: b9 0b 00 00 00               	movl	$11, %ecx
   1c945: 48 89 d8                     	movq	%rbx, %rax
   1c948: 48 89 f7                     	movq	%rsi, %rdi
   1c94b: 48 89 d5                     	movq	%rdx, %rbp
; 	err = bpf_obj_get_info_by_fd(map_fd, &map, &map_info_len);
   1c94e: 48 8d 54 24 1c               	leaq	28(%rsp), %rdx
; 	map_info_len = sizeof(map);
   1c953: c7 44 24 1c 58 00 00 00      	movl	$88, 28(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1c95b: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	err = bpf_obj_get_info_by_fd(map_fd, &map, &map_info_len);
   1c95e: 44 89 ef                     	movl	%r13d, %edi
   1c961: e8 5a b2 00 00               	callq	0x27bc0 <bpf_obj_get_info_by_fd>
; 	if (err) {
   1c966: 85 c0                        	testl	%eax, %eax
   1c968: 0f 85 5a 02 00 00            	jne	0x1cbc8 <__perf_buffer__new+0x318>
; 		if (map.type != BPF_MAP_TYPE_PERF_EVENT_ARRAY) {
   1c96e: 83 7c 24 30 04               	cmpl	$4, 48(%rsp)
   1c973: 0f 85 b7 03 00 00            	jne	0x1cd30 <__perf_buffer__new+0x480>
; 	pb = calloc(1, sizeof(*pb));
   1c979: be 50 00 00 00               	movl	$80, %esi
   1c97e: bf 01 00 00 00               	movl	$1, %edi
   1c983: e8 08 90 fe ff               	callq	0x5990 <.plt.sec+0x320>
   1c988: 49 89 c7                     	movq	%rax, %r15
; 	if (!pb)
   1c98b: 48 85 c0                     	testq	%rax, %rax
   1c98e: 0f 84 1c 05 00 00            	je	0x1ceb0 <__perf_buffer__new+0x600>
; 	pb->event_cb = p->event_cb;
   1c994: 48 8b 45 08                  	movq	8(%rbp), %rax
   1c998: 49 89 07                     	movq	%rax, (%r15)
; 	pb->sample_cb = p->sample_cb;
   1c99b: 48 8b 45 10                  	movq	16(%rbp), %rax
   1c99f: 49 89 47 08                  	movq	%rax, 8(%r15)
; 	pb->lost_cb = p->lost_cb;
   1c9a3: 48 8b 45 18                  	movq	24(%rbp), %rax
   1c9a7: 49 89 47 10                  	movq	%rax, 16(%r15)
; 	pb->ctx = p->ctx;
   1c9ab: 48 8b 45 20                  	movq	32(%rbp), %rax
   1c9af: 49 89 47 18                  	movq	%rax, 24(%r15)
; 	pb->page_size = getpagesize();
   1c9b3: e8 18 92 fe ff               	callq	0x5bd0 <.plt.sec+0x560>
; 	pb->map_fd = map_fd;
   1c9b8: 45 89 6f 48                  	movl	%r13d, 72(%r15)
; 	pb->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
   1c9bc: bf 00 00 08 00               	movl	$524288, %edi           # imm = 0x80000
; 	pb->page_size = getpagesize();
   1c9c1: 48 98                        	cltq
   1c9c3: 49 89 47 20                  	movq	%rax, 32(%r15)
; 	pb->mmap_size = pb->page_size * page_cnt;
   1c9c7: 49 0f af c4                  	imulq	%r12, %rax
   1c9cb: 49 89 47 28                  	movq	%rax, 40(%r15)
; 	pb->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
   1c9cf: e8 6c 92 fe ff               	callq	0x5c40 <.plt.sec+0x5d0>
   1c9d4: 41 89 47 44                  	movl	%eax, 68(%r15)
; 	if (pb->epoll_fd < 0) {
   1c9d8: 85 c0                        	testl	%eax, %eax
   1c9da: 0f 88 e8 03 00 00            	js	0x1cdc8 <__perf_buffer__new+0x518>
; 	if (p->cpu_cnt > 0) {
   1c9e0: 8b 7d 28                     	movl	40(%rbp), %edi
   1c9e3: 85 ff                        	testl	%edi, %edi
   1c9e5: 0f 8e 15 03 00 00            	jle	0x1cd00 <__perf_buffer__new+0x450>
; 			pb->cpu_cnt = map.max_entries;
   1c9eb: 41 89 7f 40                  	movl	%edi, 64(%r15)
; 	pb->events = calloc(pb->cpu_cnt, sizeof(*pb->events));
   1c9ef: 4c 63 e7                     	movslq	%edi, %r12
   1c9f2: be 0c 00 00 00               	movl	$12, %esi
   1c9f7: 4c 89 e7                     	movq	%r12, %rdi
   1c9fa: e8 91 8f fe ff               	callq	0x5990 <.plt.sec+0x320>
   1c9ff: 49 89 47 38                  	movq	%rax, 56(%r15)
; 	if (!pb->events) {
   1ca03: 48 85 c0                     	testq	%rax, %rax
   1ca06: 0f 84 ca 04 00 00            	je	0x1ced6 <__perf_buffer__new+0x626>
; 	pb->cpu_bufs = calloc(pb->cpu_cnt, sizeof(*pb->cpu_bufs));
   1ca0c: be 08 00 00 00               	movl	$8, %esi
   1ca11: 4c 89 e7                     	movq	%r12, %rdi
   1ca14: e8 77 8f fe ff               	callq	0x5990 <.plt.sec+0x320>
   1ca19: 49 89 47 30                  	movq	%rax, 48(%r15)
; 	if (!pb->cpu_bufs) {
   1ca1d: 48 85 c0                     	testq	%rax, %rax
   1ca20: 0f 84 96 04 00 00            	je	0x1cebc <__perf_buffer__new+0x60c>
; 	err = parse_cpu_mask_file(online_cpus_file, &online, &n);
   1ca26: 48 8d 54 24 20               	leaq	32(%rsp), %rdx
   1ca2b: 48 8d 74 24 28               	leaq	40(%rsp), %rsi
   1ca30: 48 8d 3d 11 c2 01 00         	leaq	115217(%rip), %rdi      # 0x38c48 <strs.2+0x5db8>
   1ca37: e8 b4 c8 ff ff               	callq	0x192f0 <parse_cpu_mask_file>
   1ca3c: 89 04 24                     	movl	%eax, (%rsp)
; 	if (err) {
   1ca3f: 85 c0                        	testl	%eax, %eax
   1ca41: 0f 85 69 03 00 00            	jne	0x1cdb0 <__perf_buffer__new+0x500>
; 	for (i = 0, j = 0; i < pb->cpu_cnt; i++) {
   1ca47: 41 8b 57 40                  	movl	64(%r15), %edx
; 		err = bpf_map_update_elem(pb->map_fd, &map_key,
   1ca4b: 48 8d 44 24 24               	leaq	36(%rsp), %rax
   1ca50: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	for (i = 0, j = 0; i < pb->cpu_cnt; i++) {
   1ca55: 85 d2                        	testl	%edx, %edx
   1ca57: 0f 8f 3d 01 00 00            	jg	0x1cb9a <__perf_buffer__new+0x2ea>
   1ca5d: e9 2e 03 00 00               	jmp	0x1cd90 <__perf_buffer__new+0x4e0>
   1ca62: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		cpu = p->cpu_cnt > 0 ? p->cpus[i] : i;
   1ca68: 48 8b 45 30                  	movq	48(%rbp), %rax
   1ca6c: 44 8b 24 98                  	movl	(%rax,%rbx,4), %r12d
; 		map_key = p->cpu_cnt > 0 ? p->map_keys[i] : i;
   1ca70: 48 8b 45 38                  	movq	56(%rbp), %rax
   1ca74: 8b 14 98                     	movl	(%rax,%rbx,4), %edx
   1ca77: 89 54 24 24                  	movl	%edx, 36(%rsp)
; 	cpu_buf = calloc(1, sizeof(*cpu_buf));
   1ca7b: be 30 00 00 00               	movl	$48, %esi
   1ca80: bf 01 00 00 00               	movl	$1, %edi
   1ca85: 89 54 24 04                  	movl	%edx, 4(%rsp)
; 		cpu_buf = perf_buffer__open_cpu_buf(pb, p->attr, cpu, map_key);
   1ca89: 4c 8b 6d 00                  	movq	(%rbp), %r13
; 	cpu_buf = calloc(1, sizeof(*cpu_buf));
   1ca8d: e8 fe 8e fe ff               	callq	0x5990 <.plt.sec+0x320>
   1ca92: 49 89 c6                     	movq	%rax, %r14
; 	if (!cpu_buf)
   1ca95: 48 85 c0                     	testq	%rax, %rax
   1ca98: 0f 84 01 04 00 00            	je	0x1ce9f <__perf_buffer__new+0x5ef>
; 	cpu_buf->map_key = map_key;
   1ca9e: 8b 54 24 04                  	movl	4(%rsp), %edx
; 	cpu_buf->pb = pb;
   1caa2: 4c 89 38                     	movq	%r15, (%rax)
; 	cpu_buf->fd = syscall(__NR_perf_event_open, attr, -1 /* pid */, cpu,
   1caa5: 41 b9 08 00 00 00            	movl	$8, %r9d
   1caab: 44 89 e1                     	movl	%r12d, %ecx
; 	cpu_buf->cpu = cpu;
   1caae: 44 89 60 24                  	movl	%r12d, 36(%rax)
; 	cpu_buf->fd = syscall(__NR_perf_event_open, attr, -1 /* pid */, cpu,
   1cab2: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   1cab8: 4c 89 ee                     	movq	%r13, %rsi
   1cabb: bf 2a 01 00 00               	movl	$298, %edi              # imm = 0x12A
; 	cpu_buf->map_key = map_key;
   1cac0: 89 50 28                     	movl	%edx, 40(%rax)
; 	cpu_buf->fd = syscall(__NR_perf_event_open, attr, -1 /* pid */, cpu,
   1cac3: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
   1cac8: 31 c0                        	xorl	%eax, %eax
   1caca: e8 11 8f fe ff               	callq	0x59e0 <.plt.sec+0x370>
   1cacf: 41 89 46 20                  	movl	%eax, 32(%r14)
; 	if (cpu_buf->fd < 0) {
   1cad3: 85 c0                        	testl	%eax, %eax
   1cad5: 0f 88 35 01 00 00            	js	0x1cc10 <__perf_buffer__new+0x360>
; 	cpu_buf->base = mmap(NULL, pb->mmap_size + pb->page_size,
   1cadb: 49 8b 77 20                  	movq	32(%r15), %rsi
   1cadf: 45 31 c9                     	xorl	%r9d, %r9d
   1cae2: 49 03 77 28                  	addq	40(%r15), %rsi
   1cae6: 41 89 c0                     	movl	%eax, %r8d
   1cae9: b9 01 00 00 00               	movl	$1, %ecx
   1caee: ba 03 00 00 00               	movl	$3, %edx
   1caf3: 31 ff                        	xorl	%edi, %edi
   1caf5: e8 86 8f fe ff               	callq	0x5a80 <.plt.sec+0x410>
   1cafa: 49 89 46 08                  	movq	%rax, 8(%r14)
; 	if (cpu_buf->base == MAP_FAILED) {
   1cafe: 48 83 f8 ff                  	cmpq	$-1, %rax
   1cb02: 0f 84 58 01 00 00            	je	0x1cc60 <__perf_buffer__new+0x3b0>
; 	if (ioctl(cpu_buf->fd, PERF_EVENT_IOC_ENABLE, 0) < 0) {
   1cb08: 41 8b 7e 20                  	movl	32(%r14), %edi
   1cb0c: 31 d2                        	xorl	%edx, %edx
   1cb0e: 31 c0                        	xorl	%eax, %eax
   1cb10: be 00 24 00 00               	movl	$9216, %esi             # imm = 0x2400
   1cb15: e8 d6 8d fe ff               	callq	0x58f0 <.plt.sec+0x280>
   1cb1a: 85 c0                        	testl	%eax, %eax
   1cb1c: 0f 88 7e 01 00 00            	js	0x1cca0 <__perf_buffer__new+0x3f0>
; 		if (IS_ERR(cpu_buf)) {
   1cb22: 49 81 fe 00 f0 ff ff         	cmpq	$-4096, %r14            # imm = 0xF000
   1cb29: 0f 87 d9 02 00 00            	ja	0x1ce08 <__perf_buffer__new+0x558>
; 		pb->cpu_bufs[j] = cpu_buf;
   1cb2f: 4c 63 2c 24                  	movslq	(%rsp), %r13
   1cb33: 49 8b 47 30                  	movq	48(%r15), %rax
; 		err = bpf_map_update_elem(pb->map_fd, &map_key,
   1cb37: 31 c9                        	xorl	%ecx, %ecx
; 					  &cpu_buf->fd, 0);
   1cb39: 49 8d 56 20                  	leaq	32(%r14), %rdx
; 		err = bpf_map_update_elem(pb->map_fd, &map_key,
   1cb3d: 41 8b 7f 48                  	movl	72(%r15), %edi
   1cb41: 48 8b 74 24 08               	movq	8(%rsp), %rsi
; 		pb->cpu_bufs[j] = cpu_buf;
   1cb46: 4e 89 34 e8                  	movq	%r14, (%rax,%r13,8)
; 		err = bpf_map_update_elem(pb->map_fd, &map_key,
   1cb4a: e8 a1 98 00 00               	callq	0x263f0 <bpf_map_update_elem>
; 		if (err) {
   1cb4f: 85 c0                        	testl	%eax, %eax
   1cb51: 0f 85 c1 02 00 00            	jne	0x1ce18 <__perf_buffer__new+0x568>
; 		pb->events[j].events = EPOLLIN;
   1cb57: 49 8b 47 38                  	movq	56(%r15), %rax
   1cb5b: 4b 8d 54 6d 00               	leaq	(%r13,%r13,2), %rdx
; 		if (epoll_ctl(pb->epoll_fd, EPOLL_CTL_ADD, cpu_buf->fd,
   1cb60: 41 8b 7f 44                  	movl	68(%r15), %edi
   1cb64: be 01 00 00 00               	movl	$1, %esi
; 		pb->events[j].events = EPOLLIN;
   1cb69: 48 8d 0c 90                  	leaq	(%rax,%rdx,4), %rcx
; 		if (epoll_ctl(pb->epoll_fd, EPOLL_CTL_ADD, cpu_buf->fd,
   1cb6d: 41 8b 56 20                  	movl	32(%r14), %edx
; 		pb->events[j].events = EPOLLIN;
   1cb71: c7 01 01 00 00 00            	movl	$1, (%rcx)
; 		pb->events[j].data.ptr = cpu_buf;
   1cb77: 4c 89 71 04                  	movq	%r14, 4(%rcx)
; 		if (epoll_ctl(pb->epoll_fd, EPOLL_CTL_ADD, cpu_buf->fd,
   1cb7b: e8 b0 8d fe ff               	callq	0x5930 <.plt.sec+0x2c0>
   1cb80: 85 c0                        	testl	%eax, %eax
   1cb82: 0f 88 d8 02 00 00            	js	0x1ce60 <__perf_buffer__new+0x5b0>
; 		j++;
   1cb88: 83 04 24 01                  	addl	$1, (%rsp)
; 	for (i = 0, j = 0; i < pb->cpu_cnt; i++) {
   1cb8c: 48 83 c3 01                  	addq	$1, %rbx
   1cb90: 41 39 5f 40                  	cmpl	%ebx, 64(%r15)
   1cb94: 0f 8e f6 01 00 00            	jle	0x1cd90 <__perf_buffer__new+0x4e0>
; 		cpu = p->cpu_cnt > 0 ? p->cpus[i] : i;
   1cb9a: 8b 45 28                     	movl	40(%rbp), %eax
   1cb9d: 41 89 dc                     	movl	%ebx, %r12d
   1cba0: 85 c0                        	testl	%eax, %eax
   1cba2: 0f 8f c0 fe ff ff            	jg	0x1ca68 <__perf_buffer__new+0x1b8>
; 		map_key = p->cpu_cnt > 0 ? p->map_keys[i] : i;
   1cba8: 89 5c 24 24                  	movl	%ebx, 36(%rsp)
; 		if (p->cpu_cnt <= 0 && (cpu >= n || !online[cpu]))
   1cbac: 39 5c 24 20                  	cmpl	%ebx, 32(%rsp)
   1cbb0: 7e da                        	jle	0x1cb8c <__perf_buffer__new+0x2dc>
   1cbb2: 48 8b 44 24 28               	movq	40(%rsp), %rax
   1cbb7: 80 3c 18 00                  	cmpb	$0, (%rax,%rbx)
   1cbbb: 74 cf                        	je	0x1cb8c <__perf_buffer__new+0x2dc>
   1cbbd: 89 da                        	movl	%ebx, %edx
   1cbbf: e9 b7 fe ff ff               	jmp	0x1ca7b <__perf_buffer__new+0x1cb>
   1cbc4: 0f 1f 40 00                  	nopl	(%rax)
; 		err = -errno;
   1cbc8: e8 23 8b fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1cbcd: 44 8b 18                     	movl	(%rax), %r11d
; 		if (err != -EINVAL) {
   1cbd0: 41 83 fb 16                  	cmpl	$22, %r11d
   1cbd4: 0f 84 06 01 00 00            	je	0x1cce0 <__perf_buffer__new+0x430>
; 		err = -errno;
   1cbda: 41 f7 db                     	negl	%r11d
; 			pr_warn("failed to get map info for map FD %d: %s\n",
   1cbdd: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
   1cbe5: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   1cbea: 4d 63 fb                     	movslq	%r11d, %r15
; 			pr_warn("failed to get map info for map FD %d: %s\n",
   1cbed: 44 89 ff                     	movl	%r15d, %edi
   1cbf0: e8 db 0d 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1cbf5: 44 89 ea                     	movl	%r13d, %edx
   1cbf8: 48 8d 35 69 ae 01 00         	leaq	110185(%rip), %rsi      # 0x37a68 <strs.2+0x4bd8>
   1cbff: 31 ff                        	xorl	%edi, %edi
   1cc01: 48 89 c1                     	movq	%rax, %rcx
   1cc04: 31 c0                        	xorl	%eax, %eax
   1cc06: e8 c5 b4 fe ff               	callq	0x80d0 <libbpf_print>
; 			return ERR_PTR(err);
   1cc0b: e9 f8 fc ff ff               	jmp	0x1c908 <__perf_buffer__new+0x58>
; 		err = -errno;
   1cc10: e8 db 8a fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to open perf buffer event on cpu #%d: %s\n",
   1cc15: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
   1cc1d: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   1cc22: 44 8b 28                     	movl	(%rax), %r13d
   1cc25: 41 f7 dd                     	negl	%r13d
; 		pr_warn("failed to open perf buffer event on cpu #%d: %s\n",
   1cc28: 44 89 ef                     	movl	%r13d, %edi
   1cc2b: e8 a0 0d 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1cc30: 44 89 e2                     	movl	%r12d, %edx
   1cc33: 48 8d 35 5e c0 01 00         	leaq	114782(%rip), %rsi      # 0x38c98 <strs.2+0x5e08>
   1cc3a: 31 ff                        	xorl	%edi, %edi
   1cc3c: 48 89 c1                     	movq	%rax, %rcx
   1cc3f: 31 c0                        	xorl	%eax, %eax
   1cc41: e8 8a b4 fe ff               	callq	0x80d0 <libbpf_print>
; 	perf_buffer__free_cpu_buf(pb, cpu_buf);
   1cc46: 4c 89 f6                     	movq	%r14, %rsi
   1cc49: 4c 89 ff                     	movq	%r15, %rdi
; 	return (struct perf_cpu_buf *)ERR_PTR(err);
   1cc4c: 4d 63 f5                     	movslq	%r13d, %r14
; 	perf_buffer__free_cpu_buf(pb, cpu_buf);
   1cc4f: e8 3c d5 fe ff               	callq	0xa190 <perf_buffer__free_cpu_buf>
; 	return (struct perf_cpu_buf *)ERR_PTR(err);
   1cc54: e9 c9 fe ff ff               	jmp	0x1cb22 <__perf_buffer__new+0x272>
   1cc59: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		cpu_buf->base = NULL;
   1cc60: 49 c7 46 08 00 00 00 00      	movq	$0, 8(%r14)
; 		err = -errno;
   1cc68: e8 83 8a fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to mmap perf buffer on cpu #%d: %s\n",
   1cc6d: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
   1cc75: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   1cc7a: 44 8b 28                     	movl	(%rax), %r13d
   1cc7d: 41 f7 dd                     	negl	%r13d
; 		pr_warn("failed to mmap perf buffer on cpu #%d: %s\n",
   1cc80: 44 89 ef                     	movl	%r13d, %edi
   1cc83: e8 48 0d 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1cc88: 44 89 e2                     	movl	%r12d, %edx
   1cc8b: 48 8d 35 46 c0 01 00         	leaq	114758(%rip), %rsi      # 0x38cd8 <strs.2+0x5e48>
   1cc92: 31 ff                        	xorl	%edi, %edi
   1cc94: 48 89 c1                     	movq	%rax, %rcx
   1cc97: 31 c0                        	xorl	%eax, %eax
   1cc99: e8 32 b4 fe ff               	callq	0x80d0 <libbpf_print>
; 		goto error;
   1cc9e: eb a6                        	jmp	0x1cc46 <__perf_buffer__new+0x396>
; 		err = -errno;
   1cca0: e8 4b 8a fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to enable perf buffer event on cpu #%d: %s\n",
   1cca5: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
   1ccad: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   1ccb2: 44 8b 28                     	movl	(%rax), %r13d
   1ccb5: 41 f7 dd                     	negl	%r13d
; 		pr_warn("failed to enable perf buffer event on cpu #%d: %s\n",
   1ccb8: 44 89 ef                     	movl	%r13d, %edi
   1ccbb: e8 10 0d 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1ccc0: 44 89 e2                     	movl	%r12d, %edx
   1ccc3: 48 8d 35 46 c0 01 00         	leaq	114758(%rip), %rsi      # 0x38d10 <strs.2+0x5e80>
   1ccca: 31 ff                        	xorl	%edi, %edi
   1cccc: 48 89 c1                     	movq	%rax, %rcx
   1cccf: 31 c0                        	xorl	%eax, %eax
   1ccd1: e8 fa b3 fe ff               	callq	0x80d0 <libbpf_print>
; 		goto error;
   1ccd6: e9 6b ff ff ff               	jmp	0x1cc46 <__perf_buffer__new+0x396>
   1ccdb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_debug("failed to get map info for FD %d; API not supported? Ignoring...\n",
   1cce0: 44 89 ea                     	movl	%r13d, %edx
   1cce3: 48 8d 35 2e be 01 00         	leaq	114222(%rip), %rsi      # 0x38b18 <strs.2+0x5c88>
   1ccea: bf 02 00 00 00               	movl	$2, %edi
   1ccef: 31 c0                        	xorl	%eax, %eax
   1ccf1: e8 da b3 fe ff               	callq	0x80d0 <libbpf_print>
   1ccf6: e9 7e fc ff ff               	jmp	0x1c979 <__perf_buffer__new+0xc9>
   1ccfb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	tmp_cpus = READ_ONCE(cpus);
   1cd00: 8b 05 1a a5 02 00            	movl	173338(%rip), %eax      # 0x47220 <cpus.16>
   1cd06: 89 04 24                     	movl	%eax, (%rsp)
; 	if (tmp_cpus > 0)
   1cd09: 85 c0                        	testl	%eax, %eax
   1cd0b: 7e 4b                        	jle	0x1cd58 <__perf_buffer__new+0x4a8>
; 		pb->cpu_cnt = libbpf_num_possible_cpus();
   1cd0d: 8b 04 24                     	movl	(%rsp), %eax
   1cd10: 41 89 47 40                  	movl	%eax, 64(%r15)
; 		if (map.max_entries && map.max_entries < pb->cpu_cnt)
   1cd14: 8b 7c 24 40                  	movl	64(%rsp), %edi
   1cd18: 85 ff                        	testl	%edi, %edi
   1cd1a: 74 09                        	je	0x1cd25 <__perf_buffer__new+0x475>
   1cd1c: 3b 3c 24                     	cmpl	(%rsp), %edi
   1cd1f: 0f 82 c6 fc ff ff            	jb	0x1c9eb <__perf_buffer__new+0x13b>
; 	pb->events = calloc(pb->cpu_cnt, sizeof(*pb->events));
   1cd25: 41 8b 7f 40                  	movl	64(%r15), %edi
   1cd29: e9 c1 fc ff ff               	jmp	0x1c9ef <__perf_buffer__new+0x13f>
   1cd2e: 66 90                        	nop
; 			pr_warn("map '%s' should be BPF_MAP_TYPE_PERF_EVENT_ARRAY\n",
   1cd30: 48 8d 54 24 48               	leaq	72(%rsp), %rdx
   1cd35: 48 8d 35 2c be 01 00         	leaq	114220(%rip), %rsi      # 0x38b68 <strs.2+0x5cd8>
   1cd3c: 31 ff                        	xorl	%edi, %edi
   1cd3e: 31 c0                        	xorl	%eax, %eax
   1cd40: e8 8b b3 fe ff               	callq	0x80d0 <libbpf_print>
; 			return ERR_PTR(-EINVAL);
   1cd45: 49 c7 c7 ea ff ff ff         	movq	$-22, %r15
   1cd4c: e9 b7 fb ff ff               	jmp	0x1c908 <__perf_buffer__new+0x58>
   1cd51: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   1cd58: e8 c3 c6 ff ff               	callq	0x19420 <libbpf_num_possible_cpus.part.0>
   1cd5d: 89 04 24                     	movl	%eax, (%rsp)
; 		pb->cpu_cnt = libbpf_num_possible_cpus();
   1cd60: 41 89 47 40                  	movl	%eax, 64(%r15)
; 		if (pb->cpu_cnt < 0) {
   1cd64: 85 c0                        	testl	%eax, %eax
   1cd66: 79 ac                        	jns	0x1cd14 <__perf_buffer__new+0x464>
   1cd68: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	free(online);
   1cd70: 48 8b 7c 24 28               	movq	40(%rsp), %rdi
   1cd75: e8 46 89 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		perf_buffer__free(pb);
   1cd7a: 4c 89 ff                     	movq	%r15, %rdi
   1cd7d: e8 0e bd ff ff               	callq	0x18a90 <perf_buffer__free>
; 	return ERR_PTR(err);
   1cd82: 4c 63 3c 24                  	movslq	(%rsp), %r15
   1cd86: e9 7d fb ff ff               	jmp	0x1c908 <__perf_buffer__new+0x58>
   1cd8b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	pb->cpu_cnt = j;
   1cd90: 8b 04 24                     	movl	(%rsp), %eax
; 	free(online);
   1cd93: 48 8b 7c 24 28               	movq	40(%rsp), %rdi
; 	pb->cpu_cnt = j;
   1cd98: 41 89 47 40                  	movl	%eax, 64(%r15)
; 	free(online);
   1cd9c: e8 1f 89 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return pb;
   1cda1: e9 62 fb ff ff               	jmp	0x1c908 <__perf_buffer__new+0x58>
   1cda6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("failed to get online CPU mask: %d\n", err);
   1cdb0: 8b 14 24                     	movl	(%rsp), %edx
   1cdb3: 48 8d 35 ae be 01 00         	leaq	114350(%rip), %rsi      # 0x38c68 <strs.2+0x5dd8>
   1cdba: 31 ff                        	xorl	%edi, %edi
   1cdbc: 31 c0                        	xorl	%eax, %eax
   1cdbe: e8 0d b3 fe ff               	callq	0x80d0 <libbpf_print>
; 		goto error;
   1cdc3: eb ab                        	jmp	0x1cd70 <__perf_buffer__new+0x4c0>
   1cdc5: 0f 1f 00                     	nopl	(%rax)
; 		err = -errno;
   1cdc8: e8 23 89 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("failed to create epoll instance: %s\n",
   1cdcd: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
   1cdd5: ba 80 00 00 00               	movl	$128, %edx
; 		err = -errno;
   1cdda: 44 8b 28                     	movl	(%rax), %r13d
   1cddd: 41 f7 dd                     	negl	%r13d
   1cde0: 44 89 ef                     	movl	%r13d, %edi
   1cde3: 44 89 2c 24                  	movl	%r13d, (%rsp)
; 		pr_warn("failed to create epoll instance: %s\n",
   1cde7: e8 e4 0b 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1cdec: 48 8d 35 b5 bd 01 00         	leaq	114101(%rip), %rsi      # 0x38ba8 <strs.2+0x5d18>
   1cdf3: 31 ff                        	xorl	%edi, %edi
   1cdf5: 48 89 c2                     	movq	%rax, %rdx
   1cdf8: 31 c0                        	xorl	%eax, %eax
   1cdfa: e8 d1 b2 fe ff               	callq	0x80d0 <libbpf_print>
; 		goto error;
   1cdff: e9 6c ff ff ff               	jmp	0x1cd70 <__perf_buffer__new+0x4c0>
   1ce04: 0f 1f 40 00                  	nopl	(%rax)
   1ce08: 4d 89 f5                     	movq	%r14, %r13
; 			err = PTR_ERR(cpu_buf);
   1ce0b: 44 89 2c 24                  	movl	%r13d, (%rsp)
; 			goto error;
   1ce0f: e9 5c ff ff ff               	jmp	0x1cd70 <__perf_buffer__new+0x4c0>
   1ce14: 0f 1f 40 00                  	nopl	(%rax)
; 			err = -errno;
   1ce18: e8 d3 88 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("failed to set cpu #%d, key %d -> perf FD %d: %s\n",
   1ce1d: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
   1ce25: ba 80 00 00 00               	movl	$128, %edx
; 			err = -errno;
   1ce2a: 8b 00                        	movl	(%rax), %eax
   1ce2c: f7 d8                        	negl	%eax
; 			pr_warn("failed to set cpu #%d, key %d -> perf FD %d: %s\n",
   1ce2e: 89 c7                        	movl	%eax, %edi
; 			err = -errno;
   1ce30: 89 04 24                     	movl	%eax, (%rsp)
; 			pr_warn("failed to set cpu #%d, key %d -> perf FD %d: %s\n",
   1ce33: e8 98 0b 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1ce38: 45 8b 46 20                  	movl	32(%r14), %r8d
   1ce3c: 8b 4c 24 24                  	movl	36(%rsp), %ecx
   1ce40: 44 89 e2                     	movl	%r12d, %edx
   1ce43: 49 89 c1                     	movq	%rax, %r9
   1ce46: 48 8d 35 03 bf 01 00         	leaq	114435(%rip), %rsi      # 0x38d50 <strs.2+0x5ec0>
   1ce4d: 31 ff                        	xorl	%edi, %edi
   1ce4f: 31 c0                        	xorl	%eax, %eax
   1ce51: e8 7a b2 fe ff               	callq	0x80d0 <libbpf_print>
; 			goto error;
   1ce56: e9 15 ff ff ff               	jmp	0x1cd70 <__perf_buffer__new+0x4c0>
   1ce5b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			err = -errno;
   1ce60: e8 8b 88 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("failed to epoll_ctl cpu #%d perf FD %d: %s\n",
   1ce65: 48 8d b4 24 90 00 00 00      	leaq	144(%rsp), %rsi
   1ce6d: ba 80 00 00 00               	movl	$128, %edx
; 			err = -errno;
   1ce72: 8b 00                        	movl	(%rax), %eax
   1ce74: f7 d8                        	negl	%eax
; 			pr_warn("failed to epoll_ctl cpu #%d perf FD %d: %s\n",
   1ce76: 89 c7                        	movl	%eax, %edi
; 			err = -errno;
   1ce78: 89 04 24                     	movl	%eax, (%rsp)
; 			pr_warn("failed to epoll_ctl cpu #%d perf FD %d: %s\n",
   1ce7b: e8 50 0b 00 00               	callq	0x1d9d0 <libbpf_strerror_r>
   1ce80: 41 8b 4e 20                  	movl	32(%r14), %ecx
   1ce84: 44 89 e2                     	movl	%r12d, %edx
   1ce87: 31 ff                        	xorl	%edi, %edi
   1ce89: 49 89 c0                     	movq	%rax, %r8
   1ce8c: 48 8d 35 fd be 01 00         	leaq	114429(%rip), %rsi      # 0x38d90 <strs.2+0x5f00>
   1ce93: 31 c0                        	xorl	%eax, %eax
   1ce95: e8 36 b2 fe ff               	callq	0x80d0 <libbpf_print>
; 			goto error;
   1ce9a: e9 d1 fe ff ff               	jmp	0x1cd70 <__perf_buffer__new+0x4c0>
; 		return ERR_PTR(-ENOMEM);
   1ce9f: 49 c7 c5 f4 ff ff ff         	movq	$-12, %r13
   1cea6: e9 60 ff ff ff               	jmp	0x1ce0b <__perf_buffer__new+0x55b>
; }
   1ceab: e8 50 89 fe ff               	callq	0x5800 <.plt.sec+0x190>
; 		return ERR_PTR(-ENOMEM);
   1ceb0: 49 c7 c7 f4 ff ff ff         	movq	$-12, %r15
   1ceb7: e9 4c fa ff ff               	jmp	0x1c908 <__perf_buffer__new+0x58>
; 		pr_warn("failed to allocate buffers: out of memory\n");
   1cebc: 48 8d 35 4d bd 01 00         	leaq	113997(%rip), %rsi      # 0x38c10 <strs.2+0x5d80>
   1cec3: 31 ff                        	xorl	%edi, %edi
   1cec5: e8 06 b2 fe ff               	callq	0x80d0 <libbpf_print>
; 		err = -ENOMEM;
   1ceca: c7 04 24 f4 ff ff ff         	movl	$4294967284, (%rsp)     # imm = 0xFFFFFFF4
; 		goto error;
   1ced1: e9 9a fe ff ff               	jmp	0x1cd70 <__perf_buffer__new+0x4c0>
; 		pr_warn("failed to allocate events: out of memory\n");
   1ced6: 48 8d 35 fb bc 01 00         	leaq	113915(%rip), %rsi      # 0x38bd8 <strs.2+0x5d48>
   1cedd: 31 ff                        	xorl	%edi, %edi
   1cedf: e8 ec b1 fe ff               	callq	0x80d0 <libbpf_print>
; 		err = -ENOMEM;
   1cee4: c7 04 24 f4 ff ff ff         	movl	$4294967284, (%rsp)     # imm = 0xFFFFFFF4
; 		goto error;
   1ceeb: e9 80 fe ff ff               	jmp	0x1cd70 <__perf_buffer__new+0x4c0>

000000000001cef0 <perf_buffer__new>:
; {
   1cef0: f3 0f 1e fa                  	endbr64
   1cef4: 41 54                        	pushq	%r12
; 	struct perf_buffer_params p = {};
   1cef6: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   1cefa: 49 89 d3                     	movq	%rdx, %r11
   1cefd: 41 89 fa                     	movl	%edi, %r10d
   1cf00: 48 89 ca                     	movq	%rcx, %rdx
   1cf03: 48 81 ec d0 00 00 00         	subq	$208, %rsp
   1cf0a: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1cf13: 48 89 84 24 c8 00 00 00      	movq	%rax, 200(%rsp)
   1cf1b: 31 c0                        	xorl	%eax, %eax
; 	struct perf_buffer_params p = {};
   1cf1d: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
   1cf21: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
   1cf26: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   1cf2b: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	if (!OPTS_VALID(opts, perf_buffer_opts))
   1cf30: 4d 85 c9                     	testq	%r9, %r9
   1cf33: 0f 84 87 00 00 00            	je	0x1cfc0 <perf_buffer__new+0xd0>
   1cf39: 49 8b 09                     	movq	(%r9), %rcx
; 	if (user_sz < sizeof(size_t)) {
   1cf3c: 48 83 f9 07                  	cmpq	$7, %rcx
   1cf40: 0f 86 0a 01 00 00            	jbe	0x1d050 <perf_buffer__new+0x160>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   1cf46: 48 8d 79 f8                  	leaq	-8(%rcx), %rdi
   1cf4a: 49 8d 41 08                  	leaq	8(%r9), %rax
; 	while (len > 0) {
   1cf4e: 48 85 ff                     	testq	%rdi, %rdi
   1cf51: 7e 6d                        	jle	0x1cfc0 <perf_buffer__new+0xd0>
   1cf53: 49 01 c9                     	addq	%rcx, %r9
   1cf56: eb 11                        	jmp	0x1cf69 <perf_buffer__new+0x79>
   1cf58: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		p++;
   1cf60: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   1cf64: 4c 39 c8                     	cmpq	%r9, %rax
   1cf67: 74 57                        	je	0x1cfc0 <perf_buffer__new+0xd0>
; 		if (*p)
   1cf69: 80 38 00                     	cmpb	$0, (%rax)
   1cf6c: 74 f2                        	je	0x1cf60 <perf_buffer__new+0x70>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   1cf6e: 48 8d 15 29 54 01 00         	leaq	87081(%rip), %rdx       # 0x3239e <_IO_stdin_used+0x239e>
   1cf75: 48 8d 35 94 70 01 00         	leaq	94356(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   1cf7c: 31 ff                        	xorl	%edi, %edi
   1cf7e: 31 c0                        	xorl	%eax, %eax
   1cf80: e8 4b b1 fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   1cf85: e8 66 87 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   1cf8a: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   1cf8d: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return NULL;
   1cf93: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; }
   1cf98: 48 8b 84 24 c8 00 00 00      	movq	200(%rsp), %rax
   1cfa0: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1cfa9: 0f 85 bb 00 00 00            	jne	0x1d06a <perf_buffer__new+0x17a>
   1cfaf: 48 81 c4 d0 00 00 00         	addq	$208, %rsp
   1cfb6: 4c 89 e0                     	movq	%r12, %rax
   1cfb9: 41 5c                        	popq	%r12
   1cfbb: c3                           	retq
   1cfbc: 0f 1f 40 00                  	nopl	(%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1cfc0: 4c 8d 4c 24 60               	leaq	96(%rsp), %r9
   1cfc5: 31 c0                        	xorl	%eax, %eax
   1cfc7: b9 0c 00 00 00               	movl	$12, %ecx
; 	p.lost_cb = lost_cb;
   1cfcc: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1cfd1: 4c 89 cf                     	movq	%r9, %rdi
   1cfd4: 4c 8d 64 24 40               	leaq	64(%rsp), %r12
; 	return libbpf_ptr(__perf_buffer__new(map_fd, page_cnt, &p));
   1cfd9: 48 89 e2                     	movq	%rsp, %rdx
; 	p.sample_cb = sample_cb;
   1cfdc: 4c 89 5c 24 10               	movq	%r11, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1cfe1: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	return libbpf_ptr(__perf_buffer__new(map_fd, page_cnt, &p));
   1cfe4: 44 89 d7                     	movl	%r10d, %edi
; 	attr.type = PERF_TYPE_SOFTWARE;
   1cfe7: 48 b8 01 00 00 00 80 00 00 00	movabsq	$549755813889, %rax     # imm = 0x8000000001
; 	p.attr = &attr;
   1cff1: 4c 89 24 24                  	movq	%r12, (%rsp)
; 	attr.type = PERF_TYPE_SOFTWARE;
   1cff5: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 	attr.config = PERF_COUNT_SW_BPF_OUTPUT;
   1cffa: 48 c7 44 24 48 0a 00 00 00   	movq	$10, 72(%rsp)
; 	attr.sample_period = 1;
   1d003: 48 c7 44 24 50 01 00 00 00   	movq	$1, 80(%rsp)
; 	attr.sample_type = PERF_SAMPLE_RAW;
   1d00c: 48 c7 44 24 58 00 04 00 00   	movq	$1024, 88(%rsp)         # imm = 0x400
; 	attr.wakeup_events = 1;
   1d015: c7 44 24 70 01 00 00 00      	movl	$1, 112(%rsp)
; 	p.ctx = ctx;
   1d01d: 4c 89 44 24 20               	movq	%r8, 32(%rsp)
; 	return libbpf_ptr(__perf_buffer__new(map_fd, page_cnt, &p));
   1d022: e8 89 f8 ff ff               	callq	0x1c8b0 <__perf_buffer__new>
   1d027: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   1d02a: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   1d030: 0f 86 62 ff ff ff            	jbe	0x1cf98 <perf_buffer__new+0xa8>
; 		errno = -PTR_ERR(ret);
   1d036: e8 b5 86 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d03b: 41 f7 dc                     	negl	%r12d
   1d03e: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   1d041: 45 31 e4                     	xorl	%r12d, %r12d
   1d044: e9 4f ff ff ff               	jmp	0x1cf98 <perf_buffer__new+0xa8>
   1d049: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   1d050: 48 8d 15 47 53 01 00         	leaq	86855(%rip), %rdx       # 0x3239e <_IO_stdin_used+0x239e>
   1d057: 48 8d 35 5a 6f 01 00         	leaq	94042(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   1d05e: 31 ff                        	xorl	%edi, %edi
   1d060: e8 6b b0 fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   1d065: e9 1b ff ff ff               	jmp	0x1cf85 <perf_buffer__new+0x95>
; }
   1d06a: e8 91 87 fe ff               	callq	0x5800 <.plt.sec+0x190>
   1d06f: 90                           	nop

000000000001d070 <perf_buffer__new_raw>:
; {
   1d070: f3 0f 1e fa                  	endbr64
   1d074: 41 54                        	pushq	%r12
; 	struct perf_buffer_params p = {};
   1d076: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   1d07a: 48 83 ec 50                  	subq	$80, %rsp
   1d07e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1d087: 48 89 44 24 48               	movq	%rax, 72(%rsp)
   1d08c: 31 c0                        	xorl	%eax, %eax
; 	struct perf_buffer_params p = {};
   1d08e: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
   1d092: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
   1d097: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   1d09c: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	if (!attr)
   1d0a1: 48 85 d2                     	testq	%rdx, %rdx
   1d0a4: 74 53                        	je	0x1d0f9 <perf_buffer__new_raw+0x89>
; 	if (!OPTS_VALID(opts, perf_buffer_raw_opts))
   1d0a6: 4d 85 c9                     	testq	%r9, %r9
   1d0a9: 74 65                        	je	0x1d110 <perf_buffer__new_raw+0xa0>
   1d0ab: 4d 8b 19                     	movq	(%r9), %r11
; 	if (user_sz < sizeof(size_t)) {
   1d0ae: 49 83 fb 07                  	cmpq	$7, %r11
   1d0b2: 0f 86 f8 00 00 00            	jbe	0x1d1b0 <perf_buffer__new_raw+0x140>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   1d0b8: 4d 8d 53 e0                  	leaq	-32(%r11), %r10
   1d0bc: 49 8d 41 20                  	leaq	32(%r9), %rax
; 	while (len > 0) {
   1d0c0: 4d 85 d2                     	testq	%r10, %r10
   1d0c3: 0f 8e 97 00 00 00            	jle	0x1d160 <perf_buffer__new_raw+0xf0>
   1d0c9: 4f 8d 14 19                  	leaq	(%r9,%r11), %r10
   1d0cd: eb 0e                        	jmp	0x1d0dd <perf_buffer__new_raw+0x6d>
   1d0cf: 90                           	nop
; 		p++;
   1d0d0: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   1d0d4: 4c 39 d0                     	cmpq	%r10, %rax
   1d0d7: 0f 84 83 00 00 00            	je	0x1d160 <perf_buffer__new_raw+0xf0>
; 		if (*p)
   1d0dd: 80 38 00                     	cmpb	$0, (%rax)
   1d0e0: 74 ee                        	je	0x1d0d0 <perf_buffer__new_raw+0x60>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   1d0e2: 48 8d 15 c6 52 01 00         	leaq	86726(%rip), %rdx       # 0x323af <_IO_stdin_used+0x23af>
   1d0e9: 48 8d 35 20 6f 01 00         	leaq	93984(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   1d0f0: 31 ff                        	xorl	%edi, %edi
   1d0f2: 31 c0                        	xorl	%eax, %eax
   1d0f4: e8 d7 af fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   1d0f9: e8 f2 85 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err_ptr(-EINVAL);
   1d0fe: 45 31 e4                     	xorl	%r12d, %r12d
; 	errno = -err;
   1d101: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err_ptr(-EINVAL);
   1d107: eb 3b                        	jmp	0x1d144 <perf_buffer__new_raw+0xd4>
   1d109: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	p.attr = attr;
   1d110: 48 89 14 24                  	movq	%rdx, (%rsp)
; 	p.event_cb = event_cb;
   1d114: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
; 	p.ctx = ctx;
   1d119: 4c 89 44 24 20               	movq	%r8, 32(%rsp)
; 	return libbpf_ptr(__perf_buffer__new(map_fd, page_cnt, &p));
   1d11e: 48 89 e2                     	movq	%rsp, %rdx
; 	p.map_keys = OPTS_GET(opts, map_keys, NULL);
   1d121: 4c 89 4c 24 38               	movq	%r9, 56(%rsp)
; 	return libbpf_ptr(__perf_buffer__new(map_fd, page_cnt, &p));
   1d126: e8 85 f7 ff ff               	callq	0x1c8b0 <__perf_buffer__new>
   1d12b: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   1d12e: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   1d134: 76 0e                        	jbe	0x1d144 <perf_buffer__new_raw+0xd4>
; 		errno = -PTR_ERR(ret);
   1d136: e8 b5 85 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d13b: 41 f7 dc                     	negl	%r12d
   1d13e: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   1d141: 45 31 e4                     	xorl	%r12d, %r12d
; }
   1d144: 48 8b 44 24 48               	movq	72(%rsp), %rax
   1d149: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1d152: 75 7b                        	jne	0x1d1cf <perf_buffer__new_raw+0x15f>
   1d154: 48 83 c4 50                  	addq	$80, %rsp
   1d158: 4c 89 e0                     	movq	%r12, %rax
   1d15b: 41 5c                        	popq	%r12
   1d15d: c3                           	retq
   1d15e: 66 90                        	nop
; 	p.attr = attr;
   1d160: 48 89 14 24                  	movq	%rdx, (%rsp)
; 	p.cpu_cnt = OPTS_GET(opts, cpu_cnt, 0);
   1d164: 31 c0                        	xorl	%eax, %eax
; 	p.event_cb = event_cb;
   1d166: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
; 	p.ctx = ctx;
   1d16b: 4c 89 44 24 20               	movq	%r8, 32(%rsp)
; 	p.cpu_cnt = OPTS_GET(opts, cpu_cnt, 0);
   1d170: 49 83 fb 0b                  	cmpq	$11, %r11
   1d174: 76 04                        	jbe	0x1d17a <perf_buffer__new_raw+0x10a>
   1d176: 41 8b 41 08                  	movl	8(%r9), %eax
   1d17a: 89 44 24 28                  	movl	%eax, 40(%rsp)
; 	p.cpus = OPTS_GET(opts, cpus, NULL);
   1d17e: 31 c0                        	xorl	%eax, %eax
   1d180: 49 83 fb 17                  	cmpq	$23, %r11
   1d184: 76 04                        	jbe	0x1d18a <perf_buffer__new_raw+0x11a>
   1d186: 49 8b 41 10                  	movq	16(%r9), %rax
   1d18a: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	p.map_keys = OPTS_GET(opts, map_keys, NULL);
   1d18f: 49 83 fb 1f                  	cmpq	$31, %r11
   1d193: 77 0b                        	ja	0x1d1a0 <perf_buffer__new_raw+0x130>
   1d195: 45 31 c9                     	xorl	%r9d, %r9d
   1d198: e9 81 ff ff ff               	jmp	0x1d11e <perf_buffer__new_raw+0xae>
   1d19d: 0f 1f 00                     	nopl	(%rax)
   1d1a0: 4d 8b 49 18                  	movq	24(%r9), %r9
   1d1a4: e9 75 ff ff ff               	jmp	0x1d11e <perf_buffer__new_raw+0xae>
   1d1a9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   1d1b0: 4c 89 d9                     	movq	%r11, %rcx
   1d1b3: 48 8d 15 f5 51 01 00         	leaq	86517(%rip), %rdx       # 0x323af <_IO_stdin_used+0x23af>
   1d1ba: 31 ff                        	xorl	%edi, %edi
   1d1bc: 31 c0                        	xorl	%eax, %eax
   1d1be: 48 8d 35 f3 6d 01 00         	leaq	93683(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   1d1c5: e8 06 af fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   1d1ca: e9 2a ff ff ff               	jmp	0x1d0f9 <perf_buffer__new_raw+0x89>
; }
   1d1cf: e8 2c 86 fe ff               	callq	0x5800 <.plt.sec+0x190>
   1d1d4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1d1df: 90                           	nop

000000000001d1e0 <libbpf_num_possible_cpus>:
; {
   1d1e0: f3 0f 1e fa                  	endbr64
; 	tmp_cpus = READ_ONCE(cpus);
   1d1e4: 8b 05 36 a0 02 00            	movl	172086(%rip), %eax      # 0x47220 <cpus.16>
; 	if (tmp_cpus > 0)
   1d1ea: 85 c0                        	testl	%eax, %eax
   1d1ec: 7e 02                        	jle	0x1d1f0 <libbpf_num_possible_cpus+0x10>
; }
   1d1ee: c3                           	retq
   1d1ef: 90                           	nop
   1d1f0: e9 2b c2 ff ff               	jmp	0x19420 <libbpf_num_possible_cpus.part.0>
   1d1f5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

000000000001d200 <bpf_object__open_skeleton>:
; {
   1d200: f3 0f 1e fa                  	endbr64
   1d204: 41 57                        	pushq	%r15
;   return __builtin___memset_chk (__dest, __ch, __len,
   1d206: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   1d20a: 41 56                        	pushq	%r14
   1d20c: 41 55                        	pushq	%r13
   1d20e: 41 54                        	pushq	%r12
   1d210: 55                           	pushq	%rbp
   1d211: 48 89 fd                     	movq	%rdi, %rbp
   1d214: 53                           	pushq	%rbx
   1d215: 48 83 ec 68                  	subq	$104, %rsp
   1d219: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1d222: 48 89 44 24 58               	movq	%rax, 88(%rsp)
   1d227: 31 c0                        	xorl	%eax, %eax
; 	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, skel_opts,
   1d229: 48 8b 47 08                  	movq	8(%rdi), %rax
;   return __builtin___memset_chk (__dest, __ch, __len,
   1d22d: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   1d232: 48 c7 44 24 50 00 00 00 00   	movq	$0, 80(%rsp)
; 	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, skel_opts,
   1d23b: 48 c7 44 24 10 48 00 00 00   	movq	$72, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1d244: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
   1d249: 0f 29 44 24 40               	movaps	%xmm0, 64(%rsp)
; 	if (opts) {
   1d24e: 48 85 f6                     	testq	%rsi, %rsi
   1d251: 0f 84 79 01 00 00            	je	0x1d3d0 <bpf_object__open_skeleton+0x1d0>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1d257: f3 0f 6f 0e                  	movdqu	(%rsi), %xmm1
   1d25b: f3 0f 6f 56 10               	movdqu	16(%rsi), %xmm2
   1d260: f3 0f 6f 5e 20               	movdqu	32(%rsi), %xmm3
   1d265: f3 0f 6f 66 30               	movdqu	48(%rsi), %xmm4
   1d26a: 48 8b 56 40                  	movq	64(%rsi), %rdx
; 		if (!opts->object_name)
   1d26e: 48 83 7e 08 00               	cmpq	$0, 8(%rsi)
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1d273: 0f 29 4c 24 10               	movaps	%xmm1, 16(%rsp)
   1d278: 0f 29 54 24 20               	movaps	%xmm2, 32(%rsp)
   1d27d: 48 89 54 24 50               	movq	%rdx, 80(%rsp)
   1d282: 0f 29 5c 24 30               	movaps	%xmm3, 48(%rsp)
   1d287: 0f 29 64 24 40               	movaps	%xmm4, 64(%rsp)
; 		if (!opts->object_name)
   1d28c: 0f 84 3e 01 00 00            	je	0x1d3d0 <bpf_object__open_skeleton+0x1d0>
; 	obj = bpf_object__open_mem(s->data, s->data_sz, &skel_opts);
   1d292: 48 8b 75 18                  	movq	24(%rbp), %rsi
   1d296: 48 8b 7d 10                  	movq	16(%rbp), %rdi
   1d29a: 48 8d 54 24 10               	leaq	16(%rsp), %rdx
   1d29f: e8 cc 7e ff ff               	callq	0x15170 <bpf_object__open_mem>
   1d2a4: 49 89 c7                     	movq	%rax, %r15
; 	if (!IS_ERR_OR_NULL(ptr))
   1d2a7: 48 85 c0                     	testq	%rax, %rax
   1d2aa: 0f 84 d8 00 00 00            	je	0x1d388 <bpf_object__open_skeleton+0x188>
   1d2b0: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   1d2b6: 0f 87 cc 00 00 00            	ja	0x1d388 <bpf_object__open_skeleton+0x188>
; 	*s->obj = obj;
   1d2bc: 48 8b 45 20                  	movq	32(%rbp), %rax
; 	err = populate_skeleton_maps(obj, s->maps, s->map_cnt);
   1d2c0: 48 63 55 28                  	movslq	40(%rbp), %rdx
   1d2c4: 4c 89 ff                     	movq	%r15, %rdi
   1d2c7: 48 8b 75 30                  	movq	48(%rbp), %rsi
; 	*s->obj = obj;
   1d2cb: 4c 89 38                     	movq	%r15, (%rax)
; 	err = populate_skeleton_maps(obj, s->maps, s->map_cnt);
   1d2ce: e8 3d 7f ff ff               	callq	0x15210 <populate_skeleton_maps>
   1d2d3: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	if (err) {
   1d2d7: 85 c0                        	testl	%eax, %eax
   1d2d9: 0f 85 11 01 00 00            	jne	0x1d3f0 <bpf_object__open_skeleton+0x1f0>
; 	err = populate_skeleton_progs(obj, s->progs, s->prog_cnt);
   1d2df: 48 63 45 38                  	movslq	56(%rbp), %rax
   1d2e3: 48 8b 5d 40                  	movq	64(%rbp), %rbx
; 	for (i = 0; i < prog_cnt; i++) {
   1d2e7: 45 31 f6                     	xorl	%r14d, %r14d
; 	err = populate_skeleton_progs(obj, s->progs, s->prog_cnt);
   1d2ea: 48 89 04 24                  	movq	%rax, (%rsp)
; 	for (i = 0; i < prog_cnt; i++) {
   1d2ee: 48 85 c0                     	testq	%rax, %rax
   1d2f1: 75 13                        	jne	0x1d306 <bpf_object__open_skeleton+0x106>
   1d2f3: eb 69                        	jmp	0x1d35e <bpf_object__open_skeleton+0x15e>
   1d2f5: 0f 1f 00                     	nopl	(%rax)
   1d2f8: 49 83 c6 01                  	addq	$1, %r14
   1d2fc: 48 83 c3 18                  	addq	$24, %rbx
   1d300: 4c 39 34 24                  	cmpq	%r14, (%rsp)
   1d304: 74 58                        	je	0x1d35e <bpf_object__open_skeleton+0x15e>
; 		const char *name = progs[i].name;
   1d306: 4c 8b 2b                     	movq	(%rbx), %r13
; 		struct bpf_program **prog = progs[i].prog;
   1d309: 4c 8b 63 08                  	movq	8(%rbx), %r12
; 		*prog = bpf_object__find_program_by_name(obj, name);
   1d30d: 4c 89 ff                     	movq	%r15, %rdi
   1d310: 4c 89 ee                     	movq	%r13, %rsi
   1d313: e8 a8 19 ff ff               	callq	0xecc0 <bpf_object__find_program_by_name>
   1d318: 49 89 04 24                  	movq	%rax, (%r12)
; 		if (!*prog) {
   1d31c: 48 85 c0                     	testq	%rax, %rax
   1d31f: 75 d7                        	jne	0x1d2f8 <bpf_object__open_skeleton+0xf8>
; 			pr_warn("failed to find skeleton program '%s'\n", name);
   1d321: 4c 89 ea                     	movq	%r13, %rdx
   1d324: 48 8d 35 15 bb 01 00         	leaq	113429(%rip), %rsi      # 0x38e40 <strs.2+0x5fb0>
   1d32b: 31 ff                        	xorl	%edi, %edi
   1d32d: e8 9e ad fe ff               	callq	0x80d0 <libbpf_print>
; 		pr_warn("failed to populate skeleton progs for '%s': %d\n", s->name, err);
   1d332: 48 8b 55 08                  	movq	8(%rbp), %rdx
   1d336: b9 fd ff ff ff               	movl	$4294967293, %ecx       # imm = 0xFFFFFFFD
   1d33b: 31 ff                        	xorl	%edi, %edi
   1d33d: 48 8d 35 2c bb 01 00         	leaq	113452(%rip), %rsi      # 0x38e70 <strs.2+0x5fe0>
   1d344: 31 c0                        	xorl	%eax, %eax
   1d346: e8 85 ad fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   1d34b: e8 a0 83 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d350: c7 44 24 0c fd ff ff ff      	movl	$4294967293, 12(%rsp)   # imm = 0xFFFFFFFD
   1d358: c7 00 03 00 00 00            	movl	$3, (%rax)
; }
   1d35e: 48 8b 44 24 58               	movq	88(%rsp), %rax
   1d363: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1d36c: 0f 85 ae 00 00 00            	jne	0x1d420 <bpf_object__open_skeleton+0x220>
   1d372: 8b 44 24 0c                  	movl	12(%rsp), %eax
   1d376: 48 83 c4 68                  	addq	$104, %rsp
   1d37a: 5b                           	popq	%rbx
   1d37b: 5d                           	popq	%rbp
   1d37c: 41 5c                        	popq	%r12
   1d37e: 41 5d                        	popq	%r13
   1d380: 41 5e                        	popq	%r14
   1d382: 41 5f                        	popq	%r15
   1d384: c3                           	retq
   1d385: 0f 1f 00                     	nopl	(%rax)
; 		errno = -PTR_ERR(ptr);
   1d388: e8 63 83 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d38d: 48 89 c3                     	movq	%rax, %rbx
; 	if (IS_ERR(ptr))
   1d390: 49 81 ff 00 f0 ff ff         	cmpq	$-4096, %r15            # imm = 0xF000
   1d397: 77 47                        	ja	0x1d3e0 <bpf_object__open_skeleton+0x1e0>
; 	return -errno;
   1d399: 44 8b 28                     	movl	(%rax), %r13d
; 	if (err) {
   1d39c: 45 85 ed                     	testl	%r13d, %r13d
   1d39f: 0f 84 17 ff ff ff            	je	0x1d2bc <bpf_object__open_skeleton+0xbc>
; 	return -errno;
   1d3a5: 44 89 e9                     	movl	%r13d, %ecx
; 		pr_warn("failed to initialize skeleton BPF object '%s': %d\n",
   1d3a8: 48 8b 55 08                  	movq	8(%rbp), %rdx
   1d3ac: 31 ff                        	xorl	%edi, %edi
   1d3ae: 31 c0                        	xorl	%eax, %eax
; 	return -errno;
   1d3b0: f7 d9                        	negl	%ecx
; 		pr_warn("failed to initialize skeleton BPF object '%s': %d\n",
   1d3b2: 48 8d 35 0f ba 01 00         	leaq	113167(%rip), %rsi      # 0x38dc8 <strs.2+0x5f38>
; 	return -errno;
   1d3b9: 89 4c 24 0c                  	movl	%ecx, 12(%rsp)
; 		pr_warn("failed to initialize skeleton BPF object '%s': %d\n",
   1d3bd: e8 0e ad fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   1d3c2: 45 85 ed                     	testl	%r13d, %r13d
   1d3c5: 7e 97                        	jle	0x1d35e <bpf_object__open_skeleton+0x15e>
; 		errno = -ret;
   1d3c7: 44 89 2b                     	movl	%r13d, (%rbx)
   1d3ca: eb 92                        	jmp	0x1d35e <bpf_object__open_skeleton+0x15e>
   1d3cc: 0f 1f 40 00                  	nopl	(%rax)
; 			skel_opts.object_name = s->name;
   1d3d0: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1d3d5: e9 b8 fe ff ff               	jmp	0x1d292 <bpf_object__open_skeleton+0x92>
   1d3da: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -PTR_ERR(ptr);
   1d3e0: 45 89 fd                     	movl	%r15d, %r13d
   1d3e3: 41 f7 dd                     	negl	%r13d
   1d3e6: 44 89 28                     	movl	%r13d, (%rax)
   1d3e9: eb b1                        	jmp	0x1d39c <bpf_object__open_skeleton+0x19c>
   1d3eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("failed to populate skeleton maps for '%s': %d\n", s->name, err);
   1d3f0: 48 8b 55 08                  	movq	8(%rbp), %rdx
   1d3f4: 89 c3                        	movl	%eax, %ebx
   1d3f6: 89 c1                        	movl	%eax, %ecx
   1d3f8: 31 ff                        	xorl	%edi, %edi
   1d3fa: 31 c0                        	xorl	%eax, %eax
   1d3fc: 48 8d 35 05 ba 01 00         	leaq	113157(%rip), %rsi      # 0x38e08 <strs.2+0x5f78>
   1d403: e8 c8 ac fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   1d408: 85 db                        	testl	%ebx, %ebx
   1d40a: 0f 89 4e ff ff ff            	jns	0x1d35e <bpf_object__open_skeleton+0x15e>
; 		errno = -ret;
   1d410: e8 db 82 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d415: 89 da                        	movl	%ebx, %edx
   1d417: f7 da                        	negl	%edx
   1d419: 89 10                        	movl	%edx, (%rax)
   1d41b: e9 3e ff ff ff               	jmp	0x1d35e <bpf_object__open_skeleton+0x15e>
; }
   1d420: e8 db 83 fe ff               	callq	0x5800 <.plt.sec+0x190>
   1d425: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

000000000001d430 <bpf_object__open_subskeleton>:
; {
   1d430: f3 0f 1e fa                  	endbr64
   1d434: 41 57                        	pushq	%r15
   1d436: 41 56                        	pushq	%r14
   1d438: 49 89 fe                     	movq	%rdi, %r14
   1d43b: 41 55                        	pushq	%r13
   1d43d: 41 54                        	pushq	%r12
   1d43f: 55                           	pushq	%rbp
   1d440: 53                           	pushq	%rbx
   1d441: 48 83 ec 28                  	subq	$40, %rsp
; 	if (!s->obj)
   1d445: 48 8b 7f 08                  	movq	8(%rdi), %rdi
   1d449: 48 85 ff                     	testq	%rdi, %rdi
   1d44c: 0f 84 e2 01 00 00            	je	0x1d634 <bpf_object__open_subskeleton+0x204>
; 	return obj ? obj->btf : NULL;
   1d452: 48 8b 9f 10 01 00 00         	movq	272(%rdi), %rbx
; 	if (!btf) {
   1d459: 48 85 db                     	testq	%rbx, %rbx
   1d45c: 0f 84 ea 01 00 00            	je	0x1d64c <bpf_object__open_subskeleton+0x21c>
; 	err = populate_skeleton_maps(s->obj, s->maps, s->map_cnt);
   1d462: 49 63 56 10                  	movslq	16(%r14), %rdx
   1d466: 49 8b 76 18                  	movq	24(%r14), %rsi
   1d46a: e8 a1 7d ff ff               	callq	0x15210 <populate_skeleton_maps>
   1d46f: 89 44 24 1c                  	movl	%eax, 28(%rsp)
; 	if (err) {
   1d473: 85 c0                        	testl	%eax, %eax
   1d475: 0f 85 62 01 00 00            	jne	0x1d5dd <bpf_object__open_subskeleton+0x1ad>
; 	err = populate_skeleton_progs(s->obj, s->progs, s->prog_cnt);
   1d47b: 49 63 46 20                  	movslq	32(%r14), %rax
   1d47f: 49 8b 4e 08                  	movq	8(%r14), %rcx
   1d483: 4d 8b 6e 28                  	movq	40(%r14), %r13
   1d487: 48 89 44 24 10               	movq	%rax, 16(%rsp)
   1d48c: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
; 	for (i = 0; i < prog_cnt; i++) {
   1d491: 48 85 c0                     	testq	%rax, %rax
   1d494: 0f 84 7f 00 00 00            	je	0x1d519 <bpf_object__open_subskeleton+0xe9>
   1d49a: 45 31 ff                     	xorl	%r15d, %r15d
   1d49d: eb 10                        	jmp	0x1d4af <bpf_object__open_subskeleton+0x7f>
   1d49f: 90                           	nop
   1d4a0: 49 83 c7 01                  	addq	$1, %r15
   1d4a4: 49 83 c5 18                  	addq	$24, %r13
   1d4a8: 4c 39 7c 24 10               	cmpq	%r15, 16(%rsp)
   1d4ad: 74 6a                        	je	0x1d519 <bpf_object__open_subskeleton+0xe9>
; 		const char *name = progs[i].name;
   1d4af: 49 8b 6d 00                  	movq	(%r13), %rbp
; 		*prog = bpf_object__find_program_by_name(obj, name);
   1d4b3: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
; 		struct bpf_program **prog = progs[i].prog;
   1d4b8: 4d 8b 65 08                  	movq	8(%r13), %r12
; 		*prog = bpf_object__find_program_by_name(obj, name);
   1d4bc: 48 89 ee                     	movq	%rbp, %rsi
   1d4bf: e8 fc 17 ff ff               	callq	0xecc0 <bpf_object__find_program_by_name>
   1d4c4: 49 89 04 24                  	movq	%rax, (%r12)
; 		if (!*prog) {
   1d4c8: 48 85 c0                     	testq	%rax, %rax
   1d4cb: 75 d3                        	jne	0x1d4a0 <bpf_object__open_subskeleton+0x70>
; 			pr_warn("failed to find skeleton program '%s'\n", name);
   1d4cd: 48 89 ea                     	movq	%rbp, %rdx
   1d4d0: 48 8d 35 69 b9 01 00         	leaq	113001(%rip), %rsi      # 0x38e40 <strs.2+0x5fb0>
   1d4d7: 31 ff                        	xorl	%edi, %edi
   1d4d9: e8 f2 ab fe ff               	callq	0x80d0 <libbpf_print>
; 		pr_warn("failed to populate subskeleton maps: %d\n", err);
   1d4de: ba fd ff ff ff               	movl	$4294967293, %edx       # imm = 0xFFFFFFFD
   1d4e3: 31 ff                        	xorl	%edi, %edi
   1d4e5: 31 c0                        	xorl	%eax, %eax
   1d4e7: 48 8d 35 fa b9 01 00         	leaq	113146(%rip), %rsi      # 0x38ee8 <strs.2+0x6058>
   1d4ee: e8 dd ab fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   1d4f3: e8 f8 81 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d4f8: c7 44 24 1c fd ff ff ff      	movl	$4294967293, 28(%rsp)   # imm = 0xFFFFFFFD
   1d500: c7 00 03 00 00 00            	movl	$3, (%rax)
; }
   1d506: 8b 44 24 1c                  	movl	28(%rsp), %eax
   1d50a: 48 83 c4 28                  	addq	$40, %rsp
   1d50e: 5b                           	popq	%rbx
   1d50f: 5d                           	popq	%rbp
   1d510: 41 5c                        	popq	%r12
   1d512: 41 5d                        	popq	%r13
   1d514: 41 5e                        	popq	%r14
   1d516: 41 5f                        	popq	%r15
   1d518: c3                           	retq
; 	for (var_idx = 0; var_idx < s->var_cnt; var_idx++) {
   1d519: 41 8b 46 30                  	movl	48(%r14), %eax
   1d51d: 45 31 ed                     	xorl	%r13d, %r13d
   1d520: 85 c0                        	testl	%eax, %eax
   1d522: 7e e2                        	jle	0x1d506 <bpf_object__open_subskeleton+0xd6>
   1d524: 0f 1f 40 00                  	nopl	(%rax)
; 		var_skel = &s->vars[var_idx];
   1d528: 49 8b 56 38                  	movq	56(%r14), %rdx
   1d52c: 4b 8d 44 6d 00               	leaq	(%r13,%r13,2), %rax
; 	return map ? map->btf_value_type_id : 0;
   1d531: 31 f6                        	xorl	%esi, %esi
; 		var_skel = &s->vars[var_idx];
   1d533: 48 8d 2c c2                  	leaq	(%rdx,%rax,8), %rbp
; 		map = *var_skel->map;
   1d537: 48 8b 45 08                  	movq	8(%rbp), %rax
   1d53b: 48 8b 00                     	movq	(%rax), %rax
   1d53e: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	return map ? map->btf_value_type_id : 0;
   1d543: 48 85 c0                     	testq	%rax, %rax
   1d546: 74 03                        	je	0x1d54b <bpf_object__open_subskeleton+0x11b>
   1d548: 8b 70 50                     	movl	80(%rax), %esi
; 		map_type = btf__type_by_id(btf, map_type_id);
   1d54b: 48 89 df                     	movq	%rbx, %rdi
   1d54e: e8 4d ca 00 00               	callq	0x29fa0 <btf__type_by_id>
; 	return BTF_INFO_KIND(t->info);
   1d553: 8b 48 04                     	movl	4(%rax), %ecx
   1d556: 89 ca                        	movl	%ecx, %edx
   1d558: c1 ea 18                     	shrl	$24, %edx
   1d55b: 83 e2 1f                     	andl	$31, %edx
; 		if (!btf_is_datasec(map_type)) {
   1d55e: 66 83 fa 0f                  	cmpw	$15, %dx
   1d562: 0f 85 a1 00 00 00            	jne	0x1d609 <bpf_object__open_subskeleton+0x1d9>
; 	return (struct btf_var_secinfo *)(t + 1);
   1d568: 4c 8d 78 0c                  	leaq	12(%rax), %r15
; 		for (i = 0; i < len; i++, var++) {
   1d56c: 81 e1 ff ff 00 00            	andl	$65535, %ecx            # imm = 0xFFFF
   1d572: 74 56                        	je	0x1d5ca <bpf_object__open_subskeleton+0x19a>
   1d574: 83 e9 01                     	subl	$1, %ecx
   1d577: 48 8d 0c 49                  	leaq	(%rcx,%rcx,2), %rcx
   1d57b: 4c 8d 64 88 18               	leaq	24(%rax,%rcx,4), %r12
   1d580: eb 0f                        	jmp	0x1d591 <bpf_object__open_subskeleton+0x161>
   1d582: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   1d588: 49 83 c7 0c                  	addq	$12, %r15
   1d58c: 4d 39 fc                     	cmpq	%r15, %r12
   1d58f: 74 39                        	je	0x1d5ca <bpf_object__open_subskeleton+0x19a>
; 			var_type = btf__type_by_id(btf, var->type);
   1d591: 41 8b 37                     	movl	(%r15), %esi
   1d594: 48 89 df                     	movq	%rbx, %rdi
   1d597: e8 04 ca 00 00               	callq	0x29fa0 <btf__type_by_id>
; 			var_name = btf__name_by_offset(btf, var_type->name_off);
   1d59c: 48 89 df                     	movq	%rbx, %rdi
   1d59f: 8b 30                        	movl	(%rax), %esi
   1d5a1: e8 4a e5 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 			if (strcmp(var_name, var_skel->name) == 0) {
   1d5a6: 48 8b 75 00                  	movq	(%rbp), %rsi
; 			var_name = btf__name_by_offset(btf, var_type->name_off);
   1d5aa: 48 89 c7                     	movq	%rax, %rdi
; 			if (strcmp(var_name, var_skel->name) == 0) {
   1d5ad: e8 fe 83 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   1d5b2: 85 c0                        	testl	%eax, %eax
   1d5b4: 75 d2                        	jne	0x1d588 <bpf_object__open_subskeleton+0x158>
; 				*var_skel->addr = map->mmaped + var->offset;
   1d5b6: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   1d5bb: 48 8b 4d 10                  	movq	16(%rbp), %rcx
   1d5bf: 41 8b 47 04                  	movl	4(%r15), %eax
   1d5c3: 48 03 42 60                  	addq	96(%rdx), %rax
   1d5c7: 48 89 01                     	movq	%rax, (%rcx)
; 	for (var_idx = 0; var_idx < s->var_cnt; var_idx++) {
   1d5ca: 49 83 c5 01                  	addq	$1, %r13
   1d5ce: 45 39 6e 30                  	cmpl	%r13d, 48(%r14)
   1d5d2: 0f 8f 50 ff ff ff            	jg	0x1d528 <bpf_object__open_subskeleton+0xf8>
   1d5d8: e9 29 ff ff ff               	jmp	0x1d506 <bpf_object__open_subskeleton+0xd6>
; 		pr_warn("failed to populate subskeleton maps: %d\n", err);
   1d5dd: 89 c3                        	movl	%eax, %ebx
   1d5df: 89 c2                        	movl	%eax, %edx
   1d5e1: 31 ff                        	xorl	%edi, %edi
   1d5e3: 31 c0                        	xorl	%eax, %eax
   1d5e5: 48 8d 35 fc b8 01 00         	leaq	112892(%rip), %rsi      # 0x38ee8 <strs.2+0x6058>
   1d5ec: e8 df aa fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   1d5f1: 85 db                        	testl	%ebx, %ebx
   1d5f3: 0f 89 0d ff ff ff            	jns	0x1d506 <bpf_object__open_subskeleton+0xd6>
; 		errno = -ret;
   1d5f9: e8 f2 80 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d5fe: 89 da                        	movl	%ebx, %edx
   1d600: f7 da                        	negl	%edx
   1d602: 89 10                        	movl	%edx, (%rax)
   1d604: e9 fd fe ff ff               	jmp	0x1d506 <bpf_object__open_subskeleton+0xd6>
; 			pr_warn("type for map '%1$s' is not a datasec: %2$s",
   1d609: 0f b7 fa                     	movzwl	%dx, %edi
   1d60c: e8 7f 8d fe ff               	callq	0x6390 <__btf_kind_str>
   1d611: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   1d616: 49 89 c4                     	movq	%rax, %r12
   1d619: e8 32 27 ff ff               	callq	0xfd50 <bpf_map__name>
   1d61e: 4c 89 e1                     	movq	%r12, %rcx
   1d621: 48 8d 35 f8 b8 01 00         	leaq	112888(%rip), %rsi      # 0x38f20 <strs.2+0x6090>
   1d628: 31 ff                        	xorl	%edi, %edi
   1d62a: 48 89 c2                     	movq	%rax, %rdx
   1d62d: 31 c0                        	xorl	%eax, %eax
   1d62f: e8 9c aa fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   1d634: e8 b7 80 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d639: c7 00 16 00 00 00            	movl	$22, (%rax)
; 			return libbpf_err(-EINVAL);
   1d63f: c7 44 24 1c ea ff ff ff      	movl	$4294967274, 28(%rsp)   # imm = 0xFFFFFFEA
   1d647: e9 ba fe ff ff               	jmp	0x1d506 <bpf_object__open_subskeleton+0xd6>
; 		pr_warn("subskeletons require BTF at runtime (object %s)\n",
   1d64c: 48 89 fa                     	movq	%rdi, %rdx
   1d64f: 48 8d 35 52 b8 01 00         	leaq	112722(%rip), %rsi      # 0x38ea8 <strs.2+0x6018>
   1d656: 31 ff                        	xorl	%edi, %edi
   1d658: 31 c0                        	xorl	%eax, %eax
   1d65a: e8 71 aa fe ff               	callq	0x80d0 <libbpf_print>
; 		return libbpf_err(-errno);
   1d65f: e8 8c 80 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d664: 8b 00                        	movl	(%rax), %eax
   1d666: f7 d8                        	negl	%eax
   1d668: 89 44 24 1c                  	movl	%eax, 28(%rsp)
   1d66c: e9 95 fe ff ff               	jmp	0x1d506 <bpf_object__open_subskeleton+0xd6>
   1d671: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1d67c: 0f 1f 40 00                  	nopl	(%rax)

000000000001d680 <bpf_object__destroy_subskeleton>:
; {
   1d680: f3 0f 1e fa                  	endbr64
; 	if (!s)
   1d684: 48 85 ff                     	testq	%rdi, %rdi
   1d687: 74 2f                        	je	0x1d6b8 <bpf_object__destroy_subskeleton+0x38>
; {
   1d689: 55                           	pushq	%rbp
   1d68a: 48 89 fd                     	movq	%rdi, %rbp
; 	free(s->maps);
   1d68d: 48 8b 7f 18                  	movq	24(%rdi), %rdi
   1d691: e8 2a 80 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(s->progs);
   1d696: 48 8b 7d 28                  	movq	40(%rbp), %rdi
   1d69a: e8 21 80 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(s->vars);
   1d69f: 48 8b 7d 38                  	movq	56(%rbp), %rdi
   1d6a3: e8 18 80 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(s);
   1d6a8: 48 89 ef                     	movq	%rbp, %rdi
; }
   1d6ab: 5d                           	popq	%rbp
; 	free(s);
   1d6ac: e9 0f 80 fe ff               	jmp	0x56c0 <.plt.sec+0x50>
   1d6b1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   1d6b8: c3                           	retq
   1d6b9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001d6c0 <bpf_object__load_skeleton>:
; {
   1d6c0: f3 0f 1e fa                  	endbr64
   1d6c4: 41 56                        	pushq	%r14
   1d6c6: 49 89 fe                     	movq	%rdi, %r14
   1d6c9: 41 55                        	pushq	%r13
   1d6cb: 41 54                        	pushq	%r12
   1d6cd: 55                           	pushq	%rbp
   1d6ce: 53                           	pushq	%rbx
; 	err = bpf_object__load(*s->obj);
   1d6cf: 48 8b 47 20                  	movq	32(%rdi), %rax
; 	return bpf_object_load(obj, 0, NULL);
   1d6d3: 48 8b 38                     	movq	(%rax), %rdi
   1d6d6: e8 45 c6 ff ff               	callq	0x19d20 <bpf_object_load.constprop.0>
   1d6db: 41 89 c5                     	movl	%eax, %r13d
; 	if (err) {
   1d6de: 85 c0                        	testl	%eax, %eax
   1d6e0: 0f 85 2a 01 00 00            	jne	0x1d810 <bpf_object__load_skeleton+0x150>
; 	for (i = 0; i < s->map_cnt; i++) {
   1d6e6: 41 8b 46 28                  	movl	40(%r14), %eax
   1d6ea: 45 31 e4                     	xorl	%r12d, %r12d
   1d6ed: 85 c0                        	testl	%eax, %eax
   1d6ef: 7f 65                        	jg	0x1d756 <bpf_object__load_skeleton+0x96>
   1d6f1: e9 b6 00 00 00               	jmp	0x1d7ac <bpf_object__load_skeleton+0xec>
   1d6f6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		if (map->def.map_flags & BPF_F_RDONLY_PROG)
   1d700: 81 e2 80 00 00 00            	andl	$128, %edx
; 		*mmaped = mmap(map->mmaped, mmap_sz, prot,
   1d706: 48 8b 7d 60                  	movq	96(%rbp), %rdi
; 			prot = PROT_READ | PROT_WRITE;
   1d70a: 83 fa 01                     	cmpl	$1, %edx
   1d70d: 45 19 d2                     	sbbl	%r10d, %r10d
; 	map_sz = (size_t)roundup(map->def.value_size, 8) * map->def.max_entries;
   1d710: 83 c0 07                     	addl	$7, %eax
; 	map_sz = roundup(map_sz, page_sz);
   1d713: 31 d2                        	xorl	%edx, %edx
; 		*mmaped = mmap(map->mmaped, mmap_sz, prot,
   1d715: 45 31 c9                     	xorl	%r9d, %r9d
; 	map_sz = (size_t)roundup(map->def.value_size, 8) * map->def.max_entries;
   1d718: 83 e0 f8                     	andl	$-8, %eax
; 			prot = PROT_READ | PROT_WRITE;
   1d71b: 41 83 e2 02                  	andl	$2, %r10d
; 	map_sz = (size_t)roundup(map->def.value_size, 8) * map->def.max_entries;
   1d71f: 48 0f af c6                  	imulq	%rsi, %rax
; 			prot = PROT_READ | PROT_WRITE;
   1d723: 41 83 c2 01                  	addl	$1, %r10d
; 	map_sz = roundup(map_sz, page_sz);
   1d727: 48 8d 44 01 ff               	leaq	-1(%rcx,%rax), %rax
   1d72c: 48 f7 f1                     	divq	%rcx
; 		*mmaped = mmap(map->mmaped, mmap_sz, prot,
   1d72f: 44 89 d2                     	movl	%r10d, %edx
; 	map_sz = roundup(map_sz, page_sz);
   1d732: 48 0f af c1                  	imulq	%rcx, %rax
; 		*mmaped = mmap(map->mmaped, mmap_sz, prot,
   1d736: b9 11 00 00 00               	movl	$17, %ecx
; 	map_sz = roundup(map_sz, page_sz);
   1d73b: 48 89 c6                     	movq	%rax, %rsi
; 		*mmaped = mmap(map->mmaped, mmap_sz, prot,
   1d73e: e8 3d 83 fe ff               	callq	0x5a80 <.plt.sec+0x410>
   1d743: 48 89 03                     	movq	%rax, (%rbx)
; 		if (*mmaped == MAP_FAILED) {
   1d746: 48 83 f8 ff                  	cmpq	$-1, %rax
   1d74a: 74 74                        	je	0x1d7c0 <bpf_object__load_skeleton+0x100>
; 	for (i = 0; i < s->map_cnt; i++) {
   1d74c: 49 83 c4 01                  	addq	$1, %r12
   1d750: 45 39 66 28                  	cmpl	%r12d, 40(%r14)
   1d754: 7e 56                        	jle	0x1d7ac <bpf_object__load_skeleton+0xec>
; 		struct bpf_map *map = *s->maps[i].map;
   1d756: 49 8b 46 30                  	movq	48(%r14), %rax
   1d75a: 4b 8d 1c 64                  	leaq	(%r12,%r12,2), %rbx
; 	long page_sz = sysconf(_SC_PAGE_SIZE);
   1d75e: bf 1e 00 00 00               	movl	$30, %edi
   1d763: 48 c1 e3 03                  	shlq	$3, %rbx
; 		struct bpf_map *map = *s->maps[i].map;
   1d767: 48 8b 44 18 08               	movq	8(%rax,%rbx), %rax
   1d76c: 48 8b 28                     	movq	(%rax), %rbp
; 	long page_sz = sysconf(_SC_PAGE_SIZE);
   1d76f: e8 3c 84 fe ff               	callq	0x5bb0 <.plt.sec+0x540>
; 		void **mmaped = s->maps[i].mmaped;
   1d774: 49 8b 56 30                  	movq	48(%r14), %rdx
; 	long page_sz = sysconf(_SC_PAGE_SIZE);
   1d778: 48 89 c1                     	movq	%rax, %rcx
; 	map_sz = (size_t)roundup(map->def.value_size, 8) * map->def.max_entries;
   1d77b: 8b 75 3c                     	movl	60(%rbp), %esi
   1d77e: 8b 45 38                     	movl	56(%rbp), %eax
; 		void **mmaped = s->maps[i].mmaped;
   1d781: 48 8b 5c 1a 10               	movq	16(%rdx,%rbx), %rbx
; 	return map ? map->fd : libbpf_err(-EINVAL);
   1d786: 44 8b 45 18                  	movl	24(%rbp), %r8d
; 		if (!mmaped)
   1d78a: 48 85 db                     	testq	%rbx, %rbx
   1d78d: 74 bd                        	je	0x1d74c <bpf_object__load_skeleton+0x8c>
; 		if (!(map->def.map_flags & BPF_F_MMAPABLE)) {
   1d78f: 8b 55 40                     	movl	64(%rbp), %edx
   1d792: f6 c6 04                     	testb	$4, %dh
   1d795: 0f 85 65 ff ff ff            	jne	0x1d700 <bpf_object__load_skeleton+0x40>
; 			*mmaped = NULL;
   1d79b: 48 c7 03 00 00 00 00         	movq	$0, (%rbx)
; 	for (i = 0; i < s->map_cnt; i++) {
   1d7a2: 49 83 c4 01                  	addq	$1, %r12
   1d7a6: 45 39 66 28                  	cmpl	%r12d, 40(%r14)
   1d7aa: 7f aa                        	jg	0x1d756 <bpf_object__load_skeleton+0x96>
; }
   1d7ac: 5b                           	popq	%rbx
   1d7ad: 44 89 e8                     	movl	%r13d, %eax
   1d7b0: 5d                           	popq	%rbp
   1d7b1: 41 5c                        	popq	%r12
   1d7b3: 41 5d                        	popq	%r13
   1d7b5: 41 5e                        	popq	%r14
   1d7b7: c3                           	retq
   1d7b8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 			err = -errno;
   1d7c0: e8 2b 7f fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("failed to re-mmap() map '%s': %d\n",
   1d7c5: 48 89 ef                     	movq	%rbp, %rdi
; 			err = -errno;
   1d7c8: 44 8b 30                     	movl	(%rax), %r14d
; 			*mmaped = NULL;
   1d7cb: 48 c7 03 00 00 00 00         	movq	$0, (%rbx)
; 			err = -errno;
   1d7d2: 49 89 c4                     	movq	%rax, %r12
   1d7d5: 45 89 f5                     	movl	%r14d, %r13d
; 			pr_warn("failed to re-mmap() map '%s': %d\n",
   1d7d8: e8 73 25 ff ff               	callq	0xfd50 <bpf_map__name>
; 			err = -errno;
   1d7dd: 41 f7 dd                     	negl	%r13d
; 			pr_warn("failed to re-mmap() map '%s': %d\n",
   1d7e0: 31 ff                        	xorl	%edi, %edi
   1d7e2: 48 8d 35 9f b7 01 00         	leaq	112543(%rip), %rsi      # 0x38f88 <strs.2+0x60f8>
   1d7e9: 48 89 c2                     	movq	%rax, %rdx
   1d7ec: 44 89 e9                     	movl	%r13d, %ecx
   1d7ef: 31 c0                        	xorl	%eax, %eax
   1d7f1: e8 da a8 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   1d7f6: 45 85 f6                     	testl	%r14d, %r14d
   1d7f9: 7e b1                        	jle	0x1d7ac <bpf_object__load_skeleton+0xec>
; 		errno = -ret;
   1d7fb: 45 89 34 24                  	movl	%r14d, (%r12)
; }
   1d7ff: 44 89 e8                     	movl	%r13d, %eax
   1d802: 5b                           	popq	%rbx
   1d803: 5d                           	popq	%rbp
   1d804: 41 5c                        	popq	%r12
   1d806: 41 5d                        	popq	%r13
   1d808: 41 5e                        	popq	%r14
   1d80a: c3                           	retq
   1d80b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("failed to load BPF skeleton '%s': %d\n", s->name, err);
   1d810: 49 8b 56 08                  	movq	8(%r14), %rdx
   1d814: 89 c1                        	movl	%eax, %ecx
   1d816: 31 ff                        	xorl	%edi, %edi
   1d818: 31 c0                        	xorl	%eax, %eax
   1d81a: 48 8d 35 37 b7 01 00         	leaq	112439(%rip), %rsi      # 0x38f58 <strs.2+0x60c8>
   1d821: e8 aa a8 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   1d826: 45 85 ed                     	testl	%r13d, %r13d
   1d829: 79 81                        	jns	0x1d7ac <bpf_object__load_skeleton+0xec>
; 		errno = -ret;
   1d82b: e8 c0 7e fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d830: 44 89 ea                     	movl	%r13d, %edx
   1d833: f7 da                        	negl	%edx
   1d835: 89 10                        	movl	%edx, (%rax)
   1d837: e9 70 ff ff ff               	jmp	0x1d7ac <bpf_object__load_skeleton+0xec>
   1d83c: 0f 1f 40 00                  	nopl	(%rax)

000000000001d840 <bpf_object__attach_skeleton>:
; {
   1d840: f3 0f 1e fa                  	endbr64
   1d844: 41 55                        	pushq	%r13
   1d846: 41 54                        	pushq	%r12
   1d848: 55                           	pushq	%rbp
   1d849: 53                           	pushq	%rbx
   1d84a: 48 83 ec 08                  	subq	$8, %rsp
; 	for (i = 0; i < s->prog_cnt; i++) {
   1d84e: 8b 47 38                     	movl	56(%rdi), %eax
   1d851: 85 c0                        	testl	%eax, %eax
   1d853: 0f 8e 87 00 00 00            	jle	0x1d8e0 <bpf_object__attach_skeleton+0xa0>
   1d859: 49 89 fc                     	movq	%rdi, %r12
   1d85c: 31 db                        	xorl	%ebx, %ebx
   1d85e: eb 0b                        	jmp	0x1d86b <bpf_object__attach_skeleton+0x2b>
   1d860: 48 83 c3 01                  	addq	$1, %rbx
   1d864: 41 39 5c 24 38               	cmpl	%ebx, 56(%r12)
   1d869: 7e 75                        	jle	0x1d8e0 <bpf_object__attach_skeleton+0xa0>
; 		struct bpf_program *prog = *s->progs[i].prog;
   1d86b: 49 8b 54 24 40               	movq	64(%r12), %rdx
   1d870: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
   1d874: 48 8d 04 c2                  	leaq	(%rdx,%rax,8), %rax
   1d878: 48 8b 50 08                  	movq	8(%rax), %rdx
   1d87c: 48 8b 2a                     	movq	(%rdx), %rbp
; 		struct bpf_link **link = s->progs[i].link;
   1d87f: 48 8b 50 10                  	movq	16(%rax), %rdx
; 		if (!prog->autoload || !prog->autoattach)
   1d883: 80 7d 7c 00                  	cmpb	$0, 124(%rbp)
   1d887: 74 d7                        	je	0x1d860 <bpf_object__attach_skeleton+0x20>
   1d889: 80 7d 7d 00                  	cmpb	$0, 125(%rbp)
   1d88d: 74 d1                        	je	0x1d860 <bpf_object__attach_skeleton+0x20>
; 		if (!prog->sec_def || !prog->sec_def->prog_attach_fn)
   1d88f: 48 8b 45 18                  	movq	24(%rbp), %rax
   1d893: 48 85 c0                     	testq	%rax, %rax
   1d896: 74 c8                        	je	0x1d860 <bpf_object__attach_skeleton+0x20>
   1d898: 48 8b 48 30                  	movq	48(%rax), %rcx
   1d89c: 48 85 c9                     	testq	%rcx, %rcx
   1d89f: 74 bf                        	je	0x1d860 <bpf_object__attach_skeleton+0x20>
; 		if (*link)
   1d8a1: 48 83 3a 00                  	cmpq	$0, (%rdx)
   1d8a5: 75 b9                        	jne	0x1d860 <bpf_object__attach_skeleton+0x20>
; 		err = prog->sec_def->prog_attach_fn(prog, prog->sec_def->cookie, link);
   1d8a7: 48 8b 70 10                  	movq	16(%rax), %rsi
   1d8ab: 48 89 ef                     	movq	%rbp, %rdi
   1d8ae: ff d1                        	callq	*%rcx
   1d8b0: 41 89 c5                     	movl	%eax, %r13d
; 		if (err) {
   1d8b3: 85 c0                        	testl	%eax, %eax
   1d8b5: 74 a9                        	je	0x1d860 <bpf_object__attach_skeleton+0x20>
; 			pr_warn("prog '%s': failed to auto-attach: %d\n",
   1d8b7: 48 8b 55 00                  	movq	(%rbp), %rdx
   1d8bb: 89 c1                        	movl	%eax, %ecx
   1d8bd: 31 ff                        	xorl	%edi, %edi
   1d8bf: 31 c0                        	xorl	%eax, %eax
   1d8c1: 48 8d 35 f0 b6 01 00         	leaq	112368(%rip), %rsi      # 0x38fb8 <strs.2+0x6128>
   1d8c8: e8 03 a8 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (ret < 0)
   1d8cd: 45 85 ed                     	testl	%r13d, %r13d
   1d8d0: 79 11                        	jns	0x1d8e3 <bpf_object__attach_skeleton+0xa3>
; 		errno = -ret;
   1d8d2: e8 19 7e fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1d8d7: 44 89 ea                     	movl	%r13d, %edx
   1d8da: f7 da                        	negl	%edx
   1d8dc: 89 10                        	movl	%edx, (%rax)
   1d8de: eb 03                        	jmp	0x1d8e3 <bpf_object__attach_skeleton+0xa3>
; 	return 0;
   1d8e0: 45 31 ed                     	xorl	%r13d, %r13d
; }
   1d8e3: 48 83 c4 08                  	addq	$8, %rsp
   1d8e7: 44 89 e8                     	movl	%r13d, %eax
   1d8ea: 5b                           	popq	%rbx
   1d8eb: 5d                           	popq	%rbp
   1d8ec: 41 5c                        	popq	%r12
   1d8ee: 41 5d                        	popq	%r13
   1d8f0: c3                           	retq
   1d8f1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1d8fc: 0f 1f 40 00                  	nopl	(%rax)

000000000001d900 <bpf_object__detach_skeleton>:
; {
   1d900: f3 0f 1e fa                  	endbr64
; 	for (i = 0; i < s->prog_cnt; i++) {
   1d904: 8b 4f 38                     	movl	56(%rdi), %ecx
   1d907: 85 c9                        	testl	%ecx, %ecx
   1d909: 7e 55                        	jle	0x1d960 <bpf_object__detach_skeleton+0x60>
; {
   1d90b: 41 54                        	pushq	%r12
   1d90d: 49 89 fc                     	movq	%rdi, %r12
   1d910: 55                           	pushq	%rbp
   1d911: 53                           	pushq	%rbx
; 	for (i = 0; i < s->prog_cnt; i++) {
   1d912: 31 db                        	xorl	%ebx, %ebx
   1d914: 0f 1f 40 00                  	nopl	(%rax)
; 		struct bpf_link **link = s->progs[i].link;
   1d918: 49 8b 54 24 40               	movq	64(%r12), %rdx
   1d91d: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
   1d921: 48 8d 04 c2                  	leaq	(%rdx,%rax,8), %rax
   1d925: 48 8b 68 10                  	movq	16(%rax), %rbp
; 		bpf_link__destroy(*link);
   1d929: 48 8b 7d 00                  	movq	(%rbp), %rdi
; 	if (IS_ERR_OR_NULL(link))
   1d92d: 48 85 ff                     	testq	%rdi, %rdi
   1d930: 74 0e                        	je	0x1d940 <bpf_object__detach_skeleton+0x40>
   1d932: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   1d939: 77 05                        	ja	0x1d940 <bpf_object__detach_skeleton+0x40>
   1d93b: e8 60 a3 fe ff               	callq	0x7ca0 <bpf_link__destroy.part.0>
; 		*link = NULL;
   1d940: 48 c7 45 00 00 00 00 00      	movq	$0, (%rbp)
; 	for (i = 0; i < s->prog_cnt; i++) {
   1d948: 48 83 c3 01                  	addq	$1, %rbx
   1d94c: 41 39 5c 24 38               	cmpl	%ebx, 56(%r12)
   1d951: 7f c5                        	jg	0x1d918 <bpf_object__detach_skeleton+0x18>
; }
   1d953: 5b                           	popq	%rbx
   1d954: 5d                           	popq	%rbp
   1d955: 41 5c                        	popq	%r12
   1d957: c3                           	retq
   1d958: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
   1d960: c3                           	retq
   1d961: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1d96c: 0f 1f 40 00                  	nopl	(%rax)

000000000001d970 <bpf_object__destroy_skeleton>:
; {
   1d970: f3 0f 1e fa                  	endbr64
; 	if (!s)
   1d974: 48 85 ff                     	testq	%rdi, %rdi
   1d977: 74 4f                        	je	0x1d9c8 <bpf_object__destroy_skeleton+0x58>
; {
   1d979: 55                           	pushq	%rbp
; 	if (s->progs)
   1d97a: 48 83 7f 40 00               	cmpq	$0, 64(%rdi)
   1d97f: 48 89 fd                     	movq	%rdi, %rbp
   1d982: 74 05                        	je	0x1d989 <bpf_object__destroy_skeleton+0x19>
; 		bpf_object__detach_skeleton(s);
   1d984: e8 77 ff ff ff               	callq	0x1d900 <bpf_object__detach_skeleton>
; 	if (s->obj)
   1d989: 48 8b 45 20                  	movq	32(%rbp), %rax
   1d98d: 48 85 c0                     	testq	%rax, %rax
   1d990: 74 16                        	je	0x1d9a8 <bpf_object__destroy_skeleton+0x38>
; 		bpf_object__close(*s->obj);
   1d992: 48 8b 38                     	movq	(%rax), %rdi
; 	if (IS_ERR_OR_NULL(obj))
   1d995: 48 85 ff                     	testq	%rdi, %rdi
   1d998: 74 0e                        	je	0x1d9a8 <bpf_object__destroy_skeleton+0x38>
   1d99a: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   1d9a1: 77 05                        	ja	0x1d9a8 <bpf_object__destroy_skeleton+0x38>
   1d9a3: e8 a8 a4 fe ff               	callq	0x7e50 <bpf_object__close.part.0>
; 	free(s->maps);
   1d9a8: 48 8b 7d 30                  	movq	48(%rbp), %rdi
   1d9ac: e8 0f 7d fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(s->progs);
   1d9b1: 48 8b 7d 40                  	movq	64(%rbp), %rdi
   1d9b5: e8 06 7d fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(s);
   1d9ba: 48 89 ef                     	movq	%rbp, %rdi
; }
   1d9bd: 5d                           	popq	%rbp
; 	free(s);
   1d9be: e9 fd 7c fe ff               	jmp	0x56c0 <.plt.sec+0x50>
   1d9c3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   1d9c8: c3                           	retq
   1d9c9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001d9d0 <libbpf_strerror_r>:
; {
   1d9d0: f3 0f 1e fa                  	endbr64
   1d9d4: 41 54                        	pushq	%r12
   1d9d6: 49 89 f4                     	movq	%rsi, %r12
   1d9d9: 55                           	pushq	%rbp
; 	int ret = strerror_r(err < 0 ? -err : err, dst, len);
   1d9da: 48 63 ea                     	movslq	%edx, %rbp
; {
   1d9dd: 53                           	pushq	%rbx
   1d9de: 89 fb                        	movl	%edi, %ebx
; 	int ret = strerror_r(err < 0 ? -err : err, dst, len);
   1d9e0: f7 df                        	negl	%edi
   1d9e2: 48 89 ea                     	movq	%rbp, %rdx
   1d9e5: 0f 48 fb                     	cmovsl	%ebx, %edi
   1d9e8: e8 a3 7d fe ff               	callq	0x5790 <.plt.sec+0x120>
; 	if (ret)
   1d9ed: 85 c0                        	testl	%eax, %eax
   1d9ef: 75 0f                        	jne	0x1da00 <libbpf_strerror_r+0x30>
; }
   1d9f1: 4c 89 e0                     	movq	%r12, %rax
   1d9f4: 5b                           	popq	%rbx
   1d9f5: 5d                           	popq	%rbp
   1d9f6: 41 5c                        	popq	%r12
   1d9f8: c3                           	retq
   1d9f9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1da00: 48 83 ec 08                  	subq	$8, %rsp
   1da04: 41 89 d9                     	movl	%ebx, %r9d
   1da07: ba 01 00 00 00               	movl	$1, %edx
   1da0c: 48 89 ee                     	movq	%rbp, %rsi
   1da0f: 50                           	pushq	%rax
   1da10: 4c 89 e7                     	movq	%r12, %rdi
   1da13: 4c 8d 05 4e b6 01 00         	leaq	112206(%rip), %r8       # 0x39068 <strs.2+0x61d8>
   1da1a: 31 c0                        	xorl	%eax, %eax
   1da1c: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
   1da23: e8 88 7c fe ff               	callq	0x56b0 <.plt.sec+0x40>
   1da28: 58                           	popq	%rax
; }
   1da29: 4c 89 e0                     	movq	%r12, %rax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1da2c: 5a                           	popq	%rdx
; }
   1da2d: 5b                           	popq	%rbx
   1da2e: 5d                           	popq	%rbp
   1da2f: 41 5c                        	popq	%r12
   1da31: c3                           	retq
   1da32: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   1da3c: 0f 1f 40 00                  	nopl	(%rax)

000000000001da40 <probe_prog_load.constprop.0>:
; static int probe_prog_load(enum bpf_prog_type prog_type,
   1da40: 41 55                        	pushq	%r13
   1da42: 41 54                        	pushq	%r12
   1da44: 55                           	pushq	%rbp
   1da45: 53                           	pushq	%rbx
   1da46: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   1da4d: 48 83 0c 24 00               	orq	$0, (%rsp)
   1da52: 48 81 ec 98 00 00 00         	subq	$152, %rsp
;   return __builtin___memset_chk (__dest, __ch, __len,
   1da59: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; static int probe_prog_load(enum bpf_prog_type prog_type,
   1da5d: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1da66: 48 89 84 24 88 10 00 00      	movq	%rax, 4232(%rsp)
   1da6e: 31 c0                        	xorl	%eax, %eax
; 	LIBBPF_OPTS(bpf_prog_load_opts, opts,
   1da70: 31 c0                        	xorl	%eax, %eax
   1da72: 48 85 d2                     	testq	%rdx, %rdx
   1da75: 89 4c 24 6c                  	movl	%ecx, 108(%rsp)
   1da79: 0f 95 c0                     	setne	%al
   1da7c: 48 89 54 24 70               	movq	%rdx, 112(%rsp)
   1da81: 48 c7 44 24 10 68 00 00 00   	movq	$104, 16(%rsp)
   1da8a: 89 44 24 68                  	movl	%eax, 104(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1da8e: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
   1da93: 0f 11 44 24 28               	movups	%xmm0, 40(%rsp)
   1da98: 0f 11 44 24 38               	movups	%xmm0, 56(%rsp)
   1da9d: 0f 11 44 24 48               	movups	%xmm0, 72(%rsp)
   1daa2: 0f 11 44 24 58               	movups	%xmm0, 88(%rsp)
; 	switch (prog_type) {
   1daa7: 83 ff 1f                     	cmpl	$31, %edi
   1daaa: 0f 87 04 82 fe ff            	ja	0x5cb4 <probe_prog_load.constprop.0.cold>
   1dab0: 48 8d 15 31 b6 01 00         	leaq	112177(%rip), %rdx      # 0x390e8 <strs.2+0x6258>
   1dab7: 89 f8                        	movl	%edi, %eax
   1dab9: 49 89 f4                     	movq	%rsi, %r12
   1dabc: 48 63 04 82                  	movslq	(%rdx,%rax,4), %rax
   1dac0: 48 01 d0                     	addq	%rdx, %rax
   1dac3: 3e ff e0                     	jmpq	*%rax
   1dac6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		opts.expected_attach_type = BPF_SK_LOOKUP;
   1dad0: c7 44 24 1c 24 00 00 00      	movl	$36, 28(%rsp)
; 		break;
   1dad8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	fd = bpf_prog_load(prog_type, NULL, "GPL", insns, insns_cnt, &opts);
   1dae0: 4c 8d 4c 24 10               	leaq	16(%rsp), %r9
   1dae5: 41 b8 02 00 00 00            	movl	$2, %r8d
   1daeb: 4c 89 e1                     	movq	%r12, %rcx
   1daee: 31 f6                        	xorl	%esi, %esi
   1daf0: 48 8d 15 43 41 01 00         	leaq	82243(%rip), %rdx       # 0x31c3a <_IO_stdin_used+0x1c3a>
   1daf7: e8 54 81 00 00               	callq	0x25c50 <bpf_prog_load>
   1dafc: 89 c3                        	movl	%eax, %ebx
; 	if (fd >= 0)
   1dafe: 85 c0                        	testl	%eax, %eax
   1db00: 79 2e                        	jns	0x1db30 <probe_prog_load.constprop.0+0xf0>
; 	return fd >= 0 ? 1 : 0;
   1db02: 89 d8                        	movl	%ebx, %eax
   1db04: f7 d0                        	notl	%eax
   1db06: c1 e8 1f                     	shrl	$31, %eax
; }
   1db09: 48 8b 94 24 88 10 00 00      	movq	4232(%rsp), %rdx
   1db11: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   1db1a: 0f 85 9f 01 00 00            	jne	0x1dcbf <probe_prog_load.constprop.0+0x27f>
   1db20: 48 81 c4 98 10 00 00         	addq	$4248, %rsp             # imm = 0x1098
   1db27: 5b                           	popq	%rbx
   1db28: 5d                           	popq	%rbp
   1db29: 41 5c                        	popq	%r12
   1db2b: 41 5d                        	popq	%r13
   1db2d: c3                           	retq
   1db2e: 66 90                        	nop
; 		close(fd);
   1db30: 89 df                        	movl	%ebx, %edi
   1db32: e8 c9 7d fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (exp_err) {
   1db37: eb c9                        	jmp	0x1db02 <probe_prog_load.constprop.0+0xc2>
   1db39: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		opts.log_buf = buf;
   1db40: 48 8d ac 24 80 00 00 00      	leaq	128(%rsp), %rbp
; 		exp_msg = "attach_btf_id 1 is not a function";
   1db48: 4c 8d 2d 59 b5 01 00         	leaq	111961(%rip), %r13      # 0x390a8 <strs.2+0x6218>
; 		opts.log_level = 1;
   1db4f: 48 b8 01 00 00 00 00 10 00 00	movabsq	$17592186044417, %rax   # imm = 0x100000000001
   1db59: 48 89 44 24 68               	movq	%rax, 104(%rsp)
; 			opts.expected_attach_type = BPF_TRACE_FENTRY;
   1db5e: 31 c0                        	xorl	%eax, %eax
   1db60: 83 ff 1a                     	cmpl	$26, %edi
   1db63: 0f 95 c0                     	setne	%al
; 		opts.log_buf = buf;
   1db66: 48 89 6c 24 70               	movq	%rbp, 112(%rsp)
; 			opts.expected_attach_type = BPF_TRACE_FENTRY;
   1db6b: 8d 44 00 18                  	leal	24(%rax,%rax), %eax
   1db6f: 89 44 24 1c                  	movl	%eax, 28(%rsp)
; 	fd = bpf_prog_load(prog_type, NULL, "GPL", insns, insns_cnt, &opts);
   1db73: 4c 89 e1                     	movq	%r12, %rcx
   1db76: 4c 8d 4c 24 10               	leaq	16(%rsp), %r9
   1db7b: 41 b8 02 00 00 00            	movl	$2, %r8d
   1db81: 31 f6                        	xorl	%esi, %esi
   1db83: 48 8d 15 b0 40 01 00         	leaq	82096(%rip), %rdx       # 0x31c3a <_IO_stdin_used+0x1c3a>
; 		opts.attach_btf_id = 1;
   1db8a: c7 44 24 30 01 00 00 00      	movl	$1, 48(%rsp)
; 	fd = bpf_prog_load(prog_type, NULL, "GPL", insns, insns_cnt, &opts);
   1db92: e8 b9 80 00 00               	callq	0x25c50 <bpf_prog_load>
   1db97: 41 89 c4                     	movl	%eax, %r12d
; 	err = -errno;
   1db9a: e8 51 7b fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1db9f: 8b 00                        	movl	(%rax), %eax
; 	if (fd >= 0)
   1dba1: 45 85 e4                     	testl	%r12d, %r12d
   1dba4: 0f 89 06 01 00 00            	jns	0x1dcb0 <probe_prog_load.constprop.0+0x270>
; 		if (fd >= 0 || err != exp_err)
   1dbaa: 83 f8 16                     	cmpl	$22, %eax
   1dbad: 0f 85 f4 00 00 00            	jne	0x1dca7 <probe_prog_load.constprop.0+0x267>
; 		if (exp_msg && !strstr(buf, exp_msg))
   1dbb3: 4c 89 ee                     	movq	%r13, %rsi
   1dbb6: 48 89 ef                     	movq	%rbp, %rdi
   1dbb9: e8 a2 80 fe ff               	callq	0x5c60 <.plt.sec+0x5f0>
   1dbbe: 48 85 c0                     	testq	%rax, %rax
   1dbc1: 0f 84 e0 00 00 00            	je	0x1dca7 <probe_prog_load.constprop.0+0x267>
; 		return 1;
   1dbc7: b8 01 00 00 00               	movl	$1, %eax
   1dbcc: e9 38 ff ff ff               	jmp	0x1db09 <probe_prog_load.constprop.0+0xc9>
   1dbd1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		opts.prog_flags = BPF_F_SLEEPABLE;
   1dbd8: c7 44 24 24 10 00 00 00      	movl	$16, 36(%rsp)
; 		break;
   1dbe0: e9 fb fe ff ff               	jmp	0x1dae0 <probe_prog_load.constprop.0+0xa0>
   1dbe5: 0f 1f 00                     	nopl	(%rax)
   1dbe8: 89 7c 24 0c                  	movl	%edi, 12(%rsp)
; 		opts.kern_version = get_kernel_version();
   1dbec: e8 3f d8 fe ff               	callq	0xb430 <get_kernel_version>
; 		break;
   1dbf1: 8b 7c 24 0c                  	movl	12(%rsp), %edi
; 		opts.kern_version = get_kernel_version();
   1dbf5: 89 44 24 2c                  	movl	%eax, 44(%rsp)
; 		break;
   1dbf9: e9 e2 fe ff ff               	jmp	0x1dae0 <probe_prog_load.constprop.0+0xa0>
   1dbfe: 66 90                        	nop
; 		opts.expected_attach_type = BPF_CGROUP_GETSOCKOPT;
   1dc00: c7 44 24 1c 15 00 00 00      	movl	$21, 28(%rsp)
; 		break;
   1dc08: e9 d3 fe ff ff               	jmp	0x1dae0 <probe_prog_load.constprop.0+0xa0>
   1dc0d: 0f 1f 00                     	nopl	(%rax)
; 		opts.log_buf = buf;
   1dc10: 48 8d ac 24 80 00 00 00      	leaq	128(%rsp), %rbp
; 		exp_msg = "Cannot replace kernel functions";
   1dc18: 4c 8d 2d 69 b4 01 00         	leaq	111721(%rip), %r13      # 0x39088 <strs.2+0x61f8>
; 		opts.log_level = 1;
   1dc1f: 48 b8 01 00 00 00 00 10 00 00	movabsq	$17592186044417, %rax   # imm = 0x100000000001
; 		opts.log_buf = buf;
   1dc29: 48 89 6c 24 70               	movq	%rbp, 112(%rsp)
; 		opts.log_level = 1;
   1dc2e: 48 89 44 24 68               	movq	%rax, 104(%rsp)
; 		break;
   1dc33: e9 3b ff ff ff               	jmp	0x1db73 <probe_prog_load.constprop.0+0x133>
   1dc38: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	fd = bpf_prog_load(prog_type, NULL, "GPL", insns, insns_cnt, &opts);
   1dc40: 48 89 f1                     	movq	%rsi, %rcx
   1dc43: 4c 8d 4c 24 10               	leaq	16(%rsp), %r9
   1dc48: 31 f6                        	xorl	%esi, %esi
   1dc4a: 41 b8 02 00 00 00            	movl	$2, %r8d
   1dc50: 48 8d 15 e3 3f 01 00         	leaq	81891(%rip), %rdx       # 0x31c3a <_IO_stdin_used+0x1c3a>
   1dc57: bf 1b 00 00 00               	movl	$27, %edi
   1dc5c: e8 ef 7f 00 00               	callq	0x25c50 <bpf_prog_load>
   1dc61: 89 c5                        	movl	%eax, %ebp
; 	err = -errno;
   1dc63: e8 88 7a fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1dc68: 8b 00                        	movl	(%rax), %eax
; 	if (fd >= 0)
   1dc6a: 85 ed                        	testl	%ebp, %ebp
   1dc6c: 79 32                        	jns	0x1dca0 <probe_prog_load.constprop.0+0x260>
; 		if (fd >= 0 || err != exp_err)
   1dc6e: 3d 0c 02 00 00               	cmpl	$524, %eax              # imm = 0x20C
   1dc73: 75 32                        	jne	0x1dca7 <probe_prog_load.constprop.0+0x267>
; 		return 1;
   1dc75: b8 01 00 00 00               	movl	$1, %eax
   1dc7a: e9 8a fe ff ff               	jmp	0x1db09 <probe_prog_load.constprop.0+0xc9>
   1dc7f: 90                           	nop
; 		opts.expected_attach_type = BPF_CGROUP_INET4_CONNECT;
   1dc80: c7 44 24 1c 0a 00 00 00      	movl	$10, 28(%rsp)
; 		break;
   1dc88: e9 53 fe ff ff               	jmp	0x1dae0 <probe_prog_load.constprop.0+0xa0>
   1dc8d: 0f 1f 00                     	nopl	(%rax)
; 		opts.expected_attach_type = BPF_LIRC_MODE2;
   1dc90: c7 44 24 1c 10 00 00 00      	movl	$16, 28(%rsp)
; 		break;
   1dc98: e9 43 fe ff ff               	jmp	0x1dae0 <probe_prog_load.constprop.0+0xa0>
   1dc9d: 0f 1f 00                     	nopl	(%rax)
; 		close(fd);
   1dca0: 89 ef                        	movl	%ebp, %edi
   1dca2: e8 59 7c fe ff               	callq	0x5900 <.plt.sec+0x290>
; 			return 0;
   1dca7: 31 c0                        	xorl	%eax, %eax
   1dca9: e9 5b fe ff ff               	jmp	0x1db09 <probe_prog_load.constprop.0+0xc9>
   1dcae: 66 90                        	nop
; 		close(fd);
   1dcb0: 44 89 e7                     	movl	%r12d, %edi
   1dcb3: e8 48 7c fe ff               	callq	0x5900 <.plt.sec+0x290>
; 			return 0;
   1dcb8: 31 c0                        	xorl	%eax, %eax
   1dcba: e9 4a fe ff ff               	jmp	0x1db09 <probe_prog_load.constprop.0+0xc9>
; }
   1dcbf: e8 3c 7b fe ff               	callq	0x5800 <.plt.sec+0x190>
   1dcc4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1dccf: 90                           	nop

000000000001dcd0 <libbpf_probe_bpf_prog_type>:
; {
   1dcd0: f3 0f 1e fa                  	endbr64
   1dcd4: 41 54                        	pushq	%r12
   1dcd6: 48 83 ec 20                  	subq	$32, %rsp
   1dcda: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1dce3: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1dce8: 31 c0                        	xorl	%eax, %eax
; 	struct bpf_insn insns[] = {
   1dcea: 48 c7 04 24 b7 00 00 00      	movq	$183, (%rsp)
   1dcf2: 48 c7 44 24 08 95 00 00 00   	movq	$149, 8(%rsp)
; 	if (opts)
   1dcfb: 48 85 f6                     	testq	%rsi, %rsi
   1dcfe: 75 40                        	jne	0x1dd40 <libbpf_probe_bpf_prog_type+0x70>
; 	ret = probe_prog_load(prog_type, insns, insn_cnt, NULL, 0);
   1dd00: 48 89 e6                     	movq	%rsp, %rsi
   1dd03: 31 c9                        	xorl	%ecx, %ecx
   1dd05: 31 d2                        	xorl	%edx, %edx
   1dd07: e8 34 fd ff ff               	callq	0x1da40 <probe_prog_load.constprop.0>
   1dd0c: 41 89 c4                     	movl	%eax, %r12d
; 	if (ret < 0)
   1dd0f: 85 c0                        	testl	%eax, %eax
   1dd11: 79 0c                        	jns	0x1dd1f <libbpf_probe_bpf_prog_type+0x4f>
; 		errno = -ret;
   1dd13: e8 d8 79 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1dd18: 44 89 e2                     	movl	%r12d, %edx
   1dd1b: f7 da                        	negl	%edx
   1dd1d: 89 10                        	movl	%edx, (%rax)
; }
   1dd1f: 48 8b 44 24 18               	movq	24(%rsp), %rax
   1dd24: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1dd2d: 75 24                        	jne	0x1dd53 <libbpf_probe_bpf_prog_type+0x83>
   1dd2f: 48 83 c4 20                  	addq	$32, %rsp
   1dd33: 44 89 e0                     	movl	%r12d, %eax
   1dd36: 41 5c                        	popq	%r12
   1dd38: c3                           	retq
   1dd39: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -ret;
   1dd40: e8 ab 79 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   1dd45: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   1dd4b: c7 00 16 00 00 00            	movl	$22, (%rax)
   1dd51: eb cc                        	jmp	0x1dd1f <libbpf_probe_bpf_prog_type+0x4f>
; }
   1dd53: e8 a8 7a fe ff               	callq	0x5800 <.plt.sec+0x190>
   1dd58: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000001dd60 <libbpf__load_raw_btf>:
; {
   1dd60: f3 0f 1e fa                  	endbr64
   1dd64: 41 57                        	pushq	%r15
   1dd66: 49 89 ff                     	movq	%rdi, %r15
   1dd69: 41 56                        	pushq	%r14
; 	btf_len = hdr.hdr_len + hdr.type_len + hdr.str_len;
   1dd6b: 44 8d 74 31 18               	leal	24(%rcx,%rsi), %r14d
; {
   1dd70: 41 55                        	pushq	%r13
; 	raw_btf = malloc(btf_len);
   1dd72: 4d 63 f6                     	movslq	%r14d, %r14
; {
   1dd75: 49 89 cd                     	movq	%rcx, %r13
   1dd78: 41 54                        	pushq	%r12
; 	raw_btf = malloc(btf_len);
   1dd7a: 4c 89 f7                     	movq	%r14, %rdi
; {
   1dd7d: 49 89 d4                     	movq	%rdx, %r12
   1dd80: 55                           	pushq	%rbp
   1dd81: 53                           	pushq	%rbx
   1dd82: 48 89 f3                     	movq	%rsi, %rbx
   1dd85: 48 83 ec 28                  	subq	$40, %rsp
; 	struct btf_header hdr = {
   1dd89: 48 c7 44 24 03 00 00 00 00   	movq	$0, 3(%rsp)
   1dd92: c6 44 24 0b 00               	movb	$0, 11(%rsp)
; 	raw_btf = malloc(btf_len);
   1dd97: e8 f4 7c fe ff               	callq	0x5a90 <.plt.sec+0x420>
; 	if (!raw_btf)
   1dd9c: 48 85 c0                     	testq	%rax, %rax
   1dd9f: 0f 84 83 00 00 00            	je	0x1de28 <libbpf__load_raw_btf+0xc8>
   1dda5: 48 89 c5                     	movq	%rax, %rbp
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1dda8: b8 9f eb ff ff               	movl	$4294962079, %eax       # imm = 0xFFFFEB9F
   1ddad: 89 5c 24 10                  	movl	%ebx, 16(%rsp)
   1ddb1: 4c 89 fe                     	movq	%r15, %rsi
   1ddb4: 66 89 04 24                  	movw	%ax, (%rsp)
; 	memcpy(raw_btf + hdr.hdr_len, raw_types, hdr.type_len);
   1ddb8: 48 8d 7d 18                  	leaq	24(%rbp), %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1ddbc: 44 89 6c 24 14               	movl	%r13d, 20(%rsp)
   1ddc1: 48 8b 44 24 10               	movq	16(%rsp), %rax
   1ddc6: 89 5c 24 0c                  	movl	%ebx, 12(%rsp)
   1ddca: 89 db                        	movl	%ebx, %ebx
   1ddcc: c6 44 24 02 01               	movb	$1, 2(%rsp)
   1ddd1: 48 89 da                     	movq	%rbx, %rdx
   1ddd4: c7 44 24 04 18 00 00 00      	movl	$24, 4(%rsp)
   1dddc: 66 0f 6f 04 24               	movdqa	(%rsp), %xmm0
   1dde1: 48 89 45 10                  	movq	%rax, 16(%rbp)
   1dde5: 0f 11 45 00                  	movups	%xmm0, (%rbp)
   1dde9: e8 52 7c fe ff               	callq	0x5a40 <.plt.sec+0x3d0>
   1ddee: 4c 89 e6                     	movq	%r12, %rsi
; 	memcpy(raw_btf + hdr.hdr_len + hdr.type_len, str_sec, hdr.str_len);
   1ddf1: 48 8d 7c 1d 18               	leaq	24(%rbp,%rbx), %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1ddf6: 44 89 ea                     	movl	%r13d, %edx
   1ddf9: e8 42 7c fe ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	btf_fd = bpf_btf_load(raw_btf, btf_len, NULL);
   1ddfe: 48 89 ef                     	movq	%rbp, %rdi
   1de01: 31 d2                        	xorl	%edx, %edx
   1de03: 4c 89 f6                     	movq	%r14, %rsi
   1de06: e8 45 a5 00 00               	callq	0x28350 <bpf_btf_load>
; 	free(raw_btf);
   1de0b: 48 89 ef                     	movq	%rbp, %rdi
; 	btf_fd = bpf_btf_load(raw_btf, btf_len, NULL);
   1de0e: 41 89 c4                     	movl	%eax, %r12d
; 	free(raw_btf);
   1de11: e8 aa 78 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; }
   1de16: 48 83 c4 28                  	addq	$40, %rsp
   1de1a: 44 89 e0                     	movl	%r12d, %eax
   1de1d: 5b                           	popq	%rbx
   1de1e: 5d                           	popq	%rbp
   1de1f: 41 5c                        	popq	%r12
   1de21: 41 5d                        	popq	%r13
   1de23: 41 5e                        	popq	%r14
   1de25: 41 5f                        	popq	%r15
   1de27: c3                           	retq
; 		return -ENOMEM;
   1de28: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
   1de2e: eb e6                        	jmp	0x1de16 <libbpf__load_raw_btf+0xb6>

000000000001de30 <libbpf_probe_bpf_map_type>:
; {
   1de30: f3 0f 1e fa                  	endbr64
   1de34: 41 57                        	pushq	%r15
   1de36: 41 56                        	pushq	%r14
   1de38: 41 55                        	pushq	%r13
   1de3a: 41 54                        	pushq	%r12
   1de3c: 55                           	pushq	%rbp
   1de3d: 53                           	pushq	%rbx
   1de3e: 48 81 ec c8 00 00 00         	subq	$200, %rsp
   1de45: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1de4e: 48 89 84 24 b8 00 00 00      	movq	%rax, 184(%rsp)
   1de56: 31 c0                        	xorl	%eax, %eax
; 	if (opts)
   1de58: 48 85 f6                     	testq	%rsi, %rsi
   1de5b: 0f 85 ff 03 00 00            	jne	0x1e260 <libbpf_probe_bpf_map_type+0x430>
;   return __builtin___memset_chk (__dest, __ch, __len,
   1de61: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
   1de6a: 66 0f ef c0                  	pxor	%xmm0, %xmm0
   1de6e: 89 fd                        	movl	%edi, %ebp
; 	LIBBPF_OPTS(bpf_map_create_opts, opts);
   1de70: 48 c7 44 24 10 30 00 00 00   	movq	$48, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1de79: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
   1de7e: 0f 11 44 24 28               	movups	%xmm0, 40(%rsp)
; 	switch (map_type) {
   1de83: 83 ff 1e                     	cmpl	$30, %edi
   1de86: 0f 87 ef 03 00 00            	ja	0x1e27b <libbpf_probe_bpf_map_type+0x44b>
   1de8c: 48 8d 15 d5 b2 01 00         	leaq	111317(%rip), %rdx      # 0x39168 <strs.2+0x62d8>
   1de93: 89 f8                        	movl	%edi, %eax
   1de95: 48 63 04 82                  	movslq	(%rdx,%rax,4), %rax
   1de99: 48 01 d0                     	addq	%rdx, %rax
   1de9c: 3e ff e0                     	jmpq	*%rax
   1de9f: 90                           	nop
; 	max_entries	= 1;
   1dea0: 41 bf 01 00 00 00            	movl	$1, %r15d
; 	value_size	= sizeof(__u32);
   1dea6: bb 04 00 00 00               	movl	$4, %ebx
; 	key_size	= sizeof(__u32);
   1deab: 41 bd 04 00 00 00            	movl	$4, %r13d
; 	if (map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
   1deb1: 8d 45 f4                     	leal	-12(%rbp), %eax
   1deb4: 83 f8 01                     	cmpl	$1, %eax
   1deb7: 0f 86 93 02 00 00            	jbe	0x1e150 <libbpf_probe_bpf_map_type+0x320>
; 	fd = bpf_map_create(map_type, NULL, key_size, value_size, max_entries, &opts);
   1debd: 44 89 ea                     	movl	%r13d, %edx
   1dec0: 45 89 f8                     	movl	%r15d, %r8d
   1dec3: 89 d9                        	movl	%ebx, %ecx
   1dec5: 45 31 ed                     	xorl	%r13d, %r13d
   1dec8: 89 ef                        	movl	%ebp, %edi
   1deca: 4c 8d 4c 24 10               	leaq	16(%rsp), %r9
   1decf: 31 f6                        	xorl	%esi, %esi
   1ded1: e8 ca 79 00 00               	callq	0x258a0 <bpf_map_create>
   1ded6: 89 c5                        	movl	%eax, %ebp
; 	err = -errno;
   1ded8: e8 13 78 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1dedd: 8b 18                        	movl	(%rax), %ebx
   1dedf: f7 db                        	negl	%ebx
; 	if (fd >= 0)
   1dee1: 85 ed                        	testl	%ebp, %ebp
   1dee3: 0f 89 47 02 00 00            	jns	0x1e130 <libbpf_probe_bpf_map_type+0x300>
; 	if (exp_err)
   1dee9: 45 85 ed                     	testl	%r13d, %r13d
   1deec: 0f 84 b0 01 00 00            	je	0x1e0a2 <libbpf_probe_bpf_map_type+0x272>
; 		return fd < 0 && err == exp_err ? 1 : 0;
   1def2: c1 ed 1f                     	shrl	$31, %ebp
   1def5: 81 fb f4 fd ff ff            	cmpl	$4294966772, %ebx       # imm = 0xFFFFFDF4
   1defb: 41 89 ec                     	movl	%ebp, %r12d
   1defe: 0f 94 c0                     	sete	%al
   1df01: 41 21 c4                     	andl	%eax, %r12d
; }
   1df04: 48 8b 84 24 b8 00 00 00      	movq	184(%rsp), %rax
   1df0c: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1df15: 0f 85 5b 03 00 00            	jne	0x1e276 <libbpf_probe_bpf_map_type+0x446>
   1df1b: 48 81 c4 c8 00 00 00         	addq	$200, %rsp
   1df22: 44 89 e0                     	movl	%r12d, %eax
   1df25: 5b                           	popq	%rbx
   1df26: 5d                           	popq	%rbp
   1df27: 41 5c                        	popq	%r12
   1df29: 41 5d                        	popq	%r13
   1df2b: 41 5e                        	popq	%r14
   1df2d: 41 5f                        	popq	%r15
   1df2f: c3                           	retq
; 	return libbpf__load_raw_btf((char *)types, sizeof(types),
   1df30: 48 8d 7c 24 40               	leaq	64(%rsp), %rdi
   1df35: b9 19 00 00 00               	movl	$25, %ecx
   1df3a: be 4c 00 00 00               	movl	$76, %esi
; 	const char strs[] = "\0bpf_spin_lock\0val\0cnt\0l";
   1df3f: 48 b8 61 6c 00 63 6e 74 00 6c	movabsq	$7782348173552413793, %rax # imm = 0x6C00746E63006C61
   1df49: 48 89 84 24 a0 00 00 00      	movq	%rax, 160(%rsp)
   1df51: 66 0f 6f 05 97 b2 01 00      	movdqa	111255(%rip), %xmm0     # 0x391f0 <strs.2+0x6360>
; 	__u32 types[] = {
   1df59: 48 b8 00 00 00 00 00 00 00 01	movabsq	$72057594037927936, %rax # imm = 0x100000000000000
; 	return libbpf__load_raw_btf((char *)types, sizeof(types),
   1df63: 48 8d 94 24 90 00 00 00      	leaq	144(%rsp), %rdx
; 	__u32 types[] = {
   1df6b: 48 89 44 24 40               	movq	%rax, 64(%rsp)
   1df70: 48 b8 04 00 00 00 20 00 00 01	movabsq	$72057731476881412, %rax # imm = 0x100002000000004
   1df7a: 48 89 44 24 48               	movq	%rax, 72(%rsp)
   1df7f: 48 b8 01 00 00 00 01 00 00 04	movabsq	$288230380446679041, %rax # imm = 0x400000100000001
   1df89: 48 89 44 24 50               	movq	%rax, 80(%rsp)
   1df8e: 48 b8 04 00 00 00 0f 00 00 00	movabsq	$64424509444, %rax      # imm = 0xF00000004
   1df98: 48 89 44 24 58               	movq	%rax, 88(%rsp)
   1df9d: 48 b8 0f 00 00 00 02 00 00 04	movabsq	$288230384741646351, %rax # imm = 0x40000020000000F
   1dfa7: 48 89 44 24 68               	movq	%rax, 104(%rsp)
   1dfac: 48 b8 08 00 00 00 13 00 00 00	movabsq	$81604378632, %rax      # imm = 0x1300000008
   1dfb6: 48 89 44 24 70               	movq	%rax, 112(%rsp)
   1dfbb: 48 b8 17 00 00 00 02 00 00 00	movabsq	$8589934615, %rax       # imm = 0x200000017
; 		opts.map_flags = BPF_F_NO_PREALLOC;
   1dfc5: c7 44 24 2c 01 00 00 00      	movl	$1, 44(%rsp)
; 	const char strs[] = "\0bpf_spin_lock\0val\0cnt\0l";
   1dfcd: c6 84 24 a8 00 00 00 00      	movb	$0, 168(%rsp)
; 	__u32 types[] = {
   1dfd5: 48 c7 44 24 60 01 00 00 00   	movq	$1, 96(%rsp)
   1dfde: 48 c7 44 24 78 01 00 00 00   	movq	$1, 120(%rsp)
   1dfe7: 48 89 84 24 80 00 00 00      	movq	%rax, 128(%rsp)
   1dfef: c7 84 24 88 00 00 00 20 00 00 00     	movl	$32, 136(%rsp)
; 	const char strs[] = "\0bpf_spin_lock\0val\0cnt\0l";
   1dffa: 0f 29 84 24 90 00 00 00      	movaps	%xmm0, 144(%rsp)
; 	return libbpf__load_raw_btf((char *)types, sizeof(types),
   1e002: e8 59 fd ff ff               	callq	0x1dd60 <libbpf__load_raw_btf>
   1e007: 41 89 c4                     	movl	%eax, %r12d
; 		if (btf_fd < 0)
   1e00a: 85 c0                        	testl	%eax, %eax
   1e00c: 0f 88 3e 02 00 00            	js	0x1e250 <libbpf_probe_bpf_map_type+0x420>
; 		btf_value_type_id = 3;
   1e012: 41 ba 03 00 00 00            	movl	$3, %r10d
; 		btf_key_type_id = 1;
   1e018: 41 bb 01 00 00 00            	movl	$1, %r11d
; 		max_entries = 0;
   1e01e: 45 31 ff                     	xorl	%r15d, %r15d
; 	if (map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
   1e021: 8d 45 f4                     	leal	-12(%rbp), %eax
   1e024: 83 f8 01                     	cmpl	$1, %eax
   1e027: 0f 86 6b 01 00 00            	jbe	0x1e198 <libbpf_probe_bpf_map_type+0x368>
; 	fd = bpf_map_create(map_type, NULL, key_size, value_size, max_entries, &opts);
   1e02d: ba 04 00 00 00               	movl	$4, %edx
   1e032: b9 08 00 00 00               	movl	$8, %ecx
; 	int fd = -1, btf_fd = -1, fd_inner = -1, exp_err = 0, err = 0;
   1e037: 41 be ff ff ff ff            	movl	$4294967295, %r14d      # imm = 0xFFFFFFFF
; 	if (btf_fd >= 0) {
   1e03d: 41 83 fc ff                  	cmpl	$-1, %r12d
   1e041: 74 0f                        	je	0x1e052 <libbpf_probe_bpf_map_type+0x222>
; 		opts.btf_fd = btf_fd;
   1e043: 44 89 64 24 18               	movl	%r12d, 24(%rsp)
; 		opts.btf_key_type_id = btf_key_type_id;
   1e048: 44 89 5c 24 1c               	movl	%r11d, 28(%rsp)
; 		opts.btf_value_type_id = btf_value_type_id;
   1e04d: 44 89 54 24 20               	movl	%r10d, 32(%rsp)
; 	fd = bpf_map_create(map_type, NULL, key_size, value_size, max_entries, &opts);
   1e052: 89 ef                        	movl	%ebp, %edi
   1e054: 4c 8d 4c 24 10               	leaq	16(%rsp), %r9
   1e059: 45 89 f8                     	movl	%r15d, %r8d
   1e05c: 31 f6                        	xorl	%esi, %esi
   1e05e: e8 3d 78 00 00               	callq	0x258a0 <bpf_map_create>
   1e063: 45 31 ed                     	xorl	%r13d, %r13d
   1e066: 89 c5                        	movl	%eax, %ebp
; 	err = -errno;
   1e068: e8 83 76 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1e06d: 8b 18                        	movl	(%rax), %ebx
   1e06f: f7 db                        	negl	%ebx
; 	if (fd >= 0)
   1e071: 85 ed                        	testl	%ebp, %ebp
   1e073: 0f 89 c3 00 00 00            	jns	0x1e13c <libbpf_probe_bpf_map_type+0x30c>
; 	if (fd_inner >= 0)
   1e079: 41 83 fe ff                  	cmpl	$-1, %r14d
   1e07d: 74 08                        	je	0x1e087 <libbpf_probe_bpf_map_type+0x257>
; 		close(fd_inner);
   1e07f: 44 89 f7                     	movl	%r14d, %edi
   1e082: e8 79 78 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (btf_fd >= 0)
   1e087: 41 83 fc ff                  	cmpl	$-1, %r12d
   1e08b: 0f 84 58 fe ff ff            	je	0x1dee9 <libbpf_probe_bpf_map_type+0xb9>
; 		close(btf_fd);
   1e091: 44 89 e7                     	movl	%r12d, %edi
   1e094: e8 67 78 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (exp_err)
   1e099: 45 85 ed                     	testl	%r13d, %r13d
   1e09c: 0f 85 50 fe ff ff            	jne	0x1def2 <libbpf_probe_bpf_map_type+0xc2>
; 		return fd >= 0 ? 1 : 0;
   1e0a2: f7 d5                        	notl	%ebp
   1e0a4: 41 89 ec                     	movl	%ebp, %r12d
   1e0a7: 41 c1 ec 1f                  	shrl	$31, %r12d
   1e0ab: e9 54 fe ff ff               	jmp	0x1df04 <libbpf_probe_bpf_map_type+0xd4>
; 	switch (map_type) {
   1e0b0: 45 31 ff                     	xorl	%r15d, %r15d
   1e0b3: bb 08 00 00 00               	movl	$8, %ebx
   1e0b8: 41 bd 10 00 00 00            	movl	$16, %r13d
   1e0be: e9 ee fd ff ff               	jmp	0x1deb1 <libbpf_probe_bpf_map_type+0x81>
   1e0c3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	max_entries	= 1;
   1e0c8: 41 bf 01 00 00 00            	movl	$1, %r15d
; 	value_size	= sizeof(__u32);
   1e0ce: bb 04 00 00 00               	movl	$4, %ebx
; 		key_size	= 0;
   1e0d3: 45 31 ed                     	xorl	%r13d, %r13d
   1e0d6: e9 d6 fd ff ff               	jmp	0x1deb1 <libbpf_probe_bpf_map_type+0x81>
   1e0db: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		break;
   1e0e0: ba 04 00 00 00               	movl	$4, %edx
; 		opts.btf_vmlinux_value_type_id = 1;
   1e0e5: c7 44 24 24 01 00 00 00      	movl	$1, 36(%rsp)
; 		break;
   1e0ed: b9 04 00 00 00               	movl	$4, %ecx
   1e0f2: 41 b8 01 00 00 00            	movl	$1, %r8d
; 		exp_err = -524; /* -ENOTSUPP */
   1e0f8: 41 bd f4 fd ff ff            	movl	$4294966772, %r13d      # imm = 0xFFFFFDF4
; 		break;
   1e0fe: e9 c5 fd ff ff               	jmp	0x1dec8 <libbpf_probe_bpf_map_type+0x98>
   1e103: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		opts.map_flags	= BPF_F_NO_PREALLOC;
   1e108: c7 44 24 2c 01 00 00 00      	movl	$1, 44(%rsp)
; 		break;
   1e110: ba 08 00 00 00               	movl	$8, %edx
   1e115: b9 08 00 00 00               	movl	$8, %ecx
; 	int fd = -1, btf_fd = -1, fd_inner = -1, exp_err = 0, err = 0;
   1e11a: 45 31 ed                     	xorl	%r13d, %r13d
; 		break;
   1e11d: 41 b8 01 00 00 00            	movl	$1, %r8d
   1e123: e9 a0 fd ff ff               	jmp	0x1dec8 <libbpf_probe_bpf_map_type+0x98>
   1e128: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (fd >= 0)
   1e130: 41 bc ff ff ff ff            	movl	$4294967295, %r12d      # imm = 0xFFFFFFFF
   1e136: 41 be ff ff ff ff            	movl	$4294967295, %r14d      # imm = 0xFFFFFFFF
; 		close(fd);
   1e13c: 89 ef                        	movl	%ebp, %edi
   1e13e: e8 bd 77 fe ff               	callq	0x5900 <.plt.sec+0x290>
   1e143: e9 31 ff ff ff               	jmp	0x1e079 <libbpf_probe_bpf_map_type+0x249>
   1e148: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		fd_inner = bpf_map_create(BPF_MAP_TYPE_HASH, NULL,
   1e150: 45 31 c9                     	xorl	%r9d, %r9d
   1e153: 41 b8 01 00 00 00            	movl	$1, %r8d
   1e159: b9 04 00 00 00               	movl	$4, %ecx
   1e15e: 31 f6                        	xorl	%esi, %esi
   1e160: ba 04 00 00 00               	movl	$4, %edx
   1e165: bf 01 00 00 00               	movl	$1, %edi
   1e16a: e8 31 77 00 00               	callq	0x258a0 <bpf_map_create>
   1e16f: 41 89 c6                     	movl	%eax, %r14d
; 		if (fd_inner < 0)
   1e172: 85 c0                        	testl	%eax, %eax
   1e174: 78 78                        	js	0x1e1ee <libbpf_probe_bpf_map_type+0x3be>
   1e176: 41 bc ff ff ff ff            	movl	$4294967295, %r12d      # imm = 0xFFFFFFFF
   1e17c: 45 31 db                     	xorl	%r11d, %r11d
   1e17f: 45 31 d2                     	xorl	%r10d, %r10d
; 		opts.inner_map_fd = fd_inner;
   1e182: 44 89 74 24 28               	movl	%r14d, 40(%rsp)
; 	fd = bpf_map_create(map_type, NULL, key_size, value_size, max_entries, &opts);
   1e187: 89 d9                        	movl	%ebx, %ecx
   1e189: 44 89 ea                     	movl	%r13d, %edx
   1e18c: e9 ac fe ff ff               	jmp	0x1e03d <libbpf_probe_bpf_map_type+0x20d>
   1e191: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		fd_inner = bpf_map_create(BPF_MAP_TYPE_HASH, NULL,
   1e198: 45 31 c9                     	xorl	%r9d, %r9d
   1e19b: 41 b8 01 00 00 00            	movl	$1, %r8d
   1e1a1: b9 04 00 00 00               	movl	$4, %ecx
   1e1a6: 31 f6                        	xorl	%esi, %esi
   1e1a8: ba 04 00 00 00               	movl	$4, %edx
   1e1ad: bf 01 00 00 00               	movl	$1, %edi
   1e1b2: 44 89 5c 24 0c               	movl	%r11d, 12(%rsp)
   1e1b7: 44 89 54 24 08               	movl	%r10d, 8(%rsp)
   1e1bc: e8 df 76 00 00               	callq	0x258a0 <bpf_map_create>
   1e1c1: 41 89 c6                     	movl	%eax, %r14d
; 		if (fd_inner < 0)
   1e1c4: 85 c0                        	testl	%eax, %eax
   1e1c6: 78 18                        	js	0x1e1e0 <libbpf_probe_bpf_map_type+0x3b0>
   1e1c8: 44 8b 5c 24 0c               	movl	12(%rsp), %r11d
   1e1cd: 44 8b 54 24 08               	movl	8(%rsp), %r10d
   1e1d2: bb 08 00 00 00               	movl	$8, %ebx
   1e1d7: 41 bd 04 00 00 00            	movl	$4, %r13d
   1e1dd: eb a3                        	jmp	0x1e182 <libbpf_probe_bpf_map_type+0x352>
   1e1df: 90                           	nop
; 	if (btf_fd >= 0)
   1e1e0: 41 83 fc ff                  	cmpl	$-1, %r12d
   1e1e4: 74 08                        	je	0x1e1ee <libbpf_probe_bpf_map_type+0x3be>
; 		close(btf_fd);
   1e1e6: 44 89 e7                     	movl	%r12d, %edi
   1e1e9: e8 12 77 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	int fd = -1, btf_fd = -1, fd_inner = -1, exp_err = 0, err = 0;
   1e1ee: bd ff ff ff ff               	movl	$4294967295, %ebp       # imm = 0xFFFFFFFF
   1e1f3: e9 aa fe ff ff               	jmp	0x1e0a2 <libbpf_probe_bpf_map_type+0x272>
   1e1f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	switch (map_type) {
   1e200: 41 bc ff ff ff ff            	movl	$4294967295, %r12d      # imm = 0xFFFFFFFF
   1e206: 45 31 d2                     	xorl	%r10d, %r10d
   1e209: 45 31 db                     	xorl	%r11d, %r11d
   1e20c: 41 bf 01 00 00 00            	movl	$1, %r15d
   1e212: e9 0a fe ff ff               	jmp	0x1e021 <libbpf_probe_bpf_map_type+0x1f1>
   1e217: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
   1e220: 31 d2                        	xorl	%edx, %edx
   1e222: b9 04 00 00 00               	movl	$4, %ecx
   1e227: 41 b8 01 00 00 00            	movl	$1, %r8d
   1e22d: 45 31 ed                     	xorl	%r13d, %r13d
; 	if (btf_fd >= 0) {
   1e230: e9 93 fc ff ff               	jmp	0x1dec8 <libbpf_probe_bpf_map_type+0x98>
   1e235: 0f 1f 00                     	nopl	(%rax)
; 	switch (map_type) {
   1e238: 31 d2                        	xorl	%edx, %edx
   1e23a: 31 c9                        	xorl	%ecx, %ecx
   1e23c: 41 b8 00 10 00 00            	movl	$4096, %r8d             # imm = 0x1000
; 	int fd = -1, btf_fd = -1, fd_inner = -1, exp_err = 0, err = 0;
   1e242: 45 31 ed                     	xorl	%r13d, %r13d
   1e245: e9 7e fc ff ff               	jmp	0x1dec8 <libbpf_probe_bpf_map_type+0x98>
   1e24a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -ret;
   1e250: 89 c3                        	movl	%eax, %ebx
   1e252: f7 db                        	negl	%ebx
   1e254: e8 97 74 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1e259: 89 18                        	movl	%ebx, (%rax)
   1e25b: e9 a4 fc ff ff               	jmp	0x1df04 <libbpf_probe_bpf_map_type+0xd4>
   1e260: e8 8b 74 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   1e265: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   1e26b: c7 00 16 00 00 00            	movl	$22, (%rax)
   1e271: e9 8e fc ff ff               	jmp	0x1df04 <libbpf_probe_bpf_map_type+0xd4>
; }
   1e276: e8 85 75 fe ff               	callq	0x5800 <.plt.sec+0x190>
; 	switch (map_type) {
   1e27b: bb 5f 00 00 00               	movl	$95, %ebx
   1e280: 41 bc a1 ff ff ff            	movl	$4294967201, %r12d      # imm = 0xFFFFFFA1
   1e286: eb cc                        	jmp	0x1e254 <libbpf_probe_bpf_map_type+0x424>
   1e288: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000001e290 <libbpf_probe_bpf_helper>:
; {
   1e290: f3 0f 1e fa                  	endbr64
   1e294: 41 54                        	pushq	%r12
   1e296: 55                           	pushq	%rbp
   1e297: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   1e29e: 48 83 0c 24 00               	orq	$0, (%rsp)
   1e2a3: 48 83 ec 28                  	subq	$40, %rsp
   1e2a7: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1e2b0: 48 89 84 24 18 10 00 00      	movq	%rax, 4120(%rsp)
   1e2b8: 31 c0                        	xorl	%eax, %eax
; 	struct bpf_insn insns[] = {
   1e2ba: c7 04 24 85 00 00 00         	movl	$133, (%rsp)
   1e2c1: 89 74 24 04                  	movl	%esi, 4(%rsp)
   1e2c5: 48 c7 44 24 08 95 00 00 00   	movq	$149, 8(%rsp)
; 	if (opts)
   1e2ce: 48 85 d2                     	testq	%rdx, %rdx
   1e2d1: 0f 85 a9 00 00 00            	jne	0x1e380 <libbpf_probe_bpf_helper+0xf0>
; 	switch (prog_type) {
   1e2d7: 8d 47 e6                     	leal	-26(%rdi), %eax
   1e2da: 83 f8 03                     	cmpl	$3, %eax
   1e2dd: 0f 86 8d 00 00 00            	jbe	0x1e370 <libbpf_probe_bpf_helper+0xe0>
; 	ret = probe_prog_load(prog_type, insns, insn_cnt, buf, sizeof(buf));
   1e2e3: 48 8d 6c 24 10               	leaq	16(%rsp), %rbp
   1e2e8: 48 89 e6                     	movq	%rsp, %rsi
   1e2eb: b9 00 10 00 00               	movl	$4096, %ecx             # imm = 0x1000
; 	buf[0] = '\0';
   1e2f0: c6 44 24 10 00               	movb	$0, 16(%rsp)
; 	ret = probe_prog_load(prog_type, insns, insn_cnt, buf, sizeof(buf));
   1e2f5: 48 89 ea                     	movq	%rbp, %rdx
   1e2f8: e8 43 f7 ff ff               	callq	0x1da40 <probe_prog_load.constprop.0>
   1e2fd: 41 89 c4                     	movl	%eax, %r12d
; 	if (ret < 0)
   1e300: 85 c0                        	testl	%eax, %eax
   1e302: 78 5c                        	js	0x1e360 <libbpf_probe_bpf_helper+0xd0>
; 	if (ret == 0 && (strstr(buf, "invalid func ") || strstr(buf, "unknown func ")))
   1e304: 74 2a                        	je	0x1e330 <libbpf_probe_bpf_helper+0xa0>
; 	return 1; /* assume supported */
   1e306: 41 bc 01 00 00 00            	movl	$1, %r12d
; }
   1e30c: 48 8b 84 24 18 10 00 00      	movq	4120(%rsp), %rax
   1e314: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1e31d: 75 77                        	jne	0x1e396 <libbpf_probe_bpf_helper+0x106>
   1e31f: 48 81 c4 28 10 00 00         	addq	$4136, %rsp             # imm = 0x1028
   1e326: 44 89 e0                     	movl	%r12d, %eax
   1e329: 5d                           	popq	%rbp
   1e32a: 41 5c                        	popq	%r12
   1e32c: c3                           	retq
   1e32d: 0f 1f 00                     	nopl	(%rax)
; 	if (ret == 0 && (strstr(buf, "invalid func ") || strstr(buf, "unknown func ")))
   1e330: 48 8d 35 93 ad 01 00         	leaq	109971(%rip), %rsi      # 0x390ca <strs.2+0x623a>
   1e337: 48 89 ef                     	movq	%rbp, %rdi
   1e33a: e8 21 79 fe ff               	callq	0x5c60 <.plt.sec+0x5f0>
   1e33f: 48 85 c0                     	testq	%rax, %rax
   1e342: 75 c8                        	jne	0x1e30c <libbpf_probe_bpf_helper+0x7c>
   1e344: 48 8d 35 8d ad 01 00         	leaq	109965(%rip), %rsi      # 0x390d8 <strs.2+0x6248>
   1e34b: 48 89 ef                     	movq	%rbp, %rdi
   1e34e: 45 31 e4                     	xorl	%r12d, %r12d
   1e351: e8 0a 79 fe ff               	callq	0x5c60 <.plt.sec+0x5f0>
   1e356: 48 85 c0                     	testq	%rax, %rax
   1e359: 41 0f 94 c4                  	sete	%r12b
   1e35d: eb ad                        	jmp	0x1e30c <libbpf_probe_bpf_helper+0x7c>
   1e35f: 90                           	nop
; 		errno = -ret;
   1e360: e8 8b 73 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   1e365: 44 89 e2                     	movl	%r12d, %edx
   1e368: f7 da                        	negl	%edx
   1e36a: 89 10                        	movl	%edx, (%rax)
   1e36c: eb 9e                        	jmp	0x1e30c <libbpf_probe_bpf_helper+0x7c>
   1e36e: 66 90                        	nop
; 		return -EOPNOTSUPP;
   1e370: 41 bc a1 ff ff ff            	movl	$4294967201, %r12d      # imm = 0xFFFFFFA1
   1e376: eb 94                        	jmp	0x1e30c <libbpf_probe_bpf_helper+0x7c>
   1e378: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		errno = -ret;
   1e380: e8 6b 73 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   1e385: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   1e38b: c7 00 16 00 00 00            	movl	$22, (%rax)
   1e391: e9 76 ff ff ff               	jmp	0x1e30c <libbpf_probe_bpf_helper+0x7c>
; }
   1e396: e8 65 74 fe ff               	callq	0x5800 <.plt.sec+0x190>
   1e39b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000001e3a0 <hashmap__init>:
; {
   1e3a0: f3 0f 1e fa                  	endbr64
; 	map->hash_fn = hash_fn;
   1e3a4: 48 89 37                     	movq	%rsi, (%rdi)
; 	map->equal_fn = equal_fn;
   1e3a7: 48 89 57 08                  	movq	%rdx, 8(%rdi)
; 	map->ctx = ctx;
   1e3ab: 48 89 4f 10                  	movq	%rcx, 16(%rdi)
; 	map->buckets = NULL;
   1e3af: 48 c7 47 18 00 00 00 00      	movq	$0, 24(%rdi)
; 	map->cap = 0;
   1e3b7: 48 c7 47 20 00 00 00 00      	movq	$0, 32(%rdi)
; 	map->cap_bits = 0;
   1e3bf: 48 c7 47 28 00 00 00 00      	movq	$0, 40(%rdi)
; 	map->sz = 0;
   1e3c7: 48 c7 47 30 00 00 00 00      	movq	$0, 48(%rdi)
; }
   1e3cf: c3                           	retq

000000000001e3d0 <hashmap__new>:
; {
   1e3d0: f3 0f 1e fa                  	endbr64
   1e3d4: 41 54                        	pushq	%r12
   1e3d6: 49 89 f4                     	movq	%rsi, %r12
   1e3d9: 55                           	pushq	%rbp
   1e3da: 48 89 fd                     	movq	%rdi, %rbp
; 	struct hashmap *map = malloc(sizeof(struct hashmap));
   1e3dd: bf 38 00 00 00               	movl	$56, %edi
; {
   1e3e2: 53                           	pushq	%rbx
   1e3e3: 48 89 d3                     	movq	%rdx, %rbx
; 	struct hashmap *map = malloc(sizeof(struct hashmap));
   1e3e6: e8 a5 76 fe ff               	callq	0x5a90 <.plt.sec+0x420>
; 	if (!map)
   1e3eb: 48 85 c0                     	testq	%rax, %rax
   1e3ee: 74 30                        	je	0x1e420 <hashmap__new+0x50>
; 	map->hash_fn = hash_fn;
   1e3f0: 48 89 28                     	movq	%rbp, (%rax)
; 	map->equal_fn = equal_fn;
   1e3f3: 4c 89 60 08                  	movq	%r12, 8(%rax)
; 	map->ctx = ctx;
   1e3f7: 48 89 58 10                  	movq	%rbx, 16(%rax)
; 	map->buckets = NULL;
   1e3fb: 48 c7 40 18 00 00 00 00      	movq	$0, 24(%rax)
; 	map->cap = 0;
   1e403: 48 c7 40 20 00 00 00 00      	movq	$0, 32(%rax)
; 	map->cap_bits = 0;
   1e40b: 48 c7 40 28 00 00 00 00      	movq	$0, 40(%rax)
; 	map->sz = 0;
   1e413: 48 c7 40 30 00 00 00 00      	movq	$0, 48(%rax)
; }
   1e41b: 5b                           	popq	%rbx
   1e41c: 5d                           	popq	%rbp
   1e41d: 41 5c                        	popq	%r12
   1e41f: c3                           	retq
; 		return ERR_PTR(-ENOMEM);
   1e420: 48 c7 c0 f4 ff ff ff         	movq	$-12, %rax
   1e427: eb f2                        	jmp	0x1e41b <hashmap__new+0x4b>
   1e429: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001e430 <hashmap__clear>:
; {
   1e430: f3 0f 1e fa                  	endbr64
   1e434: 41 54                        	pushq	%r12
   1e436: 49 89 fc                     	movq	%rdi, %r12
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e439: 49 83 7c 24 20 00            	cmpq	$0, 32(%r12)
; {
   1e43f: 55                           	pushq	%rbp
   1e440: 53                           	pushq	%rbx
; 	free(map->buckets);
   1e441: 48 8b 7f 18                  	movq	24(%rdi), %rdi
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e445: 74 3a                        	je	0x1e481 <hashmap__clear+0x51>
   1e447: 31 ed                        	xorl	%ebp, %ebp
   1e449: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   1e450: 48 8b 1c ef                  	movq	(%rdi,%rbp,8), %rbx
   1e454: 48 85 db                     	testq	%rbx, %rbx
   1e457: 74 1d                        	je	0x1e476 <hashmap__clear+0x46>
   1e459: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   1e460: 48 89 df                     	movq	%rbx, %rdi
   1e463: 48 8b 5b 10                  	movq	16(%rbx), %rbx
; 		free(cur);
   1e467: e8 54 72 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e46c: 48 85 db                     	testq	%rbx, %rbx
   1e46f: 75 ef                        	jne	0x1e460 <hashmap__clear+0x30>
; 	free(map->buckets);
   1e471: 49 8b 7c 24 18               	movq	24(%r12), %rdi
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e476: 48 83 c5 01                  	addq	$1, %rbp
   1e47a: 49 39 6c 24 20               	cmpq	%rbp, 32(%r12)
   1e47f: 77 cf                        	ja	0x1e450 <hashmap__clear+0x20>
; 	free(map->buckets);
   1e481: e8 3a 72 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; }
   1e486: 5b                           	popq	%rbx
   1e487: 5d                           	popq	%rbp
; 	map->buckets = NULL;
   1e488: 49 c7 44 24 18 00 00 00 00   	movq	$0, 24(%r12)
; 	map->cap = map->cap_bits = map->sz = 0;
   1e491: 49 c7 44 24 30 00 00 00 00   	movq	$0, 48(%r12)
   1e49a: 49 c7 44 24 28 00 00 00 00   	movq	$0, 40(%r12)
   1e4a3: 49 c7 44 24 20 00 00 00 00   	movq	$0, 32(%r12)
; }
   1e4ac: 41 5c                        	popq	%r12
   1e4ae: c3                           	retq
   1e4af: 90                           	nop

000000000001e4b0 <hashmap__free>:
; {
   1e4b0: f3 0f 1e fa                  	endbr64
; 	if (IS_ERR_OR_NULL(map))
   1e4b4: 48 85 ff                     	testq	%rdi, %rdi
   1e4b7: 74 27                        	je	0x1e4e0 <hashmap__free+0x30>
; {
   1e4b9: 55                           	pushq	%rbp
   1e4ba: 48 89 fd                     	movq	%rdi, %rbp
; 	if (IS_ERR_OR_NULL(map))
   1e4bd: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   1e4c4: 77 12                        	ja	0x1e4d8 <hashmap__free+0x28>
; 	hashmap__clear(map);
   1e4c6: e8 65 ff ff ff               	callq	0x1e430 <hashmap__clear>
; 	free(map);
   1e4cb: 48 89 ef                     	movq	%rbp, %rdi
; }
   1e4ce: 5d                           	popq	%rbp
; 	free(map);
   1e4cf: e9 ec 71 fe ff               	jmp	0x56c0 <.plt.sec+0x50>
   1e4d4: 0f 1f 40 00                  	nopl	(%rax)
; }
   1e4d8: 5d                           	popq	%rbp
   1e4d9: c3                           	retq
   1e4da: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   1e4e0: c3                           	retq
   1e4e1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1e4ec: 0f 1f 40 00                  	nopl	(%rax)

000000000001e4f0 <hashmap__size>:
; {
   1e4f0: f3 0f 1e fa                  	endbr64
; 	return map->sz;
   1e4f4: 48 8b 47 30                  	movq	48(%rdi), %rax
; }
   1e4f8: c3                           	retq
   1e4f9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001e500 <hashmap__capacity>:
; {
   1e500: f3 0f 1e fa                  	endbr64
; 	return map->cap;
   1e504: 48 8b 47 20                  	movq	32(%rdi), %rax
; }
   1e508: c3                           	retq
   1e509: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001e510 <hashmap__insert>:
; {
   1e510: f3 0f 1e fa                  	endbr64
   1e514: 41 57                        	pushq	%r15
   1e516: 49 89 ff                     	movq	%rdi, %r15
   1e519: 41 56                        	pushq	%r14
   1e51b: 41 55                        	pushq	%r13
   1e51d: 41 54                        	pushq	%r12
   1e51f: 41 89 cc                     	movl	%ecx, %r12d
   1e522: 55                           	pushq	%rbp
   1e523: 4c 89 c5                     	movq	%r8, %rbp
   1e526: 53                           	pushq	%rbx
   1e527: 4c 89 cb                     	movq	%r9, %rbx
   1e52a: 48 83 ec 38                  	subq	$56, %rsp
   1e52e: 48 89 74 24 10               	movq	%rsi, 16(%rsp)
   1e533: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
; 	if (old_key)
   1e538: 4d 85 c0                     	testq	%r8, %r8
   1e53b: 74 07                        	je	0x1e544 <hashmap__insert+0x34>
; 		*old_key = NULL;
   1e53d: 49 c7 00 00 00 00 00         	movq	$0, (%r8)
; 	if (old_value)
   1e544: 48 85 db                     	testq	%rbx, %rbx
   1e547: 74 07                        	je	0x1e550 <hashmap__insert+0x40>
; 		*old_value = NULL;
   1e549: 48 c7 03 00 00 00 00         	movq	$0, (%rbx)
; 	h = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);
   1e550: 4d 8b 77 28                  	movq	40(%r15), %r14
   1e554: 49 8b 77 10                  	movq	16(%r15), %rsi
; 		return 0;
   1e558: 45 31 ed                     	xorl	%r13d, %r13d
; 	h = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);
   1e55b: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   1e560: 41 ff 17                     	callq	*(%r15)
; 	if (bits == 0)
   1e563: 45 85 f6                     	testl	%r14d, %r14d
   1e566: 74 1c                        	je	0x1e584 <hashmap__insert+0x74>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   1e568: 48 ba 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdx # imm = 0x9E3779B97F4A7C15
   1e572: b9 40 00 00 00               	movl	$64, %ecx
   1e577: 48 0f af c2                  	imulq	%rdx, %rax
   1e57b: 44 29 f1                     	subl	%r14d, %ecx
   1e57e: 48 d3 e8                     	shrq	%cl, %rax
   1e581: 49 89 c5                     	movq	%rax, %r13
; 	if (strategy != HASHMAP_APPEND &&
   1e584: 41 83 fc 03                  	cmpl	$3, %r12d
   1e588: 0f 85 02 02 00 00            	jne	0x1e790 <hashmap__insert+0x280>
; 	return (map->cap == 0) || ((map->sz + 1) * 4 / 3 > map->cap);
   1e58e: 49 8b 4f 20                  	movq	32(%r15), %rcx
   1e592: 48 85 c9                     	testq	%rcx, %rcx
   1e595: 0f 84 9d 01 00 00            	je	0x1e738 <hashmap__insert+0x228>
   1e59b: 48 be ab aa aa aa aa aa aa aa	movabsq	$-6148914691236517205, %rsi # imm = 0xAAAAAAAAAAAAAAAB
   1e5a5: 49 8b 47 30                  	movq	48(%r15), %rax
   1e5a9: 48 8d 14 85 04 00 00 00      	leaq	4(,%rax,4), %rdx
   1e5b1: 48 89 d0                     	movq	%rdx, %rax
   1e5b4: 48 f7 e6                     	mulq	%rsi
   1e5b7: 48 d1 ea                     	shrq	%rdx
   1e5ba: 48 39 d1                     	cmpq	%rdx, %rcx
   1e5bd: 0f 83 26 01 00 00            	jae	0x1e6e9 <hashmap__insert+0x1d9>
; 	new_cap_bits = map->cap_bits + 1;
   1e5c3: 49 8b 47 28                  	movq	40(%r15), %rax
; 	new_buckets = calloc(new_cap, sizeof(new_buckets[0]));
   1e5c7: be 08 00 00 00               	movl	$8, %esi
; 	new_cap_bits = map->cap_bits + 1;
   1e5cc: 48 8d 50 01                  	leaq	1(%rax), %rdx
   1e5d0: b8 02 00 00 00               	movl	$2, %eax
   1e5d5: 48 39 c2                     	cmpq	%rax, %rdx
   1e5d8: 48 0f 43 c2                  	cmovaeq	%rdx, %rax
   1e5dc: 48 89 c2                     	movq	%rax, %rdx
   1e5df: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	new_cap = 1UL << new_cap_bits;
   1e5e4: b8 01 00 00 00               	movl	$1, %eax
   1e5e9: 89 d1                        	movl	%edx, %ecx
   1e5eb: 48 d3 e0                     	shlq	%cl, %rax
; 	new_buckets = calloc(new_cap, sizeof(new_buckets[0]));
   1e5ee: 48 89 c7                     	movq	%rax, %rdi
; 	new_cap = 1UL << new_cap_bits;
   1e5f1: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	new_buckets = calloc(new_cap, sizeof(new_buckets[0]));
   1e5f6: e8 95 73 fe ff               	callq	0x5990 <.plt.sec+0x320>
   1e5fb: 48 89 c3                     	movq	%rax, %rbx
; 	if (!new_buckets)
   1e5fe: 48 85 c0                     	testq	%rax, %rax
   1e601: 0f 84 75 01 00 00            	je	0x1e77c <hashmap__insert+0x26c>
; 		h = hash_bits(map->hash_fn(cur->key, map->ctx), new_cap_bits);
   1e607: 8b 6c 24 20                  	movl	32(%rsp), %ebp
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   1e60b: 41 bd 40 00 00 00            	movl	$64, %r13d
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e611: 49 8b 7f 18                  	movq	24(%r15), %rdi
   1e615: 48 c7 44 24 08 00 00 00 00   	movq	$0, 8(%rsp)
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   1e61e: 41 29 ed                     	subl	%ebp, %r13d
   1e621: 44 89 6c 24 04               	movl	%r13d, 4(%rsp)
   1e626: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   1e630: 49 bc 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %r12 # imm = 0x9E3779B97F4A7C15
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e63a: 48 8b 44 24 08               	movq	8(%rsp), %rax
   1e63f: 4c 8b 2c c7                  	movq	(%rdi,%rax,8), %r13
   1e643: 4d 85 ed                     	testq	%r13, %r13
   1e646: 74 43                        	je	0x1e68b <hashmap__insert+0x17b>
   1e648: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
   1e650: 4d 89 ee                     	movq	%r13, %r14
; 		h = hash_bits(map->hash_fn(cur->key, map->ctx), new_cap_bits);
   1e653: 49 8b 77 10                  	movq	16(%r15), %rsi
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e657: 4d 8b 6d 10                  	movq	16(%r13), %r13
; 		h = hash_bits(map->hash_fn(cur->key, map->ctx), new_cap_bits);
   1e65b: 49 8b 3e                     	movq	(%r14), %rdi
   1e65e: 41 ff 17                     	callq	*(%r15)
; 	if (bits == 0)
   1e661: 48 89 d9                     	movq	%rbx, %rcx
   1e664: 85 ed                        	testl	%ebp, %ebp
   1e666: 74 10                        	je	0x1e678 <hashmap__insert+0x168>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   1e668: 49 0f af c4                  	imulq	%r12, %rax
   1e66c: 0f b6 4c 24 04               	movzbl	4(%rsp), %ecx
   1e671: 48 d3 e8                     	shrq	%cl, %rax
; 		hashmap_add_entry(&new_buckets[h], cur);
   1e674: 48 8d 0c c3                  	leaq	(%rbx,%rax,8), %rcx
; 	entry->next = *pprev;
   1e678: 48 8b 01                     	movq	(%rcx), %rax
   1e67b: 49 89 46 10                  	movq	%rax, 16(%r14)
; 	*pprev = entry;
   1e67f: 4c 89 31                     	movq	%r14, (%rcx)
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e682: 4d 85 ed                     	testq	%r13, %r13
   1e685: 75 c9                        	jne	0x1e650 <hashmap__insert+0x140>
; 	free(map->buckets);
   1e687: 49 8b 7f 18                  	movq	24(%r15), %rdi
; 	hashmap__for_each_entry_safe(map, cur, tmp, bkt) {
   1e68b: 48 83 44 24 08 01            	addq	$1, 8(%rsp)
   1e691: 48 8b 44 24 08               	movq	8(%rsp), %rax
   1e696: 49 3b 47 20                  	cmpq	32(%r15), %rax
   1e69a: 72 94                        	jb	0x1e630 <hashmap__insert+0x120>
; 	map->cap = new_cap;
   1e69c: 48 8b 44 24 28               	movq	40(%rsp), %rax
; 		return 0;
   1e6a1: 45 31 ed                     	xorl	%r13d, %r13d
; 	map->cap = new_cap;
   1e6a4: 49 89 47 20                  	movq	%rax, 32(%r15)
; 	map->cap_bits = new_cap_bits;
   1e6a8: 48 8b 44 24 20               	movq	32(%rsp), %rax
   1e6ad: 49 89 47 28                  	movq	%rax, 40(%r15)
; 	free(map->buckets);
   1e6b1: e8 0a 70 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	map->buckets = new_buckets;
   1e6b6: 49 89 5f 18                  	movq	%rbx, 24(%r15)
; 		h = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);
   1e6ba: 49 8b 5f 28                  	movq	40(%r15), %rbx
   1e6be: 49 8b 77 10                  	movq	16(%r15), %rsi
   1e6c2: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   1e6c7: 41 ff 17                     	callq	*(%r15)
; 	if (bits == 0)
   1e6ca: 85 db                        	testl	%ebx, %ebx
   1e6cc: 74 1b                        	je	0x1e6e9 <hashmap__insert+0x1d9>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   1e6ce: 48 ba 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdx # imm = 0x9E3779B97F4A7C15
   1e6d8: b9 40 00 00 00               	movl	$64, %ecx
   1e6dd: 48 0f af c2                  	imulq	%rdx, %rax
   1e6e1: 29 d9                        	subl	%ebx, %ecx
   1e6e3: 48 d3 e8                     	shrq	%cl, %rax
   1e6e6: 49 89 c5                     	movq	%rax, %r13
; 	entry = malloc(sizeof(struct hashmap_entry));
   1e6e9: bf 18 00 00 00               	movl	$24, %edi
   1e6ee: e8 9d 73 fe ff               	callq	0x5a90 <.plt.sec+0x420>
; 	if (!entry)
   1e6f3: 48 85 c0                     	testq	%rax, %rax
   1e6f6: 0f 84 80 00 00 00            	je	0x1e77c <hashmap__insert+0x26c>
; 	entry->key = key;
   1e6fc: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   1e701: 48 89 10                     	movq	%rdx, (%rax)
; 	entry->value = value;
   1e704: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   1e709: 48 89 50 08                  	movq	%rdx, 8(%rax)
; 	hashmap_add_entry(&map->buckets[h], entry);
   1e70d: 49 8b 57 18                  	movq	24(%r15), %rdx
   1e711: 4a 8d 14 ea                  	leaq	(%rdx,%r13,8), %rdx
; 	entry->next = *pprev;
   1e715: 48 8b 0a                     	movq	(%rdx), %rcx
   1e718: 48 89 48 10                  	movq	%rcx, 16(%rax)
; 	*pprev = entry;
   1e71c: 48 89 02                     	movq	%rax, (%rdx)
; 	return 0;
   1e71f: 31 c0                        	xorl	%eax, %eax
; 	map->sz++;
   1e721: 49 83 47 30 01               	addq	$1, 48(%r15)
; }
   1e726: 48 83 c4 38                  	addq	$56, %rsp
   1e72a: 5b                           	popq	%rbx
   1e72b: 5d                           	popq	%rbp
   1e72c: 41 5c                        	popq	%r12
   1e72e: 41 5d                        	popq	%r13
   1e730: 41 5e                        	popq	%r14
   1e732: 41 5f                        	popq	%r15
   1e734: c3                           	retq
   1e735: 0f 1f 00                     	nopl	(%rax)
; 	new_cap_bits = map->cap_bits + 1;
   1e738: 49 8b 47 28                  	movq	40(%r15), %rax
; 	new_buckets = calloc(new_cap, sizeof(new_buckets[0]));
   1e73c: be 08 00 00 00               	movl	$8, %esi
; 	new_cap_bits = map->cap_bits + 1;
   1e741: 48 8d 50 01                  	leaq	1(%rax), %rdx
   1e745: b8 02 00 00 00               	movl	$2, %eax
   1e74a: 48 39 c2                     	cmpq	%rax, %rdx
   1e74d: 48 0f 43 c2                  	cmovaeq	%rdx, %rax
   1e751: 48 89 c2                     	movq	%rax, %rdx
   1e754: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	new_cap = 1UL << new_cap_bits;
   1e759: b8 01 00 00 00               	movl	$1, %eax
   1e75e: 89 d1                        	movl	%edx, %ecx
   1e760: 48 d3 e0                     	shlq	%cl, %rax
; 	new_buckets = calloc(new_cap, sizeof(new_buckets[0]));
   1e763: 48 89 c7                     	movq	%rax, %rdi
; 	new_cap = 1UL << new_cap_bits;
   1e766: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	new_buckets = calloc(new_cap, sizeof(new_buckets[0]));
   1e76b: e8 20 72 fe ff               	callq	0x5990 <.plt.sec+0x320>
   1e770: 48 89 c3                     	movq	%rax, %rbx
; 	if (!new_buckets)
   1e773: 48 85 c0                     	testq	%rax, %rax
   1e776: 0f 85 b4 00 00 00            	jne	0x1e830 <hashmap__insert+0x320>
; }
   1e77c: 48 83 c4 38                  	addq	$56, %rsp
; 		return -ENOMEM;
   1e780: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
; }
   1e785: 5b                           	popq	%rbx
   1e786: 5d                           	popq	%rbp
   1e787: 41 5c                        	popq	%r12
   1e789: 41 5d                        	popq	%r13
   1e78b: 41 5e                        	popq	%r14
   1e78d: 41 5f                        	popq	%r15
   1e78f: c3                           	retq
; 	if (!map->buckets)
   1e790: 49 8b 47 18                  	movq	24(%r15), %rax
   1e794: 48 85 c0                     	testq	%rax, %rax
   1e797: 74 67                        	je	0x1e800 <hashmap__insert+0x2f0>
; 	for (prev_ptr = &map->buckets[hash], cur = *prev_ptr;
   1e799: 4e 8b 34 e8                  	movq	(%rax,%r13,8), %r14
; 	     cur;
   1e79d: 4d 85 f6                     	testq	%r14, %r14
   1e7a0: 75 0f                        	jne	0x1e7b1 <hashmap__insert+0x2a1>
   1e7a2: eb 5c                        	jmp	0x1e800 <hashmap__insert+0x2f0>
   1e7a4: 0f 1f 40 00                  	nopl	(%rax)
; 	     prev_ptr = &cur->next, cur = cur->next) {
   1e7a8: 4d 8b 76 10                  	movq	16(%r14), %r14
; 	     cur;
   1e7ac: 4d 85 f6                     	testq	%r14, %r14
   1e7af: 74 4f                        	je	0x1e800 <hashmap__insert+0x2f0>
; 		if (map->equal_fn(cur->key, key, map->ctx)) {
   1e7b1: 49 8b 57 10                  	movq	16(%r15), %rdx
   1e7b5: 48 8b 74 24 10               	movq	16(%rsp), %rsi
   1e7ba: 49 8b 3e                     	movq	(%r14), %rdi
   1e7bd: 41 ff 57 08                  	callq	*8(%r15)
   1e7c1: 84 c0                        	testb	%al, %al
   1e7c3: 74 e3                        	je	0x1e7a8 <hashmap__insert+0x298>
; 		if (old_key)
   1e7c5: 48 85 ed                     	testq	%rbp, %rbp
   1e7c8: 74 07                        	je	0x1e7d1 <hashmap__insert+0x2c1>
; 			*old_key = entry->key;
   1e7ca: 49 8b 06                     	movq	(%r14), %rax
   1e7cd: 48 89 45 00                  	movq	%rax, (%rbp)
; 		if (old_value)
   1e7d1: 48 85 db                     	testq	%rbx, %rbx
   1e7d4: 74 07                        	je	0x1e7dd <hashmap__insert+0x2cd>
; 			*old_value = entry->value;
   1e7d6: 49 8b 46 08                  	movq	8(%r14), %rax
   1e7da: 48 89 03                     	movq	%rax, (%rbx)
; 		if (strategy == HASHMAP_SET || strategy == HASHMAP_UPDATE) {
   1e7dd: 41 8d 44 24 ff               	leal	-1(%r12), %eax
   1e7e2: 83 f8 01                     	cmpl	$1, %eax
   1e7e5: 76 31                        	jbe	0x1e818 <hashmap__insert+0x308>
; 		} else if (strategy == HASHMAP_ADD) {
   1e7e7: 45 85 e4                     	testl	%r12d, %r12d
   1e7ea: 0f 85 9e fd ff ff            	jne	0x1e58e <hashmap__insert+0x7e>
; 			return -EEXIST;
   1e7f0: b8 ef ff ff ff               	movl	$4294967279, %eax       # imm = 0xFFFFFFEF
   1e7f5: e9 2c ff ff ff               	jmp	0x1e726 <hashmap__insert+0x216>
   1e7fa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (strategy == HASHMAP_UPDATE)
   1e800: 41 83 fc 02                  	cmpl	$2, %r12d
   1e804: 0f 85 84 fd ff ff            	jne	0x1e58e <hashmap__insert+0x7e>
; 		return -ENOENT;
   1e80a: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
   1e80f: e9 12 ff ff ff               	jmp	0x1e726 <hashmap__insert+0x216>
   1e814: 0f 1f 40 00                  	nopl	(%rax)
; 			entry->key = key;
   1e818: 48 8b 44 24 10               	movq	16(%rsp), %rax
   1e81d: 49 89 06                     	movq	%rax, (%r14)
; 			entry->value = value;
   1e820: 48 8b 44 24 18               	movq	24(%rsp), %rax
   1e825: 49 89 46 08                  	movq	%rax, 8(%r14)
; 			return 0;
   1e829: 31 c0                        	xorl	%eax, %eax
   1e82b: e9 f6 fe ff ff               	jmp	0x1e726 <hashmap__insert+0x216>
; 	free(map->buckets);
   1e830: 49 8b 7f 18                  	movq	24(%r15), %rdi
   1e834: e9 63 fe ff ff               	jmp	0x1e69c <hashmap__insert+0x18c>
   1e839: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000001e840 <hashmap__find>:
; {
   1e840: f3 0f 1e fa                  	endbr64
   1e844: 41 55                        	pushq	%r13
   1e846: 49 89 d5                     	movq	%rdx, %r13
   1e849: 41 54                        	pushq	%r12
   1e84b: 49 89 f4                     	movq	%rsi, %r12
   1e84e: 55                           	pushq	%rbp
   1e84f: 48 89 fd                     	movq	%rdi, %rbp
   1e852: 53                           	pushq	%rbx
   1e853: 48 83 ec 08                  	subq	$8, %rsp
; 	h = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);
   1e857: 48 8b 5f 28                  	movq	40(%rdi), %rbx
   1e85b: 48 8b 77 10                  	movq	16(%rdi), %rsi
   1e85f: 4c 89 e7                     	movq	%r12, %rdi
   1e862: ff 55 00                     	callq	*(%rbp)
; 	if (bits == 0)
   1e865: 31 d2                        	xorl	%edx, %edx
   1e867: 85 db                        	testl	%ebx, %ebx
   1e869: 74 1b                        	je	0x1e886 <hashmap__find+0x46>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   1e86b: 48 ba 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdx # imm = 0x9E3779B97F4A7C15
   1e875: b9 40 00 00 00               	movl	$64, %ecx
   1e87a: 48 0f af c2                  	imulq	%rdx, %rax
   1e87e: 29 d9                        	subl	%ebx, %ecx
   1e880: 48 d3 e8                     	shrq	%cl, %rax
   1e883: 48 89 c2                     	movq	%rax, %rdx
; 	if (!map->buckets)
   1e886: 48 8b 45 18                  	movq	24(%rbp), %rax
   1e88a: 48 85 c0                     	testq	%rax, %rax
   1e88d: 74 49                        	je	0x1e8d8 <hashmap__find+0x98>
; 	for (prev_ptr = &map->buckets[hash], cur = *prev_ptr;
   1e88f: 48 8b 1c d0                  	movq	(%rax,%rdx,8), %rbx
; 	     cur;
   1e893: 48 85 db                     	testq	%rbx, %rbx
   1e896: 75 11                        	jne	0x1e8a9 <hashmap__find+0x69>
   1e898: eb 3e                        	jmp	0x1e8d8 <hashmap__find+0x98>
   1e89a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	     prev_ptr = &cur->next, cur = cur->next) {
   1e8a0: 48 8b 5b 10                  	movq	16(%rbx), %rbx
; 	     cur;
   1e8a4: 48 85 db                     	testq	%rbx, %rbx
   1e8a7: 74 2f                        	je	0x1e8d8 <hashmap__find+0x98>
; 		if (map->equal_fn(cur->key, key, map->ctx)) {
   1e8a9: 48 8b 55 10                  	movq	16(%rbp), %rdx
   1e8ad: 48 8b 3b                     	movq	(%rbx), %rdi
   1e8b0: 4c 89 e6                     	movq	%r12, %rsi
   1e8b3: ff 55 08                     	callq	*8(%rbp)
   1e8b6: 84 c0                        	testb	%al, %al
   1e8b8: 74 e6                        	je	0x1e8a0 <hashmap__find+0x60>
; 	if (value)
   1e8ba: 4d 85 ed                     	testq	%r13, %r13
   1e8bd: 74 08                        	je	0x1e8c7 <hashmap__find+0x87>
; 		*value = entry->value;
   1e8bf: 48 8b 53 08                  	movq	8(%rbx), %rdx
   1e8c3: 49 89 55 00                  	movq	%rdx, (%r13)
; }
   1e8c7: 48 83 c4 08                  	addq	$8, %rsp
   1e8cb: 5b                           	popq	%rbx
   1e8cc: 5d                           	popq	%rbp
   1e8cd: 41 5c                        	popq	%r12
   1e8cf: 41 5d                        	popq	%r13
   1e8d1: c3                           	retq
   1e8d2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   1e8d8: 48 83 c4 08                  	addq	$8, %rsp
; 		return false;
   1e8dc: 31 c0                        	xorl	%eax, %eax
; }
   1e8de: 5b                           	popq	%rbx
   1e8df: 5d                           	popq	%rbp
   1e8e0: 41 5c                        	popq	%r12
   1e8e2: 41 5d                        	popq	%r13
   1e8e4: c3                           	retq
   1e8e5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

000000000001e8f0 <hashmap__delete>:
; {
   1e8f0: f3 0f 1e fa                  	endbr64
   1e8f4: 41 57                        	pushq	%r15
   1e8f6: 49 89 d7                     	movq	%rdx, %r15
   1e8f9: 41 56                        	pushq	%r14
   1e8fb: 49 89 ce                     	movq	%rcx, %r14
   1e8fe: 41 55                        	pushq	%r13
   1e900: 41 54                        	pushq	%r12
   1e902: 49 89 fc                     	movq	%rdi, %r12
   1e905: 55                           	pushq	%rbp
   1e906: 53                           	pushq	%rbx
   1e907: 48 89 f3                     	movq	%rsi, %rbx
   1e90a: 48 83 ec 18                  	subq	$24, %rsp
; 	h = hash_bits(map->hash_fn(key, map->ctx), map->cap_bits);
   1e90e: 48 8b 6f 28                  	movq	40(%rdi), %rbp
   1e912: 48 8b 77 10                  	movq	16(%rdi), %rsi
   1e916: 48 89 df                     	movq	%rbx, %rdi
   1e919: 41 ff 14 24                  	callq	*(%r12)
; 	if (bits == 0)
   1e91d: 31 d2                        	xorl	%edx, %edx
   1e91f: 85 ed                        	testl	%ebp, %ebp
   1e921: 74 1b                        	je	0x1e93e <hashmap__delete+0x4e>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   1e923: 48 ba 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdx # imm = 0x9E3779B97F4A7C15
   1e92d: b9 40 00 00 00               	movl	$64, %ecx
   1e932: 48 0f af c2                  	imulq	%rdx, %rax
   1e936: 29 e9                        	subl	%ebp, %ecx
   1e938: 48 d3 e8                     	shrq	%cl, %rax
   1e93b: 48 89 c2                     	movq	%rax, %rdx
; 	if (!map->buckets)
   1e93e: 49 8b 44 24 18               	movq	24(%r12), %rax
   1e943: 48 85 c0                     	testq	%rax, %rax
   1e946: 0f 84 84 00 00 00            	je	0x1e9d0 <hashmap__delete+0xe0>
; 	for (prev_ptr = &map->buckets[hash], cur = *prev_ptr;
   1e94c: 4c 8d 2c d0                  	leaq	(%rax,%rdx,8), %r13
   1e950: 49 8b 6d 00                  	movq	(%r13), %rbp
; 	     cur;
   1e954: 48 85 ed                     	testq	%rbp, %rbp
   1e957: 75 14                        	jne	0x1e96d <hashmap__delete+0x7d>
   1e959: eb 75                        	jmp	0x1e9d0 <hashmap__delete+0xe0>
   1e95b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	     prev_ptr = &cur->next, cur = cur->next) {
   1e960: 4c 8d 6d 10                  	leaq	16(%rbp), %r13
   1e964: 48 8b 6d 10                  	movq	16(%rbp), %rbp
; 	     cur;
   1e968: 48 85 ed                     	testq	%rbp, %rbp
   1e96b: 74 63                        	je	0x1e9d0 <hashmap__delete+0xe0>
; 		if (map->equal_fn(cur->key, key, map->ctx)) {
   1e96d: 49 8b 54 24 10               	movq	16(%r12), %rdx
   1e972: 48 8b 7d 00                  	movq	(%rbp), %rdi
   1e976: 48 89 de                     	movq	%rbx, %rsi
   1e979: 41 ff 54 24 08               	callq	*8(%r12)
   1e97e: 84 c0                        	testb	%al, %al
   1e980: 74 de                        	je	0x1e960 <hashmap__delete+0x70>
; 	if (old_key)
   1e982: 4d 85 ff                     	testq	%r15, %r15
   1e985: 74 07                        	je	0x1e98e <hashmap__delete+0x9e>
; 		*old_key = entry->key;
   1e987: 48 8b 55 00                  	movq	(%rbp), %rdx
   1e98b: 49 89 17                     	movq	%rdx, (%r15)
; 	if (old_value)
   1e98e: 4d 85 f6                     	testq	%r14, %r14
   1e991: 74 07                        	je	0x1e99a <hashmap__delete+0xaa>
; 		*old_value = entry->value;
   1e993: 48 8b 55 08                  	movq	8(%rbp), %rdx
   1e997: 49 89 16                     	movq	%rdx, (%r14)
; 	*pprev = entry->next;
   1e99a: 48 8b 55 10                  	movq	16(%rbp), %rdx
; 	free(entry);
   1e99e: 48 89 ef                     	movq	%rbp, %rdi
   1e9a1: 88 44 24 0f                  	movb	%al, 15(%rsp)
; 	*pprev = entry->next;
   1e9a5: 49 89 55 00                  	movq	%rdx, (%r13)
; 	free(entry);
   1e9a9: e8 12 6d fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	map->sz--;
   1e9ae: 49 83 6c 24 30 01            	subq	$1, 48(%r12)
   1e9b4: 0f b6 44 24 0f               	movzbl	15(%rsp), %eax
; }
   1e9b9: 48 83 c4 18                  	addq	$24, %rsp
   1e9bd: 5b                           	popq	%rbx
   1e9be: 5d                           	popq	%rbp
   1e9bf: 41 5c                        	popq	%r12
   1e9c1: 41 5d                        	popq	%r13
   1e9c3: 41 5e                        	popq	%r14
   1e9c5: 41 5f                        	popq	%r15
   1e9c7: c3                           	retq
   1e9c8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
   1e9d0: 48 83 c4 18                  	addq	$24, %rsp
; 		return false;
   1e9d4: 31 c0                        	xorl	%eax, %eax
; }
   1e9d6: 5b                           	popq	%rbx
   1e9d7: 5d                           	popq	%rbp
   1e9d8: 41 5c                        	popq	%r12
   1e9da: 41 5d                        	popq	%r13
   1e9dc: 41 5e                        	popq	%r14
   1e9de: 41 5f                        	popq	%r15
   1e9e0: c3                           	retq
   1e9e1: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   1e9eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000001e9f0 <add_data>:
; {
   1e9f0: 41 57                        	pushq	%r15
   1e9f2: 41 56                        	pushq	%r14
   1e9f4: 41 55                        	pushq	%r13
   1e9f6: 41 54                        	pushq	%r12
   1e9f8: 55                           	pushq	%rbp
   1e9f9: 53                           	pushq	%rbx
   1e9fa: 48 83 ec 28                  	subq	$40, %rsp
; 	if (gen->error)
   1e9fe: 8b 6f 3c                     	movl	60(%rdi), %ebp
; {
   1ea01: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1ea0a: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1ea0f: 31 c0                        	xorl	%eax, %eax
; 	__u64 zero = 0;
   1ea11: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 	if (gen->error)
   1ea1a: 85 ed                        	testl	%ebp, %ebp
   1ea1c: 0f 85 b6 00 00 00            	jne	0x1ead8 <add_data+0xe8>
; 	__u32 size8 = roundup(size, 8);
   1ea22: 44 8d 62 07                  	leal	7(%rdx), %r12d
   1ea26: 48 89 fb                     	movq	%rdi, %rbx
   1ea29: 41 89 d6                     	movl	%edx, %r14d
; 	size_t off = gen->data_cur - gen->data_start;
   1ea2c: 48 8b 57 10                  	movq	16(%rdi), %rdx
   1ea30: 48 8b 7f 08                  	movq	8(%rdi), %rdi
; 	if (size > INT32_MAX || off + size > INT32_MAX) {
   1ea34: 41 83 e4 f8                  	andl	$-8, %r12d
   1ea38: 0f 88 b2 00 00 00            	js	0x1eaf0 <add_data+0x100>
; 	size_t off = gen->data_cur - gen->data_start;
   1ea3e: 48 29 fa                     	subq	%rdi, %rdx
; 	if (size > INT32_MAX || off + size > INT32_MAX) {
   1ea41: 45 89 e5                     	movl	%r12d, %r13d
   1ea44: 49 89 f7                     	movq	%rsi, %r15
   1ea47: 4a 8d 34 2a                  	leaq	(%rdx,%r13), %rsi
   1ea4b: 48 81 fe ff ff ff 7f         	cmpq	$2147483647, %rsi       # imm = 0x7FFFFFFF
   1ea52: 0f 87 98 00 00 00            	ja	0x1eaf0 <add_data+0x100>
   1ea58: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
; 	data_start = realloc(gen->data_start, off + size);
   1ea5d: e8 be 70 fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 	if (!data_start) {
   1ea62: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   1ea67: 48 85 c0                     	testq	%rax, %rax
   1ea6a: 0f 84 8e 00 00 00            	je	0x1eafe <add_data+0x10e>
; 	gen->data_cur = data_start + off;
   1ea70: 48 8d 2c 10                  	leaq	(%rax,%rdx), %rbp
; 	gen->data_start = data_start;
   1ea74: 48 89 43 08                  	movq	%rax, 8(%rbx)
; 	gen->data_cur = data_start + off;
   1ea78: 48 89 6b 10                  	movq	%rbp, 16(%rbx)
; 	if (data) {
   1ea7c: 4d 85 ff                     	testq	%r15, %r15
   1ea7f: 74 5f                        	je	0x1eae0 <add_data+0xf0>
; 		memcpy(gen->data_cur, data, size);
   1ea81: 44 89 f2                     	movl	%r14d, %edx
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1ea84: 4c 89 fe                     	movq	%r15, %rsi
   1ea87: 48 89 ef                     	movq	%rbp, %rdi
   1ea8a: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
   1ea8f: e8 ac 6f fe ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 		memcpy(gen->data_cur + size, &zero, size8 - size);
   1ea94: 44 89 e2                     	movl	%r12d, %edx
   1ea97: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1ea9c: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
; 		memcpy(gen->data_cur + size, &zero, size8 - size);
   1eaa1: 48 03 7b 10                  	addq	16(%rbx), %rdi
   1eaa5: 44 29 f2                     	subl	%r14d, %edx
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1eaa8: e8 93 6f fe ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	gen->data_cur += size8;
   1eaad: 4c 01 6b 10                  	addq	%r13, 16(%rbx)
; 	return prev - gen->data_start;
   1eab1: 2b 6b 08                     	subl	8(%rbx), %ebp
; }
   1eab4: 48 8b 44 24 18               	movq	24(%rsp), %rax
   1eab9: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1eac2: 75 35                        	jne	0x1eaf9 <add_data+0x109>
   1eac4: 48 83 c4 28                  	addq	$40, %rsp
   1eac8: 89 e8                        	movl	%ebp, %eax
   1eaca: 5b                           	popq	%rbx
   1eacb: 5d                           	popq	%rbp
   1eacc: 41 5c                        	popq	%r12
   1eace: 41 5d                        	popq	%r13
   1ead0: 41 5e                        	popq	%r14
   1ead2: 41 5f                        	popq	%r15
   1ead4: c3                           	retq
   1ead5: 0f 1f 00                     	nopl	(%rax)
; 		return 0;
   1ead8: 31 ed                        	xorl	%ebp, %ebp
   1eada: eb d8                        	jmp	0x1eab4 <add_data+0xc4>
   1eadc: 0f 1f 40 00                  	nopl	(%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1eae0: 4c 89 ea                     	movq	%r13, %rdx
   1eae3: 31 f6                        	xorl	%esi, %esi
   1eae5: 48 89 ef                     	movq	%rbp, %rdi
   1eae8: e8 d3 6d fe ff               	callq	0x58c0 <.plt.sec+0x250>
   1eaed: eb be                        	jmp	0x1eaad <add_data+0xbd>
   1eaef: 90                           	nop
; 		gen->error = -ERANGE;
   1eaf0: c7 43 3c de ff ff ff         	movl	$4294967262, 60(%rbx)   # imm = 0xFFFFFFDE
; 		return -ERANGE;
   1eaf7: eb bb                        	jmp	0x1eab4 <add_data+0xc4>
; }
   1eaf9: e8 02 6d fe ff               	callq	0x5800 <.plt.sec+0x190>
; 		gen->error = -ENOMEM;
   1eafe: c7 43 3c f4 ff ff ff         	movl	$4294967284, 60(%rbx)   # imm = 0xFFFFFFF4
; 		free(gen->data_start);
   1eb05: 48 8b 7b 08                  	movq	8(%rbx), %rdi
   1eb09: e8 b2 6b fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		gen->data_start = NULL;
   1eb0e: 48 c7 43 08 00 00 00 00      	movq	$0, 8(%rbx)
; 		return -ENOMEM;
   1eb16: eb 9c                        	jmp	0x1eab4 <add_data+0xc4>
   1eb18: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000001eb20 <get_ksym_desc>:
; {
   1eb20: 41 57                        	pushq	%r15
   1eb22: 41 56                        	pushq	%r14
   1eb24: 49 89 f6                     	movq	%rsi, %r14
   1eb27: 41 55                        	pushq	%r13
   1eb29: 49 89 fd                     	movq	%rdi, %r13
   1eb2c: 41 54                        	pushq	%r12
   1eb2e: 55                           	pushq	%rbp
   1eb2f: 53                           	pushq	%rbx
   1eb30: 48 83 ec 18                  	subq	$24, %rsp
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   1eb34: 8b 87 e8 00 00 00            	movl	232(%rdi), %eax
; 	kdesc = libbpf_reallocarray(gen->ksyms, gen->nr_ksyms + 1, sizeof(*kdesc));
   1eb3a: 48 8b 8f e0 00 00 00         	movq	224(%rdi), %rcx
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   1eb41: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	kdesc = libbpf_reallocarray(gen->ksyms, gen->nr_ksyms + 1, sizeof(*kdesc));
   1eb45: 48 89 0c 24                  	movq	%rcx, (%rsp)
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   1eb49: 85 c0                        	testl	%eax, %eax
   1eb4b: 0f 84 b3 00 00 00            	je	0x1ec04 <get_ksym_desc+0xe4>
   1eb51: 83 e8 01                     	subl	$1, %eax
; 		if (!strcmp(gen->ksyms[i].name, relo->name)) {
   1eb54: 48 8b 1e                     	movq	(%rsi), %rbx
   1eb57: 49 89 cf                     	movq	%rcx, %r15
   1eb5a: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   1eb5e: 48 8d 6c c1 18               	leaq	24(%rcx,%rax,8), %rbp
   1eb63: eb 0c                        	jmp	0x1eb71 <get_ksym_desc+0x51>
   1eb65: 0f 1f 00                     	nopl	(%rax)
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   1eb68: 49 83 c7 18                  	addq	$24, %r15
   1eb6c: 49 39 ef                     	cmpq	%rbp, %r15
   1eb6f: 74 2f                        	je	0x1eba0 <get_ksym_desc+0x80>
; 		if (!strcmp(gen->ksyms[i].name, relo->name)) {
   1eb71: 49 8b 3f                     	movq	(%r15), %rdi
   1eb74: 48 89 de                     	movq	%rbx, %rsi
   1eb77: 4d 89 fc                     	movq	%r15, %r12
   1eb7a: e8 31 6e fe ff               	callq	0x59b0 <.plt.sec+0x340>
   1eb7f: 85 c0                        	testl	%eax, %eax
   1eb81: 75 e5                        	jne	0x1eb68 <get_ksym_desc+0x48>
; 			gen->ksyms[i].ref++;
   1eb83: 41 83 47 08 01               	addl	$1, 8(%r15)
; }
   1eb88: 48 83 c4 18                  	addq	$24, %rsp
   1eb8c: 4c 89 e0                     	movq	%r12, %rax
   1eb8f: 5b                           	popq	%rbx
   1eb90: 5d                           	popq	%rbp
   1eb91: 41 5c                        	popq	%r12
   1eb93: 41 5d                        	popq	%r13
   1eb95: 41 5e                        	popq	%r14
   1eb97: 41 5f                        	popq	%r15
   1eb99: c3                           	retq
   1eb9a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	kdesc = libbpf_reallocarray(gen->ksyms, gen->nr_ksyms + 1, sizeof(*kdesc));
   1eba0: 8b 44 24 0c                  	movl	12(%rsp), %eax
   1eba4: 83 c0 01                     	addl	$1, %eax
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   1eba7: 48 8d 34 40                  	leaq	(%rax,%rax,2), %rsi
   1ebab: 48 c1 e6 03                  	shlq	$3, %rsi
; 	return realloc(ptr, total);
   1ebaf: 48 8b 3c 24                  	movq	(%rsp), %rdi
   1ebb3: e8 68 6f fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
   1ebb8: 49 89 c4                     	movq	%rax, %r12
; 	if (!kdesc) {
   1ebbb: 48 85 c0                     	testq	%rax, %rax
   1ebbe: 74 4b                        	je	0x1ec0b <get_ksym_desc+0xeb>
; 	gen->ksyms = kdesc;
   1ebc0: 49 89 85 e0 00 00 00         	movq	%rax, 224(%r13)
; 	kdesc = &gen->ksyms[gen->nr_ksyms++];
   1ebc7: 41 8b 85 e8 00 00 00         	movl	232(%r13), %eax
   1ebce: 8d 50 01                     	leal	1(%rax), %edx
   1ebd1: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   1ebd5: 4d 8d 24 c4                  	leaq	(%r12,%rax,8), %r12
; 	kdesc->name = relo->name;
   1ebd9: 49 8b 06                     	movq	(%r14), %rax
; 	kdesc = &gen->ksyms[gen->nr_ksyms++];
   1ebdc: 41 89 95 e8 00 00 00         	movl	%edx, 232(%r13)
; 	kdesc->name = relo->name;
   1ebe3: 49 89 04 24                  	movq	%rax, (%r12)
; 	kdesc->kind = relo->kind;
   1ebe7: 41 8b 46 08                  	movl	8(%r14), %eax
; 	kdesc->ref = 1;
   1ebeb: 41 c7 44 24 08 01 00 00 00   	movl	$1, 8(%r12)
; 	kdesc->kind = relo->kind;
   1ebf4: 41 89 44 24 0c               	movl	%eax, 12(%r12)
; 	kdesc->off = 0;
   1ebf9: 49 c7 44 24 10 00 00 00 00   	movq	$0, 16(%r12)
; 	return kdesc;
   1ec02: eb 84                        	jmp	0x1eb88 <get_ksym_desc+0x68>
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   1ec04: be 18 00 00 00               	movl	$24, %esi
   1ec09: eb a4                        	jmp	0x1ebaf <get_ksym_desc+0x8f>
; 		gen->error = -ENOMEM;
   1ec0b: 41 c7 45 3c f4 ff ff ff      	movl	$4294967284, 60(%r13)   # imm = 0xFFFFFFF4
; 		return NULL;
   1ec13: e9 70 ff ff ff               	jmp	0x1eb88 <get_ksym_desc+0x68>
   1ec18: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000001ec20 <emit>:
; 	if (gen->error)
   1ec20: 8b 47 3c                     	movl	60(%rdi), %eax
   1ec23: 85 c0                        	testl	%eax, %eax
   1ec25: 75 49                        	jne	0x1ec70 <emit+0x50>
; {
   1ec27: 41 54                        	pushq	%r12
   1ec29: 55                           	pushq	%rbp
   1ec2a: 48 89 f5                     	movq	%rsi, %rbp
   1ec2d: 53                           	pushq	%rbx
   1ec2e: 48 89 fb                     	movq	%rdi, %rbx
; 	size_t off = gen->insn_cur - gen->insn_start;
   1ec31: 48 8b 7f 18                  	movq	24(%rdi), %rdi
   1ec35: 4c 8b 63 20                  	movq	32(%rbx), %r12
   1ec39: 49 29 fc                     	subq	%rdi, %r12
; 	if (size > INT32_MAX || off + size > INT32_MAX) {
   1ec3c: 49 8d 74 24 08               	leaq	8(%r12), %rsi
   1ec41: 48 81 fe ff ff ff 7f         	cmpq	$2147483647, %rsi       # imm = 0x7FFFFFFF
   1ec48: 77 2e                        	ja	0x1ec78 <emit+0x58>
; 	insn_start = realloc(gen->insn_start, off + size);
   1ec4a: e8 d1 6e fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 	if (!insn_start) {
   1ec4f: 48 85 c0                     	testq	%rax, %rax
   1ec52: 74 2d                        	je	0x1ec81 <emit+0x61>
; 	gen->insn_start = insn_start;
   1ec54: 48 89 43 18                  	movq	%rax, 24(%rbx)
; 	gen->insn_cur = insn_start + off;
   1ec58: 4c 01 e0                     	addq	%r12, %rax
   1ec5b: 48 89 43 20                  	movq	%rax, 32(%rbx)
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1ec5f: 48 89 28                     	movq	%rbp, (%rax)
; 	gen->insn_cur += sizeof(insn);
   1ec62: 48 83 43 20 08               	addq	$8, 32(%rbx)
; }
   1ec67: 5b                           	popq	%rbx
   1ec68: 5d                           	popq	%rbp
   1ec69: 41 5c                        	popq	%r12
   1ec6b: c3                           	retq
   1ec6c: 0f 1f 40 00                  	nopl	(%rax)
   1ec70: c3                           	retq
   1ec71: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		gen->error = -ERANGE;
   1ec78: c7 43 3c de ff ff ff         	movl	$4294967262, 60(%rbx)   # imm = 0xFFFFFFDE
; 		return -ERANGE;
   1ec7f: eb e6                        	jmp	0x1ec67 <emit+0x47>
; 		gen->error = -ENOMEM;
   1ec81: c7 43 3c f4 ff ff ff         	movl	$4294967284, 60(%rbx)   # imm = 0xFFFFFFF4
; 		free(gen->insn_start);
   1ec88: 48 8b 7b 18                  	movq	24(%rbx), %rdi
   1ec8c: e8 2f 6a fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		gen->insn_start = NULL;
   1ec91: 48 c7 43 18 00 00 00 00      	movq	$0, 24(%rbx)
; 		return -ENOMEM;
   1ec99: eb cc                        	jmp	0x1ec67 <emit+0x47>
   1ec9b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000001eca0 <move_ctx2blob>:
; {
   1eca0: 41 55                        	pushq	%r13
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_6, ctx_off));
   1eca2: 83 ea 01                     	subl	$1, %edx
   1eca5: 48 8d 05 94 a9 01 00         	leaq	108948(%rip), %rax      # 0x39640 <CSWTCH.76>
   1ecac: 0f b7 c9                     	movzwl	%cx, %ecx
; {
   1ecaf: 41 54                        	pushq	%r12
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_6, ctx_off));
   1ecb1: 48 c1 e1 10                  	shlq	$16, %rcx
; {
   1ecb5: 41 89 f4                     	movl	%esi, %r12d
   1ecb8: 45 89 c5                     	movl	%r8d, %r13d
   1ecbb: 55                           	pushq	%rbp
   1ecbc: 48 89 fd                     	movq	%rdi, %rbp
   1ecbf: 53                           	pushq	%rbx
   1ecc0: 48 83 ec 08                  	subq	$8, %rsp
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_6, ctx_off));
   1ecc4: 8b 1c 90                     	movl	(%rax,%rdx,4), %ebx
   1ecc7: 31 c0                        	xorl	%eax, %eax
   1ecc9: 83 e3 18                     	andl	$24, %ebx
   1eccc: 89 da                        	movl	%ebx, %edx
   1ecce: 83 ca 61                     	orl	$97, %edx
   1ecd1: 88 d0                        	movb	%dl, %al
   1ecd3: b4 60                        	movb	$96, %ah
   1ecd5: 0f b7 f0                     	movzwl	%ax, %esi
   1ecd8: 48 09 ce                     	orq	%rcx, %rsi
   1ecdb: e8 40 ff ff ff               	callq	0x1ec20 <emit>
; 	if (check_non_zero)
   1ece0: 45 84 ed                     	testb	%r13b, %r13b
   1ece3: 75 3b                        	jne	0x1ed20 <move_ctx2blob+0x80>
; 	emit(gen, insn1);
   1ece5: 48 89 ef                     	movq	%rbp, %rdi
   1ece8: 49 c1 e4 20                  	shlq	$32, %r12
   1ecec: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   1ecf1: e8 2a ff ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   1ecf6: 4c 89 e6                     	movq	%r12, %rsi
   1ecf9: 48 89 ef                     	movq	%rbp, %rdi
   1ecfc: e8 1f ff ff ff               	callq	0x1ec20 <emit>
; }
   1ed01: 48 83 c4 08                  	addq	$8, %rsp
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_1, BPF_REG_0, 0));
   1ed05: 0f b6 f3                     	movzbl	%bl, %esi
   1ed08: 48 89 ef                     	movq	%rbp, %rdi
; }
   1ed0b: 5b                           	popq	%rbx
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_1, BPF_REG_0, 0));
   1ed0c: 48 81 ce 63 01 00 00         	orq	$355, %rsi              # imm = 0x163
; }
   1ed13: 5d                           	popq	%rbp
   1ed14: 41 5c                        	popq	%r12
   1ed16: 41 5d                        	popq	%r13
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_1, BPF_REG_0, 0));
   1ed18: e9 03 ff ff ff               	jmp	0x1ec20 <emit>
   1ed1d: 0f 1f 00                     	nopl	(%rax)
; 		emit(gen, BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 3));
   1ed20: be 15 00 03 00               	movl	$196629, %esi           # imm = 0x30015
   1ed25: 48 89 ef                     	movq	%rbp, %rdi
   1ed28: e8 f3 fe ff ff               	callq	0x1ec20 <emit>
   1ed2d: eb b6                        	jmp	0x1ece5 <move_ctx2blob+0x45>
   1ed2f: 90                           	nop

000000000001ed30 <emit_rel_store>:
; {
   1ed30: 41 54                        	pushq	%r12
   1ed32: 49 89 d4                     	movq	%rdx, %r12
   1ed35: 55                           	pushq	%rbp
   1ed36: 49 c1 e4 20                  	shlq	$32, %r12
   1ed3a: 48 89 fd                     	movq	%rdi, %rbp
   1ed3d: 53                           	pushq	%rbx
   1ed3e: 89 f3                        	movl	%esi, %ebx
; 	emit(gen, insn1);
   1ed40: be 18 60 00 00               	movl	$24600, %esi            # imm = 0x6018
   1ed45: 48 c1 e3 20                  	shlq	$32, %rbx
   1ed49: e8 d2 fe ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   1ed4e: 4c 89 e6                     	movq	%r12, %rsi
   1ed51: 48 89 ef                     	movq	%rbp, %rdi
   1ed54: e8 c7 fe ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn1);
   1ed59: 48 89 ef                     	movq	%rbp, %rdi
   1ed5c: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   1ed61: e8 ba fe ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   1ed66: 48 89 de                     	movq	%rbx, %rsi
   1ed69: 48 89 ef                     	movq	%rbp, %rdi
   1ed6c: e8 af fe ff ff               	callq	0x1ec20 <emit>
; }
   1ed71: 5b                           	popq	%rbx
; 	emit(gen, BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, 0));
   1ed72: 48 89 ef                     	movq	%rbp, %rdi
   1ed75: be 7b 01 00 00               	movl	$379, %esi              # imm = 0x17B
; }
   1ed7a: 5d                           	popq	%rbp
   1ed7b: 41 5c                        	popq	%r12
; 	emit(gen, BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, 0));
   1ed7d: e9 9e fe ff ff               	jmp	0x1ec20 <emit>
   1ed82: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1ed8d: 0f 1f 00                     	nopl	(%rax)

000000000001ed90 <emit_sys_bpf>:
; {
   1ed90: 41 54                        	pushq	%r12
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_1, cmd));
   1ed92: 48 c1 e6 20                  	shlq	$32, %rsi
; {
   1ed96: 41 89 d4                     	movl	%edx, %r12d
   1ed99: 55                           	pushq	%rbp
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_1, cmd));
   1ed9a: 48 81 ce b7 01 00 00         	orq	$439, %rsi              # imm = 0x1B7
; {
   1eda1: 48 89 fd                     	movq	%rdi, %rbp
   1eda4: 49 c1 e4 20                  	shlq	$32, %r12
   1eda8: 53                           	pushq	%rbx
   1eda9: 89 cb                        	movl	%ecx, %ebx
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_1, cmd));
   1edab: e8 70 fe ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn1);
   1edb0: 48 89 ef                     	movq	%rbp, %rdi
   1edb3: be 18 62 00 00               	movl	$25112, %esi            # imm = 0x6218
   1edb8: e8 63 fe ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   1edbd: 4c 89 e6                     	movq	%r12, %rsi
   1edc0: 48 89 ef                     	movq	%rbp, %rdi
   1edc3: e8 58 fe ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_3, attr_size));
   1edc8: 48 89 de                     	movq	%rbx, %rsi
   1edcb: 48 89 ef                     	movq	%rbp, %rdi
   1edce: 48 c1 e6 20                  	shlq	$32, %rsi
   1edd2: 48 81 ce b7 03 00 00         	orq	$951, %rsi              # imm = 0x3B7
   1edd9: e8 42 fe ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_sys_bpf));
   1edde: 48 89 ef                     	movq	%rbp, %rdi
   1ede1: 48 be 85 00 00 00 a6 00 00 00	movabsq	$712964571269, %rsi     # imm = 0xA600000085
   1edeb: e8 30 fe ff ff               	callq	0x1ec20 <emit>
; }
   1edf0: 5b                           	popq	%rbx
; 	emit(gen, BPF_MOV64_REG(BPF_REG_7, BPF_REG_0));
   1edf1: 48 89 ef                     	movq	%rbp, %rdi
   1edf4: be bf 07 00 00               	movl	$1983, %esi             # imm = 0x7BF
; }
   1edf9: 5d                           	popq	%rbp
   1edfa: 41 5c                        	popq	%r12
; 	emit(gen, BPF_MOV64_REG(BPF_REG_7, BPF_REG_0));
   1edfc: e9 1f fe ff ff               	jmp	0x1ec20 <emit>
   1ee01: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1ee0c: 0f 1f 40 00                  	nopl	(%rax)

000000000001ee10 <move_blob2blob>:
; {
   1ee10: 41 55                        	pushq	%r13
   1ee12: 49 89 cd                     	movq	%rcx, %r13
   1ee15: 41 54                        	pushq	%r12
   1ee17: 49 c1 e5 20                  	shlq	$32, %r13
   1ee1b: 41 89 f4                     	movl	%esi, %r12d
; 	emit(gen, insn1);
   1ee1e: be 18 62 00 00               	movl	$25112, %esi            # imm = 0x6218
; {
   1ee23: 55                           	pushq	%rbp
   1ee24: 48 89 fd                     	movq	%rdi, %rbp
; 	emit(gen, insn1);
   1ee27: 49 c1 e4 20                  	shlq	$32, %r12
; {
   1ee2b: 53                           	pushq	%rbx
   1ee2c: 89 d3                        	movl	%edx, %ebx
   1ee2e: 48 83 ec 08                  	subq	$8, %rsp
; 	emit(gen, insn1);
   1ee32: e8 e9 fd ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   1ee37: 4c 89 ee                     	movq	%r13, %rsi
   1ee3a: 48 89 ef                     	movq	%rbp, %rdi
   1ee3d: e8 de fd ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_2, 0));
   1ee42: 8d 53 ff                     	leal	-1(%rbx), %edx
   1ee45: 48 8d 05 f4 a7 01 00         	leaq	108532(%rip), %rax      # 0x39640 <CSWTCH.76>
   1ee4c: 48 89 ef                     	movq	%rbp, %rdi
   1ee4f: 8b 1c 90                     	movl	(%rax,%rdx,4), %ebx
   1ee52: 31 c0                        	xorl	%eax, %eax
   1ee54: 83 e3 18                     	andl	$24, %ebx
   1ee57: 89 da                        	movl	%ebx, %edx
   1ee59: 83 ca 61                     	orl	$97, %edx
   1ee5c: 88 d0                        	movb	%dl, %al
   1ee5e: b4 20                        	movb	$32, %ah
   1ee60: 0f b7 f0                     	movzwl	%ax, %esi
   1ee63: e8 b8 fd ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn1);
   1ee68: 48 89 ef                     	movq	%rbp, %rdi
   1ee6b: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   1ee70: e8 ab fd ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   1ee75: 4c 89 e6                     	movq	%r12, %rsi
   1ee78: 48 89 ef                     	movq	%rbp, %rdi
   1ee7b: e8 a0 fd ff ff               	callq	0x1ec20 <emit>
; }
   1ee80: 48 83 c4 08                  	addq	$8, %rsp
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_1, BPF_REG_0, 0));
   1ee84: 0f b6 f3                     	movzbl	%bl, %esi
   1ee87: 48 89 ef                     	movq	%rbp, %rdi
; }
   1ee8a: 5b                           	popq	%rbx
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_1, BPF_REG_0, 0));
   1ee8b: 48 81 ce 63 01 00 00         	orq	$355, %rsi              # imm = 0x163
; }
   1ee92: 5d                           	popq	%rbp
   1ee93: 41 5c                        	popq	%r12
   1ee95: 41 5d                        	popq	%r13
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_1, BPF_REG_0, 0));
   1ee97: e9 84 fd ff ff               	jmp	0x1ec20 <emit>
   1ee9c: 0f 1f 40 00                  	nopl	(%rax)

000000000001eea0 <emit_debug.part.0>:
; static void emit_debug(struct bpf_gen *gen, int reg1, int reg2,
   1eea0: 41 56                        	pushq	%r14
;   return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1eea2: 4d 89 c1                     	movq	%r8, %r9
   1eea5: 49 89 c8                     	movq	%rcx, %r8
   1eea8: b9 00 04 00 00               	movl	$1024, %ecx             # imm = 0x400
; static void emit_debug(struct bpf_gen *gen, int reg1, int reg2,
   1eead: 41 55                        	pushq	%r13
   1eeaf: 41 89 d5                     	movl	%edx, %r13d
;   return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1eeb2: ba 01 00 00 00               	movl	$1, %edx
; static void emit_debug(struct bpf_gen *gen, int reg1, int reg2,
   1eeb7: 41 54                        	pushq	%r12
   1eeb9: 55                           	pushq	%rbp
   1eeba: 48 89 fd                     	movq	%rdi, %rbp
   1eebd: 53                           	pushq	%rbx
   1eebe: 89 f3                        	movl	%esi, %ebx
;   return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1eec0: be 00 04 00 00               	movl	$1024, %esi             # imm = 0x400
; static void emit_debug(struct bpf_gen *gen, int reg1, int reg2,
   1eec5: 48 81 ec 10 04 00 00         	subq	$1040, %rsp             # imm = 0x410
   1eecc: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1eed5: 48 89 84 24 08 04 00 00      	movq	%rax, 1032(%rsp)
   1eedd: 31 c0                        	xorl	%eax, %eax
;   return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1eedf: 49 89 e6                     	movq	%rsp, %r14
   1eee2: 4c 89 f7                     	movq	%r14, %rdi
   1eee5: e8 06 6c fe ff               	callq	0x5af0 <.plt.sec+0x480>
; 	if (ret < 1024 - 7 && reg1 >= 0 && reg2 < 0)
   1eeea: 3d f8 03 00 00               	cmpl	$1016, %eax             # imm = 0x3F8
   1eeef: 7f 0a                        	jg	0x1eefb <emit_debug.part.0+0x5b>
   1eef1: 41 83 fd ff                  	cmpl	$-1, %r13d
   1eef5: 0f 84 bd 00 00 00            	je	0x1efb8 <emit_debug.part.0+0x118>
; 	len = strlen(buf) + 1;
   1eefb: 4c 89 f7                     	movq	%r14, %rdi
   1eefe: e8 dd 68 fe ff               	callq	0x57e0 <.plt.sec+0x170>
; 	addr = add_data(gen, buf, len);
   1ef03: 4c 89 f6                     	movq	%r14, %rsi
   1ef06: 48 89 ef                     	movq	%rbp, %rdi
; 	len = strlen(buf) + 1;
   1ef09: 44 8d 60 01                  	leal	1(%rax), %r12d
; 	addr = add_data(gen, buf, len);
   1ef0d: 44 89 e2                     	movl	%r12d, %edx
   1ef10: e8 db fa ff ff               	callq	0x1e9f0 <add_data>
; 	emit(gen, insn1);
   1ef15: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   1ef1a: 48 89 ef                     	movq	%rbp, %rdi
   1ef1d: 49 89 c6                     	movq	%rax, %r14
   1ef20: e8 fb fc ff ff               	callq	0x1ec20 <emit>
   1ef25: 49 c1 e6 20                  	shlq	$32, %r14
; 	emit(gen, insn2);
   1ef29: 48 89 ef                     	movq	%rbp, %rdi
   1ef2c: 4c 89 f6                     	movq	%r14, %rsi
   1ef2f: e8 ec fc ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_2, len));
   1ef34: 4c 89 e6                     	movq	%r12, %rsi
   1ef37: 48 89 ef                     	movq	%rbp, %rdi
   1ef3a: 48 c1 e6 20                  	shlq	$32, %rsi
   1ef3e: 48 81 ce b7 02 00 00         	orq	$695, %rsi              # imm = 0x2B7
   1ef45: e8 d6 fc ff ff               	callq	0x1ec20 <emit>
; 		emit(gen, BPF_MOV64_REG(BPF_REG_3, reg1));
   1ef4a: 48 63 f3                     	movslq	%ebx, %rsi
   1ef4d: 48 89 ef                     	movq	%rbp, %rdi
   1ef50: 48 c1 e6 0c                  	shlq	$12, %rsi
   1ef54: 48 81 ce bf 03 00 00         	orq	$959, %rsi              # imm = 0x3BF
   1ef5b: e8 c0 fc ff ff               	callq	0x1ec20 <emit>
; 	if (reg2 >= 0)
   1ef60: 41 83 fd ff                  	cmpl	$-1, %r13d
   1ef64: 74 19                        	je	0x1ef7f <emit_debug.part.0+0xdf>
; 		emit(gen, BPF_MOV64_REG(BPF_REG_4, reg2));
   1ef66: 44 89 ee                     	movl	%r13d, %esi
   1ef69: 48 89 ef                     	movq	%rbp, %rdi
   1ef6c: 83 e6 0f                     	andl	$15, %esi
   1ef6f: 48 c1 e6 0c                  	shlq	$12, %rsi
   1ef73: 48 81 ce bf 04 00 00         	orq	$1215, %rsi             # imm = 0x4BF
   1ef7a: e8 a1 fc ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_trace_printk));
   1ef7f: 48 be 85 00 00 00 06 00 00 00	movabsq	$25769803909, %rsi      # imm = 0x600000085
   1ef89: 48 89 ef                     	movq	%rbp, %rdi
   1ef8c: e8 8f fc ff ff               	callq	0x1ec20 <emit>
; }
   1ef91: 48 8b 84 24 08 04 00 00      	movq	1032(%rsp), %rax
   1ef99: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1efa2: 75 2d                        	jne	0x1efd1 <emit_debug.part.0+0x131>
   1efa4: 48 81 c4 10 04 00 00         	addq	$1040, %rsp             # imm = 0x410
   1efab: 5b                           	popq	%rbx
   1efac: 5d                           	popq	%rbp
   1efad: 41 5c                        	popq	%r12
   1efaf: 41 5d                        	popq	%r13
   1efb1: 41 5e                        	popq	%r14
   1efb3: c3                           	retq
   1efb4: 0f 1f 40 00                  	nopl	(%rax)
;   return __builtin___strcat_chk (__dest, __src, __glibc_objsize (__dest));
   1efb8: ba 00 04 00 00               	movl	$1024, %edx             # imm = 0x400
   1efbd: 48 8d 35 3c a2 01 00         	leaq	107068(%rip), %rsi      # 0x39200 <strs.2+0x6370>
   1efc4: 4c 89 f7                     	movq	%r14, %rdi
   1efc7: e8 a4 66 fe ff               	callq	0x5670 <.plt.sec>
   1efcc: e9 2a ff ff ff               	jmp	0x1eefb <emit_debug.part.0+0x5b>
; }
   1efd1: e8 2a 68 fe ff               	callq	0x5800 <.plt.sec+0x190>
   1efd6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000001efe0 <debug_regs>:
; {
   1efe0: 48 81 ec d8 00 00 00         	subq	$216, %rsp
   1efe7: 4c 89 44 24 40               	movq	%r8, 64(%rsp)
   1efec: 4c 89 4c 24 48               	movq	%r9, 72(%rsp)
   1eff1: 84 c0                        	testb	%al, %al
   1eff3: 74 37                        	je	0x1f02c <debug_regs+0x4c>
   1eff5: 0f 29 44 24 50               	movaps	%xmm0, 80(%rsp)
   1effa: 0f 29 4c 24 60               	movaps	%xmm1, 96(%rsp)
   1efff: 0f 29 54 24 70               	movaps	%xmm2, 112(%rsp)
   1f004: 0f 29 9c 24 80 00 00 00      	movaps	%xmm3, 128(%rsp)
   1f00c: 0f 29 a4 24 90 00 00 00      	movaps	%xmm4, 144(%rsp)
   1f014: 0f 29 ac 24 a0 00 00 00      	movaps	%xmm5, 160(%rsp)
   1f01c: 0f 29 b4 24 b0 00 00 00      	movaps	%xmm6, 176(%rsp)
   1f024: 0f 29 bc 24 c0 00 00 00      	movaps	%xmm7, 192(%rsp)
   1f02c: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1f035: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1f03a: 31 c0                        	xorl	%eax, %eax
; 	va_start(args, fmt);
   1f03c: 48 8d 84 24 e0 00 00 00      	leaq	224(%rsp), %rax
   1f044: c7 04 24 20 00 00 00         	movl	$32, (%rsp)
   1f04b: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   1f050: 48 8d 44 24 20               	leaq	32(%rsp), %rax
   1f055: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	if (!gen->log_level)
   1f05a: 8b 47 38                     	movl	56(%rdi), %eax
; 	va_start(args, fmt);
   1f05d: c7 44 24 04 30 00 00 00      	movl	$48, 4(%rsp)
; 	if (!gen->log_level)
   1f065: 85 c0                        	testl	%eax, %eax
   1f067: 74 08                        	je	0x1f071 <debug_regs+0x91>
   1f069: 49 89 e0                     	movq	%rsp, %r8
   1f06c: e8 2f fe ff ff               	callq	0x1eea0 <emit_debug.part.0>
; }
   1f071: 48 8b 44 24 18               	movq	24(%rsp), %rax
   1f076: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1f07f: 75 08                        	jne	0x1f089 <debug_regs+0xa9>
   1f081: 48 81 c4 d8 00 00 00         	addq	$216, %rsp
   1f088: c3                           	retq
   1f089: e8 72 67 fe ff               	callq	0x5800 <.plt.sec+0x190>
   1f08e: 66 90                        	nop

000000000001f090 <debug_ret>:
; {
   1f090: 48 81 ec d8 00 00 00         	subq	$216, %rsp
   1f097: 48 89 54 24 30               	movq	%rdx, 48(%rsp)
   1f09c: 48 89 4c 24 38               	movq	%rcx, 56(%rsp)
   1f0a1: 4c 89 44 24 40               	movq	%r8, 64(%rsp)
   1f0a6: 4c 89 4c 24 48               	movq	%r9, 72(%rsp)
   1f0ab: 84 c0                        	testb	%al, %al
   1f0ad: 74 37                        	je	0x1f0e6 <debug_ret+0x56>
   1f0af: 0f 29 44 24 50               	movaps	%xmm0, 80(%rsp)
   1f0b4: 0f 29 4c 24 60               	movaps	%xmm1, 96(%rsp)
   1f0b9: 0f 29 54 24 70               	movaps	%xmm2, 112(%rsp)
   1f0be: 0f 29 9c 24 80 00 00 00      	movaps	%xmm3, 128(%rsp)
   1f0c6: 0f 29 a4 24 90 00 00 00      	movaps	%xmm4, 144(%rsp)
   1f0ce: 0f 29 ac 24 a0 00 00 00      	movaps	%xmm5, 160(%rsp)
   1f0d6: 0f 29 b4 24 b0 00 00 00      	movaps	%xmm6, 176(%rsp)
   1f0de: 0f 29 bc 24 c0 00 00 00      	movaps	%xmm7, 192(%rsp)
   1f0e6: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1f0ef: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1f0f4: 31 c0                        	xorl	%eax, %eax
; 	va_start(args, fmt);
   1f0f6: 48 8d 84 24 e0 00 00 00      	leaq	224(%rsp), %rax
   1f0fe: c7 04 24 10 00 00 00         	movl	$16, (%rsp)
   1f105: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   1f10a: 48 8d 44 24 20               	leaq	32(%rsp), %rax
   1f10f: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	if (!gen->log_level)
   1f114: 8b 47 38                     	movl	56(%rdi), %eax
; 	va_start(args, fmt);
   1f117: c7 44 24 04 30 00 00 00      	movl	$48, 4(%rsp)
; 	if (!gen->log_level)
   1f11f: 85 c0                        	testl	%eax, %eax
   1f121: 74 15                        	je	0x1f138 <debug_ret+0xa8>
   1f123: 48 89 f1                     	movq	%rsi, %rcx
   1f126: 49 89 e0                     	movq	%rsp, %r8
   1f129: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
   1f12e: be 07 00 00 00               	movl	$7, %esi
   1f133: e8 68 fd ff ff               	callq	0x1eea0 <emit_debug.part.0>
; }
   1f138: 48 8b 44 24 18               	movq	24(%rsp), %rax
   1f13d: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1f146: 75 08                        	jne	0x1f150 <debug_ret+0xc0>
   1f148: 48 81 c4 d8 00 00 00         	addq	$216, %rsp
   1f14f: c3                           	retq
   1f150: e8 ab 66 fe ff               	callq	0x5800 <.plt.sec+0x190>
   1f155: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

000000000001f160 <__emit_sys_close>:
; {
   1f160: 55                           	pushq	%rbp
; 	emit(gen, BPF_JMP_IMM(BPF_JSLE, BPF_REG_1, 0,
   1f161: 83 7f 38 01                  	cmpl	$1, 56(%rdi)
; {
   1f165: 48 89 fd                     	movq	%rdi, %rbp
; 	emit(gen, BPF_JMP_IMM(BPF_JSLE, BPF_REG_1, 0,
   1f168: 19 f6                        	sbbl	%esi, %esi
   1f16a: 83 e6 fa                     	andl	$-6, %esi
   1f16d: 83 c6 08                     	addl	$8, %esi
   1f170: 0f b7 f6                     	movzwl	%si, %esi
   1f173: 48 c1 e6 10                  	shlq	$16, %rsi
   1f177: 48 81 ce d5 01 00 00         	orq	$469, %rsi              # imm = 0x1D5
   1f17e: e8 9d fa ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_REG(BPF_REG_9, BPF_REG_1));
   1f183: 48 89 ef                     	movq	%rbp, %rdi
   1f186: be bf 19 00 00               	movl	$6591, %esi             # imm = 0x19BF
   1f18b: e8 90 fa ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_sys_close));
   1f190: 48 89 ef                     	movq	%rbp, %rdi
   1f193: 48 be 85 00 00 00 a8 00 00 00	movabsq	$721554505861, %rsi     # imm = 0xA800000085
   1f19d: e8 7e fa ff ff               	callq	0x1ec20 <emit>
; 	debug_regs(gen, BPF_REG_9, BPF_REG_0, "close(%%d) = %%d");
   1f1a2: 48 89 ef                     	movq	%rbp, %rdi
   1f1a5: 48 8d 0d 5a a0 01 00         	leaq	106586(%rip), %rcx      # 0x39206 <strs.2+0x6376>
; }
   1f1ac: 5d                           	popq	%rbp
; 	debug_regs(gen, BPF_REG_9, BPF_REG_0, "close(%%d) = %%d");
   1f1ad: 31 d2                        	xorl	%edx, %edx
   1f1af: be 09 00 00 00               	movl	$9, %esi
   1f1b4: 31 c0                        	xorl	%eax, %eax
   1f1b6: e9 25 fe ff ff               	jmp	0x1efe0 <debug_regs>
   1f1bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000001f1c0 <emit_sys_close_blob>:
; {
   1f1c0: 41 54                        	pushq	%r12
   1f1c2: 49 89 f4                     	movq	%rsi, %r12
; 	emit(gen, insn1);
   1f1c5: be 18 60 00 00               	movl	$24600, %esi            # imm = 0x6018
; {
   1f1ca: 55                           	pushq	%rbp
   1f1cb: 49 c1 e4 20                  	shlq	$32, %r12
   1f1cf: 48 89 fd                     	movq	%rdi, %rbp
   1f1d2: 48 83 ec 08                  	subq	$8, %rsp
; 	emit(gen, insn1);
   1f1d6: e8 45 fa ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   1f1db: 4c 89 e6                     	movq	%r12, %rsi
   1f1de: 48 89 ef                     	movq	%rbp, %rdi
   1f1e1: e8 3a fa ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_0, 0));
   1f1e6: 48 89 ef                     	movq	%rbp, %rdi
   1f1e9: be 61 01 00 00               	movl	$353, %esi              # imm = 0x161
   1f1ee: e8 2d fa ff ff               	callq	0x1ec20 <emit>
; }
   1f1f3: 48 83 c4 08                  	addq	$8, %rsp
; 	__emit_sys_close(gen);
   1f1f7: 48 89 ef                     	movq	%rbp, %rdi
; }
   1f1fa: 5d                           	popq	%rbp
   1f1fb: 41 5c                        	popq	%r12
; 	__emit_sys_close(gen);
   1f1fd: e9 5e ff ff ff               	jmp	0x1f160 <__emit_sys_close>
   1f202: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1f20d: 0f 1f 00                     	nopl	(%rax)

000000000001f210 <emit_ksym_relo_log.part.0>:
; static void emit_ksym_relo_log(struct bpf_gen *gen, struct ksym_relo_desc *relo,
   1f210: 41 54                        	pushq	%r12
   1f212: 41 89 d4                     	movl	%edx, %r12d
   1f215: 55                           	pushq	%rbp
   1f216: 48 89 fd                     	movq	%rdi, %rbp
   1f219: 53                           	pushq	%rbx
   1f21a: 48 89 f3                     	movq	%rsi, %rbx
; 	emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_8,
   1f21d: be 61 87 04 00               	movl	$296801, %esi           # imm = 0x48761
   1f222: e8 f9 f9 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(BPF_H, BPF_REG_9, BPF_REG_8, sizeof(struct bpf_insn) +
   1f227: 48 89 ef                     	movq	%rbp, %rdi
   1f22a: be 69 89 0c 00               	movl	$821609, %esi           # imm = 0xC8969
   1f22f: e8 ec f9 ff ff               	callq	0x1ec20 <emit>
; 	debug_regs(gen, BPF_REG_7, BPF_REG_9, " var t=%d w=%d (%s:count=%d): imm[0]: %%d, imm[1]: %%d",
   1f234: 41 54                        	pushq	%r12
   1f236: 44 0f b6 4b 10               	movzbl	16(%rbx), %r9d
   1f23b: 48 89 ef                     	movq	%rbp, %rdi
   1f23e: ff 33                        	pushq	(%rbx)
   1f240: 44 0f b6 43 11               	movzbl	17(%rbx), %r8d
   1f245: 48 8d 0d 6c a0 01 00         	leaq	106604(%rip), %rcx      # 0x392b8 <strs.2+0x6428>
   1f24c: 31 c0                        	xorl	%eax, %eax
   1f24e: ba 09 00 00 00               	movl	$9, %edx
   1f253: be 07 00 00 00               	movl	$7, %esi
   1f258: e8 83 fd ff ff               	callq	0x1efe0 <debug_regs>
; 	emit(gen, BPF_LDX_MEM(BPF_B, BPF_REG_9, BPF_REG_8, offsetofend(struct bpf_insn, code)));
   1f25d: 48 89 ef                     	movq	%rbp, %rdi
   1f260: be 71 89 01 00               	movl	$100721, %esi           # imm = 0x18971
   1f265: e8 b6 f9 ff ff               	callq	0x1ec20 <emit>
; 	debug_regs(gen, BPF_REG_9, -1, " var t=%d w=%d (%s:count=%d): insn.reg",
   1f26a: 41 54                        	pushq	%r12
   1f26c: 44 0f b6 4b 10               	movzbl	16(%rbx), %r9d
   1f271: 48 89 ef                     	movq	%rbp, %rdi
   1f274: ff 33                        	pushq	(%rbx)
   1f276: 44 0f b6 43 11               	movzbl	17(%rbx), %r8d
   1f27b: 48 8d 0d 6e a0 01 00         	leaq	106606(%rip), %rcx      # 0x392f0 <strs.2+0x6460>
   1f282: 31 c0                        	xorl	%eax, %eax
   1f284: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
   1f289: be 09 00 00 00               	movl	$9, %esi
   1f28e: e8 4d fd ff ff               	callq	0x1efe0 <debug_regs>
   1f293: 48 83 c4 20                  	addq	$32, %rsp
; }
   1f297: 5b                           	popq	%rbx
   1f298: 5d                           	popq	%rbp
   1f299: 41 5c                        	popq	%r12
   1f29b: c3                           	retq
   1f29c: 0f 1f 40 00                  	nopl	(%rax)

000000000001f2a0 <emit_bpf_find_by_name_kind>:
; {
   1f2a0: 41 55                        	pushq	%r13
   1f2a2: 41 54                        	pushq	%r12
   1f2a4: 49 89 f4                     	movq	%rsi, %r12
   1f2a7: 55                           	pushq	%rbp
   1f2a8: 48 89 fd                     	movq	%rdi, %rbp
   1f2ab: 53                           	pushq	%rbx
   1f2ac: 48 83 ec 08                  	subq	$8, %rsp
; 	int name_off, len = strlen(relo->name) + 1;
   1f2b0: 4c 8b 2e                     	movq	(%rsi), %r13
   1f2b3: 4c 89 ef                     	movq	%r13, %rdi
   1f2b6: e8 25 65 fe ff               	callq	0x57e0 <.plt.sec+0x170>
; 	name_off = add_data(gen, relo->name, len);
   1f2bb: 4c 89 ee                     	movq	%r13, %rsi
   1f2be: 48 89 ef                     	movq	%rbp, %rdi
; 	int name_off, len = strlen(relo->name) + 1;
   1f2c1: 8d 58 01                     	leal	1(%rax), %ebx
; 	name_off = add_data(gen, relo->name, len);
   1f2c4: 89 da                        	movl	%ebx, %edx
   1f2c6: e8 25 f7 ff ff               	callq	0x1e9f0 <add_data>
; 	emit(gen, insn1);
   1f2cb: 48 89 ef                     	movq	%rbp, %rdi
   1f2ce: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   1f2d3: 49 89 c5                     	movq	%rax, %r13
   1f2d6: e8 45 f9 ff ff               	callq	0x1ec20 <emit>
   1f2db: 49 c1 e5 20                  	shlq	$32, %r13
; 	emit(gen, insn2);
   1f2df: 48 89 ef                     	movq	%rbp, %rdi
   1f2e2: 4c 89 ee                     	movq	%r13, %rsi
   1f2e5: e8 36 f9 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_2, len));
   1f2ea: 48 89 de                     	movq	%rbx, %rsi
   1f2ed: 48 89 ef                     	movq	%rbp, %rdi
   1f2f0: 48 c1 e6 20                  	shlq	$32, %rsi
   1f2f4: 48 81 ce b7 02 00 00         	orq	$695, %rsi              # imm = 0x2B7
   1f2fb: e8 20 f9 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_3, relo->kind));
   1f300: 41 8b 74 24 08               	movl	8(%r12), %esi
   1f305: 48 89 ef                     	movq	%rbp, %rdi
   1f308: 48 c1 e6 20                  	shlq	$32, %rsi
   1f30c: 48 81 ce b7 03 00 00         	orq	$951, %rsi              # imm = 0x3B7
   1f313: e8 08 f9 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_4, 0));
   1f318: 48 89 ef                     	movq	%rbp, %rdi
   1f31b: be b7 04 00 00               	movl	$1207, %esi             # imm = 0x4B7
   1f320: e8 fb f8 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_btf_find_by_name_kind));
   1f325: 48 89 ef                     	movq	%rbp, %rdi
   1f328: 48 be 85 00 00 00 a7 00 00 00	movabsq	$717259538565, %rsi     # imm = 0xA700000085
   1f332: e8 e9 f8 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_REG(BPF_REG_7, BPF_REG_0));
   1f337: 48 89 ef                     	movq	%rbp, %rdi
   1f33a: be bf 07 00 00               	movl	$1983, %esi             # imm = 0x7BF
   1f33f: e8 dc f8 ff ff               	callq	0x1ec20 <emit>
; 	debug_ret(gen, "find_by_name_kind(%s,%d)", relo->name, relo->kind);
   1f344: 41 8b 4c 24 08               	movl	8(%r12), %ecx
   1f349: 49 8b 14 24                  	movq	(%r12), %rdx
   1f34d: 31 c0                        	xorl	%eax, %eax
; }
   1f34f: 48 83 c4 08                  	addq	$8, %rsp
; 	debug_ret(gen, "find_by_name_kind(%s,%d)", relo->name, relo->kind);
   1f353: 48 89 ef                     	movq	%rbp, %rdi
   1f356: 48 8d 35 ba 9e 01 00         	leaq	106170(%rip), %rsi      # 0x39217 <strs.2+0x6387>
; }
   1f35d: 5b                           	popq	%rbx
   1f35e: 5d                           	popq	%rbp
   1f35f: 41 5c                        	popq	%r12
   1f361: 41 5d                        	popq	%r13
; 	debug_ret(gen, "find_by_name_kind(%s,%d)", relo->name, relo->kind);
   1f363: e9 28 fd ff ff               	jmp	0x1f090 <debug_ret>
   1f368: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000001f370 <move_stack2blob.constprop.0>:
; static void move_stack2blob(struct bpf_gen *gen, int off, int size, int stack_off)
   1f370: 55                           	pushq	%rbp
   1f371: 48 89 fd                     	movq	%rdi, %rbp
   1f374: 53                           	pushq	%rbx
   1f375: 89 f3                        	movl	%esi, %ebx
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f377: 0f b7 f2                     	movzwl	%dx, %esi
   1f37a: 48 c1 e6 10                  	shlq	$16, %rsi
   1f37e: 48 c1 e3 20                  	shlq	$32, %rbx
   1f382: 48 81 ce 61 a0 00 00         	orq	$41057, %rsi            # imm = 0xA061
; static void move_stack2blob(struct bpf_gen *gen, int off, int size, int stack_off)
   1f389: 48 83 ec 08                  	subq	$8, %rsp
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f38d: e8 8e f8 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn1);
   1f392: 48 89 ef                     	movq	%rbp, %rdi
   1f395: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   1f39a: e8 81 f8 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   1f39f: 48 89 de                     	movq	%rbx, %rsi
   1f3a2: 48 89 ef                     	movq	%rbp, %rdi
   1f3a5: e8 76 f8 ff ff               	callq	0x1ec20 <emit>
; }
   1f3aa: 48 83 c4 08                  	addq	$8, %rsp
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_1, BPF_REG_0, 0));
   1f3ae: 48 89 ef                     	movq	%rbp, %rdi
   1f3b1: be 63 01 00 00               	movl	$355, %esi              # imm = 0x163
; }
   1f3b6: 5b                           	popq	%rbx
   1f3b7: 5d                           	popq	%rbp
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_1, BPF_REG_0, 0));
   1f3b8: e9 63 f8 ff ff               	jmp	0x1ec20 <emit>
   1f3bd: 0f 1f 00                     	nopl	(%rax)

000000000001f3c0 <emit_check_err>:
; 	__s64 off = -(gen->insn_cur - gen->insn_start - gen->cleanup_label) / 8 - 1;
   1f3c0: 48 8b 47 28                  	movq	40(%rdi), %rax
   1f3c4: 48 8b 57 20                  	movq	32(%rdi), %rdx
   1f3c8: 48 2b 57 18                  	subq	24(%rdi), %rdx
   1f3cc: 48 29 d0                     	subq	%rdx, %rax
   1f3cf: 48 8d 70 07                  	leaq	7(%rax), %rsi
   1f3d3: 48 0f 49 f0                  	cmovnsq	%rax, %rsi
   1f3d7: 48 c1 fe 03                  	sarq	$3, %rsi
   1f3db: 48 83 ee 01                  	subq	$1, %rsi
; 	return value == (__s64)(__s16)value;
   1f3df: 48 0f bf c6                  	movswq	%si, %rax
; 	if (is_simm16(off)) {
   1f3e3: 48 39 c6                     	cmpq	%rax, %rsi
   1f3e6: 74 08                        	je	0x1f3f0 <emit_check_err+0x30>
; 		gen->error = -ERANGE;
   1f3e8: c7 47 3c de ff ff ff         	movl	$4294967262, 60(%rdi)   # imm = 0xFFFFFFDE
; }
   1f3ef: c3                           	retq
; 		emit(gen, BPF_JMP_IMM(BPF_JSLT, BPF_REG_7, 0, off));
   1f3f0: 0f b7 f6                     	movzwl	%si, %esi
   1f3f3: 48 c1 e6 10                  	shlq	$16, %rsi
   1f3f7: 48 81 ce c5 07 00 00         	orq	$1989, %rsi             # imm = 0x7C5
   1f3fe: e9 1d f8 ff ff               	jmp	0x1ec20 <emit>
   1f403: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1f40e: 66 90                        	nop

000000000001f410 <bpf_gen__init>:
; {
   1f410: f3 0f 1e fa                  	endbr64
   1f414: 41 57                        	pushq	%r15
   1f416: 41 56                        	pushq	%r14
   1f418: 41 55                        	pushq	%r13
   1f41a: 41 89 f5                     	movl	%esi, %r13d
; 	gen->fd_array = add_data(gen, NULL, MAX_FD_ARRAY_SZ * sizeof(int));
   1f41d: 31 f6                        	xorl	%esi, %esi
; {
   1f41f: 41 54                        	pushq	%r12
   1f421: 41 89 d4                     	movl	%edx, %r12d
; 	gen->fd_array = add_data(gen, NULL, MAX_FD_ARRAY_SZ * sizeof(int));
   1f424: ba 00 05 00 00               	movl	$1280, %edx             # imm = 0x500
; {
   1f429: 55                           	pushq	%rbp
   1f42a: 48 89 fd                     	movq	%rdi, %rbp
   1f42d: 53                           	pushq	%rbx
   1f42e: 89 cb                        	movl	%ecx, %ebx
   1f430: 48 83 ec 08                  	subq	$8, %rsp
; 	gen->fd_array = add_data(gen, NULL, MAX_FD_ARRAY_SZ * sizeof(int));
   1f434: e8 b7 f5 ff ff               	callq	0x1e9f0 <add_data>
; 	gen->log_level = log_level;
   1f439: 44 89 6d 38                  	movl	%r13d, 56(%rbp)
; 	emit(gen, BPF_MOV64_REG(BPF_REG_6, BPF_REG_1));
   1f43d: be bf 16 00 00               	movl	$5823, %esi             # imm = 0x16BF
   1f442: 48 89 ef                     	movq	%rbp, %rdi
; 	gen->fd_array = add_data(gen, NULL, MAX_FD_ARRAY_SZ * sizeof(int));
   1f445: 89 85 ec 00 00 00            	movl	%eax, 236(%rbp)
; 	emit(gen, BPF_MOV64_REG(BPF_REG_6, BPF_REG_1));
   1f44b: e8 d0 f7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_REG(BPF_REG_1, BPF_REG_10));
   1f450: be bf a1 00 00               	movl	$41407, %esi            # imm = 0xA1BF
   1f455: 48 89 ef                     	movq	%rbp, %rdi
   1f458: e8 c3 f7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -stack_sz));
   1f45d: 48 89 ef                     	movq	%rbp, %rdi
   1f460: 48 be 07 01 00 00 78 ff ff ff	movabsq	$-584115551993, %rsi    # imm = 0xFFFFFF7800000107
   1f46a: e8 b1 f7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_2, stack_sz));
   1f46f: 48 89 ef                     	movq	%rbp, %rdi
   1f472: 48 be b7 02 00 00 88 00 00 00	movabsq	$584115552951, %rsi     # imm = 0x88000002B7
   1f47c: e8 9f f7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_3, 0));
   1f481: be b7 03 00 00               	movl	$951, %esi              # imm = 0x3B7
   1f486: 48 89 ef                     	movq	%rbp, %rdi
   1f489: e8 92 f7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_probe_read_kernel));
   1f48e: 48 89 ef                     	movq	%rbp, %rdi
   1f491: 48 be 85 00 00 00 71 00 00 00	movabsq	$485331304581, %rsi     # imm = 0x7100000085
   1f49b: e8 80 f7 ff ff               	callq	0x1ec20 <emit>
; 	nr_progs_sz = offsetof(struct loader_stack, prog_fd[nr_progs]);
   1f4a0: 49 63 d4                     	movslq	%r12d, %rdx
; 	emit(gen, BPF_JMP_IMM(BPF_JA, 0, 0,
   1f4a3: 48 89 ef                     	movq	%rbp, %rdi
; 	nr_progs_sz = offsetof(struct loader_stack, prog_fd[nr_progs]);
   1f4a6: 48 83 c2 02                  	addq	$2, %rdx
; 	emit(gen, BPF_JMP_IMM(BPF_JA, 0, 0,
   1f4aa: 83 7d 38 01                  	cmpl	$1, 56(%rbp)
   1f4ae: 19 c0                        	sbbl	%eax, %eax
; 	nr_progs_sz = offsetof(struct loader_stack, prog_fd[nr_progs]);
   1f4b0: 4c 8d 24 95 00 00 00 00      	leaq	(,%rdx,4), %r12
; 	emit(gen, BPF_JMP_IMM(BPF_JA, 0, 0,
   1f4b8: 8d 54 52 02                  	leal	2(%rdx,%rdx,2), %edx
   1f4bc: 83 e0 fa                     	andl	$-6, %eax
   1f4bf: 83 c0 0c                     	addl	$12, %eax
   1f4c2: 0f af c3                     	imull	%ebx, %eax
   1f4c5: 8d 34 10                     	leal	(%rax,%rdx), %esi
   1f4c8: 0f b7 f6                     	movzwl	%si, %esi
   1f4cb: 48 c1 e6 10                  	shlq	$16, %rsi
   1f4cf: 48 83 ce 05                  	orq	$5, %rsi
   1f4d3: e8 48 f7 ff ff               	callq	0x1ec20 <emit>
; 	gen->cleanup_label = gen->insn_cur - gen->insn_start;
   1f4d8: 48 8b 45 20                  	movq	32(%rbp), %rax
   1f4dc: 48 2b 45 18                  	subq	24(%rbp), %rax
   1f4e0: 48 89 45 28                  	movq	%rax, 40(%rbp)
; 	for (i = 0; i < nr_progs_sz; i += 4) {
   1f4e4: 4d 85 e4                     	testq	%r12, %r12
   1f4e7: 74 5a                        	je	0x1f543 <bpf_gen__init+0x133>
   1f4e9: 49 bd ff ff 00 00 ff ff ff ff	movabsq	$-4294901761, %r13      # imm = 0xFFFFFFFF0000FFFF
   1f4f3: 45 31 ff                     	xorl	%r15d, %r15d
; 		emit(gen, BPF_EMIT_CALL(BPF_FUNC_sys_close));
   1f4f6: 49 be 85 00 00 00 a8 00 00 00	movabsq	$721554505861, %r14     # imm = 0xA800000085
; 		emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_10, -stack_sz + i));
   1f500: 41 8d 87 78 ff ff ff         	leal	-136(%r15), %eax
   1f507: 4c 89 ee                     	movq	%r13, %rsi
   1f50a: 48 89 ef                     	movq	%rbp, %rdi
; 	for (i = 0; i < nr_progs_sz; i += 4) {
   1f50d: 49 83 c7 04                  	addq	$4, %r15
; 		emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_10, -stack_sz + i));
   1f511: 0f b7 c0                     	movzwl	%ax, %eax
   1f514: 81 e6 61 a1 00 00            	andl	$41313, %esi            # imm = 0xA161
   1f51a: 48 c1 e0 10                  	shlq	$16, %rax
   1f51e: 48 09 c6                     	orq	%rax, %rsi
   1f521: e8 fa f6 ff ff               	callq	0x1ec20 <emit>
; 		emit(gen, BPF_JMP_IMM(BPF_JSLE, BPF_REG_1, 0, 1));
   1f526: be d5 01 01 00               	movl	$66005, %esi            # imm = 0x101D5
   1f52b: 48 89 ef                     	movq	%rbp, %rdi
   1f52e: e8 ed f6 ff ff               	callq	0x1ec20 <emit>
; 		emit(gen, BPF_EMIT_CALL(BPF_FUNC_sys_close));
   1f533: 4c 89 f6                     	movq	%r14, %rsi
   1f536: 48 89 ef                     	movq	%rbp, %rdi
   1f539: e8 e2 f6 ff ff               	callq	0x1ec20 <emit>
; 	for (i = 0; i < nr_progs_sz; i += 4) {
   1f53e: 4d 39 fc                     	cmpq	%r15, %r12
   1f541: 77 bd                        	ja	0x1f500 <bpf_gen__init+0xf0>
; 	for (i = 0; i < nr_maps; i++)
   1f543: 85 db                        	testl	%ebx, %ebx
   1f545: 7e 24                        	jle	0x1f56b <bpf_gen__init+0x15b>
   1f547: 45 31 e4                     	xorl	%r12d, %r12d
   1f54a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return gen->fd_array + index * sizeof(int);
   1f550: 8b 85 ec 00 00 00            	movl	236(%rbp), %eax
; 		emit_sys_close_blob(gen, blob_fd_array_off(gen, i));
   1f556: 48 89 ef                     	movq	%rbp, %rdi
; 	return gen->fd_array + index * sizeof(int);
   1f559: 42 8d 34 a0                  	leal	(%rax,%r12,4), %esi
; 	for (i = 0; i < nr_maps; i++)
   1f55d: 41 83 c4 01                  	addl	$1, %r12d
; 		emit_sys_close_blob(gen, blob_fd_array_off(gen, i));
   1f561: e8 5a fc ff ff               	callq	0x1f1c0 <emit_sys_close_blob>
; 	for (i = 0; i < nr_maps; i++)
   1f566: 44 39 e3                     	cmpl	%r12d, %ebx
   1f569: 75 e5                        	jne	0x1f550 <bpf_gen__init+0x140>
; 	emit(gen, BPF_MOV64_REG(BPF_REG_0, BPF_REG_7));
   1f56b: 48 89 ef                     	movq	%rbp, %rdi
   1f56e: be bf 70 00 00               	movl	$28863, %esi            # imm = 0x70BF
   1f573: e8 a8 f6 ff ff               	callq	0x1ec20 <emit>
; }
   1f578: 48 83 c4 08                  	addq	$8, %rsp
; 	emit(gen, BPF_EXIT_INSN());
   1f57c: 48 89 ef                     	movq	%rbp, %rdi
   1f57f: be 95 00 00 00               	movl	$149, %esi
; }
   1f584: 5b                           	popq	%rbx
   1f585: 5d                           	popq	%rbp
   1f586: 41 5c                        	popq	%r12
   1f588: 41 5d                        	popq	%r13
   1f58a: 41 5e                        	popq	%r14
   1f58c: 41 5f                        	popq	%r15
; 	emit(gen, BPF_EXIT_INSN());
   1f58e: e9 8d f6 ff ff               	jmp	0x1ec20 <emit>
   1f593: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1f59e: 66 90                        	nop

000000000001f5a0 <bpf_gen__finish>:
; {
   1f5a0: f3 0f 1e fa                  	endbr64
   1f5a4: 41 55                        	pushq	%r13
   1f5a6: 41 54                        	pushq	%r12
   1f5a8: 55                           	pushq	%rbp
   1f5a9: 53                           	pushq	%rbx
   1f5aa: 48 89 fb                     	movq	%rdi, %rbx
   1f5ad: 48 83 ec 08                  	subq	$8, %rsp
; 	if (nr_progs < gen->nr_progs || nr_maps != gen->nr_maps) {
   1f5b1: 8b 4f 30                     	movl	48(%rdi), %ecx
   1f5b4: 44 8b 4f 34                  	movl	52(%rdi), %r9d
   1f5b8: 39 f1                        	cmpl	%esi, %ecx
   1f5ba: 0f 87 6a 01 00 00            	ja	0x1f72a <bpf_gen__finish+0x18a>
   1f5c0: 44 39 ca                     	cmpl	%r9d, %edx
   1f5c3: 0f 85 61 01 00 00            	jne	0x1f72a <bpf_gen__finish+0x18a>
; 	emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_10, stack_off));
   1f5c9: be 61 a1 78 ff               	movl	$4286095713, %esi       # imm = 0xFF78A161
; 	for (i = 0; i < gen->nr_progs; i++)
   1f5ce: 45 31 ed                     	xorl	%r13d, %r13d
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f5d1: 49 bc ff ff 00 00 ff ff ff ff	movabsq	$-4294901761, %r12      # imm = 0xFFFFFFFF0000FFFF
; 	emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_10, stack_off));
   1f5db: e8 40 f6 ff ff               	callq	0x1ec20 <emit>
; 	__emit_sys_close(gen);
   1f5e0: 48 89 df                     	movq	%rbx, %rdi
   1f5e3: e8 78 fb ff ff               	callq	0x1f160 <__emit_sys_close>
; 	for (i = 0; i < gen->nr_progs; i++)
   1f5e8: 8b 53 30                     	movl	48(%rbx), %edx
   1f5eb: 85 d2                        	testl	%edx, %edx
   1f5ed: 74 54                        	je	0x1f643 <bpf_gen__finish+0xa3>
   1f5ef: 90                           	nop
; 			       sizeof(struct bpf_map_desc) * gen->nr_maps +
   1f5f0: 8b 43 34                     	movl	52(%rbx), %eax
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f5f3: 4c 89 e6                     	movq	%r12, %rsi
   1f5f6: 48 89 df                     	movq	%rbx, %rdi
   1f5f9: 81 e6 61 a0 00 00            	andl	$41057, %esi            # imm = 0xA061
; 			       sizeof(struct bpf_map_desc) * gen->nr_maps +
   1f5ff: 49 8d 6c 85 06               	leaq	6(%r13,%rax,4), %rbp
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f604: 42 8d 04 ad 80 ff ff ff      	leal	-128(,%r13,4), %eax
; 	for (i = 0; i < gen->nr_progs; i++)
   1f60c: 49 83 c5 01                  	addq	$1, %r13
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f610: 0f b7 c0                     	movzwl	%ax, %eax
; 		move_stack2ctx(gen,
   1f613: c1 e5 02                     	shll	$2, %ebp
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f616: 48 c1 e0 10                  	shlq	$16, %rax
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_6, BPF_REG_0, ctx_off));
   1f61a: 0f b7 ed                     	movzwl	%bp, %ebp
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f61d: 48 09 c6                     	orq	%rax, %rsi
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_6, BPF_REG_0, ctx_off));
   1f620: 48 c1 e5 10                  	shlq	$16, %rbp
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_10, stack_off));
   1f624: e8 f7 f5 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_6, BPF_REG_0, ctx_off));
   1f629: 4c 89 e6                     	movq	%r12, %rsi
   1f62c: 48 89 df                     	movq	%rbx, %rdi
   1f62f: 81 e6 63 06 00 00            	andl	$1635, %esi             # imm = 0x663
   1f635: 48 09 ee                     	orq	%rbp, %rsi
   1f638: e8 e3 f5 ff ff               	callq	0x1ec20 <emit>
; 	for (i = 0; i < gen->nr_progs; i++)
   1f63d: 44 39 6b 30                  	cmpl	%r13d, 48(%rbx)
   1f641: 77 ad                        	ja	0x1f5f0 <bpf_gen__finish+0x50>
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_6, BPF_REG_0, ctx_off));
   1f643: 48 bd ff ff 00 00 ff ff ff ff	movabsq	$-4294901761, %rbp      # imm = 0xFFFFFFFF0000FFFF
; 	for (i = 0; i < gen->nr_maps; i++)
   1f64d: 8b 43 34                     	movl	52(%rbx), %eax
   1f650: 45 31 e4                     	xorl	%r12d, %r12d
   1f653: 85 c0                        	testl	%eax, %eax
   1f655: 74 6a                        	je	0x1f6c1 <bpf_gen__finish+0x121>
   1f657: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	return gen->fd_array + index * sizeof(int);
   1f660: 8b 83 ec 00 00 00            	movl	236(%rbx), %eax
; 	emit(gen, insn1);
   1f666: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   1f66b: 48 89 df                     	movq	%rbx, %rdi
   1f66e: 46 8d 2c a0                  	leal	(%rax,%r12,4), %r13d
   1f672: e8 a9 f5 ff ff               	callq	0x1ec20 <emit>
   1f677: 49 c1 e5 20                  	shlq	$32, %r13
; 	emit(gen, insn2);
   1f67b: 48 89 df                     	movq	%rbx, %rdi
   1f67e: 4c 89 ee                     	movq	%r13, %rsi
   1f681: e8 9a f5 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_0, BPF_REG_1, 0));
   1f686: be 61 10 00 00               	movl	$4193, %esi             # imm = 0x1061
   1f68b: 48 89 df                     	movq	%rbx, %rdi
   1f68e: e8 8d f5 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_6, BPF_REG_0, ctx_off));
   1f693: 44 89 e0                     	movl	%r12d, %eax
   1f696: 48 89 ee                     	movq	%rbp, %rsi
   1f699: 48 89 df                     	movq	%rbx, %rdi
   1f69c: c1 e0 04                     	shll	$4, %eax
   1f69f: 81 e6 63 06 00 00            	andl	$1635, %esi             # imm = 0x663
; 	for (i = 0; i < gen->nr_maps; i++)
   1f6a5: 41 83 c4 01                  	addl	$1, %r12d
; 	emit(gen, BPF_STX_MEM(insn_bytes_to_bpf_size(size), BPF_REG_6, BPF_REG_0, ctx_off));
   1f6a9: 83 c0 18                     	addl	$24, %eax
   1f6ac: 0f b7 c0                     	movzwl	%ax, %eax
   1f6af: 48 c1 e0 10                  	shlq	$16, %rax
   1f6b3: 48 09 c6                     	orq	%rax, %rsi
   1f6b6: e8 65 f5 ff ff               	callq	0x1ec20 <emit>
; 	for (i = 0; i < gen->nr_maps; i++)
   1f6bb: 44 39 63 34                  	cmpl	%r12d, 52(%rbx)
   1f6bf: 77 9f                        	ja	0x1f660 <bpf_gen__finish+0xc0>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_0, 0));
   1f6c1: be b7 00 00 00               	movl	$183, %esi
   1f6c6: 48 89 df                     	movq	%rbx, %rdi
   1f6c9: e8 52 f5 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EXIT_INSN());
   1f6ce: be 95 00 00 00               	movl	$149, %esi
   1f6d3: 48 89 df                     	movq	%rbx, %rdi
   1f6d6: e8 45 f5 ff ff               	callq	0x1ec20 <emit>
; 	pr_debug("gen: finish %d\n", gen->error);
   1f6db: 8b 53 3c                     	movl	60(%rbx), %edx
   1f6de: 31 c0                        	xorl	%eax, %eax
   1f6e0: bf 02 00 00 00               	movl	$2, %edi
   1f6e5: 48 8d 35 44 9b 01 00         	leaq	105284(%rip), %rsi      # 0x39230 <strs.2+0x63a0>
   1f6ec: e8 df 89 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (!gen->error) {
   1f6f1: 8b 43 3c                     	movl	60(%rbx), %eax
   1f6f4: 85 c0                        	testl	%eax, %eax
   1f6f6: 75 27                        	jne	0x1f71f <bpf_gen__finish+0x17f>
; 		opts->insns = gen->insn_start;
   1f6f8: 48 8b 73 18                  	movq	24(%rbx), %rsi
; 		opts->insns_sz = gen->insn_cur - gen->insn_start;
   1f6fc: 48 8b 4b 20                  	movq	32(%rbx), %rcx
; 		struct gen_loader_opts *opts = gen->opts;
   1f700: 48 8b 13                     	movq	(%rbx), %rdx
; 		opts->insns_sz = gen->insn_cur - gen->insn_start;
   1f703: 48 29 f1                     	subq	%rsi, %rcx
; 		opts->insns = gen->insn_start;
   1f706: 48 89 72 10                  	movq	%rsi, 16(%rdx)
; 		opts->data = gen->data_start;
   1f70a: 48 8b 73 08                  	movq	8(%rbx), %rsi
; 		opts->insns_sz = gen->insn_cur - gen->insn_start;
   1f70e: 89 4a 1c                     	movl	%ecx, 28(%rdx)
; 		opts->data_sz = gen->data_cur - gen->data_start;
   1f711: 48 8b 4b 10                  	movq	16(%rbx), %rcx
; 		opts->data = gen->data_start;
   1f715: 48 89 72 08                  	movq	%rsi, 8(%rdx)
; 		opts->data_sz = gen->data_cur - gen->data_start;
   1f719: 48 29 f1                     	subq	%rsi, %rcx
   1f71c: 89 4a 18                     	movl	%ecx, 24(%rdx)
; }
   1f71f: 48 83 c4 08                  	addq	$8, %rsp
   1f723: 5b                           	popq	%rbx
   1f724: 5d                           	popq	%rbp
   1f725: 41 5c                        	popq	%r12
   1f727: 41 5d                        	popq	%r13
   1f729: c3                           	retq
; 		pr_warn("nr_progs %d/%d nr_maps %d/%d mismatch\n",
   1f72a: 41 89 d0                     	movl	%edx, %r8d
   1f72d: 31 c0                        	xorl	%eax, %eax
   1f72f: 89 f2                        	movl	%esi, %edx
   1f731: 31 ff                        	xorl	%edi, %edi
   1f733: 48 8d 35 de 9b 01 00         	leaq	105438(%rip), %rsi      # 0x39318 <strs.2+0x6488>
   1f73a: e8 91 89 fe ff               	callq	0x80d0 <libbpf_print>
; 		gen->error = -EFAULT;
   1f73f: c7 43 3c f2 ff ff ff         	movl	$4294967282, 60(%rbx)   # imm = 0xFFFFFFF2
; 		return gen->error;
   1f746: b8 f2 ff ff ff               	movl	$4294967282, %eax       # imm = 0xFFFFFFF2
   1f74b: eb d2                        	jmp	0x1f71f <bpf_gen__finish+0x17f>
   1f74d: 0f 1f 00                     	nopl	(%rax)

000000000001f750 <bpf_gen__free>:
; {
   1f750: f3 0f 1e fa                  	endbr64
; 	if (!gen)
   1f754: 48 85 ff                     	testq	%rdi, %rdi
   1f757: 74 27                        	je	0x1f780 <bpf_gen__free+0x30>
; {
   1f759: 55                           	pushq	%rbp
   1f75a: 48 89 fd                     	movq	%rdi, %rbp
; 	free(gen->data_start);
   1f75d: 48 8b 7f 08                  	movq	8(%rdi), %rdi
   1f761: e8 5a 5f fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(gen->insn_start);
   1f766: 48 8b 7d 18                  	movq	24(%rbp), %rdi
   1f76a: e8 51 5f fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(gen);
   1f76f: 48 89 ef                     	movq	%rbp, %rdi
; }
   1f772: 5d                           	popq	%rbp
; 	free(gen);
   1f773: e9 48 5f fe ff               	jmp	0x56c0 <.plt.sec+0x50>
   1f778: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
   1f780: c3                           	retq
   1f781: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1f78c: 0f 1f 40 00                  	nopl	(%rax)

000000000001f790 <bpf_gen__load_btf>:
; {
   1f790: f3 0f 1e fa                  	endbr64
   1f794: 41 57                        	pushq	%r15
;   return __builtin___memset_chk (__dest, __ch, __len,
   1f796: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   1f79a: 41 56                        	pushq	%r14
   1f79c: 41 55                        	pushq	%r13
   1f79e: 41 89 d5                     	movl	%edx, %r13d
   1f7a1: 41 54                        	pushq	%r12
   1f7a3: 49 89 f4                     	movq	%rsi, %r12
; 	pr_debug("gen: load_btf: size %d\n", btf_raw_size);
   1f7a6: 48 8d 35 9b 9b 01 00         	leaq	105371(%rip), %rsi      # 0x39348 <strs.2+0x64b8>
; {
   1f7ad: 55                           	pushq	%rbp
   1f7ae: 48 89 fd                     	movq	%rdi, %rbp
; 	pr_debug("gen: load_btf: size %d\n", btf_raw_size);
   1f7b1: bf 02 00 00 00               	movl	$2, %edi
; {
   1f7b6: 48 81 ec a0 00 00 00         	subq	$160, %rsp
   1f7bd: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1f7c6: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   1f7ce: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   1f7d0: 49 89 e7                     	movq	%rsp, %r15
   1f7d3: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
   1f7d7: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
   1f7e0: c7 44 24 18 00 00 00 00      	movl	$0, 24(%rsp)
; 	pr_debug("gen: load_btf: size %d\n", btf_raw_size);
   1f7e8: e8 e3 88 fe ff               	callq	0x80d0 <libbpf_print>
; 	btf_data = add_data(gen, btf_raw_data, btf_raw_size);
   1f7ed: 4c 89 e6                     	movq	%r12, %rsi
   1f7f0: 44 89 ea                     	movl	%r13d, %edx
   1f7f3: 48 89 ef                     	movq	%rbp, %rdi
   1f7f6: e8 f5 f1 ff ff               	callq	0x1e9f0 <add_data>
; 	btf_load_attr = add_data(gen, &attr, attr_size);
   1f7fb: ba 1c 00 00 00               	movl	$28, %edx
   1f800: 4c 89 fe                     	movq	%r15, %rsi
   1f803: 48 89 ef                     	movq	%rbp, %rdi
; 	btf_data = add_data(gen, btf_raw_data, btf_raw_size);
   1f806: 41 89 c6                     	movl	%eax, %r14d
; 	attr.btf_size = btf_raw_size;
   1f809: 44 89 6c 24 10               	movl	%r13d, 16(%rsp)
; 	btf_load_attr = add_data(gen, &attr, attr_size);
   1f80e: e8 dd f1 ff ff               	callq	0x1e9f0 <add_data>
; 	move_ctx2blob(gen, attr_field(btf_load_attr, btf_log_level), 4,
   1f813: 45 31 c0                     	xorl	%r8d, %r8d
   1f816: b9 08 00 00 00               	movl	$8, %ecx
   1f81b: 48 89 ef                     	movq	%rbp, %rdi
; 	btf_load_attr = add_data(gen, &attr, attr_size);
   1f81e: 41 89 c4                     	movl	%eax, %r12d
; 	move_ctx2blob(gen, attr_field(btf_load_attr, btf_log_level), 4,
   1f821: 8d 70 18                     	leal	24(%rax), %esi
   1f824: ba 04 00 00 00               	movl	$4, %edx
   1f829: e8 72 f4 ff ff               	callq	0x1eca0 <move_ctx2blob>
; 	move_ctx2blob(gen, attr_field(btf_load_attr, btf_log_size), 4,
   1f82e: 45 31 c0                     	xorl	%r8d, %r8d
   1f831: 41 8d 74 24 14               	leal	20(%r12), %esi
   1f836: 48 89 ef                     	movq	%rbp, %rdi
   1f839: b9 0c 00 00 00               	movl	$12, %ecx
   1f83e: ba 04 00 00 00               	movl	$4, %edx
   1f843: e8 58 f4 ff ff               	callq	0x1eca0 <move_ctx2blob>
; 	move_ctx2blob(gen, attr_field(btf_load_attr, btf_log_buf), 8,
   1f848: 45 31 c0                     	xorl	%r8d, %r8d
   1f84b: b9 10 00 00 00               	movl	$16, %ecx
   1f850: 48 89 ef                     	movq	%rbp, %rdi
   1f853: 41 8d 74 24 08               	leal	8(%r12), %esi
   1f858: ba 08 00 00 00               	movl	$8, %edx
   1f85d: e8 3e f4 ff ff               	callq	0x1eca0 <move_ctx2blob>
; 	emit_rel_store(gen, attr_field(btf_load_attr, btf), btf_data);
   1f862: 44 89 f2                     	movl	%r14d, %edx
   1f865: 44 89 e6                     	movl	%r12d, %esi
   1f868: 48 89 ef                     	movq	%rbp, %rdi
   1f86b: e8 c0 f4 ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_sys_bpf(gen, BPF_BTF_LOAD, btf_load_attr, attr_size);
   1f870: b9 1c 00 00 00               	movl	$28, %ecx
   1f875: 44 89 e2                     	movl	%r12d, %edx
   1f878: 48 89 ef                     	movq	%rbp, %rdi
   1f87b: be 12 00 00 00               	movl	$18, %esi
   1f880: e8 0b f5 ff ff               	callq	0x1ed90 <emit_sys_bpf>
; 	debug_ret(gen, "btf_load size %d", btf_raw_size);
   1f885: 31 c0                        	xorl	%eax, %eax
   1f887: 44 89 ea                     	movl	%r13d, %edx
   1f88a: 48 89 ef                     	movq	%rbp, %rdi
   1f88d: 48 8d 35 b4 99 01 00         	leaq	104884(%rip), %rsi      # 0x39248 <strs.2+0x63b8>
   1f894: e8 f7 f7 ff ff               	callq	0x1f090 <debug_ret>
; 	emit_check_err(gen);
   1f899: 48 89 ef                     	movq	%rbp, %rdi
   1f89c: e8 1f fb ff ff               	callq	0x1f3c0 <emit_check_err>
; 	emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_7, stack_off(btf_fd)));
   1f8a1: be 63 7a 78 ff               	movl	$4286085731, %esi       # imm = 0xFF787A63
   1f8a6: 48 89 ef                     	movq	%rbp, %rdi
   1f8a9: e8 72 f3 ff ff               	callq	0x1ec20 <emit>
; }
   1f8ae: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   1f8b6: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1f8bf: 75 11                        	jne	0x1f8d2 <bpf_gen__load_btf+0x142>
   1f8c1: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
   1f8c8: 5d                           	popq	%rbp
   1f8c9: 41 5c                        	popq	%r12
   1f8cb: 41 5d                        	popq	%r13
   1f8cd: 41 5e                        	popq	%r14
   1f8cf: 41 5f                        	popq	%r15
   1f8d1: c3                           	retq
   1f8d2: e8 29 5f fe ff               	callq	0x5800 <.plt.sec+0x190>
   1f8d7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000001f8e0 <bpf_gen__map_create>:
; {
   1f8e0: f3 0f 1e fa                  	endbr64
   1f8e4: 41 57                        	pushq	%r15
   1f8e6: 41 89 ca                     	movl	%ecx, %r10d
;   return __builtin___memset_chk (__dest, __ch, __len,
   1f8e9: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   1f8ed: 41 56                        	pushq	%r14
   1f8ef: 41 89 f6                     	movl	%esi, %r14d
   1f8f2: 41 55                        	pushq	%r13
   1f8f4: 41 54                        	pushq	%r12
   1f8f6: 55                           	pushq	%rbp
   1f8f7: 48 89 fd                     	movq	%rdi, %rbp
   1f8fa: 53                           	pushq	%rbx
   1f8fb: 44 89 c3                     	movl	%r8d, %ebx
   1f8fe: 48 81 ec b8 00 00 00         	subq	$184, %rsp
   1f905: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1f90e: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
   1f916: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   1f918: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
   1f91d: 4c 8d 6c 24 2c               	leaq	44(%rsp), %r13
; {
   1f922: 48 8b 8c 24 f0 00 00 00      	movq	240(%rsp), %rcx
; 	attr.map_type = map_type;
   1f92a: 89 74 24 10                  	movl	%esi, 16(%rsp)
; {
   1f92e: 44 8b a4 24 f8 00 00 00      	movl	248(%rsp), %r12d
; 	attr.map_flags = map_attr->map_flags;
   1f936: 8b 41 1c                     	movl	28(%rcx), %eax
; 	attr.key_size = key_size;
   1f939: 44 89 54 24 14               	movl	%r10d, 20(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1f93e: 48 c7 44 24 48 00 00 00 00   	movq	$0, 72(%rsp)
; 	attr.map_flags = map_attr->map_flags;
   1f947: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 	attr.map_extra = map_attr->map_extra;
   1f94b: 48 8b 41 20                  	movq	32(%rcx), %rax
; 	attr.value_size = value_size;
   1f94f: 44 89 44 24 18               	movl	%r8d, 24(%rsp)
; 	attr.map_extra = map_attr->map_extra;
   1f954: 48 89 44 24 50               	movq	%rax, 80(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1f959: 0f 11 44 24 28               	movups	%xmm0, 40(%rsp)
   1f95e: 0f 11 44 24 38               	movups	%xmm0, 56(%rsp)
; 	if (map_name)
   1f963: 48 85 d2                     	testq	%rdx, %rdx
   1f966: 74 2c                        	je	0x1f994 <bpf_gen__map_create+0xb4>
   1f968: 48 89 d6                     	movq	%rdx, %rsi
; 	for (i = 0; i < sz && src[i]; i++)
   1f96b: 31 c0                        	xorl	%eax, %eax
   1f96d: 4c 8d 6c 24 2c               	leaq	44(%rsp), %r13
   1f972: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   1f978: 0f b6 14 06                  	movzbl	(%rsi,%rax), %edx
   1f97c: 84 d2                        	testb	%dl, %dl
   1f97e: 74 0f                        	je	0x1f98f <bpf_gen__map_create+0xaf>
; 		dst[i] = src[i];
   1f980: 41 88 54 05 00               	movb	%dl, (%r13,%rax)
; 	for (i = 0; i < sz && src[i]; i++)
   1f985: 48 83 c0 01                  	addq	$1, %rax
   1f989: 48 83 f8 0f                  	cmpq	$15, %rax
   1f98d: 75 e9                        	jne	0x1f978 <bpf_gen__map_create+0x98>
; 	dst[i] = '\0';
   1f98f: c6 44 04 2c 00               	movb	$0, 44(%rsp,%rax)
; 	attr.numa_node = map_attr->numa_node;
   1f994: 8b 41 28                     	movl	40(%rcx), %eax
; 	attr.max_entries = max_entries;
   1f997: 44 89 4c 24 1c               	movl	%r9d, 28(%rsp)
; 	pr_debug("gen: map_create: %s idx %d type %d value_type_id %d\n",
   1f99c: 4c 8d 7c 24 10               	leaq	16(%rsp), %r15
   1f9a1: 45 89 f0                     	movl	%r14d, %r8d
   1f9a4: 44 8b 49 10                  	movl	16(%rcx), %r9d
   1f9a8: 4c 89 ea                     	movq	%r13, %rdx
   1f9ab: bf 02 00 00 00               	movl	$2, %edi
   1f9b0: 48 8d 35 b1 99 01 00         	leaq	104881(%rip), %rsi      # 0x39368 <strs.2+0x64d8>
; 	attr.numa_node = map_attr->numa_node;
   1f9b7: 89 44 24 28                  	movl	%eax, 40(%rsp)
; 	attr.map_ifindex = map_attr->map_ifindex;
   1f9bb: 8b 41 2c                     	movl	44(%rcx), %eax
   1f9be: 89 44 24 3c                  	movl	%eax, 60(%rsp)
; 	attr.btf_key_type_id = map_attr->btf_key_type_id;
   1f9c2: 48 8b 41 0c                  	movq	12(%rcx), %rax
; 	pr_debug("gen: map_create: %s idx %d type %d value_type_id %d\n",
   1f9c6: 44 89 e1                     	movl	%r12d, %ecx
; 	attr.btf_key_type_id = map_attr->btf_key_type_id;
   1f9c9: 48 89 44 24 44               	movq	%rax, 68(%rsp)
; 	pr_debug("gen: map_create: %s idx %d type %d value_type_id %d\n",
   1f9ce: 31 c0                        	xorl	%eax, %eax
   1f9d0: e8 fb 86 fe ff               	callq	0x80d0 <libbpf_print>
; 	map_create_attr = add_data(gen, &attr, attr_size);
   1f9d5: 4c 89 fe                     	movq	%r15, %rsi
   1f9d8: 48 89 ef                     	movq	%rbp, %rdi
   1f9db: ba 48 00 00 00               	movl	$72, %edx
   1f9e0: e8 0b f0 ff ff               	callq	0x1e9f0 <add_data>
; 	if (attr.btf_value_type_id)
   1f9e5: 8b 7c 24 48                  	movl	72(%rsp), %edi
; 	map_create_attr = add_data(gen, &attr, attr_size);
   1f9e9: 41 89 c7                     	movl	%eax, %r15d
; 	if (attr.btf_value_type_id)
   1f9ec: 85 ff                        	testl	%edi, %edi
   1f9ee: 0f 85 7c 01 00 00            	jne	0x1fb70 <bpf_gen__map_create+0x290>
; 	switch (attr.map_type) {
   1f9f4: 8b 44 24 10                  	movl	16(%rsp), %eax
; 	bool close_inner_map_fd = false;
   1f9f8: c6 44 24 0f 00               	movb	$0, 15(%rsp)
; 	switch (attr.map_type) {
   1f9fd: 83 e8 0c                     	subl	$12, %eax
   1fa00: 83 f8 01                     	cmpl	$1, %eax
   1fa03: 0f 86 7f 01 00 00            	jbe	0x1fb88 <bpf_gen__map_create+0x2a8>
; 	if (map_idx >= 0)
   1fa09: 45 85 e4                     	testl	%r12d, %r12d
   1fa0c: 0f 89 8e 00 00 00            	jns	0x1faa0 <bpf_gen__map_create+0x1c0>
; 	emit_sys_bpf(gen, BPF_MAP_CREATE, map_create_attr, attr_size);
   1fa12: 31 f6                        	xorl	%esi, %esi
   1fa14: b9 48 00 00 00               	movl	$72, %ecx
   1fa19: 44 89 fa                     	movl	%r15d, %edx
   1fa1c: 48 89 ef                     	movq	%rbp, %rdi
   1fa1f: e8 6c f3 ff ff               	callq	0x1ed90 <emit_sys_bpf>
; 	debug_ret(gen, "map_create %s idx %d type %d value_size %d value_btf_id %d",
   1fa24: 48 83 ec 08                  	subq	$8, %rsp
   1fa28: 4c 89 ea                     	movq	%r13, %rdx
   1fa2b: 41 89 d9                     	movl	%ebx, %r9d
   1fa2e: 8b 44 24 50                  	movl	80(%rsp), %eax
   1fa32: 45 89 f0                     	movl	%r14d, %r8d
   1fa35: 44 89 e1                     	movl	%r12d, %ecx
   1fa38: 48 89 ef                     	movq	%rbp, %rdi
   1fa3b: 48 8d 35 66 99 01 00         	leaq	104806(%rip), %rsi      # 0x393a8 <strs.2+0x6518>
   1fa42: 50                           	pushq	%rax
   1fa43: 31 c0                        	xorl	%eax, %eax
   1fa45: e8 46 f6 ff ff               	callq	0x1f090 <debug_ret>
; 	emit_check_err(gen);
   1fa4a: 48 89 ef                     	movq	%rbp, %rdi
   1fa4d: e8 6e f9 ff ff               	callq	0x1f3c0 <emit_check_err>
; 		emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_7,
   1fa52: be 63 7a 7c ff               	movl	$4286347875, %esi       # imm = 0xFF7C7A63
   1fa57: 48 89 ef                     	movq	%rbp, %rdi
   1fa5a: e8 c1 f1 ff ff               	callq	0x1ec20 <emit>
   1fa5f: 58                           	popq	%rax
   1fa60: 5a                           	popq	%rdx
; 	if (close_inner_map_fd)
   1fa61: 80 7c 24 0f 00               	cmpb	$0, 15(%rsp)
   1fa66: 0f 85 3c 01 00 00            	jne	0x1fba8 <bpf_gen__map_create+0x2c8>
   1fa6c: 0f 1f 40 00                  	nopl	(%rax)
; }
   1fa70: 48 8b 84 24 a8 00 00 00      	movq	168(%rsp), %rax
   1fa78: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1fa81: 0f 85 5f 01 00 00            	jne	0x1fbe6 <bpf_gen__map_create+0x306>
   1fa87: 48 81 c4 b8 00 00 00         	addq	$184, %rsp
   1fa8e: 5b                           	popq	%rbx
   1fa8f: 5d                           	popq	%rbp
   1fa90: 41 5c                        	popq	%r12
   1fa92: 41 5d                        	popq	%r13
   1fa94: 41 5e                        	popq	%r14
   1fa96: 41 5f                        	popq	%r15
   1fa98: c3                           	retq
   1fa99: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			      sizeof(struct bpf_map_desc) * map_idx +
   1faa0: 44 89 e1                     	movl	%r12d, %ecx
; 		move_ctx2blob(gen, attr_field(map_create_attr, max_entries), 4,
   1faa3: 41 b8 01 00 00 00            	movl	$1, %r8d
   1faa9: 41 8d 77 0c                  	leal	12(%r15), %esi
   1faad: 48 89 ef                     	movq	%rbp, %rdi
; 			      sizeof(struct bpf_map_desc) * map_idx +
   1fab0: c1 e1 04                     	shll	$4, %ecx
; 		move_ctx2blob(gen, attr_field(map_create_attr, max_entries), 4,
   1fab3: ba 04 00 00 00               	movl	$4, %edx
; 			      sizeof(struct bpf_map_desc) * map_idx +
   1fab8: 83 c1 1c                     	addl	$28, %ecx
; 		move_ctx2blob(gen, attr_field(map_create_attr, max_entries), 4,
   1fabb: e8 e0 f1 ff ff               	callq	0x1eca0 <move_ctx2blob>
; 	emit_sys_bpf(gen, BPF_MAP_CREATE, map_create_attr, attr_size);
   1fac0: b9 48 00 00 00               	movl	$72, %ecx
   1fac5: 44 89 fa                     	movl	%r15d, %edx
   1fac8: 31 f6                        	xorl	%esi, %esi
   1faca: 48 89 ef                     	movq	%rbp, %rdi
   1facd: e8 be f2 ff ff               	callq	0x1ed90 <emit_sys_bpf>
; 	debug_ret(gen, "map_create %s idx %d type %d value_size %d value_btf_id %d",
   1fad2: 48 83 ec 08                  	subq	$8, %rsp
   1fad6: 44 89 e1                     	movl	%r12d, %ecx
   1fad9: 41 89 d9                     	movl	%ebx, %r9d
   1fadc: 8b 44 24 50                  	movl	80(%rsp), %eax
   1fae0: 45 89 f0                     	movl	%r14d, %r8d
   1fae3: 4c 89 ea                     	movq	%r13, %rdx
   1fae6: 48 89 ef                     	movq	%rbp, %rdi
   1fae9: 48 8d 35 b8 98 01 00         	leaq	104632(%rip), %rsi      # 0x393a8 <strs.2+0x6518>
   1faf0: 50                           	pushq	%rax
   1faf1: 31 c0                        	xorl	%eax, %eax
   1faf3: e8 98 f5 ff ff               	callq	0x1f090 <debug_ret>
; 	emit_check_err(gen);
   1faf8: 48 89 ef                     	movq	%rbp, %rdi
   1fafb: e8 c0 f8 ff ff               	callq	0x1f3c0 <emit_check_err>
; 	} else if (map_idx != gen->nr_maps) {
   1fb00: 59                           	popq	%rcx
   1fb01: 5e                           	popq	%rsi
   1fb02: 44 3b 65 34                  	cmpl	52(%rbp), %r12d
   1fb06: 74 10                        	je	0x1fb18 <bpf_gen__map_create+0x238>
; 		gen->error = -EDOM; /* internal bug */
   1fb08: c7 45 3c df ff ff ff         	movl	$4294967263, 60(%rbp)   # imm = 0xFFFFFFDF
; 		return;
   1fb0f: e9 5c ff ff ff               	jmp	0x1fa70 <bpf_gen__map_create+0x190>
   1fb14: 0f 1f 40 00                  	nopl	(%rax)
; 	if (gen->nr_maps == MAX_USED_MAPS) {
   1fb18: 41 83 fc 40                  	cmpl	$64, %r12d
   1fb1c: 0f 84 a0 00 00 00            	je	0x1fbc2 <bpf_gen__map_create+0x2e2>
; 	return gen->nr_maps++;
   1fb22: 41 8d 44 24 01               	leal	1(%r12), %eax
; 	return gen->fd_array + index * sizeof(int);
   1fb27: 41 c1 e4 02                  	shll	$2, %r12d
; 	return gen->nr_maps++;
   1fb2b: 89 45 34                     	movl	%eax, 52(%rbp)
; 	return gen->fd_array + index * sizeof(int);
   1fb2e: 44 03 a5 ec 00 00 00         	addl	236(%rbp), %r12d
; 	emit(gen, insn1);
   1fb35: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   1fb3a: 48 89 ef                     	movq	%rbp, %rdi
   1fb3d: e8 de f0 ff ff               	callq	0x1ec20 <emit>
   1fb42: 49 c1 e4 20                  	shlq	$32, %r12
; 	emit(gen, insn2);
   1fb46: 48 89 ef                     	movq	%rbp, %rdi
   1fb49: 4c 89 e6                     	movq	%r12, %rsi
   1fb4c: e8 cf f0 ff ff               	callq	0x1ec20 <emit>
; 		emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_1, BPF_REG_7, 0));
   1fb51: be 63 71 00 00               	movl	$29027, %esi            # imm = 0x7163
   1fb56: 48 89 ef                     	movq	%rbp, %rdi
   1fb59: e8 c2 f0 ff ff               	callq	0x1ec20 <emit>
; 	if (close_inner_map_fd)
   1fb5e: 80 7c 24 0f 00               	cmpb	$0, 15(%rsp)
   1fb63: 0f 84 07 ff ff ff            	je	0x1fa70 <bpf_gen__map_create+0x190>
   1fb69: eb 3d                        	jmp	0x1fba8 <bpf_gen__map_create+0x2c8>
   1fb6b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		move_stack2blob(gen, attr_field(map_create_attr, btf_fd), 4,
   1fb70: 8d 70 30                     	leal	48(%rax), %esi
   1fb73: ba 78 ff ff ff               	movl	$4294967160, %edx       # imm = 0xFFFFFF78
   1fb78: 48 89 ef                     	movq	%rbp, %rdi
   1fb7b: e8 f0 f7 ff ff               	callq	0x1f370 <move_stack2blob.constprop.0>
   1fb80: e9 6f fe ff ff               	jmp	0x1f9f4 <bpf_gen__map_create+0x114>
   1fb85: 0f 1f 00                     	nopl	(%rax)
; 		move_stack2blob(gen, attr_field(map_create_attr, inner_map_fd), 4,
   1fb88: 41 8d 77 14                  	leal	20(%r15), %esi
   1fb8c: ba 7c ff ff ff               	movl	$4294967164, %edx       # imm = 0xFFFFFF7C
   1fb91: 48 89 ef                     	movq	%rbp, %rdi
   1fb94: e8 d7 f7 ff ff               	callq	0x1f370 <move_stack2blob.constprop.0>
; 		close_inner_map_fd = true;
   1fb99: c6 44 24 0f 01               	movb	$1, 15(%rsp)
; 		break;
   1fb9e: e9 66 fe ff ff               	jmp	0x1fa09 <bpf_gen__map_create+0x129>
   1fba3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_10, stack_off));
   1fba8: 48 89 ef                     	movq	%rbp, %rdi
   1fbab: be 61 a1 7c ff               	movl	$4286357857, %esi       # imm = 0xFF7CA161
   1fbb0: e8 6b f0 ff ff               	callq	0x1ec20 <emit>
; 	__emit_sys_close(gen);
   1fbb5: 48 89 ef                     	movq	%rbp, %rdi
   1fbb8: e8 a3 f5 ff ff               	callq	0x1f160 <__emit_sys_close>
; }
   1fbbd: e9 ae fe ff ff               	jmp	0x1fa70 <bpf_gen__map_create+0x190>
; 		pr_warn("Total maps exceeds %d\n", MAX_USED_MAPS);
   1fbc2: ba 40 00 00 00               	movl	$64, %edx
   1fbc7: 48 8d 35 1a 98 01 00         	leaq	104474(%rip), %rsi      # 0x393e8 <strs.2+0x6558>
   1fbce: 31 ff                        	xorl	%edi, %edi
   1fbd0: 31 c0                        	xorl	%eax, %eax
   1fbd2: e8 f9 84 fe ff               	callq	0x80d0 <libbpf_print>
; 		return 0;
   1fbd7: 45 31 e4                     	xorl	%r12d, %r12d
; 		gen->error = -E2BIG;
   1fbda: c7 45 3c f9 ff ff ff         	movl	$4294967289, 60(%rbp)   # imm = 0xFFFFFFF9
; 		return 0;
   1fbe1: e9 48 ff ff ff               	jmp	0x1fb2e <bpf_gen__map_create+0x24e>
; }
   1fbe6: e8 15 5c fe ff               	callq	0x5800 <.plt.sec+0x190>
   1fbeb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

000000000001fbf0 <bpf_gen__record_attach_target>:
; {
   1fbf0: f3 0f 1e fa                  	endbr64
   1fbf4: 55                           	pushq	%rbp
   1fbf5: 48 89 f5                     	movq	%rsi, %rbp
   1fbf8: 53                           	pushq	%rbx
   1fbf9: 48 89 fb                     	movq	%rdi, %rbx
   1fbfc: 89 d7                        	movl	%edx, %edi
   1fbfe: 48 83 ec 28                  	subq	$40, %rsp
   1fc02: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1fc0b: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   1fc10: 31 c0                        	xorl	%eax, %eax
; 	btf_get_kernel_prefix_kind(type, &prefix, &kind);
   1fc12: 48 8d 54 24 0c               	leaq	12(%rsp), %rdx
   1fc17: 48 8d 74 24 10               	leaq	16(%rsp), %rsi
   1fc1c: e8 bf fd fe ff               	callq	0xf9e0 <btf_get_kernel_prefix_kind>
; 	gen->attach_kind = kind;
   1fc21: 8b 44 24 0c                  	movl	12(%rsp), %eax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1fc25: 48 83 ec 08                  	subq	$8, %rsp
   1fc29: b9 80 00 00 00               	movl	$128, %ecx
   1fc2e: 55                           	pushq	%rbp
   1fc2f: 4c 8b 4c 24 20               	movq	32(%rsp), %r9
   1fc34: ba 01 00 00 00               	movl	$1, %edx
   1fc39: 48 8d 7b 5c                  	leaq	92(%rbx), %rdi
; 	gen->attach_kind = kind;
   1fc3d: 89 83 dc 00 00 00            	movl	%eax, 220(%rbx)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   1fc43: 4c 8d 05 57 23 01 00         	leaq	74583(%rip), %r8        # 0x31fa1 <_IO_stdin_used+0x1fa1>
   1fc4a: be 80 00 00 00               	movl	$128, %esi
   1fc4f: 31 c0                        	xorl	%eax, %eax
   1fc51: e8 5a 5a fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 	if (ret >= sizeof(gen->attach_target))
   1fc56: 5a                           	popq	%rdx
   1fc57: 59                           	popq	%rcx
   1fc58: 83 f8 7f                     	cmpl	$127, %eax
   1fc5b: 76 07                        	jbe	0x1fc64 <bpf_gen__record_attach_target+0x74>
; 		gen->error = -ENOSPC;
   1fc5d: c7 43 3c e4 ff ff ff         	movl	$4294967268, 60(%rbx)   # imm = 0xFFFFFFE4
; }
   1fc64: 48 8b 44 24 18               	movq	24(%rsp), %rax
   1fc69: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   1fc72: 75 07                        	jne	0x1fc7b <bpf_gen__record_attach_target+0x8b>
   1fc74: 48 83 c4 28                  	addq	$40, %rsp
   1fc78: 5b                           	popq	%rbx
   1fc79: 5d                           	popq	%rbp
   1fc7a: c3                           	retq
   1fc7b: e8 80 5b fe ff               	callq	0x5800 <.plt.sec+0x190>

000000000001fc80 <bpf_gen__record_extern>:
; {
   1fc80: f3 0f 1e fa                  	endbr64
   1fc84: 41 57                        	pushq	%r15
   1fc86: 49 89 ff                     	movq	%rdi, %r15
   1fc89: 41 56                        	pushq	%r14
   1fc8b: 49 89 f6                     	movq	%rsi, %r14
   1fc8e: 41 55                        	pushq	%r13
   1fc90: 41 89 d5                     	movl	%edx, %r13d
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   1fc93: ba 18 00 00 00               	movl	$24, %edx
; {
   1fc98: 41 54                        	pushq	%r12
   1fc9a: 55                           	pushq	%rbp
   1fc9b: 53                           	pushq	%rbx
   1fc9c: 48 83 ec 08                  	subq	$8, %rsp
; 	relo = libbpf_reallocarray(gen->relos, gen->relo_cnt + 1, sizeof(*relo));
   1fca0: 41 8b 47 48                  	movl	72(%r15), %eax
   1fca4: 48 8b 7f 40                  	movq	64(%rdi), %rdi
   1fca8: 8d 70 01                     	leal	1(%rax), %esi
   1fcab: 48 63 f6                     	movslq	%esi, %rsi
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   1fcae: 48 89 f0                     	movq	%rsi, %rax
   1fcb1: 48 f7 e2                     	mulq	%rdx
   1fcb4: 70 50                        	jo	0x1fd06 <bpf_gen__record_extern+0x86>
   1fcb6: 48 89 c6                     	movq	%rax, %rsi
; 	return realloc(ptr, total);
   1fcb9: 41 89 cc                     	movl	%ecx, %r12d
   1fcbc: 44 89 c5                     	movl	%r8d, %ebp
   1fcbf: 44 89 cb                     	movl	%r9d, %ebx
   1fcc2: e8 59 5e fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 	if (!relo) {
   1fcc7: 48 85 c0                     	testq	%rax, %rax
   1fcca: 74 3a                        	je	0x1fd06 <bpf_gen__record_extern+0x86>
; 	relo += gen->relo_cnt;
   1fccc: 49 63 4f 48                  	movslq	72(%r15), %rcx
; 	gen->relos = relo;
   1fcd0: 49 89 47 40                  	movq	%rax, 64(%r15)
; 	relo += gen->relo_cnt;
   1fcd4: 48 89 ca                     	movq	%rcx, %rdx
   1fcd7: 48 8d 0c 49                  	leaq	(%rcx,%rcx,2), %rcx
   1fcdb: 48 8d 04 c8                  	leaq	(%rax,%rcx,8), %rax
; 	gen->relo_cnt++;
   1fcdf: 83 c2 01                     	addl	$1, %edx
; 	relo->name = name;
   1fce2: 4c 89 30                     	movq	%r14, (%rax)
; 	relo->is_weak = is_weak;
   1fce5: 44 88 68 10                  	movb	%r13b, 16(%rax)
; 	relo->is_typeless = is_typeless;
   1fce9: 44 88 60 11                  	movb	%r12b, 17(%rax)
; 	relo->kind = kind;
   1fced: 89 68 08                     	movl	%ebp, 8(%rax)
; 	relo->insn_idx = insn_idx;
   1fcf0: 89 58 0c                     	movl	%ebx, 12(%rax)
; 	gen->relo_cnt++;
   1fcf3: 41 89 57 48                  	movl	%edx, 72(%r15)
; }
   1fcf7: 48 83 c4 08                  	addq	$8, %rsp
   1fcfb: 5b                           	popq	%rbx
   1fcfc: 5d                           	popq	%rbp
   1fcfd: 41 5c                        	popq	%r12
   1fcff: 41 5d                        	popq	%r13
   1fd01: 41 5e                        	popq	%r14
   1fd03: 41 5f                        	popq	%r15
   1fd05: c3                           	retq
; 		gen->error = -ENOMEM;
   1fd06: 41 c7 47 3c f4 ff ff ff      	movl	$4294967284, 60(%r15)   # imm = 0xFFFFFFF4
; }
   1fd0e: 48 83 c4 08                  	addq	$8, %rsp
   1fd12: 5b                           	popq	%rbx
   1fd13: 5d                           	popq	%rbp
   1fd14: 41 5c                        	popq	%r12
   1fd16: 41 5d                        	popq	%r13
   1fd18: 41 5e                        	popq	%r14
   1fd1a: 41 5f                        	popq	%r15
   1fd1c: c3                           	retq
   1fd1d: 0f 1f 00                     	nopl	(%rax)

000000000001fd20 <bpf_gen__record_relo_core>:
; {
   1fd20: f3 0f 1e fa                  	endbr64
   1fd24: 55                           	pushq	%rbp
   1fd25: 48 89 f5                     	movq	%rsi, %rbp
   1fd28: 53                           	pushq	%rbx
   1fd29: 48 89 fb                     	movq	%rdi, %rbx
   1fd2c: 48 83 ec 08                  	subq	$8, %rsp
; 	relos = libbpf_reallocarray(gen->core_relos, gen->core_relo_cnt + 1, sizeof(*relos));
   1fd30: 8b 43 58                     	movl	88(%rbx), %eax
   1fd33: 48 8b 7f 50                  	movq	80(%rdi), %rdi
   1fd37: 83 c0 01                     	addl	$1, %eax
   1fd3a: 48 98                        	cltq
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   1fd3c: 48 89 c6                     	movq	%rax, %rsi
   1fd3f: 48 c1 e6 04                  	shlq	$4, %rsi
   1fd43: 48 c1 e8 3c                  	shrq	$60, %rax
   1fd47: 75 2a                        	jne	0x1fd73 <bpf_gen__record_relo_core+0x53>
; 	return realloc(ptr, total);
   1fd49: e8 d2 5d fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 	if (!relos) {
   1fd4e: 48 85 c0                     	testq	%rax, %rax
   1fd51: 74 20                        	je	0x1fd73 <bpf_gen__record_relo_core+0x53>
; 	relos += gen->core_relo_cnt;
   1fd53: 48 63 53 58                  	movslq	88(%rbx), %rdx
; 	gen->core_relos = relos;
   1fd57: 48 89 43 50                  	movq	%rax, 80(%rbx)
;   return __builtin___memcpy_chk (__dest, __src, __len,
   1fd5b: f3 0f 6f 45 00               	movdqu	(%rbp), %xmm0
   1fd60: 48 c1 e2 04                  	shlq	$4, %rdx
   1fd64: 0f 11 04 10                  	movups	%xmm0, (%rax,%rdx)
; 	gen->core_relo_cnt++;
   1fd68: 83 43 58 01                  	addl	$1, 88(%rbx)
; }
   1fd6c: 48 83 c4 08                  	addq	$8, %rsp
   1fd70: 5b                           	popq	%rbx
   1fd71: 5d                           	popq	%rbp
   1fd72: c3                           	retq
; 		gen->error = -ENOMEM;
   1fd73: c7 43 3c f4 ff ff ff         	movl	$4294967284, 60(%rbx)   # imm = 0xFFFFFFF4
; }
   1fd7a: 48 83 c4 08                  	addq	$8, %rsp
   1fd7e: 5b                           	popq	%rbx
   1fd7f: 5d                           	popq	%rbp
   1fd80: c3                           	retq
   1fd81: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   1fd8c: 0f 1f 40 00                  	nopl	(%rax)

000000000001fd90 <bpf_gen__prog_load>:
; {
   1fd90: f3 0f 1e fa                  	endbr64
   1fd94: 41 57                        	pushq	%r15
   1fd96: 41 89 f7                     	movl	%esi, %r15d
   1fd99: 41 56                        	pushq	%r14
   1fd9b: 4d 89 ce                     	movq	%r9, %r14
   1fd9e: 41 55                        	pushq	%r13
   1fda0: 41 54                        	pushq	%r12
   1fda2: 49 89 fc                     	movq	%rdi, %r12
   1fda5: 55                           	pushq	%rbp
   1fda6: 48 89 d5                     	movq	%rdx, %rbp
; 	pr_debug("gen: prog_load: type %d insns_cnt %zd progi_idx %d\n",
   1fda9: 89 f2                        	movl	%esi, %edx
   1fdab: 48 8d 35 56 96 01 00         	leaq	104022(%rip), %rsi      # 0x39408 <strs.2+0x6578>
; {
   1fdb2: 53                           	pushq	%rbx
   1fdb3: 48 89 cb                     	movq	%rcx, %rbx
;   return __builtin___memset_chk (__dest, __ch, __len,
   1fdb6: b9 11 00 00 00               	movl	$17, %ecx
; {
   1fdbb: 48 81 ec d8 00 00 00         	subq	$216, %rsp
   1fdc2: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   1fdc7: 4c 8d 4c 24 30               	leaq	48(%rsp), %r9
; 	pr_debug("gen: prog_load: type %d insns_cnt %zd progi_idx %d\n",
   1fdcc: 44 8b 84 24 18 01 00 00      	movl	280(%rsp), %r8d
;   return __builtin___memset_chk (__dest, __ch, __len,
   1fdd4: 4c 89 cf                     	movq	%r9, %rdi
; {
   1fdd7: 4c 8b ac 24 10 01 00 00      	movq	272(%rsp), %r13
   1fddf: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   1fde8: 48 89 84 24 c8 00 00 00      	movq	%rax, 200(%rsp)
   1fdf0: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   1fdf2: 4c 89 4c 24 10               	movq	%r9, 16(%rsp)
   1fdf7: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	pr_debug("gen: prog_load: type %d insns_cnt %zd progi_idx %d\n",
   1fdfa: 4c 89 f1                     	movq	%r14, %rcx
;   return __builtin___memset_chk (__dest, __ch, __len,
   1fdfd: c7 07 00 00 00 00            	movl	$0, (%rdi)
; 	pr_debug("gen: prog_load: type %d insns_cnt %zd progi_idx %d\n",
   1fe03: bf 02 00 00 00               	movl	$2, %edi
   1fe08: e8 c3 82 fe ff               	callq	0x80d0 <libbpf_print>
; 	license_off = add_data(gen, license, strlen(license) + 1);
   1fe0d: 48 89 df                     	movq	%rbx, %rdi
   1fe10: e8 cb 59 fe ff               	callq	0x57e0 <.plt.sec+0x170>
   1fe15: 48 89 de                     	movq	%rbx, %rsi
   1fe18: 4c 89 e7                     	movq	%r12, %rdi
   1fe1b: 8d 50 01                     	leal	1(%rax), %edx
   1fe1e: e8 cd eb ff ff               	callq	0x1e9f0 <add_data>
; 	insns_off = add_data(gen, insns, insn_cnt * sizeof(struct bpf_insn));
   1fe23: 48 8b 74 24 08               	movq	8(%rsp), %rsi
   1fe28: 42 8d 14 f5 00 00 00 00      	leal	(,%r14,8), %edx
   1fe30: 4c 89 e7                     	movq	%r12, %rdi
; 	license_off = add_data(gen, license, strlen(license) + 1);
   1fe33: 89 c3                        	movl	%eax, %ebx
; 	insns_off = add_data(gen, insns, insn_cnt * sizeof(struct bpf_insn));
   1fe35: e8 b6 eb ff ff               	callq	0x1e9f0 <add_data>
; 	attr.func_info_rec_size = load_attr->func_info_rec_size;
   1fe3a: 41 8b 55 44                  	movl	68(%r13), %edx
; 	func_info = add_data(gen, load_attr->func_info,
   1fe3e: 49 8b 75 38                  	movq	56(%r13), %rsi
   1fe42: 4c 89 e7                     	movq	%r12, %rdi
; 	insns_off = add_data(gen, insns, insn_cnt * sizeof(struct bpf_insn));
   1fe45: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	attr.expected_attach_type = load_attr->expected_attach_type;
   1fe49: 41 8b 45 0c                  	movl	12(%r13), %eax
; 	attr.func_info_rec_size = load_attr->func_info_rec_size;
   1fe4d: 89 54 24 7c                  	movl	%edx, 124(%rsp)
; 	attr.expected_attach_type = load_attr->expected_attach_type;
   1fe51: 89 44 24 74                  	movl	%eax, 116(%rsp)
; 	attr.attach_btf_id = load_attr->attach_btf_id;
   1fe55: 41 8b 45 20                  	movl	32(%r13), %eax
; 	attr.prog_type = prog_type;
   1fe59: 44 89 7c 24 30               	movl	%r15d, 48(%rsp)
; 	attr.attach_btf_id = load_attr->attach_btf_id;
   1fe5e: 89 84 24 9c 00 00 00         	movl	%eax, 156(%rsp)
; 	attr.prog_ifindex = load_attr->prog_ifindex;
   1fe65: 41 8b 45 18                  	movl	24(%r13), %eax
; 	attr.insn_cnt = (__u32)insn_cnt;
   1fe69: 44 89 74 24 34               	movl	%r14d, 52(%rsp)
; 	attr.prog_ifindex = load_attr->prog_ifindex;
   1fe6e: 89 44 24 70                  	movl	%eax, 112(%rsp)
; 	attr.prog_flags = load_attr->prog_flags;
   1fe72: 41 8b 45 14                  	movl	20(%r13), %eax
; 	attr.kern_version = 0;
   1fe76: c7 44 24 58 00 00 00 00      	movl	$0, 88(%rsp)
; 	attr.prog_flags = load_attr->prog_flags;
   1fe7e: 89 44 24 5c                  	movl	%eax, 92(%rsp)
; 	attr.func_info_cnt = load_attr->func_info_cnt;
   1fe82: 41 8b 45 40                  	movl	64(%r13), %eax
; 	func_info = add_data(gen, load_attr->func_info,
   1fe86: 0f af d0                     	imull	%eax, %edx
; 	attr.func_info_cnt = load_attr->func_info_cnt;
   1fe89: 89 84 24 88 00 00 00         	movl	%eax, 136(%rsp)
; 	func_info = add_data(gen, load_attr->func_info,
   1fe90: e8 5b eb ff ff               	callq	0x1e9f0 <add_data>
; 	attr.line_info_rec_size = load_attr->line_info_rec_size;
   1fe95: 41 8b 55 54                  	movl	84(%r13), %edx
; 	line_info = add_data(gen, load_attr->line_info,
   1fe99: 49 8b 75 48                  	movq	72(%r13), %rsi
   1fe9d: 4c 89 e7                     	movq	%r12, %rdi
; 	func_info = add_data(gen, load_attr->func_info,
   1fea0: 41 89 c7                     	movl	%eax, %r15d
; 	attr.line_info_cnt = load_attr->line_info_cnt;
   1fea3: 41 8b 45 50                  	movl	80(%r13), %eax
; 	attr.line_info_rec_size = load_attr->line_info_rec_size;
   1fea7: 89 94 24 8c 00 00 00         	movl	%edx, 140(%rsp)
; 	line_info = add_data(gen, load_attr->line_info,
   1feae: 0f af d0                     	imull	%eax, %edx
; 	attr.line_info_cnt = load_attr->line_info_cnt;
   1feb1: 89 84 24 98 00 00 00         	movl	%eax, 152(%rsp)
; 	line_info = add_data(gen, load_attr->line_info,
   1feb8: e8 33 eb ff ff               	callq	0x1e9f0 <add_data>
; 	attr.core_relo_cnt = gen->core_relo_cnt;
   1febd: 41 8b 54 24 58               	movl	88(%r12), %edx
; 	core_relos = add_data(gen, gen->core_relos,
   1fec2: 49 8b 74 24 50               	movq	80(%r12), %rsi
   1fec7: 4c 89 e7                     	movq	%r12, %rdi
; 	attr.core_relo_rec_size = sizeof(struct bpf_core_relo);
   1feca: c7 84 24 b8 00 00 00 10 00 00 00     	movl	$16, 184(%rsp)
; 	line_info = add_data(gen, load_attr->line_info,
   1fed5: 41 89 c6                     	movl	%eax, %r14d
; 	attr.core_relo_cnt = gen->core_relo_cnt;
   1fed8: 89 94 24 a4 00 00 00         	movl	%edx, 164(%rsp)
; 	core_relos = add_data(gen, gen->core_relos,
   1fedf: c1 e2 04                     	shll	$4, %edx
   1fee2: e8 09 eb ff ff               	callq	0x1e9f0 <add_data>
   1fee7: 48 8d 4c 24 60               	leaq	96(%rsp), %rcx
   1feec: 4c 8b 4c 24 10               	movq	16(%rsp), %r9
   1fef1: 48 89 4c 24 18               	movq	%rcx, 24(%rsp)
   1fef6: 41 89 c0                     	movl	%eax, %r8d
; 	for (i = 0; i < sz && src[i]; i++)
   1fef9: 31 c0                        	xorl	%eax, %eax
   1fefb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   1ff00: 0f b6 54 05 00               	movzbl	(%rbp,%rax), %edx
   1ff05: 84 d2                        	testb	%dl, %dl
   1ff07: 74 0d                        	je	0x1ff16 <bpf_gen__prog_load+0x186>
; 		dst[i] = src[i];
   1ff09: 88 14 01                     	movb	%dl, (%rcx,%rax)
; 	for (i = 0; i < sz && src[i]; i++)
   1ff0c: 48 83 c0 01                  	addq	$1, %rax
   1ff10: 48 83 f8 0f                  	cmpq	$15, %rax
   1ff14: 75 ea                        	jne	0x1ff00 <bpf_gen__prog_load+0x170>
; 	prog_load_attr = add_data(gen, &attr, attr_size);
   1ff16: 4c 89 ce                     	movq	%r9, %rsi
   1ff19: ba 8c 00 00 00               	movl	$140, %edx
   1ff1e: 4c 89 e7                     	movq	%r12, %rdi
; 	dst[i] = '\0';
   1ff21: 44 89 44 24 20               	movl	%r8d, 32(%rsp)
   1ff26: c6 44 04 60 00               	movb	$0, 96(%rsp,%rax)
; 	prog_load_attr = add_data(gen, &attr, attr_size);
   1ff2b: e8 c0 ea ff ff               	callq	0x1e9f0 <add_data>
; 	emit_rel_store(gen, attr_field(prog_load_attr, license), license_off);
   1ff30: 89 da                        	movl	%ebx, %edx
   1ff32: 4c 89 e7                     	movq	%r12, %rdi
   1ff35: 8d 70 10                     	leal	16(%rax), %esi
; 	prog_load_attr = add_data(gen, &attr, attr_size);
   1ff38: 89 c5                        	movl	%eax, %ebp
   1ff3a: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 	emit_rel_store(gen, attr_field(prog_load_attr, license), license_off);
   1ff3e: e8 ed ed ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_rel_store(gen, attr_field(prog_load_attr, insns), insns_off);
   1ff43: 8b 54 24 08                  	movl	8(%rsp), %edx
   1ff47: 8d 75 08                     	leal	8(%rbp), %esi
   1ff4a: 4c 89 e7                     	movq	%r12, %rdi
   1ff4d: e8 de ed ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_rel_store(gen, attr_field(prog_load_attr, func_info), func_info);
   1ff52: 8d 75 50                     	leal	80(%rbp), %esi
   1ff55: 44 89 fa                     	movl	%r15d, %edx
   1ff58: 4c 89 e7                     	movq	%r12, %rdi
   1ff5b: e8 d0 ed ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_rel_store(gen, attr_field(prog_load_attr, line_info), line_info);
   1ff60: 44 89 f2                     	movl	%r14d, %edx
   1ff63: 8d 75 60                     	leal	96(%rbp), %esi
   1ff66: 4c 89 e7                     	movq	%r12, %rdi
   1ff69: e8 c2 ed ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_rel_store(gen, attr_field(prog_load_attr, core_relos), core_relos);
   1ff6e: 8b 54 24 20                  	movl	32(%rsp), %edx
   1ff72: 8d b5 80 00 00 00            	leal	128(%rbp), %esi
   1ff78: 4c 89 e7                     	movq	%r12, %rdi
   1ff7b: e8 b0 ed ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_rel_store(gen, attr_field(prog_load_attr, fd_array), gen->fd_array);
   1ff80: 41 8b 94 24 ec 00 00 00      	movl	236(%r12), %edx
   1ff88: 8d 75 78                     	leal	120(%rbp), %esi
   1ff8b: 4c 89 e7                     	movq	%r12, %rdi
   1ff8e: e8 9d ed ff ff               	callq	0x1ed30 <emit_rel_store>
; 	move_ctx2blob(gen, attr_field(prog_load_attr, log_level), 4,
   1ff93: 8d 75 18                     	leal	24(%rbp), %esi
   1ff96: 45 31 c0                     	xorl	%r8d, %r8d
   1ff99: b9 08 00 00 00               	movl	$8, %ecx
   1ff9e: ba 04 00 00 00               	movl	$4, %edx
   1ffa3: 4c 89 e7                     	movq	%r12, %rdi
   1ffa6: e8 f5 ec ff ff               	callq	0x1eca0 <move_ctx2blob>
; 	move_ctx2blob(gen, attr_field(prog_load_attr, log_size), 4,
   1ffab: 8d 75 1c                     	leal	28(%rbp), %esi
   1ffae: 45 31 c0                     	xorl	%r8d, %r8d
   1ffb1: b9 0c 00 00 00               	movl	$12, %ecx
   1ffb6: ba 04 00 00 00               	movl	$4, %edx
   1ffbb: 4c 89 e7                     	movq	%r12, %rdi
   1ffbe: e8 dd ec ff ff               	callq	0x1eca0 <move_ctx2blob>
; 	move_ctx2blob(gen, attr_field(prog_load_attr, log_buf), 8,
   1ffc3: 8d 75 20                     	leal	32(%rbp), %esi
   1ffc6: 45 31 c0                     	xorl	%r8d, %r8d
   1ffc9: b9 10 00 00 00               	movl	$16, %ecx
   1ffce: ba 08 00 00 00               	movl	$8, %edx
   1ffd3: 4c 89 e7                     	movq	%r12, %rdi
   1ffd6: e8 c5 ec ff ff               	callq	0x1eca0 <move_ctx2blob>
; 	move_stack2blob(gen, attr_field(prog_load_attr, prog_btf_fd), 4,
   1ffdb: 8d 75 48                     	leal	72(%rbp), %esi
   1ffde: ba 78 ff ff ff               	movl	$4294967160, %edx       # imm = 0xFFFFFF78
   1ffe3: 4c 89 e7                     	movq	%r12, %rdi
   1ffe6: e8 85 f3 ff ff               	callq	0x1f370 <move_stack2blob.constprop.0>
; 	if (gen->attach_kind) {
   1ffeb: 45 8b b4 24 dc 00 00 00      	movl	220(%r12), %r14d
   1fff3: 45 85 f6                     	testl	%r14d, %r14d
   1fff6: 0f 85 44 08 00 00            	jne	0x20840 <bpf_gen__prog_load+0xab0>
; 	for (i = 0; i < gen->relo_cnt; i++)
   1fffc: 45 8b 5c 24 48               	movl	72(%r12), %r11d
; 	insn = insns + sizeof(struct bpf_insn) * relo->insn_idx;
   20001: 31 db                        	xorl	%ebx, %ebx
   20003: 4c 8d 35 66 94 01 00         	leaq	103526(%rip), %r14      # 0x39470 <strs.2+0x65e0>
; 	for (i = 0; i < gen->relo_cnt; i++)
   2000a: 45 85 db                     	testl	%r11d, %r11d
   2000d: 0f 8f 9c 01 00 00            	jg	0x201af <bpf_gen__prog_load+0x41f>
   20013: e9 26 02 00 00               	jmp	0x2023e <bpf_gen__prog_load+0x4ae>
   20018: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		if (relo->is_typeless)
   20020: 41 80 7f 11 00               	cmpb	$0, 17(%r15)
; 	kdesc = get_ksym_desc(gen, relo);
   20025: 4c 89 fe                     	movq	%r15, %rsi
   20028: 4c 89 e7                     	movq	%r12, %rdi
; 		if (relo->is_typeless)
   2002b: 0f 84 47 05 00 00            	je	0x20578 <bpf_gen__prog_load+0x7e8>
; 	kdesc = get_ksym_desc(gen, relo);
   20031: e8 ea ea ff ff               	callq	0x1eb20 <get_ksym_desc>
   20036: 49 89 c0                     	movq	%rax, %r8
; 	if (!kdesc)
   20039: 48 85 c0                     	testq	%rax, %rax
   2003c: 0f 84 5e 01 00 00            	je	0x201a0 <bpf_gen__prog_load+0x410>
; 	if (kdesc->ref > 1) {
   20042: 83 78 08 01                  	cmpl	$1, 8(%rax)
   20046: 0f 8f 44 07 00 00            	jg	0x20790 <bpf_gen__prog_load+0xa00>
; 	kdesc->insn = insn;
   2004c: 89 68 14                     	movl	%ebp, 20(%rax)
; 	int name_off, len = strlen(relo->name) + 1, res_off;
   2004f: 49 8b 2f                     	movq	(%r15), %rbp
; 	kdesc->typeless = true;
   20052: c6 40 10 01                  	movb	$1, 16(%rax)
; 	int name_off, len = strlen(relo->name) + 1, res_off;
   20056: 48 89 ef                     	movq	%rbp, %rdi
; 	kdesc->typeless = true;
   20059: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	int name_off, len = strlen(relo->name) + 1, res_off;
   2005e: e8 7d 57 fe ff               	callq	0x57e0 <.plt.sec+0x170>
; 	name_off = add_data(gen, relo->name, len);
   20063: 48 89 ee                     	movq	%rbp, %rsi
   20066: 4c 89 e7                     	movq	%r12, %rdi
; 	int name_off, len = strlen(relo->name) + 1, res_off;
   20069: 8d 48 01                     	leal	1(%rax), %ecx
; 	name_off = add_data(gen, relo->name, len);
   2006c: 89 ca                        	movl	%ecx, %edx
   2006e: 89 4c 24 20                  	movl	%ecx, 32(%rsp)
   20072: e8 79 e9 ff ff               	callq	0x1e9f0 <add_data>
; 	res_off = add_data(gen, NULL, 8); /* res is u64 */
   20077: ba 08 00 00 00               	movl	$8, %edx
   2007c: 31 f6                        	xorl	%esi, %esi
   2007e: 4c 89 e7                     	movq	%r12, %rdi
; 	name_off = add_data(gen, relo->name, len);
   20081: 41 89 c5                     	movl	%eax, %r13d
; 	res_off = add_data(gen, NULL, 8); /* res is u64 */
   20084: e8 67 e9 ff ff               	callq	0x1e9f0 <add_data>
   20089: 49 c1 e5 20                  	shlq	$32, %r13
; 	emit(gen, insn1);
   2008d: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   20092: 4c 89 e7                     	movq	%r12, %rdi
; 	res_off = add_data(gen, NULL, 8); /* res is u64 */
   20095: 89 c5                        	movl	%eax, %ebp
; 	emit(gen, insn1);
   20097: e8 84 eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   2009c: 4c 89 ee                     	movq	%r13, %rsi
   2009f: 4c 89 e7                     	movq	%r12, %rdi
   200a2: 48 c1 e5 20                  	shlq	$32, %rbp
   200a6: e8 75 eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_2, len));
   200ab: 8b 4c 24 20                  	movl	32(%rsp), %ecx
   200af: 4c 89 e7                     	movq	%r12, %rdi
   200b2: 48 89 ce                     	movq	%rcx, %rsi
   200b5: 48 c1 e6 20                  	shlq	$32, %rsi
   200b9: 48 81 ce b7 02 00 00         	orq	$695, %rsi              # imm = 0x2B7
   200c0: e8 5b eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_3, 0));
   200c5: be b7 03 00 00               	movl	$951, %esi              # imm = 0x3B7
   200ca: 4c 89 e7                     	movq	%r12, %rdi
   200cd: e8 4e eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn1);
   200d2: be 18 64 00 00               	movl	$25624, %esi            # imm = 0x6418
   200d7: 4c 89 e7                     	movq	%r12, %rdi
   200da: e8 41 eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   200df: 48 89 ee                     	movq	%rbp, %rsi
   200e2: 4c 89 e7                     	movq	%r12, %rdi
   200e5: e8 36 eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_REG(BPF_REG_7, BPF_REG_4));
   200ea: be bf 47 00 00               	movl	$18367, %esi            # imm = 0x47BF
   200ef: 4c 89 e7                     	movq	%r12, %rdi
   200f2: e8 29 eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_kallsyms_lookup_name));
   200f7: 4c 89 e7                     	movq	%r12, %rdi
   200fa: 48 be 85 00 00 00 b3 00 00 00	movabsq	$768799146117, %rsi     # imm = 0xB300000085
   20104: e8 17 eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_7, 0));
   20109: be 79 79 00 00               	movl	$31097, %esi            # imm = 0x7979
   2010e: 4c 89 e7                     	movq	%r12, %rdi
   20111: e8 0a eb ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_REG(BPF_REG_7, BPF_REG_0));
   20116: be bf 07 00 00               	movl	$1983, %esi             # imm = 0x7BF
   2011b: 4c 89 e7                     	movq	%r12, %rdi
   2011e: e8 fd ea ff ff               	callq	0x1ec20 <emit>
; 	debug_ret(gen, "kallsyms_lookup_name(%s,%d)", relo->name, relo->kind);
   20123: 41 8b 4f 08                  	movl	8(%r15), %ecx
   20127: 49 8b 17                     	movq	(%r15), %rdx
   2012a: 31 c0                        	xorl	%eax, %eax
   2012c: 48 8d 35 3f 91 01 00         	leaq	102719(%rip), %rsi      # 0x39272 <strs.2+0x63e2>
   20133: 4c 89 e7                     	movq	%r12, %rdi
   20136: e8 55 ef ff ff               	callq	0x1f090 <debug_ret>
; 	emit(gen, BPF_JMP_IMM(BPF_JEQ, BPF_REG_7, -ENOENT, 1));
   2013b: 4c 89 e7                     	movq	%r12, %rdi
   2013e: 48 be 15 07 01 00 fe ff ff ff	movabsq	$-8589867243, %rsi      # imm = 0xFFFFFFFE00010715
   20148: e8 d3 ea ff ff               	callq	0x1ec20 <emit>
; 	emit_check_err(gen);
   2014d: 4c 89 e7                     	movq	%r12, %rdi
   20150: e8 6b f2 ff ff               	callq	0x1f3c0 <emit_check_err>
; 	emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_8, BPF_REG_9, offsetof(struct bpf_insn, imm)));
   20155: be 63 98 04 00               	movl	$301155, %esi           # imm = 0x49863
   2015a: 4c 89 e7                     	movq	%r12, %rdi
   2015d: e8 be ea ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ALU64_IMM(BPF_RSH, BPF_REG_9, 32));
   20162: 4c 89 e7                     	movq	%r12, %rdi
   20165: 48 be 77 09 00 00 20 00 00 00	movabsq	$137438955895, %rsi     # imm = 0x2000000977
   2016f: e8 ac ea ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_8, BPF_REG_9,
   20174: be 63 98 0c 00               	movl	$825443, %esi           # imm = 0xC9863
   20179: 4c 89 e7                     	movq	%r12, %rdi
   2017c: e8 9f ea ff ff               	callq	0x1ec20 <emit>
   20181: 4c 8b 44 24 28               	movq	40(%rsp), %r8
; 	if (!gen->log_level)
   20186: 45 8b 4c 24 38               	movl	56(%r12), %r9d
   2018b: 45 85 c9                     	testl	%r9d, %r9d
   2018e: 74 10                        	je	0x201a0 <bpf_gen__prog_load+0x410>
   20190: 41 8b 50 08                  	movl	8(%r8), %edx
   20194: 4c 89 fe                     	movq	%r15, %rsi
   20197: 4c 89 e7                     	movq	%r12, %rdi
   2019a: e8 71 f0 ff ff               	callq	0x1f210 <emit_ksym_relo_log.part.0>
   2019f: 90                           	nop
; 	for (i = 0; i < gen->relo_cnt; i++)
   201a0: 48 83 c3 01                  	addq	$1, %rbx
   201a4: 41 39 5c 24 48               	cmpl	%ebx, 72(%r12)
   201a9: 0f 8e 8f 00 00 00            	jle	0x2023e <bpf_gen__prog_load+0x4ae>
; 		emit_relo(gen, gen->relos + i, insns);
   201af: 49 8b 54 24 40               	movq	64(%r12), %rdx
   201b4: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
; 	pr_debug("gen: emit_relo (%d): %s at %d\n", relo->kind, relo->name, relo->insn_idx);
   201b8: 4c 89 f6                     	movq	%r14, %rsi
   201bb: bf 02 00 00 00               	movl	$2, %edi
; 		emit_relo(gen, gen->relos + i, insns);
   201c0: 4c 8d 3c c2                  	leaq	(%rdx,%rax,8), %r15
; 	pr_debug("gen: emit_relo (%d): %s at %d\n", relo->kind, relo->name, relo->insn_idx);
   201c4: 31 c0                        	xorl	%eax, %eax
   201c6: 41 8b 57 08                  	movl	8(%r15), %edx
   201ca: 45 8b 47 0c                  	movl	12(%r15), %r8d
   201ce: 49 8b 0f                     	movq	(%r15), %rcx
   201d1: e8 fa 7e fe ff               	callq	0x80d0 <libbpf_print>
; 	insn = insns + sizeof(struct bpf_insn) * relo->insn_idx;
   201d6: 41 8b 47 0c                  	movl	12(%r15), %eax
   201da: 8b 4c 24 08                  	movl	8(%rsp), %ecx
; 	emit(gen, insn1);
   201de: 4c 89 e7                     	movq	%r12, %rdi
   201e1: be 18 68 00 00               	movl	$26648, %esi            # imm = 0x6818
; 	insn = insns + sizeof(struct bpf_insn) * relo->insn_idx;
   201e6: 8d 2c c1                     	leal	(%rcx,%rax,8), %ebp
; 	emit(gen, insn1);
   201e9: e8 32 ea ff ff               	callq	0x1ec20 <emit>
   201ee: 49 89 ed                     	movq	%rbp, %r13
; 	emit(gen, insn2);
   201f1: 4c 89 e7                     	movq	%r12, %rdi
   201f4: 49 c1 e5 20                  	shlq	$32, %r13
   201f8: 4c 89 ee                     	movq	%r13, %rsi
   201fb: e8 20 ea ff ff               	callq	0x1ec20 <emit>
; 	switch (relo->kind) {
   20200: 41 8b 57 08                  	movl	8(%r15), %edx
   20204: 83 fa 0c                     	cmpl	$12, %edx
   20207: 0f 84 7b 01 00 00            	je	0x20388 <bpf_gen__prog_load+0x5f8>
   2020d: 83 fa 0e                     	cmpl	$14, %edx
   20210: 0f 84 0a fe ff ff            	je	0x20020 <bpf_gen__prog_load+0x290>
; 		pr_warn("Unknown relocation kind '%d'\n", relo->kind);
   20216: 48 8d 35 fb 92 01 00         	leaq	103163(%rip), %rsi      # 0x39518 <strs.2+0x6688>
   2021d: 31 ff                        	xorl	%edi, %edi
   2021f: 31 c0                        	xorl	%eax, %eax
; 	for (i = 0; i < gen->relo_cnt; i++)
   20221: 48 83 c3 01                  	addq	$1, %rbx
; 		pr_warn("Unknown relocation kind '%d'\n", relo->kind);
   20225: e8 a6 7e fe ff               	callq	0x80d0 <libbpf_print>
; 		gen->error = -EDOM;
   2022a: 41 c7 44 24 3c df ff ff ff   	movl	$4294967263, 60(%r12)   # imm = 0xFFFFFFDF
; 	for (i = 0; i < gen->relo_cnt; i++)
   20233: 41 39 5c 24 48               	cmpl	%ebx, 72(%r12)
   20238: 0f 8f 71 ff ff ff            	jg	0x201af <bpf_gen__prog_load+0x41f>
; 	emit_sys_bpf(gen, BPF_PROG_LOAD, prog_load_attr, attr_size);
   2023e: 8b 54 24 10                  	movl	16(%rsp), %edx
   20242: b9 8c 00 00 00               	movl	$140, %ecx
   20247: be 05 00 00 00               	movl	$5, %esi
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   2024c: 31 db                        	xorl	%ebx, %ebx
; 	emit_sys_bpf(gen, BPF_PROG_LOAD, prog_load_attr, attr_size);
   2024e: 4c 89 e7                     	movq	%r12, %rdi
   20251: e8 3a eb ff ff               	callq	0x1ed90 <emit_sys_bpf>
; 	debug_ret(gen, "prog_load %s insn_cnt %d", attr.prog_name, attr.insn_cnt);
   20256: 8b 4c 24 34                  	movl	52(%rsp), %ecx
   2025a: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   2025f: 31 c0                        	xorl	%eax, %eax
   20261: 48 8d 35 f1 8f 01 00         	leaq	102385(%rip), %rsi      # 0x39259 <strs.2+0x63c9>
   20268: 4c 89 e7                     	movq	%r12, %rdi
   2026b: e8 20 ee ff ff               	callq	0x1f090 <debug_ret>
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   20270: 45 8b 94 24 e8 00 00 00      	movl	232(%r12), %r10d
   20278: 45 85 d2                     	testl	%r10d, %r10d
   2027b: 75 1c                        	jne	0x20299 <bpf_gen__prog_load+0x509>
   2027d: eb 69                        	jmp	0x202e8 <bpf_gen__prog_load+0x558>
   2027f: 90                           	nop
; 		} else if (gen->ksyms[i].kind == BTF_KIND_FUNC) {
   20280: 83 f8 0c                     	cmpl	$12, %eax
   20283: 0f 84 e7 03 00 00            	je	0x20670 <bpf_gen__prog_load+0x8e0>
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   20289: 41 8b 84 24 e8 00 00 00      	movl	232(%r12), %eax
   20291: 48 83 c3 01                  	addq	$1, %rbx
   20295: 39 d8                        	cmpl	%ebx, %eax
   20297: 76 47                        	jbe	0x202e0 <bpf_gen__prog_load+0x550>
; 		if (gen->ksyms[i].kind == BTF_KIND_VAR && !gen->ksyms[i].typeless) {
   20299: 49 8b 94 24 e0 00 00 00      	movq	224(%r12), %rdx
   202a1: 48 8d 2c 5b                  	leaq	(%rbx,%rbx,2), %rbp
   202a5: 48 c1 e5 03                  	shlq	$3, %rbp
   202a9: 48 01 ea                     	addq	%rbp, %rdx
   202ac: 8b 42 0c                     	movl	12(%rdx), %eax
   202af: 83 f8 0e                     	cmpl	$14, %eax
   202b2: 75 cc                        	jne	0x20280 <bpf_gen__prog_load+0x4f0>
   202b4: 80 7a 10 00                  	cmpb	$0, 16(%rdx)
   202b8: 75 cf                        	jne	0x20289 <bpf_gen__prog_load+0x4f9>
; 			insn += sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm);
   202ba: 8b 72 14                     	movl	20(%rdx), %esi
; 			emit_sys_close_blob(gen, insn);
   202bd: 4c 89 e7                     	movq	%r12, %rdi
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   202c0: 48 83 c3 01                  	addq	$1, %rbx
; 			insn += sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm);
   202c4: 83 c6 0c                     	addl	$12, %esi
; 			emit_sys_close_blob(gen, insn);
   202c7: e8 f4 ee ff ff               	callq	0x1f1c0 <emit_sys_close_blob>
; 	for (i = 0; i < gen->nr_ksyms; i++) {
   202cc: 41 8b 84 24 e8 00 00 00      	movl	232(%r12), %eax
   202d4: 39 d8                        	cmpl	%ebx, %eax
   202d6: 77 c1                        	ja	0x20299 <bpf_gen__prog_load+0x509>
   202d8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (gen->nr_ksyms) {
   202e0: 85 c0                        	testl	%eax, %eax
   202e2: 0f 85 00 04 00 00            	jne	0x206e8 <bpf_gen__prog_load+0x958>
; 	if (gen->relo_cnt) {
   202e8: 41 8b 4c 24 48               	movl	72(%r12), %ecx
   202ed: 85 c9                        	testl	%ecx, %ecx
   202ef: 0f 85 25 04 00 00            	jne	0x2071a <bpf_gen__prog_load+0x98a>
; 	if (!gen->core_relo_cnt)
   202f5: 41 8b 54 24 58               	movl	88(%r12), %edx
   202fa: 85 d2                        	testl	%edx, %edx
   202fc: 74 1c                        	je	0x2031a <bpf_gen__prog_load+0x58a>
; 	free(gen->core_relos);
   202fe: 49 8b 7c 24 50               	movq	80(%r12), %rdi
   20303: e8 b8 53 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	gen->core_relo_cnt = 0;
   20308: 41 c7 44 24 58 00 00 00 00   	movl	$0, 88(%r12)
; 	gen->core_relos = NULL;
   20311: 49 c7 44 24 50 00 00 00 00   	movq	$0, 80(%r12)
; 	if (gen->attach_kind) {
   2031a: 41 8b 84 24 dc 00 00 00      	movl	220(%r12), %eax
   20322: 85 c0                        	testl	%eax, %eax
   20324: 0f 85 46 06 00 00            	jne	0x20970 <bpf_gen__prog_load+0xbe0>
; 	emit_check_err(gen);
   2032a: 4c 89 e7                     	movq	%r12, %rdi
   2032d: e8 8e f0 ff ff               	callq	0x1f3c0 <emit_check_err>
; 	emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_7,
   20332: 41 8b 74 24 30               	movl	48(%r12), %esi
   20337: 4c 89 e7                     	movq	%r12, %rdi
   2033a: 8d 34 b5 80 ff ff ff         	leal	-128(,%rsi,4), %esi
   20341: 0f b7 f6                     	movzwl	%si, %esi
   20344: 48 c1 e6 10                  	shlq	$16, %rsi
   20348: 48 81 ce 63 7a 00 00         	orq	$31331, %rsi            # imm = 0x7A63
   2034f: e8 cc e8 ff ff               	callq	0x1ec20 <emit>
; 	gen->nr_progs++;
   20354: 41 83 44 24 30 01            	addl	$1, 48(%r12)
; }
   2035a: 48 8b 84 24 c8 00 00 00      	movq	200(%rsp), %rax
   20362: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2036b: 0f 85 1f 06 00 00            	jne	0x20990 <bpf_gen__prog_load+0xc00>
   20371: 48 81 c4 d8 00 00 00         	addq	$216, %rsp
   20378: 5b                           	popq	%rbx
   20379: 5d                           	popq	%rbp
   2037a: 41 5c                        	popq	%r12
   2037c: 41 5d                        	popq	%r13
   2037e: 41 5e                        	popq	%r14
   20380: 41 5f                        	popq	%r15
   20382: c3                           	retq
   20383: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	kdesc = get_ksym_desc(gen, relo);
   20388: 4c 89 fe                     	movq	%r15, %rsi
   2038b: 4c 89 e7                     	movq	%r12, %rdi
   2038e: e8 8d e7 ff ff               	callq	0x1eb20 <get_ksym_desc>
   20393: 49 89 c5                     	movq	%rax, %r13
; 	if (!kdesc)
   20396: 48 85 c0                     	testq	%rax, %rax
   20399: 0f 84 01 fe ff ff            	je	0x201a0 <bpf_gen__prog_load+0x410>
; 	if (kdesc->ref > 1) {
   2039f: 83 78 08 01                  	cmpl	$1, 8(%rax)
   203a3: 0f 8f 07 03 00 00            	jg	0x206b0 <bpf_gen__prog_load+0x920>
; 	kdesc->insn = insn;
   203a9: 89 68 14                     	movl	%ebp, 20(%rax)
; 	emit_bpf_find_by_name_kind(gen, relo);
   203ac: 4c 89 fe                     	movq	%r15, %rsi
   203af: 4c 89 e7                     	movq	%r12, %rdi
   203b2: e8 e9 ee ff ff               	callq	0x1f2a0 <emit_bpf_find_by_name_kind>
; 	if (!relo->is_weak)
   203b7: 41 80 7f 10 00               	cmpb	$0, 16(%r15)
   203bc: 0f 84 3e 04 00 00            	je	0x20800 <bpf_gen__prog_load+0xa70>
; 	if (gen->nr_fd_array == MAX_KFUNC_DESCS) {
   203c2: 41 8b ac 24 f0 00 00 00      	movl	240(%r12), %ebp
   203ca: 81 fd 00 01 00 00            	cmpl	$256, %ebp              # imm = 0x100
   203d0: 0f 84 46 04 00 00            	je	0x2081c <bpf_gen__prog_load+0xa8c>
; 	return MAX_USED_MAPS + gen->nr_fd_array++;
   203d6: 8d 45 01                     	leal	1(%rbp), %eax
   203d9: 83 c5 40                     	addl	$64, %ebp
   203dc: 41 89 84 24 f0 00 00 00      	movl	%eax, 240(%r12)
; 	if (btf_fd_idx > INT16_MAX) {
   203e4: 81 fd ff 7f 00 00            	cmpl	$32767, %ebp            # imm = 0x7FFF
   203ea: 0f 8f e8 03 00 00            	jg	0x207d8 <bpf_gen__prog_load+0xa48>
; 	kdesc->off = btf_fd_idx;
   203f0: 41 89 6d 10                  	movl	%ebp, 16(%r13)
; 	emit(gen, BPF_JMP_IMM(BPF_JSGE, BPF_REG_7, 0, 3));
   203f4: be 75 07 03 00               	movl	$198517, %esi           # imm = 0x30775
   203f9: 4c 89 e7                     	movq	%r12, %rdi
   203fc: e8 1f e8 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ST_MEM(BPF_W, BPF_REG_8, offsetof(struct bpf_insn, imm), 0));
   20401: be 62 08 04 00               	movl	$264290, %esi           # imm = 0x40862
   20406: 4c 89 e7                     	movq	%r12, %rdi
   20409: e8 12 e8 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ST_MEM(BPF_H, BPF_REG_8, offsetof(struct bpf_insn, off), 0));
   2040e: be 6a 08 02 00               	movl	$133226, %esi           # imm = 0x2086A
   20413: 4c 89 e7                     	movq	%r12, %rdi
   20416: e8 05 e8 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_JMP_IMM(BPF_JA, 0, 0, 10));
   2041b: be 05 00 0a 00               	movl	$655365, %esi           # imm = 0xA0005
   20420: 4c 89 e7                     	movq	%r12, %rdi
   20423: e8 f8 e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_8, BPF_REG_7, offsetof(struct bpf_insn, imm)));
   20428: be 63 78 04 00               	movl	$292963, %esi           # imm = 0x47863
   2042d: 4c 89 e7                     	movq	%r12, %rdi
   20430: e8 eb e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_REG(BPF_REG_9, BPF_REG_7));
   20435: be bf 79 00 00               	movl	$31167, %esi            # imm = 0x79BF
   2043a: 4c 89 e7                     	movq	%r12, %rdi
   2043d: e8 de e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ALU64_IMM(BPF_RSH, BPF_REG_9, 32));
   20442: 4c 89 e7                     	movq	%r12, %rdi
   20445: 48 be 77 09 00 00 20 00 00 00	movabsq	$137438955895, %rsi     # imm = 0x2000000977
   2044f: e8 cc e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0, 2));
   20454: be 55 09 02 00               	movl	$133461, %esi           # imm = 0x20955
   20459: 4c 89 e7                     	movq	%r12, %rdi
   2045c: e8 bf e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ST_MEM(BPF_H, BPF_REG_8, offsetof(struct bpf_insn, off), 0));
   20461: be 6a 08 02 00               	movl	$133226, %esi           # imm = 0x2086A
   20466: 4c 89 e7                     	movq	%r12, %rdi
   20469: e8 b2 e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_JMP_IMM(BPF_JA, 0, 0, 4));
   2046e: be 05 00 04 00               	movl	$262149, %esi           # imm = 0x40005
   20473: 4c 89 e7                     	movq	%r12, %rdi
   20476: e8 a5 e7 ff ff               	callq	0x1ec20 <emit>
; 	return gen->fd_array + index * sizeof(int);
   2047b: 41 8b 84 24 ec 00 00 00      	movl	236(%r12), %eax
; 	emit(gen, insn1);
   20483: be 18 60 00 00               	movl	$24600, %esi            # imm = 0x6018
   20488: 4c 89 e7                     	movq	%r12, %rdi
   2048b: 44 8d 04 a8                  	leal	(%rax,%rbp,4), %r8d
   2048f: 49 c1 e0 20                  	shlq	$32, %r8
   20493: 4c 89 44 24 20               	movq	%r8, 32(%rsp)
   20498: e8 83 e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   2049d: 48 8b 74 24 20               	movq	32(%rsp), %rsi
   204a2: 4c 89 e7                     	movq	%r12, %rdi
   204a5: e8 76 e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_0, BPF_REG_9, 0));
   204aa: be 63 90 00 00               	movl	$36963, %esi            # imm = 0x9063
   204af: 4c 89 e7                     	movq	%r12, %rdi
   204b2: e8 69 e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ST_MEM(BPF_H, BPF_REG_8, offsetof(struct bpf_insn, off), btf_fd_idx));
   204b7: 48 89 ee                     	movq	%rbp, %rsi
   204ba: 4c 89 e7                     	movq	%r12, %rdi
   204bd: 48 c1 e6 20                  	shlq	$32, %rsi
   204c1: 48 81 ce 6a 08 02 00         	orq	$133226, %rsi           # imm = 0x2086A
   204c8: e8 53 e7 ff ff               	callq	0x1ec20 <emit>
; 	if (!gen->log_level)
   204cd: 41 8b 74 24 38               	movl	56(%r12), %esi
   204d2: 85 f6                        	testl	%esi, %esi
   204d4: 0f 84 c6 fc ff ff            	je	0x201a0 <bpf_gen__prog_load+0x410>
; 	emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_8,
   204da: 4c 89 e7                     	movq	%r12, %rdi
   204dd: be 61 87 04 00               	movl	$296801, %esi           # imm = 0x48761
   204e2: e8 39 e7 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(BPF_H, BPF_REG_9, BPF_REG_8,
   204e7: 4c 89 e7                     	movq	%r12, %rdi
   204ea: be 69 89 02 00               	movl	$166249, %esi           # imm = 0x28969
   204ef: e8 2c e7 ff ff               	callq	0x1ec20 <emit>
; 	debug_regs(gen, BPF_REG_7, BPF_REG_9, " func (%s:count=%d): imm: %%d, off: %%d",
   204f4: 45 8b 4d 08                  	movl	8(%r13), %r9d
   204f8: 4d 8b 07                     	movq	(%r15), %r8
   204fb: 4c 89 e7                     	movq	%r12, %rdi
   204fe: 48 8d 0d eb 8f 01 00         	leaq	102379(%rip), %rcx      # 0x394f0 <strs.2+0x6660>
   20505: 31 c0                        	xorl	%eax, %eax
   20507: ba 09 00 00 00               	movl	$9, %edx
   2050c: be 07 00 00 00               	movl	$7, %esi
   20511: e8 ca ea ff ff               	callq	0x1efe0 <debug_regs>
; 	return gen->fd_array + index * sizeof(int);
   20516: 41 8b 55 10                  	movl	16(%r13), %edx
; 	emit(gen, insn1);
   2051a: 4c 89 e7                     	movq	%r12, %rdi
; 	return gen->fd_array + index * sizeof(int);
   2051d: 41 8b 84 24 ec 00 00 00      	movl	236(%r12), %eax
; 	emit(gen, insn1);
   20525: be 18 60 00 00               	movl	$24600, %esi            # imm = 0x6018
   2052a: 8d 2c 90                     	leal	(%rax,%rdx,4), %ebp
   2052d: e8 ee e6 ff ff               	callq	0x1ec20 <emit>
   20532: 48 c1 e5 20                  	shlq	$32, %rbp
; 	emit(gen, insn2);
   20536: 4c 89 e7                     	movq	%r12, %rdi
   20539: 48 89 ee                     	movq	%rbp, %rsi
   2053c: e8 df e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_9, BPF_REG_0, 0));
   20541: 4c 89 e7                     	movq	%r12, %rdi
   20544: be 61 09 00 00               	movl	$2401, %esi             # imm = 0x961
   20549: e8 d2 e6 ff ff               	callq	0x1ec20 <emit>
; 	debug_regs(gen, BPF_REG_9, -1, " func (%s:count=%d): btf_fd",
   2054e: 45 8b 4d 08                  	movl	8(%r13), %r9d
   20552: 4d 8b 07                     	movq	(%r15), %r8
   20555: 4c 89 e7                     	movq	%r12, %rdi
   20558: 48 8d 0d 2f 8d 01 00         	leaq	101679(%rip), %rcx      # 0x3928e <strs.2+0x63fe>
   2055f: ba ff ff ff ff               	movl	$4294967295, %edx       # imm = 0xFFFFFFFF
   20564: be 09 00 00 00               	movl	$9, %esi
   20569: 31 c0                        	xorl	%eax, %eax
   2056b: e8 70 ea ff ff               	callq	0x1efe0 <debug_regs>
   20570: e9 2b fc ff ff               	jmp	0x201a0 <bpf_gen__prog_load+0x410>
   20575: 0f 1f 00                     	nopl	(%rax)
; 	kdesc = get_ksym_desc(gen, relo);
   20578: e8 a3 e5 ff ff               	callq	0x1eb20 <get_ksym_desc>
   2057d: 49 89 c5                     	movq	%rax, %r13
; 	if (!kdesc)
   20580: 48 85 c0                     	testq	%rax, %rax
   20583: 0f 84 17 fc ff ff            	je	0x201a0 <bpf_gen__prog_load+0x410>
; 	if (kdesc->ref > 1) {
   20589: 83 78 08 01                  	cmpl	$1, 8(%rax)
   2058d: 0f 8f bd 01 00 00            	jg	0x20750 <bpf_gen__prog_load+0x9c0>
; 	kdesc->insn = insn;
   20593: 89 68 14                     	movl	%ebp, 20(%rax)
; 	emit_bpf_find_by_name_kind(gen, relo);
   20596: 4c 89 fe                     	movq	%r15, %rsi
   20599: 4c 89 e7                     	movq	%r12, %rdi
   2059c: e8 ff ec ff ff               	callq	0x1f2a0 <emit_bpf_find_by_name_kind>
; 	if (!relo->is_weak)
   205a1: 41 80 7f 10 00               	cmpb	$0, 16(%r15)
   205a6: 0f 84 94 01 00 00            	je	0x20740 <bpf_gen__prog_load+0x9b0>
; 	emit(gen, BPF_JMP_IMM(BPF_JSGE, BPF_REG_7, 0, 3));
   205ac: be 75 07 03 00               	movl	$198517, %esi           # imm = 0x30775
   205b1: 4c 89 e7                     	movq	%r12, %rdi
   205b4: e8 67 e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ST_MEM(BPF_W, BPF_REG_8, offsetof(struct bpf_insn, imm), 0));
   205b9: be 62 08 04 00               	movl	$264290, %esi           # imm = 0x40862
   205be: 4c 89 e7                     	movq	%r12, %rdi
   205c1: e8 5a e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ST_MEM(BPF_W, BPF_REG_8, sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm), 0));
   205c6: be 62 08 0c 00               	movl	$788578, %esi           # imm = 0xC0862
   205cb: 4c 89 e7                     	movq	%r12, %rdi
   205ce: e8 4d e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_JMP_IMM(BPF_JA, 0, 0, 4));
   205d3: be 05 00 04 00               	movl	$262149, %esi           # imm = 0x40005
   205d8: 4c 89 e7                     	movq	%r12, %rdi
   205db: e8 40 e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_8, BPF_REG_7, offsetof(struct bpf_insn, imm)));
   205e0: be 63 78 04 00               	movl	$292963, %esi           # imm = 0x47863
   205e5: 4c 89 e7                     	movq	%r12, %rdi
   205e8: e8 33 e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ALU64_IMM(BPF_RSH, BPF_REG_7, 32));
   205ed: 4c 89 e7                     	movq	%r12, %rdi
   205f0: 48 be 77 07 00 00 20 00 00 00	movabsq	$137438955383, %rsi     # imm = 0x2000000777
   205fa: e8 21 e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_8, BPF_REG_7,
   205ff: be 63 78 0c 00               	movl	$817251, %esi           # imm = 0xC7863
   20604: 4c 89 e7                     	movq	%r12, %rdi
   20607: e8 14 e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_JMP_IMM(BPF_JSGE, BPF_REG_7, 0, 3));
   2060c: be 75 07 03 00               	movl	$198517, %esi           # imm = 0x30775
   20611: 4c 89 e7                     	movq	%r12, %rdi
   20614: e8 07 e6 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(BPF_B, BPF_REG_9, BPF_REG_8, offsetofend(struct bpf_insn, code)));
   20619: be 71 89 01 00               	movl	$100721, %esi           # imm = 0x18971
   2061e: 4c 89 e7                     	movq	%r12, %rdi
   20621: e8 fa e5 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_ALU32_IMM(BPF_AND, BPF_REG_9, reg_mask));
   20626: 4c 89 e7                     	movq	%r12, %rdi
   20629: 48 be 54 09 00 00 0f 00 00 00	movabsq	$64424511828, %rsi      # imm = 0xF00000954
   20633: e8 e8 e5 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_STX_MEM(BPF_B, BPF_REG_8, BPF_REG_9, offsetofend(struct bpf_insn, code)));
   20638: 4c 89 e7                     	movq	%r12, %rdi
   2063b: be 73 98 01 00               	movl	$104563, %esi           # imm = 0x19873
   20640: e8 db e5 ff ff               	callq	0x1ec20 <emit>
; 	if (!gen->log_level)
   20645: 41 8b 7c 24 38               	movl	56(%r12), %edi
   2064a: 85 ff                        	testl	%edi, %edi
   2064c: 0f 84 4e fb ff ff            	je	0x201a0 <bpf_gen__prog_load+0x410>
   20652: 41 8b 55 08                  	movl	8(%r13), %edx
   20656: 4c 89 fe                     	movq	%r15, %rsi
   20659: 4c 89 e7                     	movq	%r12, %rdi
   2065c: e8 af eb ff ff               	callq	0x1f210 <emit_ksym_relo_log.part.0>
   20661: e9 3a fb ff ff               	jmp	0x201a0 <bpf_gen__prog_load+0x410>
   20666: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	return gen->fd_array + index * sizeof(int);
   20670: 41 8b 84 24 ec 00 00 00      	movl	236(%r12), %eax
   20678: 8b 52 10                     	movl	16(%rdx), %edx
; 			emit_sys_close_blob(gen, blob_fd_array_off(gen, gen->ksyms[i].off));
   2067b: 4c 89 e7                     	movq	%r12, %rdi
; 	return gen->fd_array + index * sizeof(int);
   2067e: 8d 34 90                     	leal	(%rax,%rdx,4), %esi
; 			emit_sys_close_blob(gen, blob_fd_array_off(gen, gen->ksyms[i].off));
   20681: e8 3a eb ff ff               	callq	0x1f1c0 <emit_sys_close_blob>
; 			if (gen->ksyms[i].off < MAX_FD_ARRAY_SZ)
   20686: 49 8b 84 24 e0 00 00 00      	movq	224(%r12), %rax
   2068e: 81 7c 28 10 3f 01 00 00      	cmpl	$319, 16(%rax,%rbp)     # imm = 0x13F
   20696: 0f 8f ed fb ff ff            	jg	0x20289 <bpf_gen__prog_load+0x4f9>
; 				gen->nr_fd_array--;
   2069c: 41 83 ac 24 f0 00 00 00 01   	subl	$1, 240(%r12)
   206a5: e9 df fb ff ff               	jmp	0x20289 <bpf_gen__prog_load+0x4f9>
   206aa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			       kdesc->insn + offsetof(struct bpf_insn, imm));
   206b0: 8b 40 14                     	movl	20(%rax), %eax
; 		move_blob2blob(gen, insn + offsetof(struct bpf_insn, imm), 4,
   206b3: 8d 75 04                     	leal	4(%rbp), %esi
   206b6: 4c 89 e7                     	movq	%r12, %rdi
   206b9: ba 04 00 00 00               	movl	$4, %edx
; 			       kdesc->insn + offsetof(struct bpf_insn, imm));
   206be: 8d 48 04                     	leal	4(%rax), %ecx
; 		move_blob2blob(gen, insn + offsetof(struct bpf_insn, imm), 4,
   206c1: e8 4a e7 ff ff               	callq	0x1ee10 <move_blob2blob>
; 			       kdesc->insn + offsetof(struct bpf_insn, off));
   206c6: 41 8b 45 14                  	movl	20(%r13), %eax
; 		move_blob2blob(gen, insn + offsetof(struct bpf_insn, off), 2,
   206ca: 8d 75 02                     	leal	2(%rbp), %esi
   206cd: 4c 89 e7                     	movq	%r12, %rdi
   206d0: ba 02 00 00 00               	movl	$2, %edx
; 			       kdesc->insn + offsetof(struct bpf_insn, off));
   206d5: 8d 48 02                     	leal	2(%rax), %ecx
; 		move_blob2blob(gen, insn + offsetof(struct bpf_insn, off), 2,
   206d8: e8 33 e7 ff ff               	callq	0x1ee10 <move_blob2blob>
; 		goto log;
   206dd: e9 eb fd ff ff               	jmp	0x204cd <bpf_gen__prog_load+0x73d>
   206e2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		free(gen->ksyms);
   206e8: 49 8b bc 24 e0 00 00 00      	movq	224(%r12), %rdi
   206f0: e8 cb 4f fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (gen->relo_cnt) {
   206f5: 41 8b 4c 24 48               	movl	72(%r12), %ecx
; 		gen->nr_ksyms = 0;
   206fa: 41 c7 84 24 e8 00 00 00 00 00 00 00  	movl	$0, 232(%r12)
; 		gen->ksyms = NULL;
   20706: 49 c7 84 24 e0 00 00 00 00 00 00 00  	movq	$0, 224(%r12)
; 	if (gen->relo_cnt) {
   20712: 85 c9                        	testl	%ecx, %ecx
   20714: 0f 84 db fb ff ff            	je	0x202f5 <bpf_gen__prog_load+0x565>
; 		free(gen->relos);
   2071a: 49 8b 7c 24 40               	movq	64(%r12), %rdi
   2071f: e8 9c 4f fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		gen->relo_cnt = 0;
   20724: 41 c7 44 24 48 00 00 00 00   	movl	$0, 72(%r12)
; 		gen->relos = NULL;
   2072d: 49 c7 44 24 40 00 00 00 00   	movq	$0, 64(%r12)
   20736: e9 ba fb ff ff               	jmp	0x202f5 <bpf_gen__prog_load+0x565>
   2073b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		emit_check_err(gen);
   20740: 4c 89 e7                     	movq	%r12, %rdi
   20743: e8 78 ec ff ff               	callq	0x1f3c0 <emit_check_err>
   20748: e9 5f fe ff ff               	jmp	0x205ac <bpf_gen__prog_load+0x81c>
   2074d: 0f 1f 00                     	nopl	(%rax)
; 			       kdesc->insn + offsetof(struct bpf_insn, imm));
   20750: 8b 40 14                     	movl	20(%rax), %eax
; 		move_blob2blob(gen, insn + offsetof(struct bpf_insn, imm), 4,
   20753: 8d 75 04                     	leal	4(%rbp), %esi
   20756: 4c 89 e7                     	movq	%r12, %rdi
   20759: ba 04 00 00 00               	movl	$4, %edx
; 			       kdesc->insn + offsetof(struct bpf_insn, imm));
   2075e: 8d 48 04                     	leal	4(%rax), %ecx
; 		move_blob2blob(gen, insn + offsetof(struct bpf_insn, imm), 4,
   20761: e8 aa e6 ff ff               	callq	0x1ee10 <move_blob2blob>
; 			       kdesc->insn + sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm));
   20766: 41 8b 45 14                  	movl	20(%r13), %eax
; 		move_blob2blob(gen, insn + sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm), 4,
   2076a: 8d 75 0c                     	leal	12(%rbp), %esi
   2076d: 4c 89 e7                     	movq	%r12, %rdi
   20770: ba 04 00 00 00               	movl	$4, %edx
; 			       kdesc->insn + sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm));
   20775: 8d 48 0c                     	leal	12(%rax), %ecx
; 		move_blob2blob(gen, insn + sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm), 4,
   20778: e8 93 e6 ff ff               	callq	0x1ee10 <move_blob2blob>
; 		emit(gen, BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 3));
   2077d: be 55 00 03 00               	movl	$196693, %esi           # imm = 0x30055
   20782: 4c 89 e7                     	movq	%r12, %rdi
   20785: e8 96 e4 ff ff               	callq	0x1ec20 <emit>
; 		goto clear_src_reg;
   2078a: e9 8a fe ff ff               	jmp	0x20619 <bpf_gen__prog_load+0x889>
   2078f: 90                           	nop
; 			       kdesc->insn + offsetof(struct bpf_insn, imm));
   20790: 8b 40 14                     	movl	20(%rax), %eax
; 		move_blob2blob(gen, insn + offsetof(struct bpf_insn, imm), 4,
   20793: 8d 75 04                     	leal	4(%rbp), %esi
   20796: ba 04 00 00 00               	movl	$4, %edx
   2079b: 4c 89 e7                     	movq	%r12, %rdi
; 			       kdesc->insn + offsetof(struct bpf_insn, imm));
   2079e: 4c 89 44 24 20               	movq	%r8, 32(%rsp)
   207a3: 8d 48 04                     	leal	4(%rax), %ecx
; 		move_blob2blob(gen, insn + offsetof(struct bpf_insn, imm), 4,
   207a6: e8 65 e6 ff ff               	callq	0x1ee10 <move_blob2blob>
; 			       kdesc->insn + sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm));
   207ab: 4c 8b 44 24 20               	movq	32(%rsp), %r8
; 		move_blob2blob(gen, insn + sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm), 4,
   207b0: 8d 75 0c                     	leal	12(%rbp), %esi
   207b3: 4c 89 e7                     	movq	%r12, %rdi
   207b6: ba 04 00 00 00               	movl	$4, %edx
; 			       kdesc->insn + sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm));
   207bb: 41 8b 40 14                  	movl	20(%r8), %eax
   207bf: 8d 48 0c                     	leal	12(%rax), %ecx
; 		move_blob2blob(gen, insn + sizeof(struct bpf_insn) + offsetof(struct bpf_insn, imm), 4,
   207c2: e8 49 e6 ff ff               	callq	0x1ee10 <move_blob2blob>
; 		goto log;
   207c7: 4c 8b 44 24 20               	movq	32(%rsp), %r8
   207cc: e9 b5 f9 ff ff               	jmp	0x20186 <bpf_gen__prog_load+0x3f6>
   207d1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("BTF fd off %d for kfunc %s exceeds INT16_MAX, cannot process relocation\n",
   207d8: 49 8b 0f                     	movq	(%r15), %rcx
   207db: 89 ea                        	movl	%ebp, %edx
   207dd: 48 8d 35 b4 8c 01 00         	leaq	101556(%rip), %rsi      # 0x39498 <strs.2+0x6608>
   207e4: 31 ff                        	xorl	%edi, %edi
   207e6: 31 c0                        	xorl	%eax, %eax
   207e8: e8 e3 78 fe ff               	callq	0x80d0 <libbpf_print>
; 		gen->error = -E2BIG;
   207ed: 41 c7 44 24 3c f9 ff ff ff   	movl	$4294967289, 60(%r12)   # imm = 0xFFFFFFF9
; 		return;
   207f6: e9 a5 f9 ff ff               	jmp	0x201a0 <bpf_gen__prog_load+0x410>
   207fb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		emit_check_err(gen);
   20800: 4c 89 e7                     	movq	%r12, %rdi
   20803: e8 b8 eb ff ff               	callq	0x1f3c0 <emit_check_err>
; 	if (gen->nr_fd_array == MAX_KFUNC_DESCS) {
   20808: 41 8b ac 24 f0 00 00 00      	movl	240(%r12), %ebp
   20810: 81 fd 00 01 00 00            	cmpl	$256, %ebp              # imm = 0x100
   20816: 0f 85 ba fb ff ff            	jne	0x203d6 <bpf_gen__prog_load+0x646>
; 		cur = add_data(gen, NULL, sizeof(int));
   2081c: ba 04 00 00 00               	movl	$4, %edx
   20821: 31 f6                        	xorl	%esi, %esi
   20823: 4c 89 e7                     	movq	%r12, %rdi
   20826: e8 c5 e1 ff ff               	callq	0x1e9f0 <add_data>
; 		return (cur - gen->fd_array) / sizeof(int);
   2082b: 41 2b 84 24 ec 00 00 00      	subl	236(%r12), %eax
   20833: 48 63 e8                     	movslq	%eax, %rbp
   20836: 48 c1 ed 02                  	shrq	$2, %rbp
   2083a: e9 a5 fb ff ff               	jmp	0x203e4 <bpf_gen__prog_load+0x654>
   2083f: 90                           	nop
; 	int name, len = strlen(gen->attach_target) + 1;
   20840: 4d 8d 7c 24 5c               	leaq	92(%r12), %r15
   20845: 4c 89 ff                     	movq	%r15, %rdi
   20848: e8 93 4f fe ff               	callq	0x57e0 <.plt.sec+0x170>
; 	pr_debug("gen: find_attach_tgt %s %d\n", gen->attach_target, gen->attach_kind);
   2084d: 44 89 f1                     	movl	%r14d, %ecx
   20850: 4c 89 fa                     	movq	%r15, %rdx
   20853: bf 02 00 00 00               	movl	$2, %edi
; 	int name, len = strlen(gen->attach_target) + 1;
   20858: 8d 58 01                     	leal	1(%rax), %ebx
; 	pr_debug("gen: find_attach_tgt %s %d\n", gen->attach_target, gen->attach_kind);
   2085b: 48 8d 35 e6 8b 01 00         	leaq	101350(%rip), %rsi      # 0x39448 <strs.2+0x65b8>
   20862: 31 c0                        	xorl	%eax, %eax
   20864: e8 67 78 fe ff               	callq	0x80d0 <libbpf_print>
; 	name = add_data(gen, gen->attach_target, len);
   20869: 89 da                        	movl	%ebx, %edx
   2086b: 4c 89 fe                     	movq	%r15, %rsi
   2086e: 4c 89 e7                     	movq	%r12, %rdi
   20871: e8 7a e1 ff ff               	callq	0x1e9f0 <add_data>
; 	emit(gen, insn1);
   20876: 4c 89 e7                     	movq	%r12, %rdi
   20879: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   2087e: 48 89 c5                     	movq	%rax, %rbp
   20881: e8 9a e3 ff ff               	callq	0x1ec20 <emit>
   20886: 48 c1 e5 20                  	shlq	$32, %rbp
; 	emit(gen, insn2);
   2088a: 4c 89 e7                     	movq	%r12, %rdi
   2088d: 48 89 ee                     	movq	%rbp, %rsi
   20890: e8 8b e3 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_2, len));
   20895: 48 89 de                     	movq	%rbx, %rsi
   20898: 4c 89 e7                     	movq	%r12, %rdi
   2089b: 48 c1 e6 20                  	shlq	$32, %rsi
   2089f: 48 81 ce b7 02 00 00         	orq	$695, %rsi              # imm = 0x2B7
   208a6: e8 75 e3 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_3, gen->attach_kind));
   208ab: 41 8b b4 24 dc 00 00 00      	movl	220(%r12), %esi
   208b3: 4c 89 e7                     	movq	%r12, %rdi
   208b6: 48 c1 e6 20                  	shlq	$32, %rsi
   208ba: 48 81 ce b7 03 00 00         	orq	$951, %rsi              # imm = 0x3B7
   208c1: e8 5a e3 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_4, 0));
   208c6: 4c 89 e7                     	movq	%r12, %rdi
   208c9: be b7 04 00 00               	movl	$1207, %esi             # imm = 0x4B7
   208ce: e8 4d e3 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_btf_find_by_name_kind));
   208d3: 4c 89 e7                     	movq	%r12, %rdi
   208d6: 48 be 85 00 00 00 a7 00 00 00	movabsq	$717259538565, %rsi     # imm = 0xA700000085
   208e0: e8 3b e3 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_REG(BPF_REG_7, BPF_REG_0));
   208e5: 4c 89 e7                     	movq	%r12, %rdi
   208e8: be bf 07 00 00               	movl	$1983, %esi             # imm = 0x7BF
   208ed: e8 2e e3 ff ff               	callq	0x1ec20 <emit>
; 	debug_ret(gen, "find_by_name_kind(%s,%d)",
   208f2: 4c 89 fa                     	movq	%r15, %rdx
   208f5: 31 c0                        	xorl	%eax, %eax
   208f7: 4c 89 e7                     	movq	%r12, %rdi
   208fa: 41 8b 8c 24 dc 00 00 00      	movl	220(%r12), %ecx
   20902: 48 8d 35 0e 89 01 00         	leaq	100622(%rip), %rsi      # 0x39217 <strs.2+0x6387>
   20909: e8 82 e7 ff ff               	callq	0x1f090 <debug_ret>
; 	emit_check_err(gen);
   2090e: 4c 89 e7                     	movq	%r12, %rdi
   20911: e8 aa ea ff ff               	callq	0x1f3c0 <emit_check_err>
; 		emit2(gen, BPF_LD_IMM64_RAW_FULL(BPF_REG_0, BPF_PSEUDO_MAP_IDX_VALUE,
   20916: 48 8b 6c 24 10               	movq	16(%rsp), %rbp
; 	emit(gen, insn1);
   2091b: 4c 89 e7                     	movq	%r12, %rdi
   2091e: be 18 60 00 00               	movl	$24600, %esi            # imm = 0x6018
   20923: e8 f8 e2 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   20928: 4c 89 e7                     	movq	%r12, %rdi
   2092b: 48 c1 e5 20                  	shlq	$32, %rbp
   2092f: 48 89 ee                     	movq	%rbp, %rsi
   20932: e8 e9 e2 ff ff               	callq	0x1ec20 <emit>
; 		emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_0, BPF_REG_7,
   20937: 4c 89 e7                     	movq	%r12, %rdi
   2093a: be 63 70 6c 00               	movl	$7106659, %esi          # imm = 0x6C7063
   2093f: e8 dc e2 ff ff               	callq	0x1ec20 <emit>
; 		emit(gen, BPF_ALU64_IMM(BPF_RSH, BPF_REG_7, 32));
   20944: 4c 89 e7                     	movq	%r12, %rdi
   20947: 48 be 77 07 00 00 20 00 00 00	movabsq	$137438955383, %rsi     # imm = 0x2000000777
   20951: e8 ca e2 ff ff               	callq	0x1ec20 <emit>
; 		emit(gen, BPF_STX_MEM(BPF_W, BPF_REG_0, BPF_REG_7,
   20956: be 63 70 70 00               	movl	$7368803, %esi          # imm = 0x707063
   2095b: 4c 89 e7                     	movq	%r12, %rdi
   2095e: e8 bd e2 ff ff               	callq	0x1ec20 <emit>
   20963: e9 94 f6 ff ff               	jmp	0x1fffc <bpf_gen__prog_load+0x26c>
   20968: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 				    attr_field(prog_load_attr, attach_btf_obj_fd));
   20970: 8b 74 24 10                  	movl	16(%rsp), %esi
; 		emit_sys_close_blob(gen,
   20974: 4c 89 e7                     	movq	%r12, %rdi
; 				    attr_field(prog_load_attr, attach_btf_obj_fd));
   20977: 83 c6 70                     	addl	$112, %esi
; 		emit_sys_close_blob(gen,
   2097a: e8 41 e8 ff ff               	callq	0x1f1c0 <emit_sys_close_blob>
; 		gen->attach_kind = 0;
   2097f: 41 c7 84 24 dc 00 00 00 00 00 00 00  	movl	$0, 220(%r12)
   2098b: e9 9a f9 ff ff               	jmp	0x2032a <bpf_gen__prog_load+0x59a>
; }
   20990: e8 6b 4e fe ff               	callq	0x5800 <.plt.sec+0x190>
   20995: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

00000000000209a0 <bpf_gen__map_update_elem>:
; {
   209a0: f3 0f 1e fa                  	endbr64
   209a4: 41 57                        	pushq	%r15
;   return __builtin___memset_chk (__dest, __ch, __len,
   209a6: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   209aa: 41 56                        	pushq	%r14
   209ac: 41 89 f6                     	movl	%esi, %r14d
   209af: 41 55                        	pushq	%r13
   209b1: 49 89 d5                     	movq	%rdx, %r13
; 	pr_debug("gen: map_update_elem: idx %d\n", map_idx);
   209b4: 89 f2                        	movl	%esi, %edx
   209b6: 48 8d 35 83 8b 01 00         	leaq	101251(%rip), %rsi      # 0x39540 <strs.2+0x66b0>
; {
   209bd: 41 54                        	pushq	%r12
   209bf: 41 89 cc                     	movl	%ecx, %r12d
   209c2: 55                           	pushq	%rbp
   209c3: 48 89 fd                     	movq	%rdi, %rbp
; 	pr_debug("gen: map_update_elem: idx %d\n", map_idx);
   209c6: bf 02 00 00 00               	movl	$2, %edi
; {
   209cb: 53                           	pushq	%rbx
   209cc: 48 81 ec c8 00 00 00         	subq	$200, %rsp
   209d3: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   209dc: 48 89 84 24 b8 00 00 00      	movq	%rax, 184(%rsp)
   209e4: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   209e6: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   209eb: 48 8d 5c 24 20               	leaq	32(%rsp), %rbx
   209f0: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	int zero = 0;
   209f5: c7 44 24 1c 00 00 00 00      	movl	$0, 28(%rsp)
; 	pr_debug("gen: map_update_elem: idx %d\n", map_idx);
   209fd: e8 ce 76 fe ff               	callq	0x80d0 <libbpf_print>
; 	value = add_data(gen, pvalue, value_size);
   20a02: 4c 89 ee                     	movq	%r13, %rsi
   20a05: 44 89 e2                     	movl	%r12d, %edx
   20a08: 48 89 ef                     	movq	%rbp, %rdi
   20a0b: e8 e0 df ff ff               	callq	0x1e9f0 <add_data>
; 	key = add_data(gen, &zero, sizeof(zero));
   20a10: ba 04 00 00 00               	movl	$4, %edx
   20a15: 48 8d 74 24 1c               	leaq	28(%rsp), %rsi
   20a1a: 48 89 ef                     	movq	%rbp, %rdi
; 	value = add_data(gen, pvalue, value_size);
   20a1d: 41 89 c5                     	movl	%eax, %r13d
; 	key = add_data(gen, &zero, sizeof(zero));
   20a20: e8 cb df ff ff               	callq	0x1e9f0 <add_data>
; 	emit(gen, BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_6,
   20a25: 44 89 f6                     	movl	%r14d, %esi
   20a28: 48 89 ef                     	movq	%rbp, %rdi
   20a2b: c1 e6 04                     	shll	$4, %esi
; 	key = add_data(gen, &zero, sizeof(zero));
   20a2e: 41 89 c7                     	movl	%eax, %r15d
; 	emit(gen, BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_6,
   20a31: 83 c6 20                     	addl	$32, %esi
   20a34: 0f b7 f6                     	movzwl	%si, %esi
   20a37: 48 c1 e6 10                  	shlq	$16, %rsi
   20a3b: 48 81 ce 79 63 00 00         	orq	$25465, %rsi            # imm = 0x6379
   20a42: e8 d9 e1 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_JMP_IMM(BPF_JEQ, BPF_REG_3, 0, 8));
   20a47: be 15 03 08 00               	movl	$525077, %esi           # imm = 0x80315
   20a4c: 48 89 ef                     	movq	%rbp, %rdi
   20a4f: e8 cc e1 ff ff               	callq	0x1ec20 <emit>
; 	emit2(gen, BPF_LD_IMM64_RAW_FULL(BPF_REG_1, BPF_PSEUDO_MAP_IDX_VALUE,
   20a54: 4d 89 e8                     	movq	%r13, %r8
; 	emit(gen, insn1);
   20a57: be 18 61 00 00               	movl	$24856, %esi            # imm = 0x6118
   20a5c: 48 89 ef                     	movq	%rbp, %rdi
   20a5f: 49 c1 e0 20                  	shlq	$32, %r8
   20a63: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
   20a68: e8 b3 e1 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, insn2);
   20a6d: 48 8b 74 24 08               	movq	8(%rsp), %rsi
   20a72: 48 89 ef                     	movq	%rbp, %rdi
   20a75: e8 a6 e1 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_MOV64_IMM(BPF_REG_2, value_size));
   20a7a: 4c 89 e6                     	movq	%r12, %rsi
   20a7d: 48 89 ef                     	movq	%rbp, %rdi
   20a80: 48 c1 e6 20                  	shlq	$32, %rsi
   20a84: 48 81 ce b7 02 00 00         	orq	$695, %rsi              # imm = 0x2B7
   20a8b: e8 90 e1 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_LDX_MEM(BPF_W, BPF_REG_0, BPF_REG_6,
   20a90: be 61 60 04 00               	movl	$286817, %esi           # imm = 0x46061
   20a95: 48 89 ef                     	movq	%rbp, %rdi
   20a98: e8 83 e1 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_JMP_IMM(BPF_JSET, BPF_REG_0, BPF_SKEL_KERNEL, 2));
   20a9d: 48 89 ef                     	movq	%rbp, %rdi
   20aa0: 48 be 45 00 02 00 01 00 00 00	movabsq	$4295098437, %rsi       # imm = 0x100020045
   20aaa: e8 71 e1 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_copy_from_user));
   20aaf: 48 89 ef                     	movq	%rbp, %rdi
   20ab2: 48 be 85 00 00 00 94 00 00 00	movabsq	$635655159941, %rsi     # imm = 0x9400000085
   20abc: e8 5f e1 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_JMP_IMM(BPF_JA, 0, 0, 1));
   20ac1: be 05 00 01 00               	movl	$65541, %esi            # imm = 0x10005
   20ac6: 48 89 ef                     	movq	%rbp, %rdi
   20ac9: e8 52 e1 ff ff               	callq	0x1ec20 <emit>
; 	emit(gen, BPF_EMIT_CALL(BPF_FUNC_probe_read_kernel));
   20ace: 48 89 ef                     	movq	%rbp, %rdi
   20ad1: 48 be 85 00 00 00 71 00 00 00	movabsq	$485331304581, %rsi     # imm = 0x7100000085
   20adb: e8 40 e1 ff ff               	callq	0x1ec20 <emit>
; 	map_update_attr = add_data(gen, &attr, attr_size);
   20ae0: 48 89 de                     	movq	%rbx, %rsi
   20ae3: ba 20 00 00 00               	movl	$32, %edx
   20ae8: 48 89 ef                     	movq	%rbp, %rdi
   20aeb: e8 00 df ff ff               	callq	0x1e9f0 <add_data>
; 	move_blob2blob(gen, attr_field(map_update_attr, map_fd), 4,
   20af0: ba 04 00 00 00               	movl	$4, %edx
   20af5: 48 89 ef                     	movq	%rbp, %rdi
; 	map_update_attr = add_data(gen, &attr, attr_size);
   20af8: 89 c3                        	movl	%eax, %ebx
; 	return gen->fd_array + index * sizeof(int);
   20afa: 8b 85 ec 00 00 00            	movl	236(%rbp), %eax
; 	move_blob2blob(gen, attr_field(map_update_attr, map_fd), 4,
   20b00: 89 de                        	movl	%ebx, %esi
; 	return gen->fd_array + index * sizeof(int);
   20b02: 42 8d 0c b0                  	leal	(%rax,%r14,4), %ecx
; 	move_blob2blob(gen, attr_field(map_update_attr, map_fd), 4,
   20b06: e8 05 e3 ff ff               	callq	0x1ee10 <move_blob2blob>
; 	emit_rel_store(gen, attr_field(map_update_attr, key), key);
   20b0b: 8d 73 08                     	leal	8(%rbx), %esi
   20b0e: 44 89 fa                     	movl	%r15d, %edx
   20b11: 48 89 ef                     	movq	%rbp, %rdi
   20b14: e8 17 e2 ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_rel_store(gen, attr_field(map_update_attr, value), value);
   20b19: 8d 73 10                     	leal	16(%rbx), %esi
   20b1c: 44 89 ea                     	movl	%r13d, %edx
   20b1f: 48 89 ef                     	movq	%rbp, %rdi
   20b22: e8 09 e2 ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_sys_bpf(gen, BPF_MAP_UPDATE_ELEM, map_update_attr, attr_size);
   20b27: b9 20 00 00 00               	movl	$32, %ecx
   20b2c: 89 da                        	movl	%ebx, %edx
   20b2e: 48 89 ef                     	movq	%rbp, %rdi
   20b31: be 02 00 00 00               	movl	$2, %esi
   20b36: e8 55 e2 ff ff               	callq	0x1ed90 <emit_sys_bpf>
; 	debug_ret(gen, "update_elem idx %d value_size %d", map_idx, value_size);
   20b3b: 48 89 ef                     	movq	%rbp, %rdi
   20b3e: 31 c0                        	xorl	%eax, %eax
   20b40: 44 89 e1                     	movl	%r12d, %ecx
   20b43: 44 89 f2                     	movl	%r14d, %edx
   20b46: 48 8d 35 1b 8a 01 00         	leaq	100891(%rip), %rsi      # 0x39568 <strs.2+0x66d8>
   20b4d: e8 3e e5 ff ff               	callq	0x1f090 <debug_ret>
; 	emit_check_err(gen);
   20b52: 48 89 ef                     	movq	%rbp, %rdi
   20b55: e8 66 e8 ff ff               	callq	0x1f3c0 <emit_check_err>
; }
   20b5a: 48 8b 84 24 b8 00 00 00      	movq	184(%rsp), %rax
   20b62: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   20b6b: 75 12                        	jne	0x20b7f <bpf_gen__map_update_elem+0x1df>
   20b6d: 48 81 c4 c8 00 00 00         	addq	$200, %rsp
   20b74: 5b                           	popq	%rbx
   20b75: 5d                           	popq	%rbp
   20b76: 41 5c                        	popq	%r12
   20b78: 41 5d                        	popq	%r13
   20b7a: 41 5e                        	popq	%r14
   20b7c: 41 5f                        	popq	%r15
   20b7e: c3                           	retq
   20b7f: e8 7c 4c fe ff               	callq	0x5800 <.plt.sec+0x190>
   20b84: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   20b8f: 90                           	nop

0000000000020b90 <bpf_gen__populate_outer_map>:
; {
   20b90: f3 0f 1e fa                  	endbr64
   20b94: 41 56                        	pushq	%r14
;   return __builtin___memset_chk (__dest, __ch, __len,
   20b96: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	pr_debug("gen: populate_outer_map: outer %d key %d inner %d\n",
   20b9a: 41 89 c8                     	movl	%ecx, %r8d
; {
   20b9d: 41 55                        	pushq	%r13
   20b9f: 41 89 f5                     	movl	%esi, %r13d
   20ba2: 41 54                        	pushq	%r12
   20ba4: 55                           	pushq	%rbp
   20ba5: 48 89 fd                     	movq	%rdi, %rbp
; 	pr_debug("gen: populate_outer_map: outer %d key %d inner %d\n",
   20ba8: bf 02 00 00 00               	movl	$2, %edi
; {
   20bad: 53                           	pushq	%rbx
   20bae: 89 cb                        	movl	%ecx, %ebx
; 	pr_debug("gen: populate_outer_map: outer %d key %d inner %d\n",
   20bb0: 89 d1                        	movl	%edx, %ecx
; {
   20bb2: 48 81 ec b0 00 00 00         	subq	$176, %rsp
   20bb9: 89 54 24 0c                  	movl	%edx, 12(%rsp)
; 	pr_debug("gen: populate_outer_map: outer %d key %d inner %d\n",
   20bbd: 89 f2                        	movl	%esi, %edx
   20bbf: 48 8d 35 ca 89 01 00         	leaq	100810(%rip), %rsi      # 0x39590 <strs.2+0x6700>
;   return __builtin___memset_chk (__dest, __ch, __len,
   20bc6: 4c 8d 64 24 10               	leaq	16(%rsp), %r12
; {
   20bcb: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   20bd4: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
   20bdc: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   20bde: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
   20be3: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
; 	pr_debug("gen: populate_outer_map: outer %d key %d inner %d\n",
   20be8: e8 e3 74 fe ff               	callq	0x80d0 <libbpf_print>
; 	key = add_data(gen, &slot, sizeof(slot));
   20bed: 48 8d 74 24 0c               	leaq	12(%rsp), %rsi
   20bf2: ba 04 00 00 00               	movl	$4, %edx
   20bf7: 48 89 ef                     	movq	%rbp, %rdi
   20bfa: e8 f1 dd ff ff               	callq	0x1e9f0 <add_data>
; 	map_update_attr = add_data(gen, &attr, attr_size);
   20bff: 4c 89 e6                     	movq	%r12, %rsi
   20c02: ba 20 00 00 00               	movl	$32, %edx
   20c07: 48 89 ef                     	movq	%rbp, %rdi
; 	key = add_data(gen, &slot, sizeof(slot));
   20c0a: 41 89 c6                     	movl	%eax, %r14d
; 	map_update_attr = add_data(gen, &attr, attr_size);
   20c0d: e8 de dd ff ff               	callq	0x1e9f0 <add_data>
; 	move_blob2blob(gen, attr_field(map_update_attr, map_fd), 4,
   20c12: ba 04 00 00 00               	movl	$4, %edx
   20c17: 48 89 ef                     	movq	%rbp, %rdi
; 	map_update_attr = add_data(gen, &attr, attr_size);
   20c1a: 41 89 c4                     	movl	%eax, %r12d
; 	return gen->fd_array + index * sizeof(int);
   20c1d: 8b 85 ec 00 00 00            	movl	236(%rbp), %eax
; 	move_blob2blob(gen, attr_field(map_update_attr, map_fd), 4,
   20c23: 44 89 e6                     	movl	%r12d, %esi
; 	return gen->fd_array + index * sizeof(int);
   20c26: 42 8d 0c a8                  	leal	(%rax,%r13,4), %ecx
; 	move_blob2blob(gen, attr_field(map_update_attr, map_fd), 4,
   20c2a: e8 e1 e1 ff ff               	callq	0x1ee10 <move_blob2blob>
; 	emit_rel_store(gen, attr_field(map_update_attr, key), key);
   20c2f: 41 8d 74 24 08               	leal	8(%r12), %esi
   20c34: 44 89 f2                     	movl	%r14d, %edx
   20c37: 48 89 ef                     	movq	%rbp, %rdi
   20c3a: e8 f1 e0 ff ff               	callq	0x1ed30 <emit_rel_store>
; 	return gen->fd_array + index * sizeof(int);
   20c3f: 8b 85 ec 00 00 00            	movl	236(%rbp), %eax
; 	emit_rel_store(gen, attr_field(map_update_attr, value),
   20c45: 41 8d 74 24 10               	leal	16(%r12), %esi
   20c4a: 48 89 ef                     	movq	%rbp, %rdi
; 	return gen->fd_array + index * sizeof(int);
   20c4d: 8d 14 98                     	leal	(%rax,%rbx,4), %edx
; 	emit_rel_store(gen, attr_field(map_update_attr, value),
   20c50: e8 db e0 ff ff               	callq	0x1ed30 <emit_rel_store>
; 	emit_sys_bpf(gen, BPF_MAP_UPDATE_ELEM, map_update_attr, attr_size);
   20c55: b9 20 00 00 00               	movl	$32, %ecx
   20c5a: 44 89 e2                     	movl	%r12d, %edx
   20c5d: 48 89 ef                     	movq	%rbp, %rdi
   20c60: be 02 00 00 00               	movl	$2, %esi
   20c65: e8 26 e1 ff ff               	callq	0x1ed90 <emit_sys_bpf>
; 	debug_ret(gen, "populate_outer_map outer %d key %d inner %d",
   20c6a: 8b 4c 24 0c                  	movl	12(%rsp), %ecx
   20c6e: 48 89 ef                     	movq	%rbp, %rdi
   20c71: 31 c0                        	xorl	%eax, %eax
   20c73: 41 89 d8                     	movl	%ebx, %r8d
   20c76: 44 89 ea                     	movl	%r13d, %edx
   20c79: 48 8d 35 50 89 01 00         	leaq	100688(%rip), %rsi      # 0x395d0 <strs.2+0x6740>
   20c80: e8 0b e4 ff ff               	callq	0x1f090 <debug_ret>
; 	emit_check_err(gen);
   20c85: 48 89 ef                     	movq	%rbp, %rdi
   20c88: e8 33 e7 ff ff               	callq	0x1f3c0 <emit_check_err>
; }
   20c8d: 48 8b 84 24 a8 00 00 00      	movq	168(%rsp), %rax
   20c95: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   20c9e: 75 10                        	jne	0x20cb0 <bpf_gen__populate_outer_map+0x120>
   20ca0: 48 81 c4 b0 00 00 00         	addq	$176, %rsp
   20ca7: 5b                           	popq	%rbx
   20ca8: 5d                           	popq	%rbp
   20ca9: 41 5c                        	popq	%r12
   20cab: 41 5d                        	popq	%r13
   20cad: 41 5e                        	popq	%r14
   20caf: c3                           	retq
   20cb0: e8 4b 4b fe ff               	callq	0x5800 <.plt.sec+0x190>
   20cb5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

0000000000020cc0 <bpf_gen__map_freeze>:
; {
   20cc0: f3 0f 1e fa                  	endbr64
   20cc4: 41 54                        	pushq	%r12
; 	pr_debug("gen: map_freeze: idx %d\n", map_idx);
   20cc6: 89 f2                        	movl	%esi, %edx
; {
   20cc8: 55                           	pushq	%rbp
   20cc9: 48 89 fd                     	movq	%rdi, %rbp
; 	pr_debug("gen: map_freeze: idx %d\n", map_idx);
   20ccc: bf 02 00 00 00               	movl	$2, %edi
; {
   20cd1: 53                           	pushq	%rbx
   20cd2: 89 f3                        	movl	%esi, %ebx
; 	pr_debug("gen: map_freeze: idx %d\n", map_idx);
   20cd4: 48 8d 35 25 89 01 00         	leaq	100645(%rip), %rsi      # 0x39600 <strs.2+0x6770>
; {
   20cdb: 48 81 ec a0 00 00 00         	subq	$160, %rsp
   20ce2: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   20ceb: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   20cf3: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   20cf5: 49 89 e4                     	movq	%rsp, %r12
   20cf8: c7 04 24 00 00 00 00         	movl	$0, (%rsp)
; 	pr_debug("gen: map_freeze: idx %d\n", map_idx);
   20cff: e8 cc 73 fe ff               	callq	0x80d0 <libbpf_print>
; 	map_freeze_attr = add_data(gen, &attr, attr_size);
   20d04: 4c 89 e6                     	movq	%r12, %rsi
   20d07: ba 04 00 00 00               	movl	$4, %edx
   20d0c: 48 89 ef                     	movq	%rbp, %rdi
   20d0f: e8 dc dc ff ff               	callq	0x1e9f0 <add_data>
; 	move_blob2blob(gen, attr_field(map_freeze_attr, map_fd), 4,
   20d14: ba 04 00 00 00               	movl	$4, %edx
   20d19: 48 89 ef                     	movq	%rbp, %rdi
; 	map_freeze_attr = add_data(gen, &attr, attr_size);
   20d1c: 41 89 c4                     	movl	%eax, %r12d
; 	return gen->fd_array + index * sizeof(int);
   20d1f: 8b 85 ec 00 00 00            	movl	236(%rbp), %eax
; 	move_blob2blob(gen, attr_field(map_freeze_attr, map_fd), 4,
   20d25: 44 89 e6                     	movl	%r12d, %esi
; 	return gen->fd_array + index * sizeof(int);
   20d28: 8d 0c 98                     	leal	(%rax,%rbx,4), %ecx
; 	move_blob2blob(gen, attr_field(map_freeze_attr, map_fd), 4,
   20d2b: e8 e0 e0 ff ff               	callq	0x1ee10 <move_blob2blob>
; 	emit_sys_bpf(gen, BPF_MAP_FREEZE, map_freeze_attr, attr_size);
   20d30: b9 04 00 00 00               	movl	$4, %ecx
   20d35: 44 89 e2                     	movl	%r12d, %edx
   20d38: 48 89 ef                     	movq	%rbp, %rdi
   20d3b: be 16 00 00 00               	movl	$22, %esi
   20d40: e8 4b e0 ff ff               	callq	0x1ed90 <emit_sys_bpf>
; 	debug_ret(gen, "map_freeze");
   20d45: 48 89 ef                     	movq	%rbp, %rdi
   20d48: 31 c0                        	xorl	%eax, %eax
   20d4a: 48 8d 35 59 85 01 00         	leaq	99673(%rip), %rsi       # 0x392aa <strs.2+0x641a>
   20d51: e8 3a e3 ff ff               	callq	0x1f090 <debug_ret>
; 	emit_check_err(gen);
   20d56: 48 89 ef                     	movq	%rbp, %rdi
   20d59: e8 62 e6 ff ff               	callq	0x1f3c0 <emit_check_err>
; }
   20d5e: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   20d66: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   20d6f: 75 0c                        	jne	0x20d7d <bpf_gen__map_freeze+0xbd>
   20d71: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
   20d78: 5b                           	popq	%rbx
   20d79: 5d                           	popq	%rbp
   20d7a: 41 5c                        	popq	%r12
   20d7c: c3                           	retq
   20d7d: e8 7e 4a fe ff               	callq	0x5800 <.plt.sec+0x190>
   20d82: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   20d8c: 0f 1f 40 00                  	nopl	(%rax)

0000000000020d90 <core_relo_kind_str>:
; 	switch (kind) {
   20d90: 83 ff 0c                     	cmpl	$12, %edi
   20d93: 0f 87 df 00 00 00            	ja	0x20e78 <core_relo_kind_str+0xe8>
   20d99: 48 8d 15 00 8a 01 00         	leaq	100864(%rip), %rdx      # 0x397a0 <CSWTCH.76+0x160>
   20da0: 89 ff                        	movl	%edi, %edi
   20da2: 48 63 04 ba                  	movslq	(%rdx,%rdi,4), %rax
   20da6: 48 01 d0                     	addq	%rdx, %rax
   20da9: 3e ff e0                     	jmpq	*%rax
   20dac: 0f 1f 40 00                  	nopl	(%rax)
   20db0: 48 8d 05 b2 88 01 00         	leaq	100530(%rip), %rax      # 0x39669 <CSWTCH.76+0x29>
   20db7: c3                           	retq
   20db8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_FIELD_BYTE_OFFSET: return "byte_off";
   20dc0: 48 8d 05 99 88 01 00         	leaq	100505(%rip), %rax      # 0x39660 <CSWTCH.76+0x20>
; }
   20dc7: c3                           	retq
   20dc8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_FIELD_EXISTS: return "field_exists";
   20dd0: 48 8d 05 9a 88 01 00         	leaq	100506(%rip), %rax      # 0x39671 <CSWTCH.76+0x31>
   20dd7: c3                           	retq
   20dd8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_FIELD_SIGNED: return "signed";
   20de0: 48 8d 05 a3 ae 01 00         	leaq	110243(%rip), %rax      # 0x3bc8a <CSWTCH.126+0x238a>
   20de7: c3                           	retq
   20de8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_FIELD_LSHIFT_U64: return "lshift_u64";
   20df0: 48 8d 05 87 88 01 00         	leaq	100487(%rip), %rax      # 0x3967e <CSWTCH.76+0x3e>
   20df7: c3                           	retq
   20df8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_FIELD_RSHIFT_U64: return "rshift_u64";
   20e00: 48 8d 05 82 88 01 00         	leaq	100482(%rip), %rax      # 0x39689 <CSWTCH.76+0x49>
   20e07: c3                           	retq
   20e08: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_TYPE_MATCHES: return "type_matches";
   20e10: 48 8d 05 a6 88 01 00         	leaq	100518(%rip), %rax      # 0x396bd <CSWTCH.76+0x7d>
   20e17: c3                           	retq
   20e18: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_ENUMVAL_EXISTS: return "enumval_exists";
   20e20: 48 8d 05 ad 88 01 00         	leaq	100525(%rip), %rax      # 0x396d4 <CSWTCH.76+0x94>
   20e27: c3                           	retq
   20e28: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_ENUMVAL_VALUE: return "enumval_value";
   20e30: 48 8d 05 ac 88 01 00         	leaq	100524(%rip), %rax      # 0x396e3 <CSWTCH.76+0xa3>
   20e37: c3                           	retq
   20e38: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_TYPE_ID_LOCAL: return "local_type_id";
   20e40: 48 8d 05 4d 88 01 00         	leaq	100429(%rip), %rax      # 0x39694 <CSWTCH.76+0x54>
   20e47: c3                           	retq
   20e48: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_TYPE_ID_TARGET: return "target_type_id";
   20e50: 48 8d 05 4b 88 01 00         	leaq	100427(%rip), %rax      # 0x396a2 <CSWTCH.76+0x62>
   20e57: c3                           	retq
   20e58: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_TYPE_EXISTS: return "type_exists";
   20e60: 48 8d 05 4a 88 01 00         	leaq	100426(%rip), %rax      # 0x396b1 <CSWTCH.76+0x71>
   20e67: c3                           	retq
   20e68: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	case BPF_CORE_TYPE_SIZE: return "type_size";
   20e70: 48 8d 05 53 88 01 00         	leaq	100435(%rip), %rax      # 0x396ca <CSWTCH.76+0x8a>
   20e77: c3                           	retq
; 	default: return "unknown";
   20e78: 48 8d 05 b3 0d 01 00         	leaq	69043(%rip), %rax       # 0x31c32 <_IO_stdin_used+0x1c32>
   20e7f: c3                           	retq

0000000000020e80 <bpf_core_calc_field_relo>:
; {
   20e80: 41 57                        	pushq	%r15
   20e82: 41 56                        	pushq	%r14
   20e84: 41 55                        	pushq	%r13
   20e86: 41 54                        	pushq	%r12
   20e88: 49 89 cc                     	movq	%rcx, %r12
   20e8b: 55                           	pushq	%rbp
   20e8c: 53                           	pushq	%rbx
   20e8d: 48 89 d3                     	movq	%rdx, %rbx
   20e90: 48 83 ec 38                  	subq	$56, %rsp
   20e94: 48 89 7c 24 08               	movq	%rdi, 8(%rsp)
   20e99: 4c 8b 7c 24 70               	movq	112(%rsp), %r15
   20e9e: 4c 89 0c 24                  	movq	%r9, (%rsp)
   20ea2: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   20eab: 48 89 44 24 28               	movq	%rax, 40(%rsp)
   20eb0: 31 c0                        	xorl	%eax, %eax
; 	*field_sz = 0;
   20eb2: 41 c7 00 00 00 00 00         	movl	$0, (%r8)
; 	if (relo->kind == BPF_CORE_FIELD_EXISTS) {
   20eb9: 83 7e 0c 02                  	cmpl	$2, 12(%rsi)
   20ebd: 0f 84 65 01 00 00            	je	0x21028 <bpf_core_calc_field_relo+0x1a8>
; 	if (!spec)
   20ec3: 48 85 d2                     	testq	%rdx, %rdx
   20ec6: 0f 84 04 03 00 00            	je	0x211d0 <bpf_core_calc_field_relo+0x350>
   20ecc: 48 63 8a 10 04 00 00         	movslq	1040(%rdx), %rcx
; 	t = btf_type_by_id(spec->btf, acc->type_id);
   20ed3: 48 8b 3a                     	movq	(%rdx), %rdi
   20ed6: 49 89 f6                     	movq	%rsi, %r14
   20ed9: 4c 89 c5                     	movq	%r8, %rbp
   20edc: 48 c1 e1 04                  	shlq	$4, %rcx
   20ee0: 4c 8d 2c 0a                  	leaq	(%rdx,%rcx), %r13
   20ee4: 41 8b 75 f8                  	movl	-8(%r13), %esi
   20ee8: e8 73 90 00 00               	callq	0x29f60 <btf_type_by_id>
; 	if (!acc->name) {
   20eed: 49 83 7d 00 00               	cmpq	$0, (%r13)
; 	t = btf_type_by_id(spec->btf, acc->type_id);
   20ef2: 49 89 c1                     	movq	%rax, %r9
; 	if (!acc->name) {
   20ef5: 0f 84 b5 00 00 00            	je	0x20fb0 <bpf_core_calc_field_relo+0x130>
; 	m = btf_members(t) + acc->idx;
   20efb: 41 8b 45 fc                  	movl	-4(%r13), %eax
; 	mt = skip_mods_and_typedefs(spec->btf, m->type, &field_type_id);
   20eff: 48 8b 3b                     	movq	(%rbx), %rdi
   20f02: 48 8d 54 24 24               	leaq	36(%rsp), %rdx
   20f07: 4c 89 4c 24 10               	movq	%r9, 16(%rsp)
   20f0c: 48 8d 44 40 03               	leaq	3(%rax,%rax,2), %rax
   20f11: 41 8b 74 81 04               	movl	4(%r9,%rax,4), %esi
   20f16: e8 55 a6 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	return kflag ? BTF_MEMBER_BITFIELD_SIZE(m->offset) : 0;
   20f1b: 4c 8b 4c 24 10               	movq	16(%rsp), %r9
; 	bit_off = spec->bit_offset;
   20f20: 44 8b 83 18 05 00 00         	movl	1304(%rbx), %r8d
; 	mt = skip_mods_and_typedefs(spec->btf, m->type, &field_type_id);
   20f27: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   20f2c: 48 89 c6                     	movq	%rax, %rsi
; 	bit_sz = btf_member_bitfield_size(t, acc->idx);
   20f2f: 41 8b 45 fc                  	movl	-4(%r13), %eax
; 	return kflag ? BTF_MEMBER_BITFIELD_SIZE(m->offset) : 0;
   20f33: 41 8b 51 04                  	movl	4(%r9), %edx
   20f37: 85 d2                        	testl	%edx, %edx
   20f39: 79 13                        	jns	0x20f4e <bpf_core_calc_field_relo+0xce>
   20f3b: 48 8d 44 40 03               	leaq	3(%rax,%rax,2), %rax
   20f40: 41 0f b6 7c 81 0b            	movzbl	11(%r9,%rax,4), %edi
; 	if (bitfield) {
   20f46: 85 ff                        	testl	%edi, %edi
   20f48: 0f 85 f2 00 00 00            	jne	0x21040 <bpf_core_calc_field_relo+0x1c0>
; 		sz = btf__resolve_size(spec->btf, field_type_id);
   20f4e: 48 8b 3b                     	movq	(%rbx), %rdi
   20f51: 8b 74 24 24                  	movl	36(%rsp), %esi
   20f55: 44 89 44 24 08               	movl	%r8d, 8(%rsp)
   20f5a: e8 61 a5 00 00               	callq	0x2b4c0 <btf__resolve_size>
   20f5f: 48 89 c7                     	movq	%rax, %rdi
; 		if (sz < 0)
   20f62: 48 85 c0                     	testq	%rax, %rax
   20f65: 0f 88 5b 02 00 00            	js	0x211c6 <bpf_core_calc_field_relo+0x346>
; 		byte_sz = sz;
   20f6b: 89 c1                        	movl	%eax, %ecx
; 		byte_off = spec->bit_offset / 8;
   20f6d: 8b 83 18 05 00 00            	movl	1304(%rbx), %eax
   20f73: 44 8b 44 24 08               	movl	8(%rsp), %r8d
; 		bit_sz = byte_sz * 8;
   20f78: c1 e7 03                     	shll	$3, %edi
   20f7b: 45 31 c9                     	xorl	%r9d, %r9d
; 		byte_off = spec->bit_offset / 8;
   20f7e: c1 e8 03                     	shrl	$3, %eax
; 	if (validate)
   20f81: 4d 85 ff                     	testq	%r15, %r15
   20f84: 74 07                        	je	0x20f8d <bpf_core_calc_field_relo+0x10d>
; 		*validate = !bitfield;
   20f86: 45 85 c9                     	testl	%r9d, %r9d
   20f89: 41 0f 94 07                  	sete	(%r15)
; 	switch (relo->kind) {
   20f8d: 41 83 7e 0c 05               	cmpl	$5, 12(%r14)
   20f92: 0f 87 08 02 00 00            	ja	0x211a0 <bpf_core_calc_field_relo+0x320>
   20f98: 41 8b 56 0c                  	movl	12(%r14), %edx
   20f9c: 48 8d 35 31 88 01 00         	leaq	100401(%rip), %rsi      # 0x397d4 <CSWTCH.76+0x194>
   20fa3: 48 63 14 96                  	movslq	(%rsi,%rdx,4), %rdx
   20fa7: 48 01 f2                     	addq	%rsi, %rdx
   20faa: 3e ff e2                     	jmpq	*%rdx
   20fad: 0f 1f 00                     	nopl	(%rax)
; 		if (relo->kind == BPF_CORE_FIELD_BYTE_OFFSET) {
   20fb0: 41 8b 4e 0c                  	movl	12(%r14), %ecx
   20fb4: 85 c9                        	testl	%ecx, %ecx
   20fb6: 0f 84 9c 01 00 00            	je	0x21158 <bpf_core_calc_field_relo+0x2d8>
; 		} else if (relo->kind == BPF_CORE_FIELD_BYTE_SIZE) {
   20fbc: 83 f9 01                     	cmpl	$1, %ecx
   20fbf: 0f 85 e5 01 00 00            	jne	0x211aa <bpf_core_calc_field_relo+0x32a>
; 			sz = btf__resolve_size(spec->btf, acc->type_id);
   20fc5: 41 8b 75 f8                  	movl	-8(%r13), %esi
   20fc9: 48 8b 3b                     	movq	(%rbx), %rdi
   20fcc: e8 ef a4 00 00               	callq	0x2b4c0 <btf__resolve_size>
; 			if (sz < 0)
   20fd1: 48 85 c0                     	testq	%rax, %rax
   20fd4: 0f 88 ec 01 00 00            	js	0x211c6 <bpf_core_calc_field_relo+0x346>
; 		*val = 64 - bit_sz;
   20fda: 49 89 04 24                  	movq	%rax, (%r12)
; 		if (validate)
   20fde: 4d 85 ff                     	testq	%r15, %r15
   20fe1: 74 3e                        	je	0x21021 <bpf_core_calc_field_relo+0x1a1>
; 			*validate = true;
   20fe3: 41 c6 07 01                  	movb	$1, (%r15)
; 		return 0;
   20fe7: 31 c0                        	xorl	%eax, %eax
; }
   20fe9: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   20fee: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   20ff7: 0f 85 dd 01 00 00            	jne	0x211da <bpf_core_calc_field_relo+0x35a>
   20ffd: 48 83 c4 38                  	addq	$56, %rsp
   21001: 5b                           	popq	%rbx
   21002: 5d                           	popq	%rbp
   21003: 41 5c                        	popq	%r12
   21005: 41 5d                        	popq	%r13
   21007: 41 5e                        	popq	%r14
   21009: 41 5f                        	popq	%r15
   2100b: c3                           	retq
   2100c: 0f 1f 40 00                  	nopl	(%rax)
; 		*val = 64 - (bit_off + bit_sz - byte_off  * 8);
   21010: ba 40 00 00 00               	movl	$64, %edx
   21015: 44 29 c2                     	subl	%r8d, %edx
   21018: 8d 04 c2                     	leal	(%rdx,%rax,8), %eax
   2101b: 29 f8                        	subl	%edi, %eax
   2101d: 49 89 04 24                  	movq	%rax, (%r12)
; 	return 0;
   21021: 31 c0                        	xorl	%eax, %eax
; 		break;
   21023: eb c4                        	jmp	0x20fe9 <bpf_core_calc_field_relo+0x169>
   21025: 0f 1f 00                     	nopl	(%rax)
; 		*val = spec ? 1 : 0;
   21028: 31 c0                        	xorl	%eax, %eax
   2102a: 48 85 d2                     	testq	%rdx, %rdx
   2102d: 0f 95 c0                     	setne	%al
   21030: 48 89 01                     	movq	%rax, (%rcx)
; 		return 0;
   21033: 31 c0                        	xorl	%eax, %eax
   21035: eb b2                        	jmp	0x20fe9 <bpf_core_calc_field_relo+0x169>
   21037: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		byte_off = bit_off / 8 / byte_sz * byte_sz;
   21040: 45 89 c1                     	movl	%r8d, %r9d
; 		byte_sz = mt->size;
   21043: 8b 4e 08                     	movl	8(%rsi), %ecx
; 		byte_off = bit_off / 8 / byte_sz * byte_sz;
   21046: 31 d2                        	xorl	%edx, %edx
; 		while (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {
   21048: 45 8d 1c 38                  	leal	(%r8,%rdi), %r11d
; 		byte_off = bit_off / 8 / byte_sz * byte_sz;
   2104c: 41 c1 e9 03                  	shrl	$3, %r9d
; 		while (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {
   21050: 44 89 de                     	movl	%r11d, %esi
; 		byte_off = bit_off / 8 / byte_sz * byte_sz;
   21053: 44 89 c8                     	movl	%r9d, %eax
   21056: f7 f1                        	divl	%ecx
   21058: 0f af c1                     	imull	%ecx, %eax
; 		while (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {
   2105b: 8d 14 c5 00 00 00 00         	leal	(,%rax,8), %edx
   21062: 29 d6                        	subl	%edx, %esi
   21064: 8d 14 cd 00 00 00 00         	leal	(,%rcx,8), %edx
   2106b: 39 d6                        	cmpl	%edx, %esi
   2106d: 77 30                        	ja	0x2109f <bpf_core_calc_field_relo+0x21f>
   2106f: e9 1c 01 00 00               	jmp	0x21190 <bpf_core_calc_field_relo+0x310>
   21074: 0f 1f 40 00                  	nopl	(%rax)
; 			byte_sz *= 2;
   21078: 89 ce                        	movl	%ecx, %esi
; 			byte_off = bit_off / 8 / byte_sz * byte_sz;
   2107a: 44 89 c8                     	movl	%r9d, %eax
; 			byte_sz *= 2;
   2107d: 01 c9                        	addl	%ecx, %ecx
; 			byte_off = bit_off / 8 / byte_sz * byte_sz;
   2107f: 31 d2                        	xorl	%edx, %edx
   21081: f7 f1                        	divl	%ecx
; 		while (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {
   21083: 44 89 da                     	movl	%r11d, %edx
   21086: c1 e6 04                     	shll	$4, %esi
; 			byte_off = bit_off / 8 / byte_sz * byte_sz;
   21089: 0f af c1                     	imull	%ecx, %eax
; 		while (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {
   2108c: 44 8d 14 c5 00 00 00 00      	leal	(,%rax,8), %r10d
   21094: 44 29 d2                     	subl	%r10d, %edx
   21097: 39 f2                        	cmpl	%esi, %edx
   21099: 0f 86 f1 00 00 00            	jbe	0x21190 <bpf_core_calc_field_relo+0x310>
; 			if (byte_sz >= 8) {
   2109f: 83 f9 07                     	cmpl	$7, %ecx
   210a2: 76 d4                        	jbe	0x21078 <bpf_core_calc_field_relo+0x1f8>
; 				pr_warn("prog '%s': relo %d at insn #%d can't be satisfied for bitfield\n",
   210a4: 45 8b 06                     	movl	(%r14), %r8d
   210a7: 41 8b 4e 0c                  	movl	12(%r14), %ecx
   210ab: 31 c0                        	xorl	%eax, %eax
   210ad: 48 8d 35 04 89 01 00         	leaq	100612(%rip), %rsi      # 0x399b8 <CSWTCH.126+0xb8>
   210b4: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   210b9: 31 ff                        	xorl	%edi, %edi
   210bb: 41 c1 e8 03                  	shrl	$3, %r8d
   210bf: e8 0c 70 fe ff               	callq	0x80d0 <libbpf_print>
; 				return -E2BIG;
   210c4: b8 f9 ff ff ff               	movl	$4294967289, %eax       # imm = 0xFFFFFFF9
   210c9: e9 1b ff ff ff               	jmp	0x20fe9 <bpf_core_calc_field_relo+0x169>
   210ce: 66 90                        	nop
; 		*val = 64 - bit_sz;
   210d0: b8 40 00 00 00               	movl	$64, %eax
   210d5: 29 f8                        	subl	%edi, %eax
   210d7: e9 fe fe ff ff               	jmp	0x20fda <bpf_core_calc_field_relo+0x15a>
   210dc: 0f 1f 40 00                  	nopl	(%rax)
; 	return BTF_INFO_KIND(t->info);
   210e0: 48 8b 44 24 18               	movq	24(%rsp), %rax
   210e5: 8b 50 04                     	movl	4(%rax), %edx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   210e8: b8 40 00 08 00               	movl	$524352, %eax           # imm = 0x80040
; 	return BTF_INFO_KIND(t->info);
   210ed: 89 d1                        	movl	%edx, %ecx
   210ef: c1 e9 18                     	shrl	$24, %ecx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   210f2: 83 e1 1f                     	andl	$31, %ecx
   210f5: 48 d3 e8                     	shrq	%cl, %rax
   210f8: 83 e0 01                     	andl	$1, %eax
   210fb: 74 08                        	je	0x21105 <bpf_core_calc_field_relo+0x285>
; 		*val = (btf_is_any_enum(mt) && BTF_INFO_KFLAG(mt->info)) ||
   210fd: 85 d2                        	testl	%edx, %edx
   210ff: 0f 88 d5 fe ff ff            	js	0x20fda <bpf_core_calc_field_relo+0x15a>
; 	return BTF_INT_ENCODING(*(__u32 *)(t + 1));
   21105: 48 8b 44 24 18               	movq	24(%rsp), %rax
   2110a: 0f b6 40 0f                  	movzbl	15(%rax), %eax
; 		*val = (btf_is_any_enum(mt) && BTF_INFO_KFLAG(mt->info)) ||
   2110e: 83 e0 01                     	andl	$1, %eax
   21111: e9 c4 fe ff ff               	jmp	0x20fda <bpf_core_calc_field_relo+0x15a>
   21116: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		*val = byte_sz;
   21120: 89 c8                        	movl	%ecx, %eax
   21122: 49 89 04 24                  	movq	%rax, (%r12)
; 	return 0;
   21126: 31 c0                        	xorl	%eax, %eax
; 		break;
   21128: e9 bc fe ff ff               	jmp	0x20fe9 <bpf_core_calc_field_relo+0x169>
   2112d: 0f 1f 00                     	nopl	(%rax)
; 		*val = byte_off;
   21130: 49 89 04 24                  	movq	%rax, (%r12)
; 		if (!bitfield) {
   21134: 45 85 c9                     	testl	%r9d, %r9d
   21137: 0f 85 e4 fe ff ff            	jne	0x21021 <bpf_core_calc_field_relo+0x1a1>
; 			*type_id = field_type_id;
   2113d: 8b 44 24 24                  	movl	36(%rsp), %eax
   21141: 48 8b 1c 24                  	movq	(%rsp), %rbx
; 			*field_sz = byte_sz;
   21145: 89 4d 00                     	movl	%ecx, (%rbp)
; 			*type_id = field_type_id;
   21148: 89 03                        	movl	%eax, (%rbx)
; 	return 0;
   2114a: 31 c0                        	xorl	%eax, %eax
   2114c: e9 98 fe ff ff               	jmp	0x20fe9 <bpf_core_calc_field_relo+0x169>
   21151: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			*val = spec->bit_offset / 8;
   21158: 8b 83 18 05 00 00            	movl	1304(%rbx), %eax
; 			sz = btf__resolve_size(spec->btf, acc->type_id);
   2115e: 41 8b 75 f8                  	movl	-8(%r13), %esi
   21162: 48 8b 3b                     	movq	(%rbx), %rdi
; 			*val = spec->bit_offset / 8;
   21165: c1 e8 03                     	shrl	$3, %eax
   21168: 49 89 04 24                  	movq	%rax, (%r12)
; 			sz = btf__resolve_size(spec->btf, acc->type_id);
   2116c: e8 4f a3 00 00               	callq	0x2b4c0 <btf__resolve_size>
; 			if (sz < 0)
   21171: 48 85 c0                     	testq	%rax, %rax
   21174: 78 50                        	js	0x211c6 <bpf_core_calc_field_relo+0x346>
; 			*field_sz = sz;
   21176: 89 45 00                     	movl	%eax, (%rbp)
; 			*type_id = acc->type_id;
   21179: 48 8b 1c 24                  	movq	(%rsp), %rbx
   2117d: 41 8b 45 f8                  	movl	-8(%r13), %eax
   21181: 89 03                        	movl	%eax, (%rbx)
   21183: e9 56 fe ff ff               	jmp	0x20fde <bpf_core_calc_field_relo+0x15e>
   21188: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		while (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {
   21190: 41 89 f9                     	movl	%edi, %r9d
   21193: e9 e9 fd ff ff               	jmp	0x20f81 <bpf_core_calc_field_relo+0x101>
   21198: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	switch (relo->kind) {
   211a0: b8 a1 ff ff ff               	movl	$4294967201, %eax       # imm = 0xFFFFFFA1
   211a5: e9 3f fe ff ff               	jmp	0x20fe9 <bpf_core_calc_field_relo+0x169>
; 			pr_warn("prog '%s': relo %d at insn #%d can't be applied to array access\n",
   211aa: 45 8b 06                     	movl	(%r14), %r8d
   211ad: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   211b2: 31 ff                        	xorl	%edi, %edi
   211b4: 31 c0                        	xorl	%eax, %eax
   211b6: 48 8d 35 ab 87 01 00         	leaq	100267(%rip), %rsi      # 0x39968 <CSWTCH.126+0x68>
   211bd: 41 c1 e8 03                  	shrl	$3, %r8d
   211c1: e8 0a 6f fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   211c6: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   211cb: e9 19 fe ff ff               	jmp	0x20fe9 <bpf_core_calc_field_relo+0x169>
; 		return -EUCLEAN; /* request instruction poisoning */
   211d0: b8 8b ff ff ff               	movl	$4294967179, %eax       # imm = 0xFFFFFF8B
   211d5: e9 0f fe ff ff               	jmp	0x20fe9 <bpf_core_calc_field_relo+0x169>
; }
   211da: e8 21 46 fe ff               	callq	0x5800 <.plt.sec+0x190>
   211df: 90                           	nop

00000000000211e0 <bpf_core_calc_type_relo>:
; {
   211e0: 53                           	pushq	%rbx
   211e1: 48 89 f0                     	movq	%rsi, %rax
   211e4: 48 89 d3                     	movq	%rdx, %rbx
; 	if (validate)
   211e7: 48 85 c9                     	testq	%rcx, %rcx
   211ea: 74 03                        	je	0x211ef <bpf_core_calc_type_relo+0xf>
; 		*validate = true;
   211ec: c6 01 01                     	movb	$1, (%rcx)
; 	if (!spec) {
   211ef: 48 85 c0                     	testq	%rax, %rax
   211f2: 74 6c                        	je	0x21260 <bpf_core_calc_type_relo+0x80>
; 	switch (relo->kind) {
   211f4: 8b 77 0c                     	movl	12(%rdi), %esi
   211f7: 83 fe 09                     	cmpl	$9, %esi
   211fa: 74 44                        	je	0x21240 <bpf_core_calc_type_relo+0x60>
   211fc: 77 1a                        	ja	0x21218 <bpf_core_calc_type_relo+0x38>
   211fe: 83 fe 07                     	cmpl	$7, %esi
   21201: 74 25                        	je	0x21228 <bpf_core_calc_type_relo+0x48>
   21203: 83 fe 08                     	cmpl	$8, %esi
   21206: 75 15                        	jne	0x2121d <bpf_core_calc_type_relo+0x3d>
; 		*val = 1;
   21208: 48 c7 03 01 00 00 00         	movq	$1, (%rbx)
; 	return 0;
   2120f: 31 c0                        	xorl	%eax, %eax
; }
   21211: 5b                           	popq	%rbx
   21212: c3                           	retq
   21213: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	switch (relo->kind) {
   21218: 83 fe 0c                     	cmpl	$12, %esi
   2121b: 74 eb                        	je	0x21208 <bpf_core_calc_type_relo+0x28>
   2121d: b8 a1 ff ff ff               	movl	$4294967201, %eax       # imm = 0xFFFFFFA1
; }
   21222: 5b                           	popq	%rbx
   21223: c3                           	retq
   21224: 0f 1f 40 00                  	nopl	(%rax)
; 		*val = spec->root_type_id;
   21228: 8b 80 08 04 00 00            	movl	1032(%rax), %eax
   2122e: 48 89 03                     	movq	%rax, (%rbx)
; 	return 0;
   21231: 31 c0                        	xorl	%eax, %eax
; 		if (validate)
   21233: 48 85 c9                     	testq	%rcx, %rcx
   21236: 74 d9                        	je	0x21211 <bpf_core_calc_type_relo+0x31>
; 			*validate = false;
   21238: c6 01 00                     	movb	$0, (%rcx)
; }
   2123b: 5b                           	popq	%rbx
   2123c: c3                           	retq
   2123d: 0f 1f 00                     	nopl	(%rax)
; 		sz = btf__resolve_size(spec->btf, spec->root_type_id);
   21240: 8b b0 08 04 00 00            	movl	1032(%rax), %esi
   21246: 48 8b 38                     	movq	(%rax), %rdi
   21249: e8 72 a2 00 00               	callq	0x2b4c0 <btf__resolve_size>
; 		if (sz < 0)
   2124e: 48 85 c0                     	testq	%rax, %rax
   21251: 78 16                        	js	0x21269 <bpf_core_calc_type_relo+0x89>
; 		*val = sz;
   21253: 48 89 03                     	movq	%rax, (%rbx)
; 	return 0;
   21256: 31 c0                        	xorl	%eax, %eax
; }
   21258: 5b                           	popq	%rbx
   21259: c3                           	retq
   2125a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		*val = 0;
   21260: 48 c7 03 00 00 00 00         	movq	$0, (%rbx)
; }
   21267: 5b                           	popq	%rbx
   21268: c3                           	retq
; 			return -EINVAL;
   21269: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2126e: 5b                           	popq	%rbx
   2126f: c3                           	retq

0000000000021270 <bpf_core_names_match>:
; {
   21270: 41 55                        	pushq	%r13
   21272: 41 54                        	pushq	%r12
   21274: 55                           	pushq	%rbp
   21275: 48 89 d5                     	movq	%rdx, %rbp
   21278: 53                           	pushq	%rbx
   21279: 48 89 cb                     	movq	%rcx, %rbx
   2127c: 48 83 ec 08                  	subq	$8, %rsp
; 	local_n = btf__name_by_offset(local_btf, local_name_off);
   21280: e8 6b a8 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 	targ_n = btf__name_by_offset(targ_btf, targ_name_off);
   21285: 89 de                        	movl	%ebx, %esi
   21287: 48 89 ef                     	movq	%rbp, %rdi
; 	local_n = btf__name_by_offset(local_btf, local_name_off);
   2128a: 49 89 c4                     	movq	%rax, %r12
; 	targ_n = btf__name_by_offset(targ_btf, targ_name_off);
   2128d: e8 5e a8 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 	return !s || !s[0];
   21292: 48 85 c0                     	testq	%rax, %rax
   21295: 74 31                        	je	0x212c8 <bpf_core_names_match+0x58>
   21297: 80 38 00                     	cmpb	$0, (%rax)
   2129a: 48 89 c5                     	movq	%rax, %rbp
   2129d: 74 29                        	je	0x212c8 <bpf_core_names_match+0x58>
; 	targ_len = bpf_core_essential_name_len(targ_n);
   2129f: 48 89 c7                     	movq	%rax, %rdi
   212a2: e8 99 cd fe ff               	callq	0xe040 <bpf_core_essential_name_len>
; 	local_len = bpf_core_essential_name_len(local_n);
   212a7: 4c 89 e7                     	movq	%r12, %rdi
; 	targ_len = bpf_core_essential_name_len(targ_n);
   212aa: 49 89 c5                     	movq	%rax, %r13
; 	local_len = bpf_core_essential_name_len(local_n);
   212ad: e8 8e cd fe ff               	callq	0xe040 <bpf_core_essential_name_len>
; 	return targ_len == local_len && strncmp(local_n, targ_n, local_len) == 0;
   212b2: 49 39 c5                     	cmpq	%rax, %r13
   212b5: 74 31                        	je	0x212e8 <bpf_core_names_match+0x78>
   212b7: 31 c0                        	xorl	%eax, %eax
; }
   212b9: 48 83 c4 08                  	addq	$8, %rsp
   212bd: 5b                           	popq	%rbx
   212be: 5d                           	popq	%rbp
   212bf: 41 5c                        	popq	%r12
   212c1: 41 5d                        	popq	%r13
   212c3: c3                           	retq
   212c4: 0f 1f 40 00                  	nopl	(%rax)
; 	return !s || !s[0];
   212c8: b8 01 00 00 00               	movl	$1, %eax
   212cd: 4d 85 e4                     	testq	%r12, %r12
   212d0: 74 e7                        	je	0x212b9 <bpf_core_names_match+0x49>
   212d2: 41 80 3c 24 00               	cmpb	$0, (%r12)
   212d7: 0f 94 c0                     	sete	%al
; }
   212da: 48 83 c4 08                  	addq	$8, %rsp
   212de: 5b                           	popq	%rbx
   212df: 5d                           	popq	%rbp
   212e0: 41 5c                        	popq	%r12
   212e2: 41 5d                        	popq	%r13
   212e4: c3                           	retq
   212e5: 0f 1f 00                     	nopl	(%rax)
; 	return targ_len == local_len && strncmp(local_n, targ_n, local_len) == 0;
   212e8: 4c 89 ea                     	movq	%r13, %rdx
   212eb: 48 89 ee                     	movq	%rbp, %rsi
   212ee: 4c 89 e7                     	movq	%r12, %rdi
   212f1: e8 2a 44 fe ff               	callq	0x5720 <.plt.sec+0xb0>
   212f6: 85 c0                        	testl	%eax, %eax
   212f8: 0f 94 c0                     	sete	%al
; }
   212fb: 48 83 c4 08                  	addq	$8, %rsp
   212ff: 5b                           	popq	%rbx
   21300: 5d                           	popq	%rbp
   21301: 41 5c                        	popq	%r12
   21303: 41 5d                        	popq	%r13
   21305: c3                           	retq
   21306: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000021310 <bpf_core_calc_enumval_relo.isra.0>:
; static int bpf_core_calc_enumval_relo(const struct bpf_core_relo *relo,
   21310: 55                           	pushq	%rbp
   21311: 48 89 d5                     	movq	%rdx, %rbp
   21314: 53                           	pushq	%rbx
   21315: 48 89 f3                     	movq	%rsi, %rbx
   21318: 48 83 ec 08                  	subq	$8, %rsp
; 	switch (relo->kind) {
   2131c: 83 ff 0a                     	cmpl	$10, %edi
   2131f: 74 47                        	je	0x21368 <bpf_core_calc_enumval_relo.isra.0+0x58>
   21321: b8 a1 ff ff ff               	movl	$4294967201, %eax       # imm = 0xFFFFFFA1
   21326: 83 ff 0b                     	cmpl	$11, %edi
   21329: 75 30                        	jne	0x2135b <bpf_core_calc_enumval_relo.isra.0+0x4b>
; 		if (!spec)
   2132b: 48 85 f6                     	testq	%rsi, %rsi
   2132e: 74 62                        	je	0x21392 <bpf_core_calc_enumval_relo.isra.0+0x82>
; 		t = btf_type_by_id(spec->btf, spec->spec[0].type_id);
   21330: 8b 76 08                     	movl	8(%rsi), %esi
   21333: 48 8b 3b                     	movq	(%rbx), %rdi
   21336: e8 25 8c 00 00               	callq	0x29f60 <btf_type_by_id>
; 	return BTF_INFO_KIND(t->info);
   2133b: 0f b6 50 07                  	movzbl	7(%rax), %edx
   2133f: 83 e2 1f                     	andl	$31, %edx
; 		if (btf_is_enum(t))
   21342: 66 83 fa 06                  	cmpw	$6, %dx
; 			*val = btf_enum(t)[spec->spec[0].idx].val;
   21346: 8b 53 0c                     	movl	12(%rbx), %edx
; 		if (btf_is_enum(t))
   21349: 74 35                        	je	0x21380 <bpf_core_calc_enumval_relo.isra.0+0x70>
; 	return ((__u64)e->val_hi32 << 32) | e->val_lo32;
   2134b: 48 8d 54 52 03               	leaq	3(%rdx,%rdx,2), %rdx
; 			*val = btf_enum64_value(btf_enum64(t) + spec->spec[0].idx);
   21350: 48 8b 44 90 04               	movq	4(%rax,%rdx,4), %rax
   21355: 48 89 45 00                  	movq	%rax, (%rbp)
   21359: 31 c0                        	xorl	%eax, %eax
; }
   2135b: 48 83 c4 08                  	addq	$8, %rsp
   2135f: 5b                           	popq	%rbx
   21360: 5d                           	popq	%rbp
   21361: c3                           	retq
   21362: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		*val = spec ? 1 : 0;
   21368: 31 c0                        	xorl	%eax, %eax
   2136a: 48 85 f6                     	testq	%rsi, %rsi
   2136d: 0f 95 c0                     	setne	%al
   21370: 48 89 02                     	movq	%rax, (%rdx)
; }
   21373: 48 83 c4 08                  	addq	$8, %rsp
; 	return 0;
   21377: 31 c0                        	xorl	%eax, %eax
; }
   21379: 5b                           	popq	%rbx
   2137a: 5d                           	popq	%rbp
   2137b: c3                           	retq
   2137c: 0f 1f 40 00                  	nopl	(%rax)
; 			*val = btf_enum(t)[spec->spec[0].idx].val;
   21380: 48 63 44 d0 10               	movslq	16(%rax,%rdx,8), %rax
   21385: 48 89 45 00                  	movq	%rax, (%rbp)
; }
   21389: 48 83 c4 08                  	addq	$8, %rsp
   2138d: 31 c0                        	xorl	%eax, %eax
   2138f: 5b                           	popq	%rbx
   21390: 5d                           	popq	%rbp
   21391: c3                           	retq
; 			return -EUCLEAN; /* request instruction poisoning */
   21392: b8 8b ff ff ff               	movl	$4294967179, %eax       # imm = 0xFFFFFF8B
   21397: eb c2                        	jmp	0x2135b <bpf_core_calc_enumval_relo.isra.0+0x4b>
   21399: 0f 1f 80 00 00 00 00         	nopl	(%rax)

00000000000213a0 <bpf_core_calc_relo>:
; {
   213a0: 41 57                        	pushq	%r15
; 	res->poison = false;
   213a2: 41 ba 00 01 00 00            	movl	$256, %r10d             # imm = 0x100
; {
   213a8: 49 89 cf                     	movq	%rcx, %r15
   213ab: 41 56                        	pushq	%r14
   213ad: 4d 89 c6                     	movq	%r8, %r14
   213b0: 41 55                        	pushq	%r13
   213b2: 49 89 fd                     	movq	%rdi, %r13
   213b5: 41 54                        	pushq	%r12
   213b7: 55                           	pushq	%rbp
   213b8: 48 89 f5                     	movq	%rsi, %rbp
   213bb: 53                           	pushq	%rbx
   213bc: 4c 89 cb                     	movq	%r9, %rbx
   213bf: 48 83 ec 18                  	subq	$24, %rsp
; 	res->orig_val = 0;
   213c3: 49 c7 01 00 00 00 00         	movq	$0, (%r9)
; 	res->new_val = 0;
   213ca: 49 c7 41 08 00 00 00 00      	movq	$0, 8(%r9)
; 	res->poison = false;
   213d2: 66 45 89 51 10               	movw	%r10w, 16(%r9)
; 	res->fail_memsz_adjust = false;
   213d7: 41 c6 41 12 00               	movb	$0, 18(%r9)
; 	res->orig_sz = res->new_sz = 0;
   213dc: 49 c7 41 14 00 00 00 00      	movq	$0, 20(%r9)
   213e4: 49 c7 41 1c 00 00 00 00      	movq	$0, 28(%r9)
; 	if (core_relo_is_field_based(relo->kind)) {
   213ec: 44 8b 4e 0c                  	movl	12(%rsi), %r9d
; {
   213f0: 89 54 24 0c                  	movl	%edx, 12(%rsp)
; 	switch (kind) {
   213f4: 41 83 f9 05                  	cmpl	$5, %r9d
   213f8: 77 56                        	ja	0x21450 <bpf_core_calc_relo+0xb0>
; 		err = bpf_core_calc_field_relo(prog_name, relo, local_spec,
   213fa: 48 83 ec 08                  	subq	$8, %rsp
   213fe: 48 8d 43 11                  	leaq	17(%rbx), %rax
   21402: 4c 8d 43 14                  	leaq	20(%rbx), %r8
   21406: 48 89 d9                     	movq	%rbx, %rcx
   21409: 50                           	pushq	%rax
   2140a: 4c 8d 4b 18                  	leaq	24(%rbx), %r9
   2140e: 4c 89 fa                     	movq	%r15, %rdx
   21411: e8 6a fa ff ff               	callq	0x20e80 <bpf_core_calc_field_relo>
; 		err = err ?: bpf_core_calc_field_relo(prog_name, relo, targ_spec,
   21416: 5f                           	popq	%rdi
   21417: 41 58                        	popq	%r8
; 		err = bpf_core_calc_field_relo(prog_name, relo, local_spec,
   21419: 41 89 c4                     	movl	%eax, %r12d
; 		err = err ?: bpf_core_calc_field_relo(prog_name, relo, targ_spec,
   2141c: 85 c0                        	testl	%eax, %eax
   2141e: 0f 84 c4 00 00 00            	je	0x214e8 <bpf_core_calc_relo+0x148>
; 	if (err == -EUCLEAN) {
   21424: 41 83 fc 8b                  	cmpl	$-117, %r12d
   21428: 0f 84 aa 00 00 00            	je	0x214d8 <bpf_core_calc_relo+0x138>
; 	} else if (err == -EOPNOTSUPP) {
   2142e: 41 83 fc a1                  	cmpl	$-95, %r12d
   21432: 0f 84 9d 01 00 00            	je	0x215d5 <bpf_core_calc_relo+0x235>
; }
   21438: 48 83 c4 18                  	addq	$24, %rsp
   2143c: 44 89 e0                     	movl	%r12d, %eax
   2143f: 5b                           	popq	%rbx
   21440: 5d                           	popq	%rbp
   21441: 41 5c                        	popq	%r12
   21443: 41 5d                        	popq	%r13
   21445: 41 5e                        	popq	%r14
   21447: 41 5f                        	popq	%r15
   21449: c3                           	retq
   2144a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	switch (kind) {
   21450: 41 83 f9 09                  	cmpl	$9, %r9d
   21454: 77 32                        	ja	0x21488 <bpf_core_calc_relo+0xe8>
; 		err = bpf_core_calc_type_relo(relo, local_spec, &res->orig_val, &res->validate);
   21456: 48 8d 4b 11                  	leaq	17(%rbx), %rcx
   2145a: 48 89 da                     	movq	%rbx, %rdx
   2145d: 4c 89 fe                     	movq	%r15, %rsi
   21460: 48 89 ef                     	movq	%rbp, %rdi
   21463: e8 78 fd ff ff               	callq	0x211e0 <bpf_core_calc_type_relo>
   21468: 41 89 c4                     	movl	%eax, %r12d
; 		err = err ?: bpf_core_calc_type_relo(relo, targ_spec, &res->new_val, NULL);
   2146b: 85 c0                        	testl	%eax, %eax
   2146d: 75 b5                        	jne	0x21424 <bpf_core_calc_relo+0x84>
   2146f: 48 8d 53 08                  	leaq	8(%rbx), %rdx
   21473: 31 c9                        	xorl	%ecx, %ecx
   21475: 4c 89 f6                     	movq	%r14, %rsi
   21478: 48 89 ef                     	movq	%rbp, %rdi
   2147b: e8 60 fd ff ff               	callq	0x211e0 <bpf_core_calc_type_relo>
   21480: 41 89 c4                     	movl	%eax, %r12d
   21483: eb 9f                        	jmp	0x21424 <bpf_core_calc_relo+0x84>
   21485: 0f 1f 00                     	nopl	(%rax)
; 	switch (kind) {
   21488: 41 83 f9 0c                  	cmpl	$12, %r9d
   2148c: 74 c8                        	je	0x21456 <bpf_core_calc_relo+0xb6>
; 	switch (kind) {
   2148e: 41 8d 41 f6                  	leal	-10(%r9), %eax
   21492: 83 f8 01                     	cmpl	$1, %eax
   21495: 0f 86 d5 00 00 00            	jbe	0x21570 <bpf_core_calc_relo+0x1d0>
; 		pr_warn("prog '%s': relo #%d: unrecognized CO-RE relocation %s (%d) at insn #%d\n",
   2149b: 44 89 cf                     	movl	%r9d, %edi
   2149e: 48 8d 35 5b 85 01 00         	leaq	99675(%rip), %rsi       # 0x39a00 <CSWTCH.126+0x100>
   214a5: 41 bc a1 ff ff ff            	movl	$4294967201, %r12d      # imm = 0xFFFFFFA1
   214ab: e8 e0 f8 ff ff               	callq	0x20d90 <core_relo_kind_str>
   214b0: 8b 55 00                     	movl	(%rbp), %edx
   214b3: 48 83 ec 08                  	subq	$8, %rsp
   214b7: 31 ff                        	xorl	%edi, %edi
   214b9: 49 89 c0                     	movq	%rax, %r8
   214bc: 31 c0                        	xorl	%eax, %eax
   214be: c1 ea 03                     	shrl	$3, %edx
   214c1: 52                           	pushq	%rdx
   214c2: 8b 4c 24 1c                  	movl	28(%rsp), %ecx
   214c6: 4c 89 ea                     	movq	%r13, %rdx
   214c9: e8 02 6c fe ff               	callq	0x80d0 <libbpf_print>
   214ce: 58                           	popq	%rax
   214cf: 5a                           	popq	%rdx
   214d0: e9 63 ff ff ff               	jmp	0x21438 <bpf_core_calc_relo+0x98>
   214d5: 0f 1f 00                     	nopl	(%rax)
; 		res->poison = true;
   214d8: c6 43 10 01                  	movb	$1, 16(%rbx)
; 		err = 0;
   214dc: 45 31 e4                     	xorl	%r12d, %r12d
   214df: e9 54 ff ff ff               	jmp	0x21438 <bpf_core_calc_relo+0x98>
   214e4: 0f 1f 40 00                  	nopl	(%rax)
; 		err = err ?: bpf_core_calc_field_relo(prog_name, relo, targ_spec,
   214e8: 48 83 ec 08                  	subq	$8, %rsp
   214ec: 48 8d 4b 08                  	leaq	8(%rbx), %rcx
   214f0: 48 89 ee                     	movq	%rbp, %rsi
   214f3: 4c 89 f2                     	movq	%r14, %rdx
   214f6: 6a 00                        	pushq	$0
   214f8: 4c 8d 4b 20                  	leaq	32(%rbx), %r9
   214fc: 4c 8d 43 1c                  	leaq	28(%rbx), %r8
   21500: 4c 89 ef                     	movq	%r13, %rdi
   21503: e8 78 f9 ff ff               	callq	0x20e80 <bpf_core_calc_field_relo>
; 		if (err)
   21508: 59                           	popq	%rcx
   21509: 5e                           	popq	%rsi
; 		err = err ?: bpf_core_calc_field_relo(prog_name, relo, targ_spec,
   2150a: 41 89 c4                     	movl	%eax, %r12d
; 		if (err)
   2150d: 85 c0                        	testl	%eax, %eax
   2150f: 0f 85 0f ff ff ff            	jne	0x21424 <bpf_core_calc_relo+0x84>
; 		res->fail_memsz_adjust = false;
   21515: c6 43 12 00                  	movb	$0, 18(%rbx)
; 		if (res->orig_sz != res->new_sz) {
   21519: 8b 43 1c                     	movl	28(%rbx), %eax
   2151c: 39 43 14                     	cmpl	%eax, 20(%rbx)
   2151f: 0f 84 13 ff ff ff            	je	0x21438 <bpf_core_calc_relo+0x98>
; 			orig_t = btf_type_by_id(local_spec->btf, res->orig_type_id);
   21525: 8b 73 18                     	movl	24(%rbx), %esi
   21528: 49 8b 3f                     	movq	(%r15), %rdi
   2152b: e8 30 8a 00 00               	callq	0x29f60 <btf_type_by_id>
; 			new_t = btf_type_by_id(targ_spec->btf, res->new_type_id);
   21530: 8b 73 20                     	movl	32(%rbx), %esi
   21533: 49 8b 3e                     	movq	(%r14), %rdi
; 			orig_t = btf_type_by_id(local_spec->btf, res->orig_type_id);
   21536: 48 89 c5                     	movq	%rax, %rbp
; 			new_t = btf_type_by_id(targ_spec->btf, res->new_type_id);
   21539: e8 22 8a 00 00               	callq	0x29f60 <btf_type_by_id>
; 	return BTF_INFO_KIND(t->info);
   2153e: 0f b6 55 07                  	movzbl	7(%rbp), %edx
   21542: 83 e2 1f                     	andl	$31, %edx
; 			if (btf_is_ptr(orig_t) && btf_is_ptr(new_t))
   21545: 66 83 fa 02                  	cmpw	$2, %dx
   21549: 74 55                        	je	0x215a0 <bpf_core_calc_relo+0x200>
; 			if (btf_is_int(orig_t) && btf_is_int(new_t) &&
   2154b: 66 83 fa 01                  	cmpw	$1, %dx
   2154f: 75 0d                        	jne	0x2155e <bpf_core_calc_relo+0x1be>
; 	return BTF_INFO_KIND(t->info);
   21551: 0f b6 50 07                  	movzbl	7(%rax), %edx
   21555: 83 e2 1f                     	andl	$31, %edx
; 			if (btf_is_int(orig_t) && btf_is_int(new_t) &&
   21558: 66 83 fa 01                  	cmpw	$1, %dx
   2155c: 74 5a                        	je	0x215b8 <bpf_core_calc_relo+0x218>
; 			res->fail_memsz_adjust = true;
   2155e: c6 43 12 01                  	movb	$1, 18(%rbx)
; 	} else if (err == -EOPNOTSUPP) {
   21562: e9 d1 fe ff ff               	jmp	0x21438 <bpf_core_calc_relo+0x98>
   21567: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		err = bpf_core_calc_enumval_relo(relo, local_spec, &res->orig_val);
   21570: 48 89 da                     	movq	%rbx, %rdx
   21573: 48 89 ce                     	movq	%rcx, %rsi
   21576: 44 89 cf                     	movl	%r9d, %edi
   21579: e8 92 fd ff ff               	callq	0x21310 <bpf_core_calc_enumval_relo.isra.0>
   2157e: 41 89 c4                     	movl	%eax, %r12d
; 		err = err ?: bpf_core_calc_enumval_relo(relo, targ_spec, &res->new_val);
   21581: 85 c0                        	testl	%eax, %eax
   21583: 0f 85 9b fe ff ff            	jne	0x21424 <bpf_core_calc_relo+0x84>
   21589: 8b 7d 0c                     	movl	12(%rbp), %edi
   2158c: 48 8d 53 08                  	leaq	8(%rbx), %rdx
   21590: 4c 89 f6                     	movq	%r14, %rsi
   21593: e8 78 fd ff ff               	callq	0x21310 <bpf_core_calc_enumval_relo.isra.0>
   21598: 41 89 c4                     	movl	%eax, %r12d
   2159b: e9 84 fe ff ff               	jmp	0x21424 <bpf_core_calc_relo+0x84>
; 	return BTF_INFO_KIND(t->info);
   215a0: 0f b6 40 07                  	movzbl	7(%rax), %eax
   215a4: 83 e0 1f                     	andl	$31, %eax
; 			if (btf_is_ptr(orig_t) && btf_is_ptr(new_t))
   215a7: 66 83 f8 02                  	cmpw	$2, %ax
   215ab: 75 b1                        	jne	0x2155e <bpf_core_calc_relo+0x1be>
   215ad: e9 86 fe ff ff               	jmp	0x21438 <bpf_core_calc_relo+0x98>
   215b2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return BTF_INT_ENCODING(*(__u32 *)(t + 1));
   215b8: 0f b6 55 0f                  	movzbl	15(%rbp), %edx
   215bc: 83 e2 0f                     	andl	$15, %edx
; 			if (btf_is_int(orig_t) && btf_is_int(new_t) &&
   215bf: 80 fa 01                     	cmpb	$1, %dl
   215c2: 74 9a                        	je	0x2155e <bpf_core_calc_relo+0x1be>
; 	return BTF_INT_ENCODING(*(__u32 *)(t + 1));
   215c4: 0f b6 40 0f                  	movzbl	15(%rax), %eax
   215c8: 83 e0 0f                     	andl	$15, %eax
; 			    btf_int_encoding(orig_t) != BTF_INT_SIGNED &&
   215cb: 3c 01                        	cmpb	$1, %al
   215cd: 0f 85 65 fe ff ff            	jne	0x21438 <bpf_core_calc_relo+0x98>
   215d3: eb 89                        	jmp	0x2155e <bpf_core_calc_relo+0x1be>
   215d5: 44 8b 4d 0c                  	movl	12(%rbp), %r9d
   215d9: e9 bd fe ff ff               	jmp	0x2149b <bpf_core_calc_relo+0xfb>
   215de: 66 90                        	nop

00000000000215e0 <bpf_core_match_member>:
; {
   215e0: 41 57                        	pushq	%r15
   215e2: 4d 89 c7                     	movq	%r8, %r15
   215e5: 41 56                        	pushq	%r14
   215e7: 41 55                        	pushq	%r13
   215e9: 41 54                        	pushq	%r12
   215eb: 49 89 d4                     	movq	%rdx, %r12
   215ee: 55                           	pushq	%rbp
   215ef: 53                           	pushq	%rbx
   215f0: 48 83 ec 58                  	subq	$88, %rsp
   215f4: 48 89 7c 24 10               	movq	%rdi, 16(%rsp)
; 	targ_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
   215f9: 48 8d 54 24 3c               	leaq	60(%rsp), %rdx
   215fe: 4c 89 e7                     	movq	%r12, %rdi
; {
   21601: 48 89 74 24 18               	movq	%rsi, 24(%rsp)
   21606: 89 ce                        	movl	%ecx, %esi
   21608: 89 4c 24 3c                  	movl	%ecx, 60(%rsp)
   2160c: 4c 89 4c 24 28               	movq	%r9, 40(%rsp)
   21611: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2161a: 48 89 44 24 48               	movq	%rax, 72(%rsp)
   2161f: 31 c0                        	xorl	%eax, %eax
; 	targ_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
   21621: e8 4a 9f fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   21626: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	if (!targ_type)
   2162b: 48 85 c0                     	testq	%rax, %rax
   2162e: 0f 84 4c 03 00 00            	je	0x21980 <bpf_core_match_member+0x3a0>
; 	return BTF_INFO_KIND(t->info);
   21634: 0f b6 40 07                  	movzbl	7(%rax), %eax
   21638: 83 e0 1f                     	andl	$31, %eax
; 	return kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;
   2163b: 83 e8 04                     	subl	$4, %eax
; 	if (!btf_is_composite(targ_type))
   2163e: 66 83 f8 01                  	cmpw	$1, %ax
   21642: 76 2c                        	jbe	0x21670 <bpf_core_match_member+0x90>
; 		return 0;
   21644: 45 31 c9                     	xorl	%r9d, %r9d
; }
   21647: 48 8b 44 24 48               	movq	72(%rsp), %rax
   2164c: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   21655: 0f 85 30 03 00 00            	jne	0x2198b <bpf_core_match_member+0x3ab>
   2165b: 48 83 c4 58                  	addq	$88, %rsp
   2165f: 44 89 c8                     	movl	%r9d, %eax
   21662: 5b                           	popq	%rbx
   21663: 5d                           	popq	%rbp
   21664: 41 5c                        	popq	%r12
   21666: 41 5d                        	popq	%r13
   21668: 41 5e                        	popq	%r14
   2166a: 41 5f                        	popq	%r15
   2166c: c3                           	retq
   2166d: 0f 1f 00                     	nopl	(%rax)
; 	local_type = btf_type_by_id(local_btf, local_id);
   21670: 48 8b 5c 24 18               	movq	24(%rsp), %rbx
   21675: 4c 8b 74 24 10               	movq	16(%rsp), %r14
   2167a: 8b 33                        	movl	(%rbx), %esi
   2167c: 4c 89 f7                     	movq	%r14, %rdi
   2167f: e8 dc 88 00 00               	callq	0x29f60 <btf_type_by_id>
; 	local_name = btf__name_by_offset(local_btf, local_member->name_off);
   21684: 4c 89 f7                     	movq	%r14, %rdi
; 	local_type = btf_type_by_id(local_btf, local_id);
   21687: 49 89 c1                     	movq	%rax, %r9
; 	local_member = btf_members(local_type) + local_acc->idx;
   2168a: 8b 43 04                     	movl	4(%rbx), %eax
   2168d: 48 8d 44 40 03               	leaq	3(%rax,%rax,2), %rax
   21692: 49 8d 04 81                  	leaq	(%r9,%rax,4), %rax
; 	local_name = btf__name_by_offset(local_btf, local_member->name_off);
   21696: 8b 30                        	movl	(%rax), %esi
; 	local_member = btf_members(local_type) + local_acc->idx;
   21698: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	local_name = btf__name_by_offset(local_btf, local_member->name_off);
   2169d: e8 4e a4 00 00               	callq	0x2baf0 <btf__name_by_offset>
   216a2: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	return BTF_INFO_VLEN(t->info);
   216a7: 48 8b 44 24 08               	movq	8(%rsp), %rax
   216ac: 8b 50 04                     	movl	4(%rax), %edx
; 	return (struct btf_member *)(t + 1);
   216af: 4c 8d 70 0c                  	leaq	12(%rax), %r14
; 	for (i = 0; i < n; i++, m++) {
   216b3: 89 d0                        	movl	%edx, %eax
   216b5: 25 ff ff 00 00               	andl	$65535, %eax            # imm = 0xFFFF
   216ba: 89 44 24 38                  	movl	%eax, 56(%rsp)
   216be: 74 84                        	je	0x21644 <bpf_core_match_member+0x64>
   216c0: 4d 89 f5                     	movq	%r14, %r13
   216c3: 4c 89 24 24                  	movq	%r12, (%rsp)
; 		if (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)
   216c7: 41 8b 87 14 05 00 00         	movl	1300(%r15), %eax
; 	for (i = 0; i < n; i++, m++) {
   216ce: 31 ed                        	xorl	%ebp, %ebp
   216d0: 4d 89 fe                     	movq	%r15, %r14
   216d3: eb 5a                        	jmp	0x2172f <bpf_core_match_member+0x14f>
   216d5: 0f 1f 00                     	nopl	(%rax)
; 			found = bpf_core_match_member(local_btf, local_acc,
   216d8: 41 8b 4d 04                  	movl	4(%r13), %ecx
   216dc: 4c 8b 4c 24 28               	movq	40(%rsp), %r9
   216e1: 4d 89 f0                     	movq	%r14, %r8
   216e4: 48 8b 14 24                  	movq	(%rsp), %rdx
   216e8: 48 8b 74 24 18               	movq	24(%rsp), %rsi
   216ed: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   216f2: e8 e9 fe ff ff               	callq	0x215e0 <bpf_core_match_member>
; 			if (found) /* either found or error */
   216f7: 85 c0                        	testl	%eax, %eax
   216f9: 0f 85 79 02 00 00            	jne	0x21978 <bpf_core_match_member+0x398>
; 		spec->raw_len--;
   216ff: 41 8b 86 14 05 00 00         	movl	1300(%r14), %eax
; 		spec->bit_offset -= bit_offset;
   21706: 45 29 a6 18 05 00 00         	subl	%r12d, 1304(%r14)
; 	for (i = 0; i < n; i++, m++) {
   2170d: 49 83 c5 0c                  	addq	$12, %r13
; 		spec->raw_len--;
   21711: 83 e8 01                     	subl	$1, %eax
   21714: 41 89 86 14 05 00 00         	movl	%eax, 1300(%r14)
; 	for (i = 0; i < n; i++, m++) {
   2171b: 39 5c 24 38                  	cmpl	%ebx, 56(%rsp)
   2171f: 0f 84 1f ff ff ff            	je	0x21644 <bpf_core_match_member+0x64>
; 	return BTF_INFO_KFLAG(t->info);
   21725: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   2172a: 89 dd                        	movl	%ebx, %ebp
   2172c: 8b 57 04                     	movl	4(%rdi), %edx
; 	return kflag ? BTF_MEMBER_BIT_OFFSET(m->offset) : m->offset;
   2172f: 45 8b 65 08                  	movl	8(%r13), %r12d
   21733: 8d 5d 01                     	leal	1(%rbp), %ebx
   21736: 44 89 e1                     	movl	%r12d, %ecx
   21739: 81 e1 ff ff ff 00            	andl	$16777215, %ecx         # imm = 0xFFFFFF
   2173f: 85 d2                        	testl	%edx, %edx
   21741: 44 0f 48 e1                  	cmovsl	%ecx, %r12d
; 		if (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)
   21745: 83 f8 40                     	cmpl	$64, %eax
   21748: 0f 84 6a 01 00 00            	je	0x218b8 <bpf_core_match_member+0x2d8>
; 		spec->bit_offset += bit_offset;
   2174e: 45 01 a6 18 05 00 00         	addl	%r12d, 1304(%r14)
; 		spec->raw_spec[spec->raw_len++] = i;
   21755: 8d 50 01                     	leal	1(%rax), %edx
   21758: 48 98                        	cltq
; 		targ_name = btf__name_by_offset(targ_btf, m->name_off);
   2175a: 48 8b 3c 24                  	movq	(%rsp), %rdi
; 		spec->raw_spec[spec->raw_len++] = i;
   2175e: 41 89 96 14 05 00 00         	movl	%edx, 1300(%r14)
   21765: 41 89 ac 86 14 04 00 00      	movl	%ebp, 1044(%r14,%rax,4)
; 		targ_name = btf__name_by_offset(targ_btf, m->name_off);
   2176d: 41 8b 75 00                  	movl	(%r13), %esi
   21771: e8 7a a3 00 00               	callq	0x2baf0 <btf__name_by_offset>
   21776: 49 89 c7                     	movq	%rax, %r15
; 	return !s || !s[0];
   21779: 48 85 c0                     	testq	%rax, %rax
   2177c: 0f 84 56 ff ff ff            	je	0x216d8 <bpf_core_match_member+0xf8>
   21782: 80 38 00                     	cmpb	$0, (%rax)
   21785: 0f 84 4d ff ff ff            	je	0x216d8 <bpf_core_match_member+0xf8>
; 		} else if (strcmp(local_name, targ_name) == 0) {
   2178b: 48 8b 7c 24 20               	movq	32(%rsp), %rdi
   21790: 48 89 c6                     	movq	%rax, %rsi
   21793: e8 18 42 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   21798: 85 c0                        	testl	%eax, %eax
   2179a: 0f 85 5f ff ff ff            	jne	0x216ff <bpf_core_match_member+0x11f>
   217a0: 41 89 c1                     	movl	%eax, %r9d
   217a3: 4c 89 fa                     	movq	%r15, %rdx
; 			*next_targ_id = m->type;
   217a6: 48 8b 5c 24 28               	movq	40(%rsp), %rbx
   217ab: 4c 8b 24 24                  	movq	(%rsp), %r12
; 			targ_acc = &spec->spec[spec->len++];
   217af: 49 63 86 10 04 00 00         	movslq	1040(%r14), %rax
; 	switch (btf_kind(local_type)) {
   217b6: 45 89 cf                     	movl	%r9d, %r15d
; 			targ_acc = &spec->spec[spec->len++];
   217b9: 8d 48 01                     	leal	1(%rax), %ecx
   217bc: 48 c1 e0 04                  	shlq	$4, %rax
   217c0: 41 89 8e 10 04 00 00         	movl	%ecx, 1040(%r14)
; 			targ_acc->type_id = targ_id;
   217c7: 8b 4c 24 3c                  	movl	60(%rsp), %ecx
   217cb: 4c 01 f0                     	addq	%r14, %rax
; 			targ_acc->idx = i;
   217ce: 89 68 0c                     	movl	%ebp, 12(%rax)
   217d1: 48 8d 6c 24 44               	leaq	68(%rsp), %rbp
; 			targ_acc->type_id = targ_id;
   217d6: 89 48 08                     	movl	%ecx, 8(%rax)
; 			targ_acc->name = targ_name;
   217d9: 48 89 50 10                  	movq	%rdx, 16(%rax)
; 			*next_targ_id = m->type;
   217dd: 41 8b 45 04                  	movl	4(%r13), %eax
   217e1: 89 03                        	movl	%eax, (%rbx)
; 							   local_member->type,
   217e3: 48 8b 5c 24 30               	movq	48(%rsp), %rbx
; 							   targ_btf, m->type);
   217e8: 41 8b 45 04                  	movl	4(%r13), %eax
; 	switch (btf_kind(local_type)) {
   217ec: 4d 89 f5                     	movq	%r14, %r13
; 							   local_member->type,
   217ef: 8b 73 04                     	movl	4(%rbx), %esi
   217f2: 48 8d 5c 24 40               	leaq	64(%rsp), %rbx
   217f7: 89 74 24 40                  	movl	%esi, 64(%rsp)
; 	local_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);
   217fb: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   21800: 48 89 da                     	movq	%rbx, %rdx
   21803: 89 44 24 44                  	movl	%eax, 68(%rsp)
   21807: e8 64 9d fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	targ_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
   2180c: 8b 74 24 44                  	movl	68(%rsp), %esi
   21810: 4c 89 e7                     	movq	%r12, %rdi
   21813: 48 89 ea                     	movq	%rbp, %rdx
; 	local_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);
   21816: 49 89 c6                     	movq	%rax, %r14
; 	targ_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
   21819: e8 52 9d fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   2181e: 48 89 c7                     	movq	%rax, %rdi
; 	if (!local_type || !targ_type)
   21821: 4d 85 f6                     	testq	%r14, %r14
   21824: 0f 84 56 01 00 00            	je	0x21980 <bpf_core_match_member+0x3a0>
   2182a: 48 85 c0                     	testq	%rax, %rax
   2182d: 0f 84 4d 01 00 00            	je	0x21980 <bpf_core_match_member+0x3a0>
; 	return BTF_INFO_KIND(t->info);
   21833: 41 0f b6 46 07               	movzbl	7(%r14), %eax
   21838: 0f b6 57 07                  	movzbl	7(%rdi), %edx
   2183c: 83 e0 1f                     	andl	$31, %eax
   2183f: 83 e2 1f                     	andl	$31, %edx
; 	return kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;
   21842: 8d 70 fc                     	leal	-4(%rax), %esi
; 	if (btf_is_composite(local_type) && btf_is_composite(targ_type))
   21845: 66 83 fe 01                  	cmpw	$1, %si
   21849: 76 3d                        	jbe	0x21888 <bpf_core_match_member+0x2a8>
; 	return btf_kind(t1) == btf_kind(t2) ||
   2184b: 66 39 d0                     	cmpw	%dx, %ax
   2184e: 74 18                        	je	0x21868 <bpf_core_match_member+0x288>
; 	return btf_is_enum(t) || btf_is_enum64(t);
   21850: 0f b7 f0                     	movzwl	%ax, %esi
   21853: 41 b8 40 00 08 00            	movl	$524352, %r8d           # imm = 0x80040
   21859: 49 0f a3 f0                  	btq	%rsi, %r8
   2185d: 73 41                        	jae	0x218a0 <bpf_core_match_member+0x2c0>
   2185f: 0f b7 d2                     	movzwl	%dx, %edx
   21862: 49 0f a3 d0                  	btq	%rdx, %r8
   21866: 73 38                        	jae	0x218a0 <bpf_core_match_member+0x2c0>
; 	switch (btf_kind(local_type)) {
   21868: 66 83 f8 13                  	cmpw	$19, %ax
   2186c: 77 32                        	ja	0x218a0 <bpf_core_match_member+0x2c0>
   2186e: 48 8d 35 77 7f 01 00         	leaq	98167(%rip), %rsi       # 0x397ec <CSWTCH.76+0x1ac>
   21875: 0f b7 c0                     	movzwl	%ax, %eax
   21878: 48 63 04 86                  	movslq	(%rsi,%rax,4), %rax
   2187c: 48 01 f0                     	addq	%rsi, %rax
   2187f: 3e ff e0                     	jmpq	*%rax
   21882: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;
   21888: 8d 72 fc                     	leal	-4(%rdx), %esi
; 	if (btf_is_composite(local_type) && btf_is_composite(targ_type))
   2188b: 66 83 fe 01                  	cmpw	$1, %si
   2188f: 0f 86 a3 00 00 00            	jbe	0x21938 <bpf_core_match_member+0x358>
; 	return btf_kind(t1) == btf_kind(t2) ||
   21895: 66 39 d0                     	cmpw	%dx, %ax
   21898: 75 b6                        	jne	0x21850 <bpf_core_match_member+0x270>
   2189a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   218a0: 45 89 f9                     	movl	%r15d, %r9d
   218a3: 4d 89 ef                     	movq	%r13, %r15
; 				spec->len--; /* pop accessor */
   218a6: 41 83 af 10 04 00 00 01      	subl	$1, 1040(%r15)
   218ae: e9 94 fd ff ff               	jmp	0x21647 <bpf_core_match_member+0x67>
   218b3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			return -E2BIG;
   218b8: 41 b9 f9 ff ff ff            	movl	$4294967289, %r9d       # imm = 0xFFFFFFF9
   218be: e9 84 fd ff ff               	jmp	0x21647 <bpf_core_match_member+0x67>
; 		local_name = btf__name_by_offset(local_btf,
   218c3: 44 89 3c 24                  	movl	%r15d, (%rsp)
   218c7: 4d 89 ef                     	movq	%r13, %r15
   218ca: 4d 89 f5                     	movq	%r14, %r13
   218cd: 49 89 fe                     	movq	%rdi, %r14
   218d0: 41 8b 75 00                  	movl	(%r13), %esi
   218d4: 48 8b 7c 24 10               	movq	16(%rsp), %rdi
   218d9: e8 12 a2 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 		targ_name = btf__name_by_offset(targ_btf, targ_type->name_off);
   218de: 41 8b 36                     	movl	(%r14), %esi
   218e1: 4c 89 e7                     	movq	%r12, %rdi
; 		local_name = btf__name_by_offset(local_btf,
   218e4: 48 89 c5                     	movq	%rax, %rbp
; 		targ_name = btf__name_by_offset(targ_btf, targ_type->name_off);
   218e7: e8 04 a2 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 		local_len = bpf_core_essential_name_len(local_name);
   218ec: 48 89 ef                     	movq	%rbp, %rdi
; 		targ_name = btf__name_by_offset(targ_btf, targ_type->name_off);
   218ef: 49 89 c5                     	movq	%rax, %r13
; 		local_len = bpf_core_essential_name_len(local_name);
   218f2: e8 49 c7 fe ff               	callq	0xe040 <bpf_core_essential_name_len>
; 		targ_len = bpf_core_essential_name_len(targ_name);
   218f7: 4c 89 ef                     	movq	%r13, %rdi
; 		local_len = bpf_core_essential_name_len(local_name);
   218fa: 49 89 c4                     	movq	%rax, %r12
; 		targ_len = bpf_core_essential_name_len(targ_name);
   218fd: e8 3e c7 fe ff               	callq	0xe040 <bpf_core_essential_name_len>
; 		return local_len == 0 || targ_len == 0 ||
   21902: 4d 85 e4                     	testq	%r12, %r12
   21905: 74 31                        	je	0x21938 <bpf_core_match_member+0x358>
   21907: 48 85 c0                     	testq	%rax, %rax
   2190a: 44 8b 0c 24                  	movl	(%rsp), %r9d
   2190e: 74 28                        	je	0x21938 <bpf_core_match_member+0x358>
   21910: 49 39 c4                     	cmpq	%rax, %r12
   21913: 75 91                        	jne	0x218a6 <bpf_core_match_member+0x2c6>
; 			strncmp(local_name, targ_name, local_len) == 0);
   21915: 4c 89 e2                     	movq	%r12, %rdx
   21918: 4c 89 ee                     	movq	%r13, %rsi
   2191b: 48 89 ef                     	movq	%rbp, %rdi
   2191e: 44 89 0c 24                  	movl	%r9d, (%rsp)
   21922: e8 f9 3d fe ff               	callq	0x5720 <.plt.sec+0xb0>
   21927: 44 8b 0c 24                  	movl	(%rsp), %r9d
; 		       (local_len == targ_len &&
   2192b: 85 c0                        	testl	%eax, %eax
   2192d: 0f 85 73 ff ff ff            	jne	0x218a6 <bpf_core_match_member+0x2c6>
   21933: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		return 1;
   21938: 41 b9 01 00 00 00            	movl	$1, %r9d
; 			if (!found)
   2193e: e9 04 fd ff ff               	jmp	0x21647 <bpf_core_match_member+0x67>
; 		local_id = btf_array(local_type)->type;
   21943: 41 8b 76 0c                  	movl	12(%r14), %esi
; 		targ_id = btf_array(targ_type)->type;
   21947: 8b 47 0c                     	movl	12(%rdi), %eax
; 		local_id = btf_array(local_type)->type;
   2194a: 89 74 24 40                  	movl	%esi, 64(%rsp)
; 		goto recur;
   2194e: e9 a8 fe ff ff               	jmp	0x217fb <bpf_core_match_member+0x21b>
; 		return btf_int_offset(local_type) == 0 &&
   21953: 45 89 f9                     	movl	%r15d, %r9d
   21956: 4d 89 ef                     	movq	%r13, %r15
   21959: 4d 89 f5                     	movq	%r14, %r13
   2195c: 41 80 7d 0e 00               	cmpb	$0, 14(%r13)
   21961: 0f 85 3f ff ff ff            	jne	0x218a6 <bpf_core_match_member+0x2c6>
   21967: 80 7f 0e 00                  	cmpb	$0, 14(%rdi)
   2196b: 74 cb                        	je	0x21938 <bpf_core_match_member+0x358>
   2196d: e9 34 ff ff ff               	jmp	0x218a6 <bpf_core_match_member+0x2c6>
   21972: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   21978: 41 89 c1                     	movl	%eax, %r9d
   2197b: e9 c7 fc ff ff               	jmp	0x21647 <bpf_core_match_member+0x67>
; 		return -EINVAL;
   21980: 41 b9 ea ff ff ff            	movl	$4294967274, %r9d       # imm = 0xFFFFFFEA
   21986: e9 bc fc ff ff               	jmp	0x21647 <bpf_core_match_member+0x67>
; }
   2198b: e8 70 3e fe ff               	callq	0x5800 <.plt.sec+0x190>

0000000000021990 <__bpf_core_types_are_compat>:
; {
   21990: f3 0f 1e fa                  	endbr64
   21994: 41 57                        	pushq	%r15
   21996: 41 56                        	pushq	%r14
   21998: 41 55                        	pushq	%r13
   2199a: 41 54                        	pushq	%r12
   2199c: 55                           	pushq	%rbp
   2199d: 48 89 d5                     	movq	%rdx, %rbp
   219a0: 53                           	pushq	%rbx
   219a1: 48 89 fb                     	movq	%rdi, %rbx
   219a4: 48 83 ec 38                  	subq	$56, %rsp
   219a8: 44 89 44 24 04               	movl	%r8d, 4(%rsp)
   219ad: 89 74 24 2c                  	movl	%esi, 44(%rsp)
   219b1: 89 4c 24 28                  	movl	%ecx, 40(%rsp)
; 	local_type = btf_type_by_id(local_btf, local_id);
   219b5: e8 a6 85 00 00               	callq	0x29f60 <btf_type_by_id>
; 	targ_type = btf_type_by_id(targ_btf, targ_id);
   219ba: 8b 74 24 28                  	movl	40(%rsp), %esi
   219be: 48 89 ef                     	movq	%rbp, %rdi
; 	local_type = btf_type_by_id(local_btf, local_id);
   219c1: 49 89 c4                     	movq	%rax, %r12
; 	targ_type = btf_type_by_id(targ_btf, targ_id);
   219c4: e8 97 85 00 00               	callq	0x29f60 <btf_type_by_id>
   219c9: 49 89 c0                     	movq	%rax, %r8
; 	return BTF_INFO_KIND(t->info);
   219cc: 41 0f b6 44 24 07            	movzbl	7(%r12), %eax
   219d2: 41 0f b6 50 07               	movzbl	7(%r8), %edx
   219d7: 83 e0 1f                     	andl	$31, %eax
   219da: 83 e2 1f                     	andl	$31, %edx
; 	return btf_kind(t1) == btf_kind(t2) ||
   219dd: 66 39 d0                     	cmpw	%dx, %ax
   219e0: 0f 84 1a 01 00 00            	je	0x21b00 <__bpf_core_types_are_compat+0x170>
; 	return btf_is_enum(t) || btf_is_enum64(t);
   219e6: 0f b7 c0                     	movzwl	%ax, %eax
   219e9: b9 40 00 08 00               	movl	$524352, %ecx           # imm = 0x80040
   219ee: 48 0f a3 c1                  	btq	%rax, %rcx
   219f2: 0f 83 d8 00 00 00            	jae	0x21ad0 <__bpf_core_types_are_compat+0x140>
   219f8: 0f b7 d2                     	movzwl	%dx, %edx
   219fb: c7 04 24 20 00 00 00         	movl	$32, (%rsp)
   21a02: 48 0f a3 d1                  	btq	%rdx, %rcx
   21a06: 0f 83 c4 00 00 00            	jae	0x21ad0 <__bpf_core_types_are_compat+0x140>
   21a0c: 4c 8d 64 24 2c               	leaq	44(%rsp), %r12
   21a11: 4c 8d 6c 24 28               	leaq	40(%rsp), %r13
; 	local_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);
   21a16: 8b 74 24 2c                  	movl	44(%rsp), %esi
   21a1a: 4c 89 e2                     	movq	%r12, %rdx
   21a1d: 48 89 df                     	movq	%rbx, %rdi
   21a20: e8 4b 9b fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	targ_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
   21a25: 8b 74 24 28                  	movl	40(%rsp), %esi
   21a29: 4c 89 ea                     	movq	%r13, %rdx
   21a2c: 48 89 ef                     	movq	%rbp, %rdi
; 	local_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);
   21a2f: 49 89 c7                     	movq	%rax, %r15
; 	targ_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
   21a32: e8 39 9b fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   21a37: 49 89 c2                     	movq	%rax, %r10
; 	if (!local_type || !targ_type)
   21a3a: 4d 85 ff                     	testq	%r15, %r15
   21a3d: 0f 84 bf 01 00 00            	je	0x21c02 <__bpf_core_types_are_compat+0x272>
   21a43: 48 85 c0                     	testq	%rax, %rax
   21a46: 0f 84 b6 01 00 00            	je	0x21c02 <__bpf_core_types_are_compat+0x272>
; 	if (!btf_kind_core_compat(local_type, targ_type))
   21a4c: 8b 70 04                     	movl	4(%rax), %esi
; 	return BTF_INFO_KIND(t->info);
   21a4f: 41 8b 4f 04                  	movl	4(%r15), %ecx
   21a53: 89 f2                        	movl	%esi, %edx
   21a55: 89 c8                        	movl	%ecx, %eax
   21a57: c1 e8 18                     	shrl	$24, %eax
   21a5a: c1 ea 18                     	shrl	$24, %edx
   21a5d: 83 e0 1f                     	andl	$31, %eax
   21a60: 83 e2 1f                     	andl	$31, %edx
; 	return btf_kind(t1) == btf_kind(t2) ||
   21a63: 66 39 d0                     	cmpw	%dx, %ax
   21a66: 74 18                        	je	0x21a80 <__bpf_core_types_are_compat+0xf0>
; 	return btf_is_enum(t) || btf_is_enum64(t);
   21a68: 0f b7 f8                     	movzwl	%ax, %edi
   21a6b: 41 b8 40 00 08 00            	movl	$524352, %r8d           # imm = 0x80040
   21a71: 49 0f a3 f8                  	btq	%rdi, %r8
   21a75: 73 59                        	jae	0x21ad0 <__bpf_core_types_are_compat+0x140>
   21a77: 0f b7 d2                     	movzwl	%dx, %edx
   21a7a: 49 0f a3 d0                  	btq	%rdx, %r8
   21a7e: 73 50                        	jae	0x21ad0 <__bpf_core_types_are_compat+0x140>
; 	switch (btf_kind(local_type)) {
   21a80: 66 83 f8 13                  	cmpw	$19, %ax
   21a84: 77 1a                        	ja	0x21aa0 <__bpf_core_types_are_compat+0x110>
   21a86: 48 8d 3d af 7d 01 00         	leaq	97711(%rip), %rdi       # 0x3983c <CSWTCH.76+0x1fc>
   21a8d: 0f b7 c0                     	movzwl	%ax, %eax
   21a90: 48 63 04 87                  	movslq	(%rdi,%rax,4), %rax
   21a94: 48 01 f8                     	addq	%rdi, %rax
   21a97: 3e ff e0                     	jmpq	*%rax
   21a9a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("unexpected kind %s relocated, local [%d], target [%d]\n",
   21aa0: 8b 5c 24 28                  	movl	40(%rsp), %ebx
   21aa4: 44 8b 64 24 2c               	movl	44(%rsp), %r12d
   21aa9: 4c 89 ff                     	movq	%r15, %rdi
   21aac: e8 4f 9d fe ff               	callq	0xb800 <btf_kind_str>
   21ab1: 48 8d 35 98 7f 01 00         	leaq	98200(%rip), %rsi       # 0x39a50 <CSWTCH.126+0x150>
   21ab8: 31 ff                        	xorl	%edi, %edi
   21aba: 48 89 c2                     	movq	%rax, %rdx
   21abd: 41 89 d8                     	movl	%ebx, %r8d
   21ac0: 44 89 e1                     	movl	%r12d, %ecx
   21ac3: 31 c0                        	xorl	%eax, %eax
   21ac5: e8 06 66 fe ff               	callq	0x80d0 <libbpf_print>
   21aca: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return 0;
   21ad0: 31 c0                        	xorl	%eax, %eax
; }
   21ad2: 48 83 c4 38                  	addq	$56, %rsp
   21ad6: 5b                           	popq	%rbx
   21ad7: 5d                           	popq	%rbp
   21ad8: 41 5c                        	popq	%r12
   21ada: 41 5d                        	popq	%r13
   21adc: 41 5e                        	popq	%r14
   21ade: 41 5f                        	popq	%r15
   21ae0: c3                           	retq
   21ae1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   21ae8: 48 83 c4 38                  	addq	$56, %rsp
; 	switch (btf_kind(local_type)) {
   21aec: b8 01 00 00 00               	movl	$1, %eax
; }
   21af1: 5b                           	popq	%rbx
   21af2: 5d                           	popq	%rbp
   21af3: 41 5c                        	popq	%r12
   21af5: 41 5d                        	popq	%r13
   21af7: 41 5e                        	popq	%r14
   21af9: 41 5f                        	popq	%r15
   21afb: c3                           	retq
   21afc: 0f 1f 40 00                  	nopl	(%rax)
   21b00: c7 04 24 20 00 00 00         	movl	$32, (%rsp)
   21b07: e9 00 ff ff ff               	jmp	0x21a0c <__bpf_core_types_are_compat+0x7c>
   21b0c: 0f 1f 40 00                  	nopl	(%rax)
; 	return (struct btf_param *)(t + 1);
   21b10: 4d 8d 5f 0c                  	leaq	12(%r15), %r11
   21b14: 4d 8d 72 0c                  	leaq	12(%r10), %r14
; 		if (local_vlen != targ_vlen)
   21b18: 66 39 ce                     	cmpw	%cx, %si
   21b1b: 75 b3                        	jne	0x21ad0 <__bpf_core_types_are_compat+0x140>
; 		for (i = 0; i < local_vlen; i++, local_p++, targ_p++) {
   21b1d: 81 e1 ff ff 00 00            	andl	$65535, %ecx            # imm = 0xFFFF
   21b23: 0f 84 8e 00 00 00            	je	0x21bb7 <__bpf_core_types_are_compat+0x227>
; 			if (level <= 0)
   21b29: 8b 44 24 04                  	movl	4(%rsp), %eax
   21b2d: 85 c0                        	testl	%eax, %eax
   21b2f: 0f 8e cd 00 00 00            	jle	0x21c02 <__bpf_core_types_are_compat+0x272>
; 			err = __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id,
   21b35: 83 e8 01                     	subl	$1, %eax
   21b38: 4c 89 54 24 20               	movq	%r10, 32(%rsp)
   21b3d: 89 44 24 08                  	movl	%eax, 8(%rsp)
   21b41: 8d 41 ff                     	leal	-1(%rcx), %eax
   21b44: 49 8d 44 c7 14               	leaq	20(%r15,%rax,8), %rax
   21b49: 4c 89 7c 24 18               	movq	%r15, 24(%rsp)
   21b4e: 4d 89 df                     	movq	%r11, %r15
   21b51: 48 89 44 24 10               	movq	%rax, 16(%rsp)
   21b56: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 			skip_mods_and_typedefs(local_btf, local_p->type, &local_id);
   21b60: 41 8b 77 04                  	movl	4(%r15), %esi
   21b64: 4c 89 e2                     	movq	%r12, %rdx
   21b67: 48 89 df                     	movq	%rbx, %rdi
   21b6a: e8 01 9a fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 			skip_mods_and_typedefs(targ_btf, targ_p->type, &targ_id);
   21b6f: 41 8b 76 04                  	movl	4(%r14), %esi
   21b73: 4c 89 ea                     	movq	%r13, %rdx
   21b76: 48 89 ef                     	movq	%rbp, %rdi
   21b79: e8 f2 99 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 			err = __bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id,
   21b7e: 44 8b 44 24 08               	movl	8(%rsp), %r8d
   21b83: 48 89 ea                     	movq	%rbp, %rdx
   21b86: 48 89 df                     	movq	%rbx, %rdi
   21b89: 8b 4c 24 28                  	movl	40(%rsp), %ecx
   21b8d: 8b 74 24 2c                  	movl	44(%rsp), %esi
   21b91: e8 fa fd ff ff               	callq	0x21990 <__bpf_core_types_are_compat>
; 			if (err <= 0)
   21b96: 85 c0                        	testl	%eax, %eax
   21b98: 0f 8e 34 ff ff ff            	jle	0x21ad2 <__bpf_core_types_are_compat+0x142>
; 		for (i = 0; i < local_vlen; i++, local_p++, targ_p++) {
   21b9e: 49 83 c7 08                  	addq	$8, %r15
   21ba2: 49 83 c6 08                  	addq	$8, %r14
   21ba6: 4c 3b 7c 24 10               	cmpq	16(%rsp), %r15
   21bab: 75 b3                        	jne	0x21b60 <__bpf_core_types_are_compat+0x1d0>
   21bad: 4c 8b 7c 24 18               	movq	24(%rsp), %r15
   21bb2: 4c 8b 54 24 20               	movq	32(%rsp), %r10
; 		skip_mods_and_typedefs(local_btf, local_type->type, &local_id);
   21bb7: 41 8b 77 08                  	movl	8(%r15), %esi
   21bbb: 4c 89 e2                     	movq	%r12, %rdx
   21bbe: 48 89 df                     	movq	%rbx, %rdi
   21bc1: 4c 89 54 24 08               	movq	%r10, 8(%rsp)
   21bc6: e8 a5 99 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 		skip_mods_and_typedefs(targ_btf, targ_type->type, &targ_id);
   21bcb: 4c 8b 54 24 08               	movq	8(%rsp), %r10
   21bd0: 4c 89 ea                     	movq	%r13, %rdx
   21bd3: 48 89 ef                     	movq	%rbp, %rdi
   21bd6: 41 8b 72 08                  	movl	8(%r10), %esi
   21bda: e8 91 99 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 		goto recur;
   21bdf: eb 17                        	jmp	0x21bf8 <__bpf_core_types_are_compat+0x268>
   21be1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		local_id = btf_array(local_type)->type;
   21be8: 41 8b 47 0c                  	movl	12(%r15), %eax
   21bec: 89 44 24 2c                  	movl	%eax, 44(%rsp)
; 		targ_id = btf_array(targ_type)->type;
   21bf0: 41 8b 42 0c                  	movl	12(%r10), %eax
   21bf4: 89 44 24 28                  	movl	%eax, 40(%rsp)
; 	if (depth < 0)
   21bf8: 83 2c 24 01                  	subl	$1, (%rsp)
   21bfc: 0f 85 14 fe ff ff            	jne	0x21a16 <__bpf_core_types_are_compat+0x86>
; 		return -EINVAL;
   21c02: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   21c07: e9 c6 fe ff ff               	jmp	0x21ad2 <__bpf_core_types_are_compat+0x142>
   21c0c: 0f 1f 40 00                  	nopl	(%rax)
; 		return btf_int_offset(local_type) == 0 && btf_int_offset(targ_type) == 0;
   21c10: 41 80 7f 0e 00               	cmpb	$0, 14(%r15)
   21c15: 0f 85 b5 fe ff ff            	jne	0x21ad0 <__bpf_core_types_are_compat+0x140>
   21c1b: 31 c0                        	xorl	%eax, %eax
   21c1d: 41 80 7a 0e 00               	cmpb	$0, 14(%r10)
   21c22: 0f 94 c0                     	sete	%al
   21c25: e9 a8 fe ff ff               	jmp	0x21ad2 <__bpf_core_types_are_compat+0x142>
   21c2a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		local_id = local_type->type;
   21c30: 41 8b 47 08                  	movl	8(%r15), %eax
   21c34: 89 44 24 2c                  	movl	%eax, 44(%rsp)
; 		targ_id = targ_type->type;
   21c38: 41 8b 42 08                  	movl	8(%r10), %eax
   21c3c: 89 44 24 28                  	movl	%eax, 40(%rsp)
; 		goto recur;
   21c40: eb b6                        	jmp	0x21bf8 <__bpf_core_types_are_compat+0x268>
   21c42: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   21c4d: 0f 1f 00                     	nopl	(%rax)

0000000000021c50 <bpf_core_parse_spec>:
; {
   21c50: f3 0f 1e fa                  	endbr64
   21c54: 41 57                        	pushq	%r15
   21c56: 41 56                        	pushq	%r14
   21c58: 41 55                        	pushq	%r13
   21c5a: 41 54                        	pushq	%r12
   21c5c: 55                           	pushq	%rbp
   21c5d: 48 89 cd                     	movq	%rcx, %rbp
   21c60: 53                           	pushq	%rbx
   21c61: 48 89 d3                     	movq	%rdx, %rbx
   21c64: 48 83 ec 48                  	subq	$72, %rsp
   21c68: 48 89 7c 24 10               	movq	%rdi, 16(%rsp)
   21c6d: 48 89 f7                     	movq	%rsi, %rdi
   21c70: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	spec_str = btf__name_by_offset(btf, relo->access_str_off);
   21c75: 8b 72 08                     	movl	8(%rdx), %esi
; {
   21c78: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   21c81: 48 89 44 24 38               	movq	%rax, 56(%rsp)
   21c86: 31 c0                        	xorl	%eax, %eax
; 	spec_str = btf__name_by_offset(btf, relo->access_str_off);
   21c88: e8 63 9e 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 	return !s || !s[0];
   21c8d: 48 85 c0                     	testq	%rax, %rax
   21c90: 74 0a                        	je	0x21c9c <bpf_core_parse_spec+0x4c>
   21c92: 49 89 c7                     	movq	%rax, %r15
   21c95: 0f b6 00                     	movzbl	(%rax), %eax
   21c98: 84 c0                        	testb	%al, %al
   21c9a: 75 2c                        	jne	0x21cc8 <bpf_core_parse_spec+0x78>
; 			return -EINVAL;
   21c9c: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   21ca1: 48 8b 54 24 38               	movq	56(%rsp), %rdx
   21ca6: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   21caf: 0f 85 32 04 00 00            	jne	0x220e7 <bpf_core_parse_spec+0x497>
   21cb5: 48 83 c4 48                  	addq	$72, %rsp
   21cb9: 5b                           	popq	%rbx
   21cba: 5d                           	popq	%rbp
   21cbb: 41 5c                        	popq	%r12
   21cbd: 41 5d                        	popq	%r13
   21cbf: 41 5e                        	popq	%r14
   21cc1: 41 5f                        	popq	%r15
   21cc3: c3                           	retq
   21cc4: 0f 1f 40 00                  	nopl	(%rax)
; 	if (str_is_empty(spec_str) || *spec_str == ':')
   21cc8: 3c 3a                        	cmpb	$58, %al
   21cca: 74 d0                        	je	0x21c9c <bpf_core_parse_spec+0x4c>
;   return __builtin___memset_chk (__dest, __ch, __len,
   21ccc: 48 8d 7d 08                  	leaq	8(%rbp), %rdi
   21cd0: 48 89 e9                     	movq	%rbp, %rcx
   21cd3: 31 c0                        	xorl	%eax, %eax
   21cd5: 48 c7 85 18 05 00 00 00 00 00 00     	movq	$0, 1304(%rbp)
   21ce0: 48 83 e7 f8                  	andq	$-8, %rdi
   21ce4: 48 29 f9                     	subq	%rdi, %rcx
   21ce7: 81 c1 20 05 00 00            	addl	$1312, %ecx             # imm = 0x520
   21ced: c1 e9 03                     	shrl	$3, %ecx
   21cf0: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	spec->btf = btf;
   21cf3: 48 8b 44 24 08               	movq	8(%rsp), %rax
   21cf8: 48 89 45 00                  	movq	%rax, (%rbp)
; 	spec->root_type_id = relo->type_id;
   21cfc: 8b 43 04                     	movl	4(%rbx), %eax
   21cff: 89 85 08 04 00 00            	movl	%eax, 1032(%rbp)
; 	spec->relo_kind = relo->kind;
   21d05: 8b 43 0c                     	movl	12(%rbx), %eax
   21d08: 89 85 0c 04 00 00            	movl	%eax, 1036(%rbp)
; 	switch (kind) {
   21d0e: 83 f8 09                     	cmpl	$9, %eax
   21d11: 77 2d                        	ja	0x21d40 <bpf_core_parse_spec+0xf0>
   21d13: 83 f8 05                     	cmpl	$5, %eax
   21d16: 77 2d                        	ja	0x21d45 <bpf_core_parse_spec+0xf5>
; 	while (*spec_str) {
   21d18: 41 0f b6 07                  	movzbl	(%r15), %eax
   21d1c: 4c 8d 74 24 30               	leaq	48(%rsp), %r14
   21d21: 4c 8d 6c 24 2c               	leaq	44(%rsp), %r13
   21d26: 4c 8d 25 e3 05 01 00         	leaq	67043(%rip), %r12       # 0x32310 <_IO_stdin_used+0x2310>
   21d2d: 84 c0                        	testb	%al, %al
   21d2f: 75 67                        	jne	0x21d98 <bpf_core_parse_spec+0x148>
   21d31: e9 66 ff ff ff               	jmp	0x21c9c <bpf_core_parse_spec+0x4c>
   21d36: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	switch (kind) {
   21d40: 83 f8 0c                     	cmpl	$12, %eax
   21d43: 75 d3                        	jne	0x21d18 <bpf_core_parse_spec+0xc8>
; 		if (strcmp(spec_str, "0"))
   21d45: 41 80 3f 30                  	cmpb	$48, (%r15)
   21d49: 0f 85 4d ff ff ff            	jne	0x21c9c <bpf_core_parse_spec+0x4c>
   21d4f: 41 80 7f 01 00               	cmpb	$0, 1(%r15)
   21d54: 0f 85 42 ff ff ff            	jne	0x21c9c <bpf_core_parse_spec+0x4c>
; 		return 0;
   21d5a: 31 c0                        	xorl	%eax, %eax
   21d5c: e9 40 ff ff ff               	jmp	0x21ca1 <bpf_core_parse_spec+0x51>
   21d61: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)
   21d68: 48 63 85 14 05 00 00         	movslq	1300(%rbp), %rax
   21d6f: 83 f8 40                     	cmpl	$64, %eax
   21d72: 74 4c                        	je	0x21dc0 <bpf_core_parse_spec+0x170>
; 		spec_str += parsed_len;
   21d74: 48 63 54 24 30               	movslq	48(%rsp), %rdx
; 		spec->raw_spec[spec->raw_len++] = access_idx;
   21d79: 8b 4c 24 2c                  	movl	44(%rsp), %ecx
; 		spec_str += parsed_len;
   21d7d: 49 01 d7                     	addq	%rdx, %r15
; 		spec->raw_spec[spec->raw_len++] = access_idx;
   21d80: 8d 50 01                     	leal	1(%rax), %edx
   21d83: 89 95 14 05 00 00            	movl	%edx, 1300(%rbp)
   21d89: 89 8c 85 14 04 00 00         	movl	%ecx, 1044(%rbp,%rax,4)
; 	while (*spec_str) {
   21d90: 41 0f b6 07                  	movzbl	(%r15), %eax
   21d94: 84 c0                        	testb	%al, %al
   21d96: 74 38                        	je	0x21dd0 <bpf_core_parse_spec+0x180>
; 			++spec_str;
   21d98: 3c 3a                        	cmpb	$58, %al
; 		if (sscanf(spec_str, "%d%n", &access_idx, &parsed_len) != 1)
   21d9a: 4c 89 f1                     	movq	%r14, %rcx
   21d9d: 4c 89 ea                     	movq	%r13, %rdx
   21da0: 4c 89 e6                     	movq	%r12, %rsi
; 			++spec_str;
   21da3: 0f 94 c0                     	sete	%al
   21da6: 0f b6 c0                     	movzbl	%al, %eax
   21da9: 49 01 c7                     	addq	%rax, %r15
; 		if (sscanf(spec_str, "%d%n", &access_idx, &parsed_len) != 1)
   21dac: 31 c0                        	xorl	%eax, %eax
   21dae: 4c 89 ff                     	movq	%r15, %rdi
   21db1: e8 ea 3c fe ff               	callq	0x5aa0 <.plt.sec+0x430>
   21db6: 83 f8 01                     	cmpl	$1, %eax
   21db9: 74 ad                        	je	0x21d68 <bpf_core_parse_spec+0x118>
   21dbb: e9 dc fe ff ff               	jmp	0x21c9c <bpf_core_parse_spec+0x4c>
; 			return -E2BIG;
   21dc0: b8 f9 ff ff ff               	movl	$4294967289, %eax       # imm = 0xFFFFFFF9
   21dc5: e9 d7 fe ff ff               	jmp	0x21ca1 <bpf_core_parse_spec+0x51>
   21dca: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (spec->raw_len == 0)
   21dd0: 85 d2                        	testl	%edx, %edx
   21dd2: 0f 84 c4 fe ff ff            	je	0x21c9c <bpf_core_parse_spec+0x4c>
; 	t = skip_mods_and_typedefs(btf, relo->type_id, &id);
   21dd8: 8b 73 04                     	movl	4(%rbx), %esi
   21ddb: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   21de0: 4c 8d 6c 24 34               	leaq	52(%rsp), %r13
   21de5: 4c 89 ea                     	movq	%r13, %rdx
   21de8: e8 83 97 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   21ded: 48 89 c2                     	movq	%rax, %rdx
; 	if (!t)
   21df0: 48 85 c0                     	testq	%rax, %rax
   21df3: 0f 84 a3 fe ff ff            	je	0x21c9c <bpf_core_parse_spec+0x4c>
; 	if (core_relo_is_enumval_based(relo->kind)) {
   21df9: 8b 4b 0c                     	movl	12(%rbx), %ecx
; 	access_idx = spec->raw_spec[0];
   21dfc: 48 63 85 14 04 00 00         	movslq	1044(%rbp), %rax
; 	acc->type_id = id;
   21e03: 8b 74 24 34                  	movl	52(%rsp), %esi
; 	spec->len++;
   21e07: 83 85 10 04 00 00 01         	addl	$1, 1040(%rbp)
; 	switch (kind) {
   21e0e: 8d 79 f6                     	leal	-10(%rcx), %edi
; 	access_idx = spec->raw_spec[0];
   21e11: 89 44 24 2c                  	movl	%eax, 44(%rsp)
; 	acc->type_id = id;
   21e15: 89 75 08                     	movl	%esi, 8(%rbp)
; 	acc->idx = access_idx;
   21e18: 89 45 0c                     	movl	%eax, 12(%rbp)
; 	switch (kind) {
   21e1b: 83 ff 01                     	cmpl	$1, %edi
   21e1e: 0f 86 bc 01 00 00            	jbe	0x21fe0 <bpf_core_parse_spec+0x390>
; 	switch (kind) {
   21e24: 83 f9 05                     	cmpl	$5, %ecx
   21e27: 0f 87 6f fe ff ff            	ja	0x21c9c <bpf_core_parse_spec+0x4c>
; 	sz = btf__resolve_size(btf, id);
   21e2d: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   21e32: e8 89 96 00 00               	callq	0x2b4c0 <btf__resolve_size>
; 	if (sz < 0)
   21e37: 48 85 c0                     	testq	%rax, %rax
   21e3a: 0f 88 61 fe ff ff            	js	0x21ca1 <bpf_core_parse_spec+0x51>
; 	spec->bit_offset = access_idx * sz * 8;
   21e40: 0f af 44 24 2c               	imull	44(%rsp), %eax
   21e45: c1 e0 03                     	shll	$3, %eax
; 	for (i = 1; i < spec->raw_len; i++) {
   21e48: 83 bd 14 05 00 00 01         	cmpl	$1, 1300(%rbp)
; 	spec->bit_offset = access_idx * sz * 8;
   21e4f: 89 85 18 05 00 00            	movl	%eax, 1304(%rbp)
; 	for (i = 1; i < spec->raw_len; i++) {
   21e55: 0f 8e ff fe ff ff            	jle	0x21d5a <bpf_core_parse_spec+0x10a>
   21e5b: 41 bc 01 00 00 00            	movl	$1, %r12d
   21e61: e9 d9 00 00 00               	jmp	0x21f3f <bpf_core_parse_spec+0x2ef>
   21e66: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   21e70: 89 4c 24 18                  	movl	%ecx, 24(%rsp)
; 		} else if (btf_is_array(t)) {
   21e74: 66 83 fa 03                  	cmpw	$3, %dx
   21e78: 0f 85 36 02 00 00            	jne	0x220b4 <bpf_core_parse_spec+0x464>
; 			t = skip_mods_and_typedefs(btf, a->type, &id);
   21e7e: 41 8b 76 0c                  	movl	12(%r14), %esi
   21e82: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   21e87: 4c 89 ea                     	movq	%r13, %rdx
   21e8a: e8 e1 96 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 			if (!t)
   21e8f: 48 85 c0                     	testq	%rax, %rax
   21e92: 0f 84 04 fe ff ff            	je	0x21c9c <bpf_core_parse_spec+0x4c>
; 		acc = &spec->spec[spec->len];
   21e98: 48 63 4c 24 18               	movslq	24(%rsp), %rcx
; 	if (!acc->name || arr->nelems > 0)
   21e9d: 41 8b 46 14                  	movl	20(%r14), %eax
; 		acc = &spec->spec[spec->len];
   21ea1: 48 c1 e1 04                  	shlq	$4, %rcx
; 	if (!acc->name || arr->nelems > 0)
   21ea5: 48 83 7c 0d 00 00            	cmpq	$0, (%rbp,%rcx)
; 		acc = &spec->spec[spec->len];
   21eab: 48 8d 54 0d 08               	leaq	8(%rbp,%rcx), %rdx
; 	if (!acc->name || arr->nelems > 0)
   21eb0: 0f 84 9a 01 00 00            	je	0x22050 <bpf_core_parse_spec+0x400>
   21eb6: 85 c0                        	testl	%eax, %eax
   21eb8: 0f 85 92 01 00 00            	jne	0x22050 <bpf_core_parse_spec+0x400>
; 	t = btf_type_by_id(btf, acc->type_id);
   21ebe: 8b 72 f0                     	movl	-16(%rdx), %esi
   21ec1: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   21ec6: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
   21ecb: e8 90 80 00 00               	callq	0x29f60 <btf_type_by_id>
; 			if (!flex && access_idx >= a->nelems)
   21ed0: 48 8b 54 24 18               	movq	24(%rsp), %rdx
; 	return acc->idx == btf_vlen(t) - 1;
   21ed5: 0f b7 40 04                  	movzwl	4(%rax), %eax
   21ed9: 83 e8 01                     	subl	$1, %eax
; 			if (!flex && access_idx >= a->nelems)
   21edc: 39 42 f4                     	cmpl	%eax, -12(%rdx)
   21edf: 0f 85 60 01 00 00            	jne	0x22045 <bpf_core_parse_spec+0x3f5>
   21ee5: 8b 4c 24 2c                  	movl	44(%rsp), %ecx
; 			spec->spec[spec->len].type_id = id;
   21ee9: 48 63 85 10 04 00 00         	movslq	1040(%rbp), %rax
   21ef0: 8b 74 24 34                  	movl	52(%rsp), %esi
; 			sz = btf__resolve_size(btf, id);
   21ef4: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
; 			spec->spec[spec->len].type_id = id;
   21ef9: 48 89 c2                     	movq	%rax, %rdx
   21efc: 48 c1 e0 04                  	shlq	$4, %rax
   21f00: 48 01 e8                     	addq	%rbp, %rax
; 			spec->len++;
   21f03: 83 c2 01                     	addl	$1, %edx
; 			spec->spec[spec->len].type_id = id;
   21f06: 89 70 08                     	movl	%esi, 8(%rax)
; 			spec->spec[spec->len].idx = access_idx;
   21f09: 89 48 0c                     	movl	%ecx, 12(%rax)
; 			spec->len++;
   21f0c: 89 95 10 04 00 00            	movl	%edx, 1040(%rbp)
; 			sz = btf__resolve_size(btf, id);
   21f12: e8 a9 95 00 00               	callq	0x2b4c0 <btf__resolve_size>
; 			if (sz < 0)
   21f17: 48 85 c0                     	testq	%rax, %rax
   21f1a: 0f 88 81 fd ff ff            	js	0x21ca1 <bpf_core_parse_spec+0x51>
; 			spec->bit_offset += access_idx * sz * 8;
   21f20: 0f af 44 24 2c               	imull	44(%rsp), %eax
   21f25: c1 e0 03                     	shll	$3, %eax
   21f28: 01 85 18 05 00 00            	addl	%eax, 1304(%rbp)
; 	for (i = 1; i < spec->raw_len; i++) {
   21f2e: 49 83 c4 01                  	addq	$1, %r12
   21f32: 44 39 a5 14 05 00 00         	cmpl	%r12d, 1300(%rbp)
   21f39: 0f 8e 1b fe ff ff            	jle	0x21d5a <bpf_core_parse_spec+0x10a>
; 		t = skip_mods_and_typedefs(btf, id, &id);
   21f3f: 8b 74 24 34                  	movl	52(%rsp), %esi
   21f43: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   21f48: 4c 89 ea                     	movq	%r13, %rdx
   21f4b: e8 20 96 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   21f50: 49 89 c6                     	movq	%rax, %r14
; 		if (!t)
   21f53: 48 85 c0                     	testq	%rax, %rax
   21f56: 0f 84 40 fd ff ff            	je	0x21c9c <bpf_core_parse_spec+0x4c>
; 	return BTF_INFO_KIND(t->info);
   21f5c: 41 8b 76 04                  	movl	4(%r14), %esi
; 		access_idx = spec->raw_spec[i];
   21f60: 42 8b 84 a5 14 04 00 00      	movl	1044(%rbp,%r12,4), %eax
; 		acc = &spec->spec[spec->len];
   21f68: 8b 8d 10 04 00 00            	movl	1040(%rbp), %ecx
; 	return BTF_INFO_KIND(t->info);
   21f6e: 89 f2                        	movl	%esi, %edx
; 		access_idx = spec->raw_spec[i];
   21f70: 89 44 24 2c                  	movl	%eax, 44(%rsp)
; 	return BTF_INFO_KIND(t->info);
   21f74: c1 ea 18                     	shrl	$24, %edx
   21f77: 83 e2 1f                     	andl	$31, %edx
; 	return kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;
   21f7a: 8d 7a fc                     	leal	-4(%rdx), %edi
; 		if (btf_is_composite(t)) {
   21f7d: 66 83 ff 01                  	cmpw	$1, %di
   21f81: 0f 87 e9 fe ff ff            	ja	0x21e70 <bpf_core_parse_spec+0x220>
; 			if (access_idx >= btf_vlen(t))
   21f87: 0f b7 d6                     	movzwl	%si, %edx
   21f8a: 39 d0                        	cmpl	%edx, %eax
   21f8c: 0f 8d 0a fd ff ff            	jge	0x21c9c <bpf_core_parse_spec+0x4c>
; 	const struct btf_member *m = btf_members(t) + member_idx;
   21f92: 89 c2                        	movl	%eax, %edx
; 	return kflag ? BTF_MEMBER_BIT_OFFSET(m->offset) : m->offset;
   21f94: 48 8d 54 52 03               	leaq	3(%rdx,%rdx,2), %rdx
   21f99: 41 8b 54 96 08               	movl	8(%r14,%rdx,4), %edx
   21f9e: 89 d7                        	movl	%edx, %edi
   21fa0: 81 e7 ff ff ff 00            	andl	$16777215, %edi         # imm = 0xFFFFFF
   21fa6: 85 f6                        	testl	%esi, %esi
   21fa8: 0f 48 d7                     	cmovsl	%edi, %edx
; 			m = btf_members(t) + access_idx;
   21fab: 83 c0 01                     	addl	$1, %eax
; 			spec->bit_offset += bit_offset;
   21fae: 01 95 18 05 00 00            	addl	%edx, 1304(%rbp)
; 			m = btf_members(t) + access_idx;
   21fb4: 48 98                        	cltq
   21fb6: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   21fba: 4d 8d 34 86                  	leaq	(%r14,%rax,4), %r14
; 			if (m->name_off) {
   21fbe: 41 8b 36                     	movl	(%r14), %esi
   21fc1: 85 f6                        	testl	%esi, %esi
   21fc3: 0f 85 9f 00 00 00            	jne	0x22068 <bpf_core_parse_spec+0x418>
; 			id = m->type;
   21fc9: 41 8b 46 04                  	movl	4(%r14), %eax
   21fcd: 89 44 24 34                  	movl	%eax, 52(%rsp)
   21fd1: e9 58 ff ff ff               	jmp	0x21f2e <bpf_core_parse_spec+0x2de>
   21fd6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	return BTF_INFO_KIND(t->info);
   21fe0: 8b 4a 04                     	movl	4(%rdx), %ecx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   21fe3: 41 b8 40 00 08 00            	movl	$524352, %r8d           # imm = 0x80040
; 	return BTF_INFO_KIND(t->info);
   21fe9: 89 ce                        	movl	%ecx, %esi
   21feb: c1 ee 18                     	shrl	$24, %esi
   21fee: 89 f7                        	movl	%esi, %edi
; 	return btf_is_enum(t) || btf_is_enum64(t);
   21ff0: 83 e6 1f                     	andl	$31, %esi
; 	return BTF_INFO_KIND(t->info);
   21ff3: 83 e7 1f                     	andl	$31, %edi
; 	return btf_is_enum(t) || btf_is_enum64(t);
   21ff6: 49 0f a3 f0                  	btq	%rsi, %r8
   21ffa: 0f 83 9c fc ff ff            	jae	0x21c9c <bpf_core_parse_spec+0x4c>
; 		if (!btf_is_any_enum(t) || spec->raw_len > 1 || access_idx >= btf_vlen(t))
   22000: 83 bd 14 05 00 00 01         	cmpl	$1, 1300(%rbp)
   22007: 0f 8f 8f fc ff ff            	jg	0x21c9c <bpf_core_parse_spec+0x4c>
   2200d: 0f b7 c9                     	movzwl	%cx, %ecx
   22010: 39 c8                        	cmpl	%ecx, %eax
   22012: 0f 8d 84 fc ff ff            	jge	0x21c9c <bpf_core_parse_spec+0x4c>
; 					  : btf_enum64(t)[access_idx].name_off;
   22018: 66 83 ff 06                  	cmpw	$6, %di
   2201c: 74 21                        	je	0x2203f <bpf_core_parse_spec+0x3ef>
   2201e: 83 c0 01                     	addl	$1, %eax
   22021: 48 98                        	cltq
   22023: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   22027: 8b 34 82                     	movl	(%rdx,%rax,4), %esi
; 		acc->name = btf__name_by_offset(btf, name_off);
   2202a: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   2202f: e8 bc 9a 00 00               	callq	0x2baf0 <btf__name_by_offset>
   22034: 48 89 45 10                  	movq	%rax, 16(%rbp)
; 		return 0;
   22038: 31 c0                        	xorl	%eax, %eax
   2203a: e9 62 fc ff ff               	jmp	0x21ca1 <bpf_core_parse_spec+0x51>
; 					  : btf_enum64(t)[access_idx].name_off;
   2203f: 8b 74 c2 0c                  	movl	12(%rdx,%rax,8), %esi
   22043: eb e5                        	jmp	0x2202a <bpf_core_parse_spec+0x3da>
; 			if (!flex && access_idx >= a->nelems)
   22045: 41 8b 46 14                  	movl	20(%r14), %eax
   22049: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   22050: 8b 4c 24 2c                  	movl	44(%rsp), %ecx
   22054: 39 c1                        	cmpl	%eax, %ecx
   22056: 0f 82 8d fe ff ff            	jb	0x21ee9 <bpf_core_parse_spec+0x299>
   2205c: e9 3b fc ff ff               	jmp	0x21c9c <bpf_core_parse_spec+0x4c>
   22061: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 				name = btf__name_by_offset(btf, m->name_off);
   22068: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   2206d: 89 4c 24 18                  	movl	%ecx, 24(%rsp)
   22071: e8 7a 9a 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 	return !s || !s[0];
   22076: 48 85 c0                     	testq	%rax, %rax
   22079: 0f 84 1d fc ff ff            	je	0x21c9c <bpf_core_parse_spec+0x4c>
   2207f: 80 38 00                     	cmpb	$0, (%rax)
   22082: 0f 84 14 fc ff ff            	je	0x21c9c <bpf_core_parse_spec+0x4c>
   22088: 48 63 4c 24 18               	movslq	24(%rsp), %rcx
; 				acc->type_id = id;
   2208d: 48 c1 e1 04                  	shlq	$4, %rcx
   22091: 48 8d 54 0d 00               	leaq	(%rbp,%rcx), %rdx
   22096: 8b 4c 24 34                  	movl	52(%rsp), %ecx
; 				acc->name = name;
   2209a: 48 89 42 10                  	movq	%rax, 16(%rdx)
; 				acc->type_id = id;
   2209e: 89 4a 08                     	movl	%ecx, 8(%rdx)
; 				acc->idx = access_idx;
   220a1: 8b 4c 24 2c                  	movl	44(%rsp), %ecx
   220a5: 89 4a 0c                     	movl	%ecx, 12(%rdx)
; 				spec->len++;
   220a8: 83 85 10 04 00 00 01         	addl	$1, 1040(%rbp)
   220af: e9 15 ff ff ff               	jmp	0x21fc9 <bpf_core_parse_spec+0x379>
; 			pr_warn("prog '%s': relo for [%u] %s (at idx %d) captures type [%d] of unexpected kind %s\n",
   220b4: 4c 89 f7                     	movq	%r14, %rdi
   220b7: e8 44 97 fe ff               	callq	0xb800 <btf_kind_str>
   220bc: 8b 4b 04                     	movl	4(%rbx), %ecx
   220bf: 45 89 e1                     	movl	%r12d, %r9d
   220c2: 4d 89 f8                     	movq	%r15, %r8
   220c5: 50                           	pushq	%rax
   220c6: 8b 44 24 3c                  	movl	60(%rsp), %eax
   220ca: 48 8d 35 bf 79 01 00         	leaq	96703(%rip), %rsi       # 0x39a90 <CSWTCH.126+0x190>
   220d1: 31 ff                        	xorl	%edi, %edi
   220d3: 50                           	pushq	%rax
   220d4: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   220d9: 31 c0                        	xorl	%eax, %eax
   220db: e8 f0 5f fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   220e0: 58                           	popq	%rax
   220e1: 5a                           	popq	%rdx
   220e2: e9 b5 fb ff ff               	jmp	0x21c9c <bpf_core_parse_spec+0x4c>
; }
   220e7: e8 14 37 fe ff               	callq	0x5800 <.plt.sec+0x190>
   220ec: 0f 1f 40 00                  	nopl	(%rax)

00000000000220f0 <bpf_core_patch_insn>:
; {
   220f0: f3 0f 1e fa                  	endbr64
   220f4: 41 56                        	pushq	%r14
   220f6: 44 89 c1                     	movl	%r8d, %ecx
   220f9: 41 89 d6                     	movl	%edx, %r14d
   220fc: 41 55                        	pushq	%r13
   220fe: 49 89 fd                     	movq	%rdi, %r13
   22101: 41 54                        	pushq	%r12
   22103: 55                           	pushq	%rbp
   22104: 4c 89 cd                     	movq	%r9, %rbp
   22107: 53                           	pushq	%rbx
   22108: 48 89 f3                     	movq	%rsi, %rbx
   2210b: 48 83 ec 10                  	subq	$16, %rsp
; 	if (res->poison) {
   2210f: 80 7d 10 00                  	cmpb	$0, 16(%rbp)
; 	class = BPF_CLASS(insn->code);
   22113: 44 0f b6 0e                  	movzbl	(%rsi), %r9d
; 	if (res->poison) {
   22117: 0f 85 3b 01 00 00            	jne	0x22258 <bpf_core_patch_insn+0x168>
; 	class = BPF_CLASS(insn->code);
   2211d: 44 89 c8                     	movl	%r9d, %eax
; 	orig_val = res->orig_val;
   22120: 48 8b 7d 00                  	movq	(%rbp), %rdi
; 	new_val = res->new_val;
   22124: 48 8b 55 08                  	movq	8(%rbp), %rdx
; 	class = BPF_CLASS(insn->code);
   22128: 83 e0 07                     	andl	$7, %eax
; 	switch (class) {
   2212b: 41 f6 c1 04                  	testb	$4, %r9b
   2212f: 0f 85 9b 00 00 00            	jne	0x221d0 <bpf_core_patch_insn+0xe0>
   22135: 84 c0                        	testb	%al, %al
   22137: 0f 85 a3 01 00 00            	jne	0x222e0 <bpf_core_patch_insn+0x1f0>
; 		if (!is_ldimm64_insn(insn) ||
   2213d: 41 80 f9 18                  	cmpb	$24, %r9b
   22141: 0f 85 cd 02 00 00            	jne	0x22414 <bpf_core_patch_insn+0x324>
; 		    insn[0].src_reg != 0 || insn[0].off != 0 ||
   22147: f7 06 00 f0 ff ff            	testl	$4294963200, (%rsi)     # imm = 0xFFFFF000
   2214d: 0f 85 c1 02 00 00            	jne	0x22414 <bpf_core_patch_insn+0x324>
; 		    insn[1].code != 0 || insn[1].dst_reg != 0 ||
   22153: 66 f7 46 08 ff 0f            	testw	$4095, 8(%rsi)          # imm = 0xFFF
   22159: 0f 85 b5 02 00 00            	jne	0x22414 <bpf_core_patch_insn+0x324>
; 		    insn[1].src_reg != 0 || insn[1].off != 0) {
   2215f: f7 46 08 00 f0 ff ff         	testl	$4294963200, 8(%rsi)    # imm = 0xFFFFF000
   22166: 0f 85 a8 02 00 00            	jne	0x22414 <bpf_core_patch_insn+0x324>
; 		imm = (__u32)insn[0].imm | ((__u64)insn[1].imm << 32);
   2216c: 4c 63 4e 0c                  	movslq	12(%rsi), %r9
   22170: 8b 46 04                     	movl	4(%rsi), %eax
   22173: 49 c1 e1 20                  	shlq	$32, %r9
   22177: 49 09 c1                     	orq	%rax, %r9
; 		if (res->validate && imm != orig_val) {
   2217a: 4c 39 cf                     	cmpq	%r9, %rdi
   2217d: 74 0a                        	je	0x22189 <bpf_core_patch_insn+0x99>
   2217f: 80 7d 11 00                  	cmpb	$0, 17(%rbp)
   22183: 0f 85 b7 02 00 00            	jne	0x22440 <bpf_core_patch_insn+0x350>
; 		insn[1].imm = new_val >> 32;
   22189: 48 89 d0                     	movq	%rdx, %rax
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDIMM64) imm64 %llu -> %llu\n",
   2218c: 48 83 ec 08                  	subq	$8, %rsp
; 		insn[0].imm = new_val;
   22190: 89 53 04                     	movl	%edx, 4(%rbx)
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDIMM64) imm64 %llu -> %llu\n",
   22193: 45 89 f0                     	movl	%r14d, %r8d
; 		insn[1].imm = new_val >> 32;
   22196: 48 c1 e8 20                  	shrq	$32, %rax
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDIMM64) imm64 %llu -> %llu\n",
   2219a: 52                           	pushq	%rdx
   2219b: 48 8d 35 8e 7d 01 00         	leaq	97678(%rip), %rsi       # 0x39f30 <CSWTCH.126+0x630>
   221a2: 4c 89 ea                     	movq	%r13, %rdx
; 		insn[1].imm = new_val >> 32;
   221a5: 89 43 0c                     	movl	%eax, 12(%rbx)
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDIMM64) imm64 %llu -> %llu\n",
   221a8: 31 c0                        	xorl	%eax, %eax
   221aa: bf 02 00 00 00               	movl	$2, %edi
; 	return 0;
   221af: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDIMM64) imm64 %llu -> %llu\n",
   221b2: e8 19 5f fe ff               	callq	0x80d0 <libbpf_print>
; 		break;
   221b7: 58                           	popq	%rax
   221b8: 5a                           	popq	%rdx
; }
   221b9: 44 89 e0                     	movl	%r12d, %eax
   221bc: 48 83 c4 10                  	addq	$16, %rsp
   221c0: 5b                           	popq	%rbx
   221c1: 5d                           	popq	%rbp
   221c2: 41 5c                        	popq	%r12
   221c4: 41 5d                        	popq	%r13
   221c6: 41 5e                        	popq	%r14
   221c8: c3                           	retq
   221c9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	switch (class) {
   221d0: 48 c7 c6 6f ff ff ff         	movq	$-145, %rsi
   221d7: 48 0f a3 c6                  	btq	%rax, %rsi
   221db: 0f 83 bf 00 00 00            	jae	0x222a0 <bpf_core_patch_insn+0x1b0>
; 		pr_warn("prog '%s': relo #%d: trying to relocate unrecognized insn #%d, code:0x%x, src:0x%x, dst:0x%x, off:0x%x, imm:0x%x\n",
   221e1: 8b 43 04                     	movl	4(%rbx), %eax
   221e4: 45 89 f0                     	movl	%r14d, %r8d
   221e7: 48 8d 35 92 7d 01 00         	leaq	97682(%rip), %rsi       # 0x39f80 <CSWTCH.126+0x680>
   221ee: 31 ff                        	xorl	%edi, %edi
; 		return -EINVAL;
   221f0: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		pr_warn("prog '%s': relo #%d: trying to relocate unrecognized insn #%d, code:0x%x, src:0x%x, dst:0x%x, off:0x%x, imm:0x%x\n",
   221f6: 50                           	pushq	%rax
   221f7: 0f bf 43 02                  	movswl	2(%rbx), %eax
   221fb: 50                           	pushq	%rax
   221fc: 0f b6 43 01                  	movzbl	1(%rbx), %eax
   22200: 89 c2                        	movl	%eax, %edx
   22202: c0 e8 04                     	shrb	$4, %al
   22205: 83 e2 0f                     	andl	$15, %edx
   22208: 0f b6 c0                     	movzbl	%al, %eax
   2220b: 52                           	pushq	%rdx
   2220c: 4c 89 ea                     	movq	%r13, %rdx
   2220f: 50                           	pushq	%rax
   22210: 31 c0                        	xorl	%eax, %eax
   22212: e8 b9 5e fe ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   22217: 48 83 c4 20                  	addq	$32, %rsp
; }
   2221b: 44 89 e0                     	movl	%r12d, %eax
   2221e: 48 83 c4 10                  	addq	$16, %rsp
   22222: 5b                           	popq	%rbx
   22223: 5d                           	popq	%rbp
   22224: 41 5c                        	popq	%r12
   22226: 41 5d                        	popq	%r13
   22228: 41 5e                        	popq	%r14
   2222a: c3                           	retq
   2222b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			pr_warn("prog '%s': relo #%d: insn #%d (LDX/ST/STX) accesses field incorrectly. "
   22230: 45 89 f0                     	movl	%r14d, %r8d
   22233: 4c 89 ea                     	movq	%r13, %rdx
   22236: 48 8d 35 53 7a 01 00         	leaq	96851(%rip), %rsi       # 0x39c90 <CSWTCH.126+0x390>
   2223d: 31 ff                        	xorl	%edi, %edi
   2223f: 31 c0                        	xorl	%eax, %eax
   22241: 89 4c 24 0c                  	movl	%ecx, 12(%rsp)
   22245: e8 86 5e fe ff               	callq	0x80d0 <libbpf_print>
; 	return insn->code == (BPF_LD | BPF_IMM | BPF_DW);
   2224a: 44 0f b6 0b                  	movzbl	(%rbx), %r9d
; 			goto poison;
   2224e: 8b 4c 24 0c                  	movl	12(%rsp), %ecx
   22252: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return insn->code == (BPF_LD | BPF_IMM | BPF_DW);
   22258: 48 8d 35 91 78 01 00         	leaq	96401(%rip), %rsi       # 0x39af0 <CSWTCH.126+0x1f0>
; 		if (is_ldimm64_insn(insn))
   2225f: 41 80 f9 18                  	cmpb	$24, %r9b
   22263: 0f 84 4f 01 00 00            	je	0x223b8 <bpf_core_patch_insn+0x2c8>
; 	pr_debug("prog '%s': relo #%d: substituting insn #%d w/ invalid insn\n",
   22269: 31 c0                        	xorl	%eax, %eax
   2226b: 45 89 f0                     	movl	%r14d, %r8d
   2226e: 4c 89 ea                     	movq	%r13, %rdx
   22271: bf 02 00 00 00               	movl	$2, %edi
   22276: e8 55 5e fe ff               	callq	0x80d0 <libbpf_print>
; 		return 0;
   2227b: 45 31 e4                     	xorl	%r12d, %r12d
; 	insn->code = BPF_JMP | BPF_CALL;
   2227e: 48 b8 85 00 00 00 10 23 ad 0b	movabsq	$841367257014599813, %rax # imm = 0xBAD231000000085
   22288: 48 89 03                     	movq	%rax, (%rbx)
; }
   2228b: 48 83 c4 10                  	addq	$16, %rsp
   2228f: 44 89 e0                     	movl	%r12d, %eax
   22292: 5b                           	popq	%rbx
   22293: 5d                           	popq	%rbp
   22294: 41 5c                        	popq	%r12
   22296: 41 5d                        	popq	%r13
   22298: 41 5e                        	popq	%r14
   2229a: c3                           	retq
   2229b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		if (BPF_SRC(insn->code) != BPF_K)
   222a0: 41 83 e1 08                  	andl	$8, %r9d
   222a4: 0f 85 8b 01 00 00            	jne	0x22435 <bpf_core_patch_insn+0x345>
; 		if (res->validate && insn->imm != orig_val) {
   222aa: 80 7d 11 00                  	cmpb	$0, 17(%rbp)
   222ae: 4c 63 4b 04                  	movslq	4(%rbx), %r9
   222b2: 74 09                        	je	0x222bd <bpf_core_patch_insn+0x1cd>
   222b4: 4c 39 cf                     	cmpq	%r9, %rdi
   222b7: 0f 85 a8 01 00 00            	jne	0x22465 <bpf_core_patch_insn+0x375>
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (ALU/ALU64) imm %llu -> %llu\n",
   222bd: 48 83 ec 08                  	subq	$8, %rsp
; 		insn->imm = new_val;
   222c1: 89 53 04                     	movl	%edx, 4(%rbx)
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (ALU/ALU64) imm %llu -> %llu\n",
   222c4: 45 89 f0                     	movl	%r14d, %r8d
   222c7: 48 8d 35 ca 78 01 00         	leaq	96458(%rip), %rsi       # 0x39b98 <CSWTCH.126+0x298>
   222ce: 52                           	pushq	%rdx
   222cf: 4c 89 ea                     	movq	%r13, %rdx
   222d2: e9 d1 fe ff ff               	jmp	0x221a8 <bpf_core_patch_insn+0xb8>
   222d7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		if (res->validate && insn->off != orig_val) {
   222e0: 80 7d 11 00                  	cmpb	$0, 17(%rbp)
   222e4: 74 11                        	je	0x222f7 <bpf_core_patch_insn+0x207>
   222e6: 48 0f bf 46 02               	movswq	2(%rsi), %rax
   222eb: 49 89 c1                     	movq	%rax, %r9
   222ee: 48 39 f8                     	cmpq	%rdi, %rax
   222f1: 0f 85 cf 01 00 00            	jne	0x224c6 <bpf_core_patch_insn+0x3d6>
; 		if (new_val > SHRT_MAX) {
   222f7: 48 81 fa ff 7f 00 00         	cmpq	$32767, %rdx            # imm = 0x7FFF
   222fe: 0f 87 88 01 00 00            	ja	0x2248c <bpf_core_patch_insn+0x39c>
; 		if (res->fail_memsz_adjust) {
   22304: 80 7d 12 00                  	cmpb	$0, 18(%rbp)
   22308: 0f 85 22 ff ff ff            	jne	0x22230 <bpf_core_patch_insn+0x140>
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) off %llu -> %llu\n",
   2230e: 48 83 ec 08                  	subq	$8, %rsp
; 		orig_val = insn->off;
   22312: 4c 0f bf 4b 02               	movswq	2(%rbx), %r9
; 		insn->off = new_val;
   22317: 66 89 53 02                  	movw	%dx, 2(%rbx)
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) off %llu -> %llu\n",
   2231b: 31 c0                        	xorl	%eax, %eax
   2231d: 52                           	pushq	%rdx
   2231e: 45 89 f0                     	movl	%r14d, %r8d
   22321: 4c 89 ea                     	movq	%r13, %rdx
   22324: 48 8d 35 15 7a 01 00         	leaq	96789(%rip), %rsi       # 0x39d40 <CSWTCH.126+0x440>
   2232b: bf 02 00 00 00               	movl	$2, %edi
; 	return 0;
   22330: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_debug("prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) off %llu -> %llu\n",
   22333: 89 4c 24 1c                  	movl	%ecx, 28(%rsp)
   22337: e8 94 5d fe ff               	callq	0x80d0 <libbpf_print>
; 		if (res->new_sz != res->orig_sz) {
   2233c: 8b 45 1c                     	movl	28(%rbp), %eax
   2233f: 44 8b 4d 14                  	movl	20(%rbp), %r9d
   22343: 41 5b                        	popq	%r11
   22345: 5d                           	popq	%rbp
   22346: 44 39 c8                     	cmpl	%r9d, %eax
   22349: 0f 84 3c ff ff ff            	je	0x2228b <bpf_core_patch_insn+0x19b>
; 	switch (BPF_SIZE(insn->code)) {
   2234f: 0f b6 13                     	movzbl	(%rbx), %edx
   22352: 48 8d 35 a7 75 01 00         	leaq	95655(%rip), %rsi       # 0x39900 <CSWTCH.126>
; 			if (insn_bytes_sz != res->orig_sz) {
   22359: 8b 4c 24 0c                  	movl	12(%rsp), %ecx
   2235d: 48 89 d7                     	movq	%rdx, %rdi
   22360: 83 e7 18                     	andl	$24, %edi
   22363: 8b 34 be                     	movl	(%rsi,%rdi,4), %esi
   22366: 41 39 f1                     	cmpl	%esi, %r9d
   22369: 0f 85 41 01 00 00            	jne	0x224b0 <bpf_core_patch_insn+0x3c0>
; 	switch (sz) {
   2236f: 8d 70 ff                     	leal	-1(%rax), %esi
   22372: 83 fe 07                     	cmpl	$7, %esi
   22375: 77 79                        	ja	0x223f0 <bpf_core_patch_insn+0x300>
   22377: 48 8d 3d 62 75 01 00         	leaq	95586(%rip), %rdi       # 0x398e0 <CSWTCH.128>
   2237e: 8b 34 b7                     	movl	(%rdi,%rsi,4), %esi
; 			if (insn_bpf_sz < 0) {
   22381: 85 f6                        	testl	%esi, %esi
   22383: 78 6b                        	js	0x223f0 <bpf_core_patch_insn+0x300>
; 			insn->code = BPF_MODE(insn->code) | insn_bpf_sz | BPF_CLASS(insn->code);
   22385: 83 e2 e7                     	andl	$-25, %edx
; 			pr_debug("prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) mem_sz %u -> %u\n",
   22388: 48 83 ec 08                  	subq	$8, %rsp
   2238c: 45 89 f0                     	movl	%r14d, %r8d
   2238f: bf 02 00 00 00               	movl	$2, %edi
; 			insn->code = BPF_MODE(insn->code) | insn_bpf_sz | BPF_CLASS(insn->code);
   22394: 09 f2                        	orl	%esi, %edx
; 			pr_debug("prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) mem_sz %u -> %u\n",
   22396: 50                           	pushq	%rax
   22397: 48 8d 35 9a 7a 01 00         	leaq	96922(%rip), %rsi       # 0x39e38 <CSWTCH.126+0x538>
   2239e: 31 c0                        	xorl	%eax, %eax
; 			insn->code = BPF_MODE(insn->code) | insn_bpf_sz | BPF_CLASS(insn->code);
   223a0: 88 13                        	movb	%dl, (%rbx)
; 			pr_debug("prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) mem_sz %u -> %u\n",
   223a2: 4c 89 ea                     	movq	%r13, %rdx
   223a5: e8 26 5d fe ff               	callq	0x80d0 <libbpf_print>
   223aa: 5f                           	popq	%rdi
   223ab: 41 58                        	popq	%r8
   223ad: e9 d9 fe ff ff               	jmp	0x2228b <bpf_core_patch_insn+0x19b>
   223b2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	pr_debug("prog '%s': relo #%d: substituting insn #%d w/ invalid insn\n",
   223b8: 31 c0                        	xorl	%eax, %eax
   223ba: 45 8d 46 01                  	leal	1(%r14), %r8d
   223be: 4c 89 ea                     	movq	%r13, %rdx
   223c1: bf 02 00 00 00               	movl	$2, %edi
   223c6: 89 4c 24 0c                  	movl	%ecx, 12(%rsp)
   223ca: e8 01 5d fe ff               	callq	0x80d0 <libbpf_print>
; 	insn->code = BPF_JMP | BPF_CALL;
   223cf: 8b 4c 24 0c                  	movl	12(%rsp), %ecx
   223d3: 48 8d 35 16 77 01 00         	leaq	96022(%rip), %rsi       # 0x39af0 <CSWTCH.126+0x1f0>
   223da: 48 b8 85 00 00 00 10 23 ad 0b	movabsq	$841367257014599813, %rax # imm = 0xBAD231000000085
   223e4: 48 89 43 08                  	movq	%rax, 8(%rbx)
; }
   223e8: e9 7c fe ff ff               	jmp	0x22269 <bpf_core_patch_insn+0x179>
   223ed: 0f 1f 00                     	nopl	(%rax)
; 				pr_warn("prog '%s': relo #%d: insn #%d (LDX/ST/STX) invalid new mem size: %u\n",
   223f0: 41 89 c1                     	movl	%eax, %r9d
   223f3: 45 89 f0                     	movl	%r14d, %r8d
   223f6: 4c 89 ea                     	movq	%r13, %rdx
   223f9: 31 ff                        	xorl	%edi, %edi
   223fb: 48 8d 35 e6 79 01 00         	leaq	96742(%rip), %rsi       # 0x39de8 <CSWTCH.126+0x4e8>
   22402: 31 c0                        	xorl	%eax, %eax
; 				return -EINVAL;
   22404: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 				pr_warn("prog '%s': relo #%d: insn #%d (LDX/ST/STX) invalid new mem size: %u\n",
   2240a: e8 c1 5c fe ff               	callq	0x80d0 <libbpf_print>
; 				return -EINVAL;
   2240f: e9 77 fe ff ff               	jmp	0x2228b <bpf_core_patch_insn+0x19b>
; 			pr_warn("prog '%s': relo #%d: insn #%d (LDIMM64) has unexpected form\n",
   22414: 45 89 f0                     	movl	%r14d, %r8d
   22417: 4c 89 ea                     	movq	%r13, %rdx
   2241a: 48 8d 35 67 7a 01 00         	leaq	96871(%rip), %rsi       # 0x39e88 <CSWTCH.126+0x588>
   22421: 31 ff                        	xorl	%edi, %edi
   22423: 31 c0                        	xorl	%eax, %eax
; 			return -EINVAL;
   22425: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("prog '%s': relo #%d: insn #%d (LDIMM64) has unexpected form\n",
   2242b: e8 a0 5c fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   22430: e9 56 fe ff ff               	jmp	0x2228b <bpf_core_patch_insn+0x19b>
; 			return -EINVAL;
   22435: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
   2243b: e9 4b fe ff ff               	jmp	0x2228b <bpf_core_patch_insn+0x19b>
; 			pr_warn("prog '%s': relo #%d: unexpected insn #%d (LDIMM64) value: got %llu, exp %llu -> %llu\n",
   22440: 52                           	pushq	%rdx
   22441: 48 8d 35 88 7a 01 00         	leaq	96904(%rip), %rsi       # 0x39ed0 <CSWTCH.126+0x5d0>
   22448: 45 89 f0                     	movl	%r14d, %r8d
   2244b: 4c 89 ea                     	movq	%r13, %rdx
   2244e: 57                           	pushq	%rdi
   2244f: 31 c0                        	xorl	%eax, %eax
   22451: 31 ff                        	xorl	%edi, %edi
; 			return -EINVAL;
   22453: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 			pr_warn("prog '%s': relo #%d: unexpected insn #%d (LDIMM64) value: got %llu, exp %llu -> %llu\n",
   22459: e8 72 5c fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   2245e: 59                           	popq	%rcx
   2245f: 5e                           	popq	%rsi
   22460: e9 26 fe ff ff               	jmp	0x2228b <bpf_core_patch_insn+0x19b>
; 			pr_warn("prog '%s': relo #%d: unexpected insn #%d (ALU/ALU64) value: got %u, exp %llu -> %llu\n",
   22465: 52                           	pushq	%rdx
   22466: 45 89 f0                     	movl	%r14d, %r8d
   22469: 4c 89 ea                     	movq	%r13, %rdx
   2246c: 48 8d 35 c5 76 01 00         	leaq	95941(%rip), %rsi       # 0x39b38 <CSWTCH.126+0x238>
   22473: 57                           	pushq	%rdi
; 			pr_warn("prog '%s': relo #%d: unexpected insn #%d (LDX/ST/STX) value: got %u, exp %llu -> %llu\n",
   22474: 31 ff                        	xorl	%edi, %edi
   22476: 31 c0                        	xorl	%eax, %eax
   22478: e8 53 5c fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   2247d: 41 5c                        	popq	%r12
   2247f: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
   22485: 41 5d                        	popq	%r13
   22487: e9 ff fd ff ff               	jmp	0x2228b <bpf_core_patch_insn+0x19b>
; 			pr_warn("prog '%s': relo #%d: insn #%d (LDX/ST/STX) value too big: %llu\n",
   2248c: 49 89 d1                     	movq	%rdx, %r9
   2248f: 45 89 f0                     	movl	%r14d, %r8d
   22492: 4c 89 ea                     	movq	%r13, %rdx
   22495: 31 ff                        	xorl	%edi, %edi
   22497: 48 8d 35 aa 77 01 00         	leaq	96170(%rip), %rsi       # 0x39c48 <CSWTCH.126+0x348>
   2249e: 31 c0                        	xorl	%eax, %eax
; 			return -ERANGE;
   224a0: 41 bc de ff ff ff            	movl	$4294967262, %r12d      # imm = 0xFFFFFFDE
; 			pr_warn("prog '%s': relo #%d: insn #%d (LDX/ST/STX) value too big: %llu\n",
   224a6: e8 25 5c fe ff               	callq	0x80d0 <libbpf_print>
; 			return -ERANGE;
   224ab: e9 db fd ff ff               	jmp	0x2228b <bpf_core_patch_insn+0x19b>
; 				pr_warn("prog '%s': relo #%d: insn #%d (LDX/ST/STX) unexpected mem size: got %d, exp %u\n",
   224b0: 45 89 f0                     	movl	%r14d, %r8d
   224b3: 41 52                        	pushq	%r10
   224b5: 4c 89 ea                     	movq	%r13, %rdx
   224b8: 41 51                        	pushq	%r9
   224ba: 41 89 f1                     	movl	%esi, %r9d
   224bd: 48 8d 35 cc 78 01 00         	leaq	96460(%rip), %rsi       # 0x39d90 <CSWTCH.126+0x490>
   224c4: eb ae                        	jmp	0x22474 <bpf_core_patch_insn+0x384>
; 			pr_warn("prog '%s': relo #%d: unexpected insn #%d (LDX/ST/STX) value: got %u, exp %llu -> %llu\n",
   224c6: 52                           	pushq	%rdx
   224c7: 45 89 f0                     	movl	%r14d, %r8d
   224ca: 4c 89 ea                     	movq	%r13, %rdx
   224cd: 48 8d 35 14 77 01 00         	leaq	96020(%rip), %rsi       # 0x39be8 <CSWTCH.126+0x2e8>
   224d4: 57                           	pushq	%rdi
   224d5: eb 9d                        	jmp	0x22474 <bpf_core_patch_insn+0x384>
   224d7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

00000000000224e0 <bpf_core_format_spec>:
; {
   224e0: f3 0f 1e fa                  	endbr64
   224e4: 41 57                        	pushq	%r15
   224e6: 41 56                        	pushq	%r14
   224e8: 41 55                        	pushq	%r13
; 	append_buf("<%s> [%u] %s %s",
   224ea: 4c 8d 2d 00 72 01 00         	leaq	94720(%rip), %r13       # 0x396f1 <CSWTCH.76+0xb1>
; {
   224f1: 41 54                        	pushq	%r12
   224f3: 49 89 fc                     	movq	%rdi, %r12
   224f6: 55                           	pushq	%rbp
   224f7: 48 89 f5                     	movq	%rsi, %rbp
   224fa: 53                           	pushq	%rbx
   224fb: 48 89 d3                     	movq	%rdx, %rbx
   224fe: 48 83 ec 08                  	subq	$8, %rsp
; 	type_id = spec->root_type_id;
   22502: 44 8b b2 08 04 00 00         	movl	1032(%rdx), %r14d
; 	t = btf_type_by_id(spec->btf, type_id);
   22509: 48 8b 3a                     	movq	(%rdx), %rdi
   2250c: 44 89 f6                     	movl	%r14d, %esi
   2250f: e8 4c 7a 00 00               	callq	0x29f60 <btf_type_by_id>
; 	s = btf__name_by_offset(spec->btf, t->name_off);
   22514: 48 8b 3b                     	movq	(%rbx), %rdi
   22517: 8b 30                        	movl	(%rax), %esi
; 	t = btf_type_by_id(spec->btf, type_id);
   22519: 49 89 c7                     	movq	%rax, %r15
; 	s = btf__name_by_offset(spec->btf, t->name_off);
   2251c: e8 cf 95 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 	return !s || !s[0];
   22521: 48 85 c0                     	testq	%rax, %rax
   22524: 74 11                        	je	0x22537 <bpf_core_format_spec+0x57>
   22526: 49 89 c5                     	movq	%rax, %r13
; 	append_buf("<%s> [%u] %s %s",
   22529: 80 38 00                     	cmpb	$0, (%rax)
   2252c: 48 8d 05 be 71 01 00         	leaq	94654(%rip), %rax       # 0x396f1 <CSWTCH.76+0xb1>
   22533: 4c 0f 44 e8                  	cmoveq	%rax, %r13
   22537: 4c 89 ff                     	movq	%r15, %rdi
   2253a: e8 c1 92 fe ff               	callq	0xb800 <btf_kind_str>
   2253f: 8b bb 0c 04 00 00            	movl	1036(%rbx), %edi
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   22545: 4c 8d 05 da 71 01 00         	leaq	94682(%rip), %r8        # 0x39726 <CSWTCH.76+0xe6>
   2254c: 48 89 ee                     	movq	%rbp, %rsi
; 	append_buf("<%s> [%u] %s %s",
   2254f: 48 89 c1                     	movq	%rax, %rcx
   22552: e8 39 e8 ff ff               	callq	0x20d90 <core_relo_kind_str>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   22557: 48 83 ec 08                  	subq	$8, %rsp
   2255b: ba 01 00 00 00               	movl	$1, %edx
   22560: 4c 89 e7                     	movq	%r12, %rdi
   22563: 41 55                        	pushq	%r13
; 	append_buf("<%s> [%u] %s %s",
   22565: 49 89 c1                     	movq	%rax, %r9
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   22568: 31 c0                        	xorl	%eax, %eax
   2256a: 51                           	pushq	%rcx
   2256b: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
   22572: 41 56                        	pushq	%r14
   22574: e8 37 31 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 	append_buf("<%s> [%u] %s %s",
   22579: 48 63 d5                     	movslq	%ebp, %rdx
   2257c: 48 83 c4 20                  	addq	$32, %rsp
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   22580: 41 89 c5                     	movl	%eax, %r13d
; 	append_buf("<%s> [%u] %s %s",
   22583: 48 98                        	cltq
   22585: 48 39 e8                     	cmpq	%rbp, %rax
   22588: 48 0f 43 c2                  	cmovaeq	%rdx, %rax
; 	if (core_relo_is_type_based(spec->relo_kind))
   2258c: 8b 93 0c 04 00 00            	movl	1036(%rbx), %edx
; 	switch (kind) {
   22592: 83 fa 09                     	cmpl	$9, %edx
   22595: 0f 87 b5 01 00 00            	ja	0x22750 <bpf_core_format_spec+0x270>
   2259b: 83 fa 05                     	cmpl	$5, %edx
   2259e: 0f 87 0c 01 00 00            	ja	0x226b0 <bpf_core_format_spec+0x1d0>
; 	append_buf("<%s> [%u] %s %s",
   225a4: 4d 8d 3c 04                  	leaq	(%r12,%rax), %r15
   225a8: 48 29 c5                     	subq	%rax, %rbp
; 		for (i = 0; i < spec->len; i++) {
   225ab: 8b 83 10 04 00 00            	movl	1040(%rbx), %eax
   225b1: 45 31 e4                     	xorl	%r12d, %r12d
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   225b4: 4c 8d 35 7f 71 01 00         	leaq	94591(%rip), %r14       # 0x3973a <CSWTCH.76+0xfa>
; 		for (i = 0; i < spec->len; i++) {
   225bb: 85 c0                        	testl	%eax, %eax
   225bd: 0f 8f 4b 01 00 00            	jg	0x2270e <bpf_core_format_spec+0x22e>
   225c3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   225c8: 48 8d 15 70 71 01 00         	leaq	94576(%rip), %rdx       # 0x3973f <CSWTCH.76+0xff>
   225cf: 48 89 ee                     	movq	%rbp, %rsi
   225d2: 31 c0                        	xorl	%eax, %eax
   225d4: 4c 89 ff                     	movq	%r15, %rdi
   225d7: e8 74 32 fe ff               	callq	0x5850 <.plt.sec+0x1e0>
; 		append_buf(" (");
   225dc: 48 63 d5                     	movslq	%ebp, %rdx
; 		for (i = 0; i < spec->raw_len; i++)
   225df: 44 8b 83 14 05 00 00         	movl	1300(%rbx), %r8d
; 		append_buf(" (");
   225e6: 46 8d 24 28                  	leal	(%rax,%r13), %r12d
   225ea: 48 98                        	cltq
   225ec: 48 39 e8                     	cmpq	%rbp, %rax
   225ef: 48 0f 43 c2                  	cmovaeq	%rdx, %rax
   225f3: 4d 8d 2c 07                  	leaq	(%r15,%rax), %r13
   225f7: 48 29 c5                     	subq	%rax, %rbp
; 		for (i = 0; i < spec->raw_len; i++)
   225fa: 45 85 c0                     	testl	%r8d, %r8d
   225fd: 7e 70                        	jle	0x2266f <bpf_core_format_spec+0x18f>
   225ff: 45 31 ff                     	xorl	%r15d, %r15d
; 			append_buf("%s%d", i == 0 ? "" : ":", spec->raw_spec[i]);
   22602: 4c 8d 35 1b 71 01 00         	leaq	94491(%rip), %r14       # 0x39724 <CSWTCH.76+0xe4>
   22609: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   22610: 4d 85 ff                     	testq	%r15, %r15
   22613: 4c 8d 0d 43 f8 00 00         	leaq	63555(%rip), %r9        # 0x31e5d <_IO_stdin_used+0x1e5d>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   2261a: 48 89 ee                     	movq	%rbp, %rsi
   2261d: 4c 89 ef                     	movq	%r13, %rdi
; 			append_buf("%s%d", i == 0 ? "" : ":", spec->raw_spec[i]);
   22620: 4d 0f 45 ce                  	cmovneq	%r14, %r9
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   22624: 48 83 ec 08                  	subq	$8, %rsp
; 			append_buf("%s%d", i == 0 ? "" : ":", spec->raw_spec[i]);
   22628: 42 8b 84 bb 14 04 00 00      	movl	1044(%rbx,%r15,4), %eax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   22630: ba 01 00 00 00               	movl	$1, %edx
   22635: 4c 8d 05 06 71 01 00         	leaq	94470(%rip), %r8        # 0x39742 <CSWTCH.76+0x102>
   2263c: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
   22643: 50                           	pushq	%rax
   22644: 31 c0                        	xorl	%eax, %eax
   22646: e8 65 30 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 			append_buf("%s%d", i == 0 ? "" : ":", spec->raw_spec[i]);
   2264b: 48 63 d5                     	movslq	%ebp, %rdx
   2264e: 5e                           	popq	%rsi
   2264f: 5f                           	popq	%rdi
   22650: 41 01 c4                     	addl	%eax, %r12d
   22653: 48 98                        	cltq
   22655: 48 39 e8                     	cmpq	%rbp, %rax
   22658: 48 0f 43 c2                  	cmovaeq	%rdx, %rax
; 		for (i = 0; i < spec->raw_len; i++)
   2265c: 49 83 c7 01                  	addq	$1, %r15
; 			append_buf("%s%d", i == 0 ? "" : ":", spec->raw_spec[i]);
   22660: 49 01 c5                     	addq	%rax, %r13
   22663: 48 29 c5                     	subq	%rax, %rbp
; 		for (i = 0; i < spec->raw_len; i++)
   22666: 44 39 bb 14 05 00 00         	cmpl	%r15d, 1300(%rbx)
   2266d: 7f a1                        	jg	0x22610 <bpf_core_format_spec+0x130>
; 		if (spec->bit_offset % 8)
   2266f: 8b 83 18 05 00 00            	movl	1304(%rbx), %eax
; 			append_buf(" @ offset %u.%u)", spec->bit_offset / 8, spec->bit_offset % 8);
   22675: 41 89 c1                     	movl	%eax, %r9d
   22678: 41 c1 e9 03                  	shrl	$3, %r9d
; 		if (spec->bit_offset % 8)
   2267c: 83 e0 07                     	andl	$7, %eax
   2267f: 0f 84 ab 01 00 00            	je	0x22830 <bpf_core_format_spec+0x350>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   22685: 48 83 ec 08                  	subq	$8, %rsp
   22689: ba 01 00 00 00               	movl	$1, %edx
   2268e: 4c 89 ef                     	movq	%r13, %rdi
   22691: 48 89 ee                     	movq	%rbp, %rsi
   22694: 50                           	pushq	%rax
   22695: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
   2269c: 4c 8d 05 a4 70 01 00         	leaq	94372(%rip), %r8        # 0x39747 <CSWTCH.76+0x107>
   226a3: 31 c0                        	xorl	%eax, %eax
   226a5: e8 06 30 fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 			append_buf(" @ offset %u.%u)", spec->bit_offset / 8, spec->bit_offset % 8);
   226aa: 5a                           	popq	%rdx
   226ab: 59                           	popq	%rcx
   226ac: 46 8d 2c 20                  	leal	(%rax,%r12), %r13d
; }
   226b0: 48 83 c4 08                  	addq	$8, %rsp
   226b4: 44 89 e8                     	movl	%r13d, %eax
   226b7: 5b                           	popq	%rbx
   226b8: 5d                           	popq	%rbp
   226b9: 41 5c                        	popq	%r12
   226bb: 41 5d                        	popq	%r13
   226bd: 41 5e                        	popq	%r14
   226bf: 41 5f                        	popq	%r15
   226c1: c3                           	retq
   226c2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   226c8: 4c 8d 05 67 70 01 00         	leaq	94311(%rip), %r8        # 0x39736 <CSWTCH.76+0xf6>
   226cf: 48 89 ee                     	movq	%rbp, %rsi
   226d2: 4c 89 ff                     	movq	%r15, %rdi
   226d5: 31 c0                        	xorl	%eax, %eax
   226d7: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
   226de: ba 01 00 00 00               	movl	$1, %edx
   226e3: e8 c8 2f fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 				append_buf("[%u]", spec->spec[i].idx);
   226e8: 41 01 c5                     	addl	%eax, %r13d
   226eb: 48 98                        	cltq
   226ed: 48 63 d5                     	movslq	%ebp, %rdx
   226f0: 48 39 e8                     	cmpq	%rbp, %rax
   226f3: 48 0f 43 c2                  	cmovaeq	%rdx, %rax
   226f7: 49 01 c7                     	addq	%rax, %r15
   226fa: 48 29 c5                     	subq	%rax, %rbp
; 		for (i = 0; i < spec->len; i++) {
   226fd: 49 83 c4 01                  	addq	$1, %r12
   22701: 44 39 a3 10 04 00 00         	cmpl	%r12d, 1040(%rbx)
   22708: 0f 8e ba fe ff ff            	jle	0x225c8 <bpf_core_format_spec+0xe8>
; 			if (spec->spec[i].name)
   2270e: 4c 89 e0                     	movq	%r12, %rax
   22711: 48 c1 e0 04                  	shlq	$4, %rax
   22715: 4c 8b 4c 03 10               	movq	16(%rbx,%rax), %r9
   2271a: 4d 85 c9                     	testq	%r9, %r9
   2271d: 75 a9                        	jne	0x226c8 <bpf_core_format_spec+0x1e8>
; 			else if (i > 0 || spec->spec[i].idx > 0)
   2271f: 4d 85 e4                     	testq	%r12, %r12
   22722: 75 09                        	jne	0x2272d <bpf_core_format_spec+0x24d>
   22724: 44 8b 4b 0c                  	movl	12(%rbx), %r9d
   22728: 45 85 c9                     	testl	%r9d, %r9d
   2272b: 74 d0                        	je	0x226fd <bpf_core_format_spec+0x21d>
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   2272d: 44 8b 4c 03 0c               	movl	12(%rbx,%rax), %r9d
   22732: 4d 89 f0                     	movq	%r14, %r8
   22735: ba 01 00 00 00               	movl	$1, %edx
   2273a: 48 89 ee                     	movq	%rbp, %rsi
   2273d: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
   22744: 4c 89 ff                     	movq	%r15, %rdi
   22747: 31 c0                        	xorl	%eax, %eax
   22749: e8 62 2f fe ff               	callq	0x56b0 <.plt.sec+0x40>
   2274e: eb 98                        	jmp	0x226e8 <bpf_core_format_spec+0x208>
; 	switch (kind) {
   22750: 83 fa 0c                     	cmpl	$12, %edx
   22753: 0f 84 57 ff ff ff            	je	0x226b0 <bpf_core_format_spec+0x1d0>
; 	switch (kind) {
   22759: 83 ea 0a                     	subl	$10, %edx
; 	append_buf("<%s> [%u] %s %s",
   2275c: 49 01 c4                     	addq	%rax, %r12
   2275f: 48 29 c5                     	subq	%rax, %rbp
; 	switch (kind) {
   22762: 83 fa 01                     	cmpl	$1, %edx
   22765: 0f 87 45 ff ff ff            	ja	0x226b0 <bpf_core_format_spec+0x1d0>
; 		t = skip_mods_and_typedefs(spec->btf, type_id, NULL);
   2276b: 48 8b 3b                     	movq	(%rbx), %rdi
   2276e: 31 d2                        	xorl	%edx, %edx
   22770: 44 89 f6                     	movl	%r14d, %esi
   22773: e8 f8 8d fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   22778: 49 89 c6                     	movq	%rax, %r14
; 	return BTF_INFO_KIND(t->info);
   2277b: 0f b6 40 07                  	movzbl	7(%rax), %eax
   2277f: 83 e0 1f                     	andl	$31, %eax
; 		if (btf_is_enum(t)) {
   22782: 66 83 f8 06                  	cmpw	$6, %ax
; 			e = btf_enum(t) + spec->raw_spec[0];
   22786: 48 63 83 14 04 00 00         	movslq	1044(%rbx), %rax
; 		if (btf_is_enum(t)) {
   2278d: 74 61                        	je	0x227f0 <bpf_core_format_spec+0x310>
; 			e = btf_enum64(t) + spec->raw_spec[0];
   2278f: 48 8d 44 40 03               	leaq	3(%rax,%rax,2), %rax
; 			s = btf__name_by_offset(spec->btf, e->name_off);
   22794: 48 8b 3b                     	movq	(%rbx), %rdi
; 			e = btf_enum64(t) + spec->raw_spec[0];
   22797: 4d 8d 3c 86                  	leaq	(%r14,%rax,4), %r15
; 			s = btf__name_by_offset(spec->btf, e->name_off);
   2279b: 41 8b 37                     	movl	(%r15), %esi
   2279e: e8 4d 93 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 			fmt_str = BTF_INFO_KFLAG(t->info) ? "::%s = %lld" : "::%s = %llu";
   227a3: 41 8b 5e 04                  	movl	4(%r14), %ebx
   227a7: 4c 8d 05 5e 6f 01 00         	leaq	94046(%rip), %r8        # 0x3970c <CSWTCH.76+0xcc>
; 			s = btf__name_by_offset(spec->btf, e->name_off);
   227ae: 49 89 c1                     	movq	%rax, %r9
; 			fmt_str = BTF_INFO_KFLAG(t->info) ? "::%s = %lld" : "::%s = %llu";
   227b1: 48 8d 05 60 6f 01 00         	leaq	94048(%rip), %rax       # 0x39718 <CSWTCH.76+0xd8>
   227b8: 85 db                        	testl	%ebx, %ebx
   227ba: 4c 0f 49 c0                  	cmovnsq	%rax, %r8
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   227be: 48 83 ec 08                  	subq	$8, %rsp
   227c2: 41 ff 77 04                  	pushq	4(%r15)
   227c6: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
   227cd: ba 01 00 00 00               	movl	$1, %edx
   227d2: 48 89 ee                     	movq	%rbp, %rsi
   227d5: 4c 89 e7                     	movq	%r12, %rdi
   227d8: 31 c0                        	xorl	%eax, %eax
   227da: e8 d1 2e fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 			append_buf(fmt_str, s, (unsigned long long)btf_enum64_value(e));
   227df: 41 5a                        	popq	%r10
   227e1: 41 5b                        	popq	%r11
   227e3: 41 01 c5                     	addl	%eax, %r13d
   227e6: e9 c5 fe ff ff               	jmp	0x226b0 <bpf_core_format_spec+0x1d0>
   227eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			e = btf_enum(t) + spec->raw_spec[0];
   227f0: 4d 8d 7c c6 0c               	leaq	12(%r14,%rax,8), %r15
; 			s = btf__name_by_offset(spec->btf, e->name_off);
   227f5: 48 8b 3b                     	movq	(%rbx), %rdi
   227f8: 41 8b 37                     	movl	(%r15), %esi
   227fb: e8 f0 92 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 			fmt_str = BTF_INFO_KFLAG(t->info) ? "::%s = %d" : "::%s = %u";
   22800: 45 8b 76 04                  	movl	4(%r14), %r14d
   22804: 4c 8d 05 ed 6e 01 00         	leaq	93933(%rip), %r8        # 0x396f8 <CSWTCH.76+0xb8>
; 			s = btf__name_by_offset(spec->btf, e->name_off);
   2280b: 49 89 c1                     	movq	%rax, %r9
; 			fmt_str = BTF_INFO_KFLAG(t->info) ? "::%s = %d" : "::%s = %u";
   2280e: 48 8d 05 ed 6e 01 00         	leaq	93933(%rip), %rax       # 0x39702 <CSWTCH.76+0xc2>
   22815: 45 85 f6                     	testl	%r14d, %r14d
   22818: 4c 0f 49 c0                  	cmovnsq	%rax, %r8
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   2281c: 41 8b 47 04                  	movl	4(%r15), %eax
   22820: 48 83 ec 08                  	subq	$8, %rsp
   22824: 50                           	pushq	%rax
   22825: eb 9f                        	jmp	0x227c6 <bpf_core_format_spec+0x2e6>
   22827: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
   22830: 4c 89 ef                     	movq	%r13, %rdi
   22833: 4c 8d 05 1e 6f 01 00         	leaq	93982(%rip), %r8        # 0x39758 <CSWTCH.76+0x118>
   2283a: 48 89 ee                     	movq	%rbp, %rsi
   2283d: 31 c0                        	xorl	%eax, %eax
   2283f: 48 c7 c1 ff ff ff ff         	movq	$-1, %rcx
   22846: ba 01 00 00 00               	movl	$1, %edx
   2284b: e8 60 2e fe ff               	callq	0x56b0 <.plt.sec+0x40>
; 			append_buf(" @ offset %u)", spec->bit_offset / 8);
   22850: 46 8d 2c 20                  	leal	(%rax,%r12), %r13d
   22854: e9 57 fe ff ff               	jmp	0x226b0 <bpf_core_format_spec+0x1d0>
   22859: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000022860 <bpf_core_calc_relo_insn>:
; {
   22860: f3 0f 1e fa                  	endbr64
   22864: 41 57                        	pushq	%r15
   22866: 49 89 f7                     	movq	%rsi, %r15
   22869: 41 56                        	pushq	%r14
   2286b: 41 55                        	pushq	%r13
   2286d: 49 89 cd                     	movq	%rcx, %r13
   22870: 41 54                        	pushq	%r12
   22872: 4d 89 cc                     	movq	%r9, %r12
   22875: 55                           	pushq	%rbp
   22876: 53                           	pushq	%rbx
   22877: 48 81 ec d8 01 00 00         	subq	$472, %rsp              # imm = 0x1D8
; 	local_id = relo->type_id;
   2287e: 44 8b 76 04                  	movl	4(%rsi), %r14d
; {
   22882: 48 8b 84 24 10 02 00 00      	movq	528(%rsp), %rax
   2288a: 48 89 7c 24 30               	movq	%rdi, 48(%rsp)
; 	local_type = btf_type_by_id(local_btf, local_id);
   2288f: 48 89 cf                     	movq	%rcx, %rdi
; {
   22892: 48 89 74 24 50               	movq	%rsi, 80(%rsp)
; 	local_type = btf_type_by_id(local_btf, local_id);
   22897: 44 89 f6                     	movl	%r14d, %esi
; {
   2289a: 89 54 24 70                  	movl	%edx, 112(%rsp)
   2289e: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
   228a3: 48 89 44 24 58               	movq	%rax, 88(%rsp)
   228a8: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   228b1: 48 89 84 24 c8 01 00 00      	movq	%rax, 456(%rsp)
   228b9: 31 c0                        	xorl	%eax, %eax
; 	local_type = btf_type_by_id(local_btf, local_id);
   228bb: e8 a0 76 00 00               	callq	0x29f60 <btf_type_by_id>
; 	local_name = btf__name_by_offset(local_btf, local_type->name_off);
   228c0: 4c 89 ef                     	movq	%r13, %rdi
   228c3: 8b 30                        	movl	(%rax), %esi
; 	local_type = btf_type_by_id(local_btf, local_id);
   228c5: 48 89 c5                     	movq	%rax, %rbp
; 	local_name = btf__name_by_offset(local_btf, local_type->name_off);
   228c8: e8 23 92 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 	if (!local_name)
   228cd: 48 85 c0                     	testq	%rax, %rax
   228d0: 0f 84 13 08 00 00            	je	0x230e9 <bpf_core_calc_relo_insn+0x889>
; 	err = bpf_core_parse_spec(prog_name, local_btf, relo, local_spec);
   228d6: 48 8b 7c 24 30               	movq	48(%rsp), %rdi
   228db: 4c 89 e1                     	movq	%r12, %rcx
   228de: 4c 89 fa                     	movq	%r15, %rdx
   228e1: 4c 89 ee                     	movq	%r13, %rsi
   228e4: 48 89 c3                     	movq	%rax, %rbx
   228e7: e8 64 f3 ff ff               	callq	0x21c50 <bpf_core_parse_spec>
   228ec: 89 44 24 74                  	movl	%eax, 116(%rsp)
; 	if (err) {
   228f0: 85 c0                        	testl	%eax, %eax
   228f2: 0f 85 fe 07 00 00            	jne	0x230f6 <bpf_core_calc_relo_insn+0x896>
; 	bpf_core_format_spec(spec_buf, sizeof(spec_buf), local_spec);
   228f8: 48 8d 84 24 c0 00 00 00      	leaq	192(%rsp), %rax
   22900: 4c 89 e2                     	movq	%r12, %rdx
   22903: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
   22908: 48 89 c7                     	movq	%rax, %rdi
   2290b: 49 89 c7                     	movq	%rax, %r15
   2290e: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   22913: e8 c8 fb ff ff               	callq	0x224e0 <bpf_core_format_spec>
; 	pr_debug("prog '%s': relo #%d: %s\n", prog_name, relo_idx, spec_buf);
   22918: 8b 4c 24 70                  	movl	112(%rsp), %ecx
   2291c: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   22921: 31 c0                        	xorl	%eax, %eax
   22923: 4d 89 f8                     	movq	%r15, %r8
   22926: 48 8d 35 1b 77 01 00         	leaq	96027(%rip), %rsi       # 0x3a048 <CSWTCH.126+0x748>
   2292d: bf 02 00 00 00               	movl	$2, %edi
   22932: e8 99 57 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (relo->kind == BPF_CORE_TYPE_ID_LOCAL) {
   22937: 48 8b 44 24 50               	movq	80(%rsp), %rax
   2293c: 44 8b 48 0c                  	movl	12(%rax), %r9d
   22940: 41 83 f9 06                  	cmpl	$6, %r9d
   22944: 0f 84 16 07 00 00            	je	0x23060 <bpf_core_calc_relo_insn+0x800>
; 	return !s || !s[0];
   2294a: 80 3b 00                     	cmpb	$0, (%rbx)
   2294d: 0f 84 65 07 00 00            	je	0x230b8 <bpf_core_calc_relo_insn+0x858>
; 	for (i = 0, j = 0; i < cands->len; i++) {
   22953: 48 8b 44 24 10               	movq	16(%rsp), %rax
   22958: 8b 68 08                     	movl	8(%rax), %ebp
   2295b: 85 ed                        	testl	%ebp, %ebp
   2295d: 0f 8e ac 06 00 00            	jle	0x2300f <bpf_core_calc_relo_insn+0x7af>
   22963: 49 8d 84 24 48 0a 00 00      	leaq	2632(%r12), %rax
; 	struct bpf_core_spec *cand_spec = &specs_scratch[1];
   2296b: c7 44 24 2c 00 00 00 00      	movl	$0, 44(%rsp)
; 		targ_type = skip_mods_and_typedefs(targ_spec->btf, targ_id, &targ_id);
   22973: 4c 89 e3                     	movq	%r12, %rbx
; 	struct bpf_core_spec *cand_spec = &specs_scratch[1];
   22976: 49 8d ac 24 20 05 00 00      	leaq	1312(%r12), %rbp
   2297e: 48 89 44 24 40               	movq	%rax, 64(%rsp)
   22983: 49 8d 84 24 28 05 00 00      	leaq	1320(%r12), %rax
   2298b: 48 89 44 24 48               	movq	%rax, 72(%rsp)
; 		err = bpf_core_calc_relo(prog_name, relo, relo_idx, local_spec, cand_spec, &cand_res);
   22990: 48 8d 84 24 90 00 00 00      	leaq	144(%rsp), %rax
   22998: 48 89 44 24 60               	movq	%rax, 96(%rsp)
; 		targ_type = skip_mods_and_typedefs(targ_spec->btf, targ_id, &targ_id);
   2299d: 48 8d 84 24 8c 00 00 00      	leaq	140(%rsp), %rax
; 	struct bpf_core_spec *cand_spec = &specs_scratch[1];
   229a5: 48 c7 44 24 08 00 00 00 00   	movq	$0, 8(%rsp)
; 		targ_type = skip_mods_and_typedefs(targ_spec->btf, targ_id, &targ_id);
   229ae: 48 89 44 24 68               	movq	%rax, 104(%rsp)
   229b3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   229b8: 48 8b 44 24 08               	movq	8(%rsp), %rax
; 					  cands->cands[i].id, cand_spec);
   229bd: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   229c2: 89 44 24 28                  	movl	%eax, 40(%rsp)
; 		err = bpf_core_spec_match(local_spec, cands->cands[i].btf,
   229c6: 48 c1 e0 04                  	shlq	$4, %rax
   229ca: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 					  cands->cands[i].id, cand_spec);
   229cf: 48 03 01                     	addq	(%rcx), %rax
;   return __builtin___memset_chk (__dest, __ch, __len,
   229d2: 48 89 e9                     	movq	%rbp, %rcx
; 		err = bpf_core_spec_match(local_spec, cands->cands[i].btf,
   229d5: 8b 70 08                     	movl	8(%rax), %esi
   229d8: 4c 8b 30                     	movq	(%rax), %r14
   229db: 89 b4 24 8c 00 00 00         	movl	%esi, 140(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   229e2: 48 c7 45 00 00 00 00 00      	movq	$0, (%rbp)
   229ea: 48 8b 44 24 40               	movq	64(%rsp), %rax
   229ef: 48 c7 40 f0 00 00 00 00      	movq	$0, -16(%rax)
   229f7: 48 8b 7c 24 48               	movq	72(%rsp), %rdi
   229fc: 31 c0                        	xorl	%eax, %eax
   229fe: 48 83 e7 f8                  	andq	$-8, %rdi
   22a02: 48 29 f9                     	subq	%rdi, %rcx
   22a05: 81 c1 20 05 00 00            	addl	$1312, %ecx             # imm = 0x520
   22a0b: c1 e9 03                     	shrl	$3, %ecx
   22a0e: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	targ_spec->btf = targ_btf;
   22a11: 4c 89 b3 20 05 00 00         	movq	%r14, 1312(%rbx)
; 	targ_spec->root_type_id = targ_id;
   22a18: 89 b3 28 09 00 00            	movl	%esi, 2344(%rbx)
; 	targ_spec->relo_kind = local_spec->relo_kind;
   22a1e: 8b 83 0c 04 00 00            	movl	1036(%rbx), %eax
   22a24: 89 83 2c 09 00 00            	movl	%eax, 2348(%rbx)
; 	switch (kind) {
   22a2a: 83 f8 09                     	cmpl	$9, %eax
   22a2d: 0f 87 7d 01 00 00            	ja	0x22bb0 <bpf_core_calc_relo_insn+0x350>
   22a33: 83 f8 05                     	cmpl	$5, %eax
   22a36: 0f 87 1c 03 00 00            	ja	0x22d58 <bpf_core_calc_relo_insn+0x4f8>
; 	for (i = 0; i < local_spec->len; i++, local_acc++, targ_acc++) {
   22a3c: 8b 83 10 04 00 00            	movl	1040(%rbx), %eax
   22a42: 85 c0                        	testl	%eax, %eax
   22a44: 0f 8e 16 02 00 00            	jle	0x22c60 <bpf_core_calc_relo_insn+0x400>
   22a4a: 4c 8b 7c 24 68               	movq	104(%rsp), %r15
; 	local_acc = &local_spec->spec[0];
   22a4f: 4c 8d 63 08                  	leaq	8(%rbx), %r12
   22a53: 4c 89 f7                     	movq	%r14, %rdi
   22a56: 45 31 ed                     	xorl	%r13d, %r13d
   22a59: eb 4b                        	jmp	0x22aa6 <bpf_core_calc_relo_insn+0x246>
   22a5b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			matched = bpf_core_match_member(local_spec->btf,
   22a60: 8b 8c 24 8c 00 00 00         	movl	140(%rsp), %ecx
   22a67: 48 8b 3b                     	movq	(%rbx), %rdi
   22a6a: 4d 89 f9                     	movq	%r15, %r9
   22a6d: 49 89 e8                     	movq	%rbp, %r8
   22a70: 4c 89 f2                     	movq	%r14, %rdx
   22a73: 4c 89 e6                     	movq	%r12, %rsi
   22a76: e8 65 eb ff ff               	callq	0x215e0 <bpf_core_match_member>
; 			if (matched <= 0)
   22a7b: 85 c0                        	testl	%eax, %eax
   22a7d: 0f 8e 4d 01 00 00            	jle	0x22bd0 <bpf_core_calc_relo_insn+0x370>
; 	for (i = 0; i < local_spec->len; i++, local_acc++, targ_acc++) {
   22a83: 41 83 c5 01                  	addl	$1, %r13d
   22a87: 49 83 c4 10                  	addq	$16, %r12
   22a8b: 44 3b ab 10 04 00 00         	cmpl	1040(%rbx), %r13d
   22a92: 0f 8d c8 01 00 00            	jge	0x22c60 <bpf_core_calc_relo_insn+0x400>
; 		targ_type = skip_mods_and_typedefs(targ_spec->btf, targ_id,
   22a98: 8b b4 24 8c 00 00 00         	movl	140(%rsp), %esi
   22a9f: 48 8b bb 20 05 00 00         	movq	1312(%rbx), %rdi
   22aa6: 4c 89 fa                     	movq	%r15, %rdx
   22aa9: e8 c2 8a fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   22aae: 48 89 c2                     	movq	%rax, %rdx
; 		if (!targ_type)
   22ab1: 48 85 c0                     	testq	%rax, %rax
   22ab4: 0f 84 de 04 00 00            	je	0x22f98 <bpf_core_calc_relo_insn+0x738>
; 		if (local_acc->name) {
   22aba: 49 83 7c 24 08 00            	cmpq	$0, 8(%r12)
   22ac0: 75 9e                        	jne	0x22a60 <bpf_core_calc_relo_insn+0x200>
; 			if (i > 0) {
   22ac2: 45 85 ed                     	testl	%r13d, %r13d
   22ac5: 74 71                        	je	0x22b38 <bpf_core_calc_relo_insn+0x2d8>
; 	return BTF_INFO_KIND(t->info);
   22ac7: 0f b6 40 07                  	movzbl	7(%rax), %eax
   22acb: 83 e0 1f                     	andl	$31, %eax
; 				if (!btf_is_array(targ_type))
   22ace: 66 83 f8 03                  	cmpw	$3, %ax
   22ad2: 0f 85 c0 02 00 00            	jne	0x22d98 <bpf_core_calc_relo_insn+0x538>
; 	if (!acc->name || arr->nelems > 0)
   22ad8: 49 83 bc 24 18 05 00 00 00   	cmpq	$0, 1304(%r12)
   22ae1: 8b 42 14                     	movl	20(%rdx), %eax
   22ae4: 0f 84 9e 02 00 00            	je	0x22d88 <bpf_core_calc_relo_insn+0x528>
   22aea: 85 c0                        	testl	%eax, %eax
   22aec: 0f 85 96 02 00 00            	jne	0x22d88 <bpf_core_calc_relo_insn+0x528>
; 	t = btf_type_by_id(btf, acc->type_id);
   22af2: 41 8b b4 24 10 05 00 00      	movl	1296(%r12), %esi
   22afa: 4c 89 f7                     	movq	%r14, %rdi
   22afd: 48 89 54 24 38               	movq	%rdx, 56(%rsp)
   22b02: e8 59 74 00 00               	callq	0x29f60 <btf_type_by_id>
; 				if (!flex && local_acc->idx >= a->nelems)
   22b07: 48 8b 54 24 38               	movq	56(%rsp), %rdx
; 	return acc->idx == btf_vlen(t) - 1;
   22b0c: 0f b7 40 04                  	movzwl	4(%rax), %eax
   22b10: 83 e8 01                     	subl	$1, %eax
; 				if (!flex && local_acc->idx >= a->nelems)
   22b13: 41 39 84 24 14 05 00 00      	cmpl	%eax, 1300(%r12)
   22b1b: 0f 85 5f 02 00 00            	jne	0x22d80 <bpf_core_calc_relo_insn+0x520>
; 				if (!skip_mods_and_typedefs(targ_btf, a->type,
   22b21: 8b 72 0c                     	movl	12(%rdx), %esi
   22b24: 4c 89 f7                     	movq	%r14, %rdi
   22b27: 4c 89 fa                     	movq	%r15, %rdx
   22b2a: e8 41 8a fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   22b2f: 48 85 c0                     	testq	%rax, %rax
   22b32: 0f 84 60 04 00 00            	je	0x22f98 <bpf_core_calc_relo_insn+0x738>
; 			if (targ_spec->raw_len == BPF_CORE_SPEC_MAX_LEN)
   22b38: 8b 83 34 0a 00 00            	movl	2612(%rbx), %eax
   22b3e: 83 f8 40                     	cmpl	$64, %eax
   22b41: 0f 84 0f 05 00 00            	je	0x23056 <bpf_core_calc_relo_insn+0x7f6>
; 			targ_acc->idx = local_acc->idx;
   22b47: 41 8b 54 24 04               	movl	4(%r12), %edx
; 			targ_acc->type_id = targ_id;
   22b4c: 8b b4 24 8c 00 00 00         	movl	140(%rsp), %esi
; 			targ_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;
   22b53: 48 63 c8                     	movslq	%eax, %rcx
; 			targ_spec->raw_len++;
   22b56: 83 c0 01                     	addl	$1, %eax
; 			targ_acc->name = NULL;
   22b59: 49 c7 84 24 28 05 00 00 00 00 00 00  	movq	$0, 1320(%r12)
; 			sz = btf__resolve_size(targ_btf, targ_id);
   22b65: 4c 89 f7                     	movq	%r14, %rdi
; 			targ_acc->idx = local_acc->idx;
   22b68: 41 89 94 24 24 05 00 00      	movl	%edx, 1316(%r12)
; 			targ_acc->type_id = targ_id;
   22b70: 41 89 b4 24 20 05 00 00      	movl	%esi, 1312(%r12)
; 			targ_spec->len++;
   22b78: 83 83 30 09 00 00 01         	addl	$1, 2352(%rbx)
; 			targ_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;
   22b7f: 89 94 8b 34 09 00 00         	movl	%edx, 2356(%rbx,%rcx,4)
; 			targ_spec->raw_len++;
   22b86: 89 83 34 0a 00 00            	movl	%eax, 2612(%rbx)
; 			sz = btf__resolve_size(targ_btf, targ_id);
   22b8c: e8 2f 89 00 00               	callq	0x2b4c0 <btf__resolve_size>
   22b91: 89 c2                        	movl	%eax, %edx
; 			if (sz < 0)
   22b93: 85 c0                        	testl	%eax, %eax
   22b95: 0f 88 02 04 00 00            	js	0x22f9d <bpf_core_calc_relo_insn+0x73d>
; 			targ_spec->bit_offset += local_acc->idx * sz * 8;
   22b9b: 41 0f af 44 24 04            	imull	4(%r12), %eax
   22ba1: c1 e0 03                     	shll	$3, %eax
   22ba4: 01 83 38 0a 00 00            	addl	%eax, 2616(%rbx)
   22baa: e9 d4 fe ff ff               	jmp	0x22a83 <bpf_core_calc_relo_insn+0x223>
   22baf: 90                           	nop
; 	switch (kind) {
   22bb0: 83 f8 0c                     	cmpl	$12, %eax
   22bb3: 0f 85 87 02 00 00            	jne	0x22e40 <bpf_core_calc_relo_insn+0x5e0>
; 			return bpf_core_types_match(local_spec->btf,
   22bb9: 44 8b 83 08 04 00 00         	movl	1032(%rbx), %r8d
   22bc0: 48 8b 3b                     	movq	(%rbx), %rdi
   22bc3: 89 f1                        	movl	%esi, %ecx
   22bc5: 4c 89 f2                     	movq	%r14, %rdx
   22bc8: 44 89 c6                     	movl	%r8d, %esi
   22bcb: e8 a0 ba fe ff               	callq	0xe670 <bpf_core_types_match>
   22bd0: 41 89 c7                     	movl	%eax, %r15d
; 		if (err < 0) {
   22bd3: 45 85 ff                     	testl	%r15d, %r15d
   22bd6: 0f 88 90 05 00 00            	js	0x2316c <bpf_core_calc_relo_insn+0x90c>
; 		bpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);
   22bdc: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
   22be1: 48 89 ea                     	movq	%rbp, %rdx
   22be4: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
   22be9: e8 f2 f8 ff ff               	callq	0x224e0 <bpf_core_format_spec>
; 		pr_debug("prog '%s': relo #%d: %s candidate #%d %s\n", prog_name,
   22bee: 45 85 ff                     	testl	%r15d, %r15d
   22bf1: 0f 85 81 00 00 00            	jne	0x22c78 <bpf_core_calc_relo_insn+0x418>
   22bf7: 48 83 ec 08                  	subq	$8, %rsp
   22bfb: 4c 8d 05 74 6b 01 00         	leaq	93044(%rip), %r8        # 0x39776 <CSWTCH.76+0x136>
   22c02: 48 8d 35 af 74 01 00         	leaq	95407(%rip), %rsi       # 0x3a0b8 <CSWTCH.126+0x7b8>
   22c09: 31 c0                        	xorl	%eax, %eax
   22c0b: ff 74 24 20                  	pushq	32(%rsp)
   22c0f: 44 8b 4c 24 38               	movl	56(%rsp), %r9d
   22c14: bf 02 00 00 00               	movl	$2, %edi
   22c19: 8b 8c 24 80 00 00 00         	movl	128(%rsp), %ecx
   22c20: 48 8b 54 24 40               	movq	64(%rsp), %rdx
   22c25: e8 a6 54 fe ff               	callq	0x80d0 <libbpf_print>
   22c2a: 5a                           	popq	%rdx
   22c2b: 59                           	popq	%rcx
; 	for (i = 0, j = 0; i < cands->len; i++) {
   22c2c: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   22c31: 48 83 44 24 08 01            	addq	$1, 8(%rsp)
   22c37: 48 8b 44 24 08               	movq	8(%rsp), %rax
   22c3c: 39 42 08                     	cmpl	%eax, 8(%rdx)
   22c3f: 0f 8f 73 fd ff ff            	jg	0x229b8 <bpf_core_calc_relo_insn+0x158>
; 	if (j > 0)
   22c45: 8b 44 24 2c                  	movl	44(%rsp), %eax
   22c49: 49 89 dc                     	movq	%rbx, %r12
   22c4c: 85 c0                        	testl	%eax, %eax
   22c4e: 0f 84 bb 03 00 00            	je	0x2300f <bpf_core_calc_relo_insn+0x7af>
; 		cands->len = j;
   22c54: 89 42 08                     	movl	%eax, 8(%rdx)
; 	if (j == 0) {
   22c57: e9 fa 02 00 00               	jmp	0x22f56 <bpf_core_calc_relo_insn+0x6f6>
   22c5c: 0f 1f 40 00                  	nopl	(%rax)
; 		bpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);
   22c60: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
   22c65: 48 89 ea                     	movq	%rbp, %rdx
   22c68: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
   22c6d: e8 6e f8 ff ff               	callq	0x224e0 <bpf_core_format_spec>
; 		pr_debug("prog '%s': relo #%d: %s candidate #%d %s\n", prog_name,
   22c72: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   22c78: 48 83 ec 08                  	subq	$8, %rsp
   22c7c: 4c 8d 05 f7 6a 01 00         	leaq	92919(%rip), %r8        # 0x3977a <CSWTCH.76+0x13a>
   22c83: 48 8d 35 2e 74 01 00         	leaq	95278(%rip), %rsi       # 0x3a0b8 <CSWTCH.126+0x7b8>
   22c8a: 31 c0                        	xorl	%eax, %eax
   22c8c: ff 74 24 20                  	pushq	32(%rsp)
   22c90: 4c 8b 7c 24 40               	movq	64(%rsp), %r15
   22c95: bf 02 00 00 00               	movl	$2, %edi
   22c9a: 44 8b b4 24 80 00 00 00      	movl	128(%rsp), %r14d
   22ca2: 44 8b 4c 24 38               	movl	56(%rsp), %r9d
   22ca7: 4c 89 fa                     	movq	%r15, %rdx
   22caa: 44 89 f1                     	movl	%r14d, %ecx
   22cad: e8 1e 54 fe ff               	callq	0x80d0 <libbpf_print>
; 		err = bpf_core_calc_relo(prog_name, relo, relo_idx, local_spec, cand_spec, &cand_res);
   22cb2: 4c 8b 4c 24 70               	movq	112(%rsp), %r9
   22cb7: 49 89 e8                     	movq	%rbp, %r8
   22cba: 48 89 d9                     	movq	%rbx, %rcx
   22cbd: 48 8b 74 24 60               	movq	96(%rsp), %rsi
   22cc2: 44 89 f2                     	movl	%r14d, %edx
   22cc5: 4c 89 ff                     	movq	%r15, %rdi
   22cc8: e8 d3 e6 ff ff               	callq	0x213a0 <bpf_core_calc_relo>
; 		if (err)
   22ccd: 41 59                        	popq	%r9
   22ccf: 41 5a                        	popq	%r10
   22cd1: 85 c0                        	testl	%eax, %eax
   22cd3: 0f 85 74 03 00 00            	jne	0x2304d <bpf_core_calc_relo_insn+0x7ed>
; 		if (j == 0) {
   22cd9: 44 8b 44 24 2c               	movl	44(%rsp), %r8d
   22cde: 45 85 c0                     	testl	%r8d, %r8d
   22ce1: 0f 85 c9 00 00 00            	jne	0x22db0 <bpf_core_calc_relo_insn+0x550>
; 			*targ_res = cand_res;
   22ce7: 48 8b 54 24 58               	movq	88(%rsp), %rdx
; 			*targ_spec = *cand_spec;
   22cec: b9 a4 00 00 00               	movl	$164, %ecx
   22cf1: 48 89 ee                     	movq	%rbp, %rsi
; 			*targ_res = cand_res;
   22cf4: 66 0f 6f 8c 24 90 00 00 00   	movdqa	144(%rsp), %xmm1
   22cfd: 66 0f 6f 94 24 a0 00 00 00   	movdqa	160(%rsp), %xmm2
   22d06: 48 8b 84 24 b0 00 00 00      	movq	176(%rsp), %rax
; 			*targ_spec = *cand_spec;
   22d0e: 48 8d bb 40 0a 00 00         	leaq	2624(%rbx), %rdi
; 			*targ_res = cand_res;
   22d15: 0f 11 0a                     	movups	%xmm1, (%rdx)
   22d18: 48 89 42 20                  	movq	%rax, 32(%rdx)
   22d1c: 0f 11 52 10                  	movups	%xmm2, 16(%rdx)
; 			*targ_spec = *cand_spec;
   22d20: f3 48 a5                     	rep		movsq	(%rsi), %es:(%rdi)
; 		cands->cands[j++] = cands->cands[i];
   22d23: 48 8b 44 24 10               	movq	16(%rsp), %rax
   22d28: 48 8b 74 24 20               	movq	32(%rsp), %rsi
   22d2d: 48 8b 10                     	movq	(%rax), %rdx
   22d30: 48 63 44 24 2c               	movslq	44(%rsp), %rax
   22d35: f3 0f 6f 04 32               	movdqu	(%rdx,%rsi), %xmm0
   22d3a: 48 89 c1                     	movq	%rax, %rcx
   22d3d: 48 c1 e0 04                  	shlq	$4, %rax
   22d41: 0f 11 04 02                  	movups	%xmm0, (%rdx,%rax)
   22d45: 8d 41 01                     	leal	1(%rcx), %eax
   22d48: 89 44 24 2c                  	movl	%eax, 44(%rsp)
   22d4c: e9 db fe ff ff               	jmp	0x22c2c <bpf_core_calc_relo_insn+0x3cc>
   22d51: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			return bpf_core_types_are_compat(local_spec->btf,
   22d58: 44 8b 83 08 04 00 00         	movl	1032(%rbx), %r8d
   22d5f: 48 8b 3b                     	movq	(%rbx), %rdi
   22d62: 89 f1                        	movl	%esi, %ecx
   22d64: 4c 89 f2                     	movq	%r14, %rdx
   22d67: 44 89 c6                     	movl	%r8d, %esi
   22d6a: e8 f1 b8 fe ff               	callq	0xe660 <bpf_core_types_are_compat>
   22d6f: 41 89 c7                     	movl	%eax, %r15d
   22d72: e9 5c fe ff ff               	jmp	0x22bd3 <bpf_core_calc_relo_insn+0x373>
   22d77: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 				if (!flex && local_acc->idx >= a->nelems)
   22d80: 8b 42 14                     	movl	20(%rdx), %eax
   22d83: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   22d88: 41 3b 44 24 04               	cmpl	4(%r12), %eax
   22d8d: 0f 87 8e fd ff ff            	ja	0x22b21 <bpf_core_calc_relo_insn+0x2c1>
   22d93: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		bpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);
   22d98: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
   22d9d: 48 89 ea                     	movq	%rbp, %rdx
   22da0: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
   22da5: e8 36 f7 ff ff               	callq	0x224e0 <bpf_core_format_spec>
; 		pr_debug("prog '%s': relo #%d: %s candidate #%d %s\n", prog_name,
   22daa: e9 48 fe ff ff               	jmp	0x22bf7 <bpf_core_calc_relo_insn+0x397>
   22daf: 90                           	nop
; 		} else if (cand_spec->bit_offset != targ_spec->bit_offset) {
   22db0: 44 8b 83 38 0a 00 00         	movl	2616(%rbx), %r8d
   22db7: 44 8b 8b 58 0f 00 00         	movl	3928(%rbx), %r9d
   22dbe: 45 39 c8                     	cmpl	%r9d, %r8d
   22dc1: 0f 85 c5 02 00 00            	jne	0x2308c <bpf_core_calc_relo_insn+0x82c>
; 		} else if (cand_res.poison != targ_res->poison ||
   22dc7: 48 8b 4c 24 58               	movq	88(%rsp), %rcx
   22dcc: 0f b6 84 24 a0 00 00 00      	movzbl	160(%rsp), %eax
; 			   cand_res.new_val != targ_res->new_val) {
   22dd4: 4c 8b 8c 24 98 00 00 00      	movq	152(%rsp), %r9
; 		} else if (cand_res.poison != targ_res->poison ||
   22ddc: 0f b6 51 10                  	movzbl	16(%rcx), %edx
; 			   cand_res.new_val != targ_res->new_val) {
   22de0: 48 8b 49 08                  	movq	8(%rcx), %rcx
; 		} else if (cand_res.poison != targ_res->poison ||
   22de4: 38 d0                        	cmpb	%dl, %al
   22de6: 75 09                        	jne	0x22df1 <bpf_core_calc_relo_insn+0x591>
   22de8: 4c 39 c9                     	cmpq	%r9, %rcx
   22deb: 0f 84 32 ff ff ff            	je	0x22d23 <bpf_core_calc_relo_insn+0x4c3>
; 			pr_warn("prog '%s': relo #%d: relocation decision ambiguity: %s %llu != %s %llu\n",
   22df1: 48 8d 35 76 69 01 00         	leaq	92534(%rip), %rsi       # 0x3976e <CSWTCH.76+0x12e>
   22df8: 84 d2                        	testb	%dl, %dl
   22dfa: 4c 8d 05 65 69 01 00         	leaq	92517(%rip), %r8        # 0x39766 <CSWTCH.76+0x126>
   22e01: 51                           	pushq	%rcx
   22e02: 48 89 f2                     	movq	%rsi, %rdx
   22e05: 49 0f 45 d0                  	cmovneq	%r8, %rdx
   22e09: 84 c0                        	testb	%al, %al
   22e0b: 4c 0f 44 c6                  	cmoveq	%rsi, %r8
   22e0f: 48 8d 35 1a 73 01 00         	leaq	95002(%rip), %rsi       # 0x3a130 <CSWTCH.126+0x830>
   22e16: 31 ff                        	xorl	%edi, %edi
   22e18: 52                           	pushq	%rdx
   22e19: 8b 8c 24 80 00 00 00         	movl	128(%rsp), %ecx
   22e20: 31 c0                        	xorl	%eax, %eax
   22e22: 48 8b 54 24 40               	movq	64(%rsp), %rdx
   22e27: e8 a4 52 fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   22e2c: 5e                           	popq	%rsi
   22e2d: 5f                           	popq	%rdi
   22e2e: c7 44 24 74 ea ff ff ff      	movl	$4294967274, 116(%rsp)  # imm = 0xFFFFFFEA
   22e36: e9 1b 01 00 00               	jmp	0x22f56 <bpf_core_calc_relo_insn+0x6f6>
   22e3b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	switch (kind) {
   22e40: 83 e8 0a                     	subl	$10, %eax
   22e43: 83 f8 01                     	cmpl	$1, %eax
   22e46: 0f 87 bd 00 00 00            	ja	0x22f09 <bpf_core_calc_relo_insn+0x6a9>
; 		targ_type = skip_mods_and_typedefs(targ_spec->btf, targ_id, &targ_id);
   22e4c: 48 8b 54 24 68               	movq	104(%rsp), %rdx
   22e51: 4c 89 f7                     	movq	%r14, %rdi
   22e54: e8 17 87 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	return btf_is_enum(t) || btf_is_enum64(t);
   22e59: ba 40 00 08 00               	movl	$524352, %edx           # imm = 0x80040
; 		targ_type = skip_mods_and_typedefs(targ_spec->btf, targ_id, &targ_id);
   22e5e: 49 89 c5                     	movq	%rax, %r13
; 	return BTF_INFO_KIND(t->info);
   22e61: 0f b6 40 07                  	movzbl	7(%rax), %eax
; 	return btf_is_enum(t) || btf_is_enum64(t);
   22e65: 83 e0 1f                     	andl	$31, %eax
   22e68: 48 0f a3 c2                  	btq	%rax, %rdx
   22e6c: 0f 83 26 ff ff ff            	jae	0x22d98 <bpf_core_calc_relo_insn+0x538>
; 		local_essent_len = bpf_core_essential_name_len(local_acc->name);
   22e72: 48 8b 7b 10                  	movq	16(%rbx), %rdi
; 		for (i = 0; i < btf_vlen(targ_type); i++) {
   22e76: 45 31 e4                     	xorl	%r12d, %r12d
; 		local_essent_len = bpf_core_essential_name_len(local_acc->name);
   22e79: e8 c2 b1 fe ff               	callq	0xe040 <bpf_core_essential_name_len>
   22e7e: 49 89 c6                     	movq	%rax, %r14
; 	return BTF_INFO_VLEN(t->info);
   22e81: 41 8b 45 04                  	movl	4(%r13), %eax
; 		for (i = 0; i < btf_vlen(targ_type); i++) {
   22e85: 66 85 c0                     	testw	%ax, %ax
   22e88: 0f 84 0a ff ff ff            	je	0x22d98 <bpf_core_calc_relo_insn+0x538>
   22e8e: 48 89 6c 24 78               	movq	%rbp, 120(%rsp)
   22e93: 48 89 dd                     	movq	%rbx, %rbp
   22e96: 4c 89 e3                     	movq	%r12, %rbx
   22e99: eb 54                        	jmp	0x22eef <bpf_core_calc_relo_insn+0x68f>
   22e9b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 				name_off = btf_enum64(targ_type)[i].name_off;
   22ea0: 48 8d 04 5b                  	leaq	(%rbx,%rbx,2), %rax
   22ea4: 41 8b 74 85 0c               	movl	12(%r13,%rax,4), %esi
; 			targ_name = btf__name_by_offset(targ_spec->btf, name_off);
   22ea9: 48 8b bd 20 05 00 00         	movq	1312(%rbp), %rdi
   22eb0: e8 3b 8c 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 			targ_essent_len = bpf_core_essential_name_len(targ_name);
   22eb5: 48 89 c7                     	movq	%rax, %rdi
; 			targ_name = btf__name_by_offset(targ_spec->btf, name_off);
   22eb8: 49 89 c4                     	movq	%rax, %r12
; 			targ_essent_len = bpf_core_essential_name_len(targ_name);
   22ebb: e8 80 b1 fe ff               	callq	0xe040 <bpf_core_essential_name_len>
; 			if (targ_essent_len != local_essent_len)
   22ec0: 49 39 c6                     	cmpq	%rax, %r14
   22ec3: 75 17                        	jne	0x22edc <bpf_core_calc_relo_insn+0x67c>
; 			if (strncmp(local_acc->name, targ_name, local_essent_len) == 0) {
   22ec5: 48 8b 7d 10                  	movq	16(%rbp), %rdi
   22ec9: 4c 89 f2                     	movq	%r14, %rdx
   22ecc: 4c 89 e6                     	movq	%r12, %rsi
   22ecf: e8 4c 28 fe ff               	callq	0x5720 <.plt.sec+0xb0>
   22ed4: 85 c0                        	testl	%eax, %eax
   22ed6: 0f 84 d4 00 00 00            	je	0x22fb0 <bpf_core_calc_relo_insn+0x750>
; 	return BTF_INFO_VLEN(t->info);
   22edc: 41 8b 45 04                  	movl	4(%r13), %eax
; 		for (i = 0; i < btf_vlen(targ_type); i++) {
   22ee0: 48 83 c3 01                  	addq	$1, %rbx
   22ee4: 0f b7 d0                     	movzwl	%ax, %edx
   22ee7: 39 da                        	cmpl	%ebx, %edx
   22ee9: 0f 8e 99 00 00 00            	jle	0x22f88 <bpf_core_calc_relo_insn+0x728>
; 	return BTF_INFO_KIND(t->info);
   22eef: c1 e8 18                     	shrl	$24, %eax
   22ef2: 89 5c 24 38                  	movl	%ebx, 56(%rsp)
   22ef6: 41 89 df                     	movl	%ebx, %r15d
   22ef9: 83 e0 1f                     	andl	$31, %eax
; 			if (btf_is_enum(targ_type))
   22efc: 66 83 f8 06                  	cmpw	$6, %ax
   22f00: 75 9e                        	jne	0x22ea0 <bpf_core_calc_relo_insn+0x640>
; 				name_off = btf_enum(targ_type)[i].name_off;
   22f02: 41 8b 74 dd 0c               	movl	12(%r13,%rbx,8), %esi
   22f07: eb a0                        	jmp	0x22ea9 <bpf_core_calc_relo_insn+0x649>
; 		err = bpf_core_spec_match(local_spec, cands->cands[i].btf,
   22f09: c7 44 24 74 ea ff ff ff      	movl	$4294967274, 116(%rsp)  # imm = 0xFFFFFFEA
; 			bpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);
   22f11: 48 8b 5c 24 18               	movq	24(%rsp), %rbx
   22f16: 48 89 ea                     	movq	%rbp, %rdx
   22f19: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
   22f1e: 48 89 df                     	movq	%rbx, %rdi
   22f21: e8 ba f5 ff ff               	callq	0x224e0 <bpf_core_format_spec>
; 			pr_warn("prog '%s': relo #%d: error matching candidate #%d %s: %d\n ",
   22f26: 48 83 ec 08                  	subq	$8, %rsp
   22f2a: 49 89 d9                     	movq	%rbx, %r9
   22f2d: 31 ff                        	xorl	%edi, %edi
   22f2f: 8b 44 24 7c                  	movl	124(%rsp), %eax
   22f33: 48 8d 35 36 71 01 00         	leaq	94518(%rip), %rsi       # 0x3a070 <CSWTCH.126+0x770>
   22f3a: 50                           	pushq	%rax
   22f3b: 44 8b 44 24 38               	movl	56(%rsp), %r8d
   22f40: 31 c0                        	xorl	%eax, %eax
   22f42: 8b 8c 24 80 00 00 00         	movl	128(%rsp), %ecx
   22f49: 48 8b 54 24 40               	movq	64(%rsp), %rdx
   22f4e: e8 7d 51 fe ff               	callq	0x80d0 <libbpf_print>
; 			return err;
   22f53: 41 5b                        	popq	%r11
   22f55: 5b                           	popq	%rbx
; }
   22f56: 48 8b 84 24 c8 01 00 00      	movq	456(%rsp), %rax
   22f5e: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   22f67: 0f 85 09 02 00 00            	jne	0x23176 <bpf_core_calc_relo_insn+0x916>
   22f6d: 8b 44 24 74                  	movl	116(%rsp), %eax
   22f71: 48 81 c4 d8 01 00 00         	addq	$472, %rsp              # imm = 0x1D8
   22f78: 5b                           	popq	%rbx
   22f79: 5d                           	popq	%rbp
   22f7a: 41 5c                        	popq	%r12
   22f7c: 41 5d                        	popq	%r13
   22f7e: 41 5e                        	popq	%r14
   22f80: 41 5f                        	popq	%r15
   22f82: c3                           	retq
   22f83: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   22f88: 48 89 eb                     	movq	%rbp, %rbx
   22f8b: 48 8b 6c 24 78               	movq	120(%rsp), %rbp
   22f90: e9 03 fe ff ff               	jmp	0x22d98 <bpf_core_calc_relo_insn+0x538>
   22f95: 0f 1f 00                     	nopl	(%rax)
; 			return -EINVAL;
   22f98: ba ea ff ff ff               	movl	$4294967274, %edx       # imm = 0xFFFFFFEA
; 		err = bpf_core_spec_match(local_spec, cands->cands[i].btf,
   22f9d: 89 54 24 74                  	movl	%edx, 116(%rsp)
   22fa1: e9 6b ff ff ff               	jmp	0x22f11 <bpf_core_calc_relo_insn+0x6b1>
   22fa6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 				targ_acc->type_id = targ_id;
   22fb0: 8b 84 24 8c 00 00 00         	movl	140(%rsp), %eax
   22fb7: 48 89 eb                     	movq	%rbp, %rbx
   22fba: 48 8b 6c 24 78               	movq	120(%rsp), %rbp
; 		bpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);
   22fbf: be 00 01 00 00               	movl	$256, %esi              # imm = 0x100
; 				targ_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;
   22fc4: 48 63 93 34 0a 00 00         	movslq	2612(%rbx), %rdx
; 				targ_spec->len++;
   22fcb: 83 83 30 09 00 00 01         	addl	$1, 2352(%rbx)
; 				targ_acc->type_id = targ_id;
   22fd2: 89 83 28 05 00 00            	movl	%eax, 1320(%rbx)
; 				targ_acc->idx = i;
   22fd8: 8b 44 24 38                  	movl	56(%rsp), %eax
; 				targ_acc->name = targ_name;
   22fdc: 4c 89 a3 30 05 00 00         	movq	%r12, 1328(%rbx)
; 		bpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);
   22fe3: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
; 				targ_acc->idx = i;
   22fe8: 89 83 2c 05 00 00            	movl	%eax, 1324(%rbx)
; 				targ_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;
   22fee: 48 89 d0                     	movq	%rdx, %rax
; 				targ_spec->raw_len++;
   22ff1: 83 c0 01                     	addl	$1, %eax
; 				targ_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;
   22ff4: 44 89 bc 93 34 09 00 00      	movl	%r15d, 2356(%rbx,%rdx,4)
; 		bpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);
   22ffc: 48 89 ea                     	movq	%rbp, %rdx
; 				targ_spec->raw_len++;
   22fff: 89 83 34 0a 00 00            	movl	%eax, 2612(%rbx)
; 		bpf_core_format_spec(spec_buf, sizeof(spec_buf), cand_spec);
   23005: e8 d6 f4 ff ff               	callq	0x224e0 <bpf_core_format_spec>
; 		pr_debug("prog '%s': relo #%d: %s candidate #%d %s\n", prog_name,
   2300a: e9 69 fc ff ff               	jmp	0x22c78 <bpf_core_calc_relo_insn+0x418>
; 		pr_debug("prog '%s': relo #%d: no matching targets found\n",
   2300f: 44 8b 7c 24 70               	movl	112(%rsp), %r15d
   23014: 48 8b 5c 24 30               	movq	48(%rsp), %rbx
   23019: 48 8d 35 60 71 01 00         	leaq	94560(%rip), %rsi       # 0x3a180 <CSWTCH.126+0x880>
   23020: 31 c0                        	xorl	%eax, %eax
   23022: bf 02 00 00 00               	movl	$2, %edi
   23027: 44 89 f9                     	movl	%r15d, %ecx
   2302a: 48 89 da                     	movq	%rbx, %rdx
   2302d: e8 9e 50 fe ff               	callq	0x80d0 <libbpf_print>
; 		err = bpf_core_calc_relo(prog_name, relo, relo_idx, local_spec, NULL, targ_res);
   23032: 4c 8b 4c 24 58               	movq	88(%rsp), %r9
   23037: 45 31 c0                     	xorl	%r8d, %r8d
   2303a: 4c 89 e1                     	movq	%r12, %rcx
   2303d: 48 8b 74 24 50               	movq	80(%rsp), %rsi
   23042: 44 89 fa                     	movl	%r15d, %edx
   23045: 48 89 df                     	movq	%rbx, %rdi
   23048: e8 53 e3 ff ff               	callq	0x213a0 <bpf_core_calc_relo>
   2304d: 89 44 24 74                  	movl	%eax, 116(%rsp)
; 		if (err)
   23051: e9 00 ff ff ff               	jmp	0x22f56 <bpf_core_calc_relo_insn+0x6f6>
; 				return -E2BIG;
   23056: ba f9 ff ff ff               	movl	$4294967289, %edx       # imm = 0xFFFFFFF9
   2305b: e9 3d ff ff ff               	jmp	0x22f9d <bpf_core_calc_relo_insn+0x73d>
;   return __builtin___memset_chk (__dest, __ch, __len,
   23060: 48 8b 5c 24 58               	movq	88(%rsp), %rbx
   23065: 66 0f ef c0                  	pxor	%xmm0, %xmm0
   23069: 0f 11 03                     	movups	%xmm0, (%rbx)
   2306c: 48 c7 43 20 00 00 00 00      	movq	$0, 32(%rbx)
   23074: 0f 11 43 10                  	movups	%xmm0, 16(%rbx)
; 		targ_res->orig_val = local_spec->root_type_id;
   23078: 41 8b 84 24 08 04 00 00      	movl	1032(%r12), %eax
   23080: 48 89 03                     	movq	%rax, (%rbx)
; 		targ_res->new_val = local_spec->root_type_id;
   23083: 48 89 43 08                  	movq	%rax, 8(%rbx)
; 		return 0;
   23087: e9 ca fe ff ff               	jmp	0x22f56 <bpf_core_calc_relo_insn+0x6f6>
; 			pr_warn("prog '%s': relo #%d: field offset ambiguity: %u != %u\n",
   2308c: 8b 4c 24 70                  	movl	112(%rsp), %ecx
   23090: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   23095: 31 ff                        	xorl	%edi, %edi
   23097: 31 c0                        	xorl	%eax, %eax
   23099: 48 8d 35 50 70 01 00         	leaq	94288(%rip), %rsi       # 0x3a0f0 <CSWTCH.126+0x7f0>
   230a0: e8 2b 50 fe ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   230a5: c7 44 24 74 ea ff ff ff      	movl	$4294967274, 116(%rsp)  # imm = 0xFFFFFFEA
   230ad: e9 a4 fe ff ff               	jmp	0x22f56 <bpf_core_calc_relo_insn+0x6f6>
   230b2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("prog '%s': relo #%d: <%s> (%d) relocation doesn't support anonymous types\n",
   230b8: 44 89 cf                     	movl	%r9d, %edi
   230bb: 48 8d 35 f6 70 01 00         	leaq	94454(%rip), %rsi       # 0x3a1b8 <CSWTCH.126+0x8b8>
   230c2: e8 c9 dc ff ff               	callq	0x20d90 <core_relo_kind_str>
   230c7: 8b 4c 24 70                  	movl	112(%rsp), %ecx
   230cb: 48 8b 54 24 30               	movq	48(%rsp), %rdx
   230d0: 31 ff                        	xorl	%edi, %edi
   230d2: 49 89 c0                     	movq	%rax, %r8
   230d5: 31 c0                        	xorl	%eax, %eax
   230d7: e8 f4 4f fe ff               	callq	0x80d0 <libbpf_print>
; 		return -EOPNOTSUPP;
   230dc: c7 44 24 74 a1 ff ff ff      	movl	$4294967201, 116(%rsp)  # imm = 0xFFFFFFA1
   230e4: e9 6d fe ff ff               	jmp	0x22f56 <bpf_core_calc_relo_insn+0x6f6>
; 		return -EINVAL;
   230e9: c7 44 24 74 ea ff ff ff      	movl	$4294967274, 116(%rsp)  # imm = 0xFFFFFFEA
   230f1: e9 60 fe ff ff               	jmp	0x22f56 <bpf_core_calc_relo_insn+0x6f6>
; 		spec_str = btf__name_by_offset(local_btf, relo->access_str_off);
   230f6: 48 8b 44 24 50               	movq	80(%rsp), %rax
   230fb: 4c 89 ef                     	movq	%r13, %rdi
   230fe: 8b 70 08                     	movl	8(%rax), %esi
   23101: e8 ea 89 00 00               	callq	0x2baf0 <btf__name_by_offset>
; 		pr_warn("prog '%s': relo #%d: parsing [%d] %s %s + %s failed: %d\n",
   23106: 48 89 ef                     	movq	%rbp, %rdi
   23109: 48 85 c0                     	testq	%rax, %rax
; 		spec_str = btf__name_by_offset(local_btf, relo->access_str_off);
   2310c: 49 89 c5                     	movq	%rax, %r13
; 		pr_warn("prog '%s': relo #%d: parsing [%d] %s %s + %s failed: %d\n",
   2310f: 48 8d 05 56 ed 00 00         	leaq	60758(%rip), %rax       # 0x31e6c <_IO_stdin_used+0x1e6c>
   23116: 4c 0f 44 e8                  	cmoveq	%rax, %r13
   2311a: 80 3b 00                     	cmpb	$0, (%rbx)
   2311d: 48 8d 05 cd 65 01 00         	leaq	91597(%rip), %rax       # 0x396f1 <CSWTCH.76+0xb1>
   23124: 48 0f 44 d8                  	cmoveq	%rax, %rbx
   23128: e8 d3 86 fe ff               	callq	0xb800 <btf_kind_str>
   2312d: 48 83 ec 08                  	subq	$8, %rsp
   23131: 45 89 f0                     	movl	%r14d, %r8d
   23134: 31 ff                        	xorl	%edi, %edi
   23136: 49 89 c1                     	movq	%rax, %r9
   23139: 8b 44 24 7c                  	movl	124(%rsp), %eax
   2313d: 48 8d 35 bc 6e 01 00         	leaq	93884(%rip), %rsi       # 0x3a000 <CSWTCH.126+0x700>
   23144: 50                           	pushq	%rax
   23145: 31 c0                        	xorl	%eax, %eax
   23147: 41 55                        	pushq	%r13
   23149: 53                           	pushq	%rbx
   2314a: 8b 8c 24 90 00 00 00         	movl	144(%rsp), %ecx
   23151: 48 8b 54 24 50               	movq	80(%rsp), %rdx
   23156: e8 75 4f fe ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   2315b: 48 83 c4 20                  	addq	$32, %rsp
   2315f: c7 44 24 74 ea ff ff ff      	movl	$4294967274, 116(%rsp)  # imm = 0xFFFFFFEA
   23167: e9 ea fd ff ff               	jmp	0x22f56 <bpf_core_calc_relo_insn+0x6f6>
   2316c: 44 89 7c 24 74               	movl	%r15d, 116(%rsp)
   23171: e9 9b fd ff ff               	jmp	0x22f11 <bpf_core_calc_relo_insn+0x6b1>
; }
   23176: e8 85 26 fe ff               	callq	0x5800 <.plt.sec+0x190>
   2317b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000023180 <__bpf_core_types_match>:
; {
   23180: f3 0f 1e fa                  	endbr64
   23184: 41 57                        	pushq	%r15
   23186: 41 56                        	pushq	%r14
   23188: 41 55                        	pushq	%r13
   2318a: 41 54                        	pushq	%r12
   2318c: 55                           	pushq	%rbp
   2318d: 53                           	pushq	%rbx
   2318e: 48 83 ec 58                  	subq	$88, %rsp
   23192: 89 74 24 4c                  	movl	%esi, 76(%rsp)
   23196: 89 4c 24 48                  	movl	%ecx, 72(%rsp)
   2319a: 44 89 4c 24 18               	movl	%r9d, 24(%rsp)
   2319f: 44 88 44 24 08               	movb	%r8b, 8(%rsp)
; 	if (level <= 0)
   231a4: 45 85 c9                     	testl	%r9d, %r9d
   231a7: 0f 8e 96 02 00 00            	jle	0x23443 <__bpf_core_types_match+0x2c3>
; 	local_t = btf_type_by_id(local_btf, local_id);
   231ad: 8b 74 24 4c                  	movl	76(%rsp), %esi
   231b1: 48 89 d5                     	movq	%rdx, %rbp
   231b4: 48 89 fb                     	movq	%rdi, %rbx
   231b7: 4c 8d 6c 24 4c               	leaq	76(%rsp), %r13
   231bc: 4c 8d 7c 24 48               	leaq	72(%rsp), %r15
   231c1: e8 9a 6d 00 00               	callq	0x29f60 <btf_type_by_id>
; 	targ_t = btf_type_by_id(targ_btf, targ_id);
   231c6: 8b 74 24 48                  	movl	72(%rsp), %esi
   231ca: 48 89 ef                     	movq	%rbp, %rdi
   231cd: e8 8e 6d 00 00               	callq	0x29f60 <btf_type_by_id>
   231d2: c7 44 24 10 20 00 00 00      	movl	$32, 16(%rsp)
; 	local_t = skip_mods_and_typedefs(local_btf, local_id, &local_id);
   231da: 8b 74 24 4c                  	movl	76(%rsp), %esi
   231de: 4c 89 ea                     	movq	%r13, %rdx
   231e1: 48 89 df                     	movq	%rbx, %rdi
   231e4: e8 87 83 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
; 	targ_t = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
   231e9: 8b 74 24 48                  	movl	72(%rsp), %esi
   231ed: 4c 89 fa                     	movq	%r15, %rdx
   231f0: 48 89 ef                     	movq	%rbp, %rdi
; 	local_t = skip_mods_and_typedefs(local_btf, local_id, &local_id);
   231f3: 49 89 c4                     	movq	%rax, %r12
; 	targ_t = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);
   231f6: e8 75 83 fe ff               	callq	0xb570 <skip_mods_and_typedefs>
   231fb: 49 89 c6                     	movq	%rax, %r14
; 	if (!local_t || !targ_t)
   231fe: 4d 85 e4                     	testq	%r12, %r12
   23201: 0f 84 3c 02 00 00            	je	0x23443 <__bpf_core_types_match+0x2c3>
   23207: 48 85 c0                     	testq	%rax, %rax
   2320a: 0f 84 33 02 00 00            	je	0x23443 <__bpf_core_types_match+0x2c3>
; 	if (!bpf_core_names_match(local_btf, local_t->name_off, targ_btf, targ_t->name_off))
   23210: 41 8b 34 24                  	movl	(%r12), %esi
   23214: 8b 08                        	movl	(%rax), %ecx
   23216: 48 89 ea                     	movq	%rbp, %rdx
   23219: 48 89 df                     	movq	%rbx, %rdi
   2321c: e8 4f e0 ff ff               	callq	0x21270 <bpf_core_names_match>
   23221: 89 c6                        	movl	%eax, %esi
   23223: 84 c0                        	testb	%al, %al
   23225: 74 63                        	je	0x2328a <__bpf_core_types_match+0x10a>
; 	return BTF_INFO_KIND(t->info);
   23227: 41 8b 54 24 04               	movl	4(%r12), %edx
   2322c: 41 8b 7e 04                  	movl	4(%r14), %edi
   23230: 89 d0                        	movl	%edx, %eax
   23232: 89 f9                        	movl	%edi, %ecx
   23234: c1 e8 18                     	shrl	$24, %eax
   23237: c1 e9 18                     	shrl	$24, %ecx
   2323a: 83 e0 1f                     	andl	$31, %eax
   2323d: 83 e1 1f                     	andl	$31, %ecx
; 	switch (local_k) {
   23240: 66 83 f8 13                  	cmpw	$19, %ax
   23244: 77 1a                        	ja	0x23260 <__bpf_core_types_match+0xe0>
   23246: 4c 8d 15 3f 66 01 00         	leaq	91711(%rip), %r10       # 0x3988c <CSWTCH.76+0x24c>
   2324d: 44 0f b7 c0                  	movzwl	%ax, %r8d
   23251: 4f 63 04 82                  	movslq	(%r10,%r8,4), %r8
   23255: 4d 01 d0                     	addq	%r10, %r8
   23258: 3e 41 ff e0                  	jmpq	*%r8
   2325c: 0f 1f 40 00                  	nopl	(%rax)
; 		pr_warn("unexpected kind %s relocated, local [%d], target [%d]\n",
   23260: 8b 5c 24 48                  	movl	72(%rsp), %ebx
   23264: 44 8b 6c 24 4c               	movl	76(%rsp), %r13d
   23269: 4c 89 e7                     	movq	%r12, %rdi
   2326c: e8 8f 85 fe ff               	callq	0xb800 <btf_kind_str>
   23271: 48 8d 35 d8 67 01 00         	leaq	92120(%rip), %rsi       # 0x39a50 <CSWTCH.126+0x150>
   23278: 31 ff                        	xorl	%edi, %edi
   2327a: 48 89 c2                     	movq	%rax, %rdx
   2327d: 41 89 d8                     	movl	%ebx, %r8d
   23280: 44 89 e9                     	movl	%r13d, %ecx
   23283: 31 c0                        	xorl	%eax, %eax
   23285: e8 46 4e fe ff               	callq	0x80d0 <libbpf_print>
; 		return 0;
   2328a: 31 c0                        	xorl	%eax, %eax
; }
   2328c: 48 83 c4 58                  	addq	$88, %rsp
   23290: 5b                           	popq	%rbx
   23291: 5d                           	popq	%rbp
   23292: 41 5c                        	popq	%r12
   23294: 41 5d                        	popq	%r13
   23296: 41 5e                        	popq	%r14
   23298: 41 5f                        	popq	%r15
   2329a: c3                           	retq
   2329b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		if (behind_ptr) {
   232a0: 80 7c 24 08 00               	cmpb	$0, 8(%rsp)
   232a5: 0f 84 ed 02 00 00            	je	0x23598 <__bpf_core_types_match+0x418>
; 			if (local_k == targ_k)
   232ab: 66 39 c1                     	cmpw	%ax, %cx
   232ae: 0f 84 54 01 00 00            	je	0x23408 <__bpf_core_types_match+0x288>
; 			if (targ_k != BTF_KIND_FWD)
   232b4: 66 83 f9 07                  	cmpw	$7, %cx
   232b8: 75 d0                        	jne	0x2328a <__bpf_core_types_match+0x10a>
; 			return (local_k == BTF_KIND_UNION) == targ_f;
   232ba: 66 83 f8 05                  	cmpw	$5, %ax
   232be: 0f 94 c0                     	sete	%al
; 			bool targ_f = BTF_INFO_KFLAG(targ_t->info);
   232c1: c1 ef 1f                     	shrl	$31, %edi
; 			return (local_k == BTF_KIND_UNION) == targ_f;
   232c4: 40 38 f8                     	cmpb	%dil, %al
   232c7: 0f 94 c0                     	sete	%al
   232ca: 0f b6 c0                     	movzbl	%al, %eax
   232cd: eb bd                        	jmp	0x2328c <__bpf_core_types_match+0x10c>
   232cf: 90                           	nop
; 	return btf_is_enum(t) || btf_is_enum64(t);
   232d0: 0f b7 c9                     	movzwl	%cx, %ecx
   232d3: b8 40 00 08 00               	movl	$524352, %eax           # imm = 0x80040
   232d8: 48 d3 e8                     	shrq	%cl, %rax
   232db: 83 e0 01                     	andl	$1, %eax
   232de: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   232e3: 74 a5                        	je	0x2328a <__bpf_core_types_match+0x10a>
; 	if (local_vlen > targ_vlen)
   232e5: 41 8b 46 08                  	movl	8(%r14), %eax
   232e9: 41 39 44 24 08               	cmpl	%eax, 8(%r12)
   232ee: 75 9a                        	jne	0x2328a <__bpf_core_types_match+0x10a>
   232f0: 66 39 fa                     	cmpw	%di, %dx
   232f3: 77 95                        	ja	0x2328a <__bpf_core_types_match+0x10a>
; 	for (i = 0; i < local_vlen; i++) {
   232f5: 89 d0                        	movl	%edx, %eax
   232f7: 25 ff ff 00 00               	andl	$65535, %eax            # imm = 0xFFFF
   232fc: 0f 84 06 01 00 00            	je	0x23408 <__bpf_core_types_match+0x288>
   23302: 83 c0 01                     	addl	$1, %eax
   23305: 0f b7 ff                     	movzwl	%di, %edi
   23308: 4c 89 64 24 10               	movq	%r12, 16(%rsp)
   2330d: 48 89 44 24 28               	movq	%rax, 40(%rsp)
   23312: 48 8b 44 24 18               	movq	24(%rsp), %rax
   23317: 89 7c 24 20                  	movl	%edi, 32(%rsp)
   2331b: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   23320: 8d 47 01                     	leal	1(%rdi), %eax
   23323: 89 44 24 30                  	movl	%eax, 48(%rsp)
   23327: 89 d0                        	movl	%edx, %eax
   23329: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return BTF_INFO_KIND(t->info);
   23330: c1 e8 18                     	shrl	$24, %eax
   23333: 83 e0 1f                     	andl	$31, %eax
; 		local_n_off = btf_is_enum(local_t) ? btf_enum(local_t)[i].name_off :
   23336: 66 83 f8 06                  	cmpw	$6, %ax
   2333a: 0f 84 38 03 00 00            	je	0x23678 <__bpf_core_types_match+0x4f8>
   23340: 48 8b 44 24 08               	movq	8(%rsp), %rax
   23345: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2334a: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   2334e: 44 8b 2c 82                  	movl	(%rdx,%rax,4), %r13d
; 		for (j = 0; j < targ_vlen; j++) {
   23352: 8b 54 24 20                  	movl	32(%rsp), %edx
   23356: 85 d2                        	testl	%edx, %edx
   23358: 0f 84 2c ff ff ff            	je	0x2328a <__bpf_core_types_match+0x10a>
   2335e: 44 8b 7c 24 30               	movl	48(%rsp), %r15d
; 			if (bpf_core_names_match(local_btf, local_n_off, targ_btf, targ_n_off)) {
   23363: 4c 8b 64 24 18               	movq	24(%rsp), %r12
   23368: eb 31                        	jmp	0x2339b <__bpf_core_types_match+0x21b>
   2336a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			targ_n_off = btf_is_enum(targ_t) ? btf_enum(targ_t)[j].name_off :
   23370: 4b 8d 04 64                  	leaq	(%r12,%r12,2), %rax
   23374: 41 8b 0c 86                  	movl	(%r14,%rax,4), %ecx
; 			if (bpf_core_names_match(local_btf, local_n_off, targ_btf, targ_n_off)) {
   23378: 48 89 ea                     	movq	%rbp, %rdx
   2337b: 4c 89 ee                     	movq	%r13, %rsi
   2337e: 48 89 df                     	movq	%rbx, %rdi
   23381: e8 ea de ff ff               	callq	0x21270 <bpf_core_names_match>
   23386: 84 c0                        	testb	%al, %al
   23388: 0f 85 c2 02 00 00            	jne	0x23650 <__bpf_core_types_match+0x4d0>
; 		for (j = 0; j < targ_vlen; j++) {
   2338e: 49 83 c4 01                  	addq	$1, %r12
   23392: 4d 39 fc                     	cmpq	%r15, %r12
   23395: 0f 84 ef fe ff ff            	je	0x2328a <__bpf_core_types_match+0x10a>
; 	return BTF_INFO_KIND(t->info);
   2339b: 41 0f b6 46 07               	movzbl	7(%r14), %eax
   233a0: 83 e0 1f                     	andl	$31, %eax
; 			targ_n_off = btf_is_enum(targ_t) ? btf_enum(targ_t)[j].name_off :
   233a3: 66 83 f8 06                  	cmpw	$6, %ax
   233a7: 75 c7                        	jne	0x23370 <__bpf_core_types_match+0x1f0>
   233a9: 43 8b 4c e6 04               	movl	4(%r14,%r12,8), %ecx
   233ae: eb c8                        	jmp	0x23378 <__bpf_core_types_match+0x1f8>
; 		return local_k == targ_k;
   233b0: 31 c0                        	xorl	%eax, %eax
   233b2: 66 85 c9                     	testw	%cx, %cx
   233b5: 0f 94 c0                     	sete	%al
; }
   233b8: 48 83 c4 58                  	addq	$88, %rsp
   233bc: 5b                           	popq	%rbx
   233bd: 5d                           	popq	%rbp
   233be: 41 5c                        	popq	%r12
   233c0: 41 5d                        	popq	%r13
   233c2: 41 5e                        	popq	%r14
   233c4: 41 5f                        	popq	%r15
   233c6: c3                           	retq
   233c7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		if (local_k != targ_k)
   233d0: 66 83 f9 01                  	cmpw	$1, %cx
   233d4: 0f 85 b0 fe ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
; 	return BTF_INT_ENCODING(*(__u32 *)(t + 1));
   233da: 41 8b 54 24 0c               	movl	12(%r12), %edx
   233df: 41 8b 46 0c                  	movl	12(%r14), %eax
; 		return local_t->size == targ_t->size && local_sgn == targ_sgn;
   233e3: 41 8b 5e 08                  	movl	8(%r14), %ebx
   233e7: 41 39 5c 24 08               	cmpl	%ebx, 8(%r12)
   233ec: 0f 85 98 fe ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
; 	return BTF_INT_ENCODING(*(__u32 *)(t + 1));
   233f2: c1 e8 18                     	shrl	$24, %eax
   233f5: c1 ea 18                     	shrl	$24, %edx
; 		return local_t->size == targ_t->size && local_sgn == targ_sgn;
   233f8: 31 d0                        	xorl	%edx, %eax
   233fa: a8 01                        	testb	$1, %al
   233fc: 0f 85 88 fe ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
   23402: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			return (targ_k == BTF_KIND_STRUCT && !local_f) ||
   23408: b8 01 00 00 00               	movl	$1, %eax
   2340d: e9 7a fe ff ff               	jmp	0x2328c <__bpf_core_types_match+0x10c>
   23412: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		if (local_k != targ_k)
   23418: 66 83 f9 02                  	cmpw	$2, %cx
   2341c: 0f 85 68 fe ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
; 		local_id = local_t->type;
   23422: 41 8b 44 24 08               	movl	8(%r12), %eax
; 		behind_ptr = true;
   23427: 40 88 74 24 08               	movb	%sil, 8(%rsp)
; 		local_id = local_t->type;
   2342c: 89 44 24 4c                  	movl	%eax, 76(%rsp)
; 		targ_id = targ_t->type;
   23430: 41 8b 46 08                  	movl	8(%r14), %eax
; 	if (depth < 0)
   23434: 83 6c 24 10 01               	subl	$1, 16(%rsp)
; 		targ_id = targ_t->type;
   23439: 89 44 24 48                  	movl	%eax, 72(%rsp)
; 	if (depth < 0)
   2343d: 0f 85 97 fd ff ff            	jne	0x231da <__bpf_core_types_match+0x5a>
; 		return -EINVAL;
   23443: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   23448: e9 3f fe ff ff               	jmp	0x2328c <__bpf_core_types_match+0x10c>
   2344d: 0f 1f 00                     	nopl	(%rax)
; 		if (local_k != targ_k)
   23450: 66 83 f9 03                  	cmpw	$3, %cx
   23454: 0f 85 30 fe ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
; 		if (local_array->nelems != targ_array->nelems)
   2345a: 41 8b 46 14                  	movl	20(%r14), %eax
   2345e: 41 39 44 24 14               	cmpl	%eax, 20(%r12)
   23463: 0f 85 21 fe ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
; 		local_id = local_array->type;
   23469: 41 8b 44 24 0c               	movl	12(%r12), %eax
   2346e: 89 44 24 4c                  	movl	%eax, 76(%rsp)
; 		targ_id = targ_array->type;
   23472: 41 8b 46 0c                  	movl	12(%r14), %eax
; 		goto recur;
   23476: eb bc                        	jmp	0x23434 <__bpf_core_types_match+0x2b4>
   23478: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		bool local_f = BTF_INFO_KFLAG(local_t->info);
   23480: c1 ea 1f                     	shrl	$31, %edx
; 		if (behind_ptr) {
   23483: 80 7c 24 08 00               	cmpb	$0, 8(%rsp)
   23488: 0f 84 ea 00 00 00            	je	0x23578 <__bpf_core_types_match+0x3f8>
; 			if (local_k == targ_k)
   2348e: 66 83 f9 07                  	cmpw	$7, %cx
   23492: 0f 84 ea 00 00 00            	je	0x23582 <__bpf_core_types_match+0x402>
; 			return (targ_k == BTF_KIND_STRUCT && !local_f) ||
   23498: 66 83 f9 04                  	cmpw	$4, %cx
   2349c: 75 08                        	jne	0x234a6 <__bpf_core_types_match+0x326>
   2349e: 85 d2                        	testl	%edx, %edx
   234a0: 0f 84 62 ff ff ff            	je	0x23408 <__bpf_core_types_match+0x288>
; 			       (targ_k == BTF_KIND_UNION && local_f);
   234a6: 66 83 f9 05                  	cmpw	$5, %cx
   234aa: 0f 94 c0                     	sete	%al
; 		return -EINVAL;
   234ad: 21 d0                        	andl	%edx, %eax
   234af: e9 d8 fd ff ff               	jmp	0x2328c <__bpf_core_types_match+0x10c>
   234b4: 0f 1f 40 00                  	nopl	(%rax)
; 	return (struct btf_param *)(t + 1);
   234b8: 4d 8d 5c 24 0c               	leaq	12(%r12), %r11
   234bd: 4d 8d 56 0c                  	leaq	12(%r14), %r10
; 		if (local_vlen != targ_vlen)
   234c1: 66 39 d7                     	cmpw	%dx, %di
   234c4: 0f 85 c0 fd ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
   234ca: 66 83 f9 0d                  	cmpw	$13, %cx
   234ce: 0f 85 b6 fd ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
; 		for (i = 0; i < local_vlen; i++, local_p++, targ_p++) {
   234d4: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   234da: 0f 84 80 00 00 00            	je	0x23560 <__bpf_core_types_match+0x3e0>
; 			err = __bpf_core_types_match(local_btf, local_m->type, targ_btf,
   234e0: 8b 44 24 18                  	movl	24(%rsp), %eax
; 			err = __bpf_core_types_match(local_btf, local_p->type, targ_btf,
   234e4: 44 0f b6 44 24 08            	movzbl	8(%rsp), %r8d
   234ea: 4c 89 64 24 28               	movq	%r12, 40(%rsp)
   234ef: 4d 89 d4                     	movq	%r10, %r12
   234f2: 4c 89 74 24 30               	movq	%r14, 48(%rsp)
; 			err = __bpf_core_types_match(local_btf, local_m->type, targ_btf,
   234f7: 44 8d 48 ff                  	leal	-1(%rax), %r9d
   234fb: 8d 42 ff                     	leal	-1(%rdx), %eax
   234fe: 4c 89 7c 24 38               	movq	%r15, 56(%rsp)
   23503: 49 8d 44 c6 14               	leaq	20(%r14,%rax,8), %rax
   23508: 4c 89 6c 24 40               	movq	%r13, 64(%rsp)
   2350d: 45 89 c6                     	movl	%r8d, %r14d
   23510: 45 89 cf                     	movl	%r9d, %r15d
   23513: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   23518: 4d 89 dd                     	movq	%r11, %r13
; 			err = __bpf_core_types_match(local_btf, local_p->type, targ_btf,
   2351b: 41 8b 4c 24 04               	movl	4(%r12), %ecx
   23520: 41 8b 75 04                  	movl	4(%r13), %esi
   23524: 45 89 f9                     	movl	%r15d, %r9d
   23527: 45 89 f0                     	movl	%r14d, %r8d
   2352a: 48 89 ea                     	movq	%rbp, %rdx
   2352d: 48 89 df                     	movq	%rbx, %rdi
   23530: e8 4b fc ff ff               	callq	0x23180 <__bpf_core_types_match>
; 			if (err <= 0)
   23535: 85 c0                        	testl	%eax, %eax
   23537: 0f 8e 4f fd ff ff            	jle	0x2328c <__bpf_core_types_match+0x10c>
; 		for (i = 0; i < local_vlen; i++, local_p++, targ_p++) {
   2353d: 49 83 c5 08                  	addq	$8, %r13
   23541: 49 83 c4 08                  	addq	$8, %r12
   23545: 4c 3b 64 24 20               	cmpq	32(%rsp), %r12
   2354a: 75 cf                        	jne	0x2351b <__bpf_core_types_match+0x39b>
   2354c: 4c 8b 64 24 28               	movq	40(%rsp), %r12
   23551: 4c 8b 74 24 30               	movq	48(%rsp), %r14
   23556: 4c 8b 7c 24 38               	movq	56(%rsp), %r15
   2355b: 4c 8b 6c 24 40               	movq	64(%rsp), %r13
; 		local_id = local_t->type;
   23560: 41 8b 44 24 08               	movl	8(%r12), %eax
   23565: 89 44 24 4c                  	movl	%eax, 76(%rsp)
; 		targ_id = targ_t->type;
   23569: 41 8b 46 08                  	movl	8(%r14), %eax
; 		goto recur;
   2356d: e9 c2 fe ff ff               	jmp	0x23434 <__bpf_core_types_match+0x2b4>
   23572: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			if (local_k != targ_k)
   23578: 66 83 f9 07                  	cmpw	$7, %cx
   2357c: 0f 85 08 fd ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
; 			return local_f == BTF_INFO_KFLAG(targ_t->info);
   23582: c1 ef 1f                     	shrl	$31, %edi
   23585: 31 c0                        	xorl	%eax, %eax
   23587: 39 d7                        	cmpl	%edx, %edi
   23589: 0f 94 c0                     	sete	%al
   2358c: e9 fb fc ff ff               	jmp	0x2328c <__bpf_core_types_match+0x10c>
   23591: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			if (local_k != targ_k)
   23598: 66 39 c1                     	cmpw	%ax, %cx
   2359b: 0f 85 e9 fc ff ff            	jne	0x2328a <__bpf_core_types_match+0x10a>
; 	if (local_vlen > targ_vlen)
   235a1: 66 39 fa                     	cmpw	%di, %dx
   235a4: 0f 87 e0 fc ff ff            	ja	0x2328a <__bpf_core_types_match+0x10a>
; 	for (i = 0; i < local_vlen; i++, local_m++) {
   235aa: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   235b0: 0f 84 52 fe ff ff            	je	0x23408 <__bpf_core_types_match+0x288>
; 	return (struct btf_member *)(t + 1);
   235b6: 49 8d 46 0c                  	leaq	12(%r14), %rax
   235ba: 0f b7 ff                     	movzwl	%di, %edi
; 			err = __bpf_core_types_match(local_btf, local_m->type, targ_btf,
   235bd: 44 8b 7c 24 18               	movl	24(%rsp), %r15d
; 	return (struct btf_member *)(t + 1);
   235c2: 4d 8d 6c 24 0c               	leaq	12(%r12), %r13
   235c7: 48 89 44 24 10               	movq	%rax, 16(%rsp)
   235cc: 8d 42 ff                     	leal	-1(%rdx), %eax
   235cf: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   235d3: 89 7c 24 08                  	movl	%edi, 8(%rsp)
; 			err = __bpf_core_types_match(local_btf, local_m->type, targ_btf,
   235d7: 41 83 ef 01                  	subl	$1, %r15d
   235db: 49 8d 44 84 18               	leaq	24(%r12,%rax,4), %rax
   235e0: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   235e5: 8d 47 ff                     	leal	-1(%rdi), %eax
   235e8: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   235ec: 4d 8d 64 86 18               	leaq	24(%r14,%rax,4), %r12
; 		for (j = 0; j < targ_vlen; j++, targ_m++) {
   235f1: 8b 44 24 08                  	movl	8(%rsp), %eax
   235f5: 85 c0                        	testl	%eax, %eax
   235f7: 0f 84 8d fc ff ff            	je	0x2328a <__bpf_core_types_match+0x10a>
; 		const struct btf_member *targ_m = btf_members(targ_t);
   235fd: 4c 8b 74 24 10               	movq	16(%rsp), %r14
   23602: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			if (!bpf_core_names_match(local_btf, local_m->name_off,
   23608: 41 8b 0e                     	movl	(%r14), %ecx
   2360b: 41 8b 75 00                  	movl	(%r13), %esi
   2360f: 48 89 ea                     	movq	%rbp, %rdx
   23612: 48 89 df                     	movq	%rbx, %rdi
   23615: e8 56 dc ff ff               	callq	0x21270 <bpf_core_names_match>
   2361a: 84 c0                        	testb	%al, %al
   2361c: 74 23                        	je	0x23641 <__bpf_core_types_match+0x4c1>
; 			err = __bpf_core_types_match(local_btf, local_m->type, targ_btf,
   2361e: 41 8b 4e 04                  	movl	4(%r14), %ecx
   23622: 41 8b 75 04                  	movl	4(%r13), %esi
   23626: 45 31 c0                     	xorl	%r8d, %r8d
   23629: 45 89 f9                     	movl	%r15d, %r9d
   2362c: 48 89 ea                     	movq	%rbp, %rdx
   2362f: 48 89 df                     	movq	%rbx, %rdi
   23632: e8 49 fb ff ff               	callq	0x23180 <__bpf_core_types_match>
; 			if (err < 0)
   23637: 85 c0                        	testl	%eax, %eax
   23639: 0f 88 4d fc ff ff            	js	0x2328c <__bpf_core_types_match+0x10c>
; 			if (err > 0) {
   2363f: 75 4b                        	jne	0x2368c <__bpf_core_types_match+0x50c>
; 		for (j = 0; j < targ_vlen; j++, targ_m++) {
   23641: 49 83 c6 0c                  	addq	$12, %r14
   23645: 4d 39 f4                     	cmpq	%r14, %r12
   23648: 75 be                        	jne	0x23608 <__bpf_core_types_match+0x488>
   2364a: e9 3b fc ff ff               	jmp	0x2328a <__bpf_core_types_match+0x10a>
   2364f: 90                           	nop
; 	for (i = 0; i < local_vlen; i++) {
   23650: 48 83 44 24 08 01            	addq	$1, 8(%rsp)
   23656: 48 8b 44 24 08               	movq	8(%rsp), %rax
   2365b: 48 39 44 24 28               	cmpq	%rax, 40(%rsp)
   23660: 0f 84 a2 fd ff ff            	je	0x23408 <__bpf_core_types_match+0x288>
; 	return BTF_INFO_KIND(t->info);
   23666: 48 8b 44 24 10               	movq	16(%rsp), %rax
   2366b: 8b 40 04                     	movl	4(%rax), %eax
   2366e: e9 bd fc ff ff               	jmp	0x23330 <__bpf_core_types_match+0x1b0>
   23673: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		local_n_off = btf_is_enum(local_t) ? btf_enum(local_t)[i].name_off :
   23678: 48 8b 44 24 10               	movq	16(%rsp), %rax
   2367d: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   23682: 44 8b 6c d0 04               	movl	4(%rax,%rdx,8), %r13d
   23687: e9 c6 fc ff ff               	jmp	0x23352 <__bpf_core_types_match+0x1d2>
; 	for (i = 0; i < local_vlen; i++, local_m++) {
   2368c: 49 83 c5 0c                  	addq	$12, %r13
   23690: 4c 39 6c 24 20               	cmpq	%r13, 32(%rsp)
   23695: 0f 85 56 ff ff ff            	jne	0x235f1 <__bpf_core_types_match+0x471>
   2369b: e9 68 fd ff ff               	jmp	0x23408 <__bpf_core_types_match+0x288>

00000000000236a0 <cmp_elf_segs>:
; {
   236a0: f3 0f 1e fa                  	endbr64
; 	return a->start < b->start ? -1 : 1;
   236a4: 48 8b 06                     	movq	(%rsi), %rax
   236a7: 48 39 07                     	cmpq	%rax, (%rdi)
   236aa: 0f 9d c0                     	setge	%al
   236ad: 0f b6 c0                     	movzbl	%al, %eax
   236b0: 8d 44 00 ff                  	leal	-1(%rax,%rax), %eax
; }
   236b4: c3                           	retq
   236b5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

00000000000236c0 <specs_hash_fn>:
; {
   236c0: f3 0f 1e fa                  	endbr64
; 	while (*s) {
   236c4: 48 0f be 07                  	movsbq	(%rdi), %rax
; 	size_t h = 0;
   236c8: 45 31 c0                     	xorl	%r8d, %r8d
; 	while (*s) {
   236cb: 84 c0                        	testb	%al, %al
   236cd: 74 1b                        	je	0x236ea <specs_hash_fn+0x2a>
   236cf: 90                           	nop
; 		h = h * 31 + *s;
   236d0: 4c 89 c2                     	movq	%r8, %rdx
; 		s++;
   236d3: 48 83 c7 01                  	addq	$1, %rdi
; 		h = h * 31 + *s;
   236d7: 48 c1 e2 05                  	shlq	$5, %rdx
   236db: 4c 29 c2                     	subq	%r8, %rdx
   236de: 4c 8d 04 10                  	leaq	(%rax,%rdx), %r8
; 	while (*s) {
   236e2: 48 0f be 07                  	movsbq	(%rdi), %rax
   236e6: 84 c0                        	testb	%al, %al
   236e8: 75 e6                        	jne	0x236d0 <specs_hash_fn+0x10>
; }
   236ea: 4c 89 c0                     	movq	%r8, %rax
   236ed: c3                           	retq
   236ee: 66 90                        	nop

00000000000236f0 <bpf_link_usdt_dealloc>:
; {
   236f0: f3 0f 1e fa                  	endbr64
   236f4: 55                           	pushq	%rbp
   236f5: 48 89 fd                     	movq	%rdi, %rbp
; 	free(usdt_link->spec_ids);
   236f8: 48 8b 7f 30                  	movq	48(%rdi), %rdi
   236fc: e8 bf 1f fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(usdt_link->uprobes);
   23701: 48 8b 7d 40                  	movq	64(%rbp), %rdi
   23705: e8 b6 1f fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(usdt_link);
   2370a: 48 89 ef                     	movq	%rbp, %rdi
; }
   2370d: 5d                           	popq	%rbp
; 	free(usdt_link);
   2370e: e9 ad 1f fe ff               	jmp	0x56c0 <.plt.sec+0x50>
   23713: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2371e: 66 90                        	nop

0000000000023720 <bpf_link_usdt_detach>:
; {
   23720: f3 0f 1e fa                  	endbr64
   23724: 41 55                        	pushq	%r13
   23726: 41 54                        	pushq	%r12
   23728: 55                           	pushq	%rbp
   23729: 48 89 fd                     	movq	%rdi, %rbp
   2372c: 53                           	pushq	%rbx
   2372d: 31 db                        	xorl	%ebx, %ebx
   2372f: 48 83 ec 08                  	subq	$8, %rsp
; 	for (i = 0; i < usdt_link->uprobe_cnt; i++) {
   23733: 48 83 7f 38 00               	cmpq	$0, 56(%rdi)
; 	struct usdt_manager *man = usdt_link->usdt_man;
   23738: 4c 8b 6f 20                  	movq	32(%rdi), %r13
; 	for (i = 0; i < usdt_link->uprobe_cnt; i++) {
   2373c: 75 0c                        	jne	0x2374a <bpf_link_usdt_detach+0x2a>
   2373e: eb 47                        	jmp	0x23787 <bpf_link_usdt_detach+0x67>
   23740: 48 83 c3 01                  	addq	$1, %rbx
   23744: 48 39 5d 38                  	cmpq	%rbx, 56(%rbp)
   23748: 76 3d                        	jbe	0x23787 <bpf_link_usdt_detach+0x67>
; 		bpf_link__destroy(usdt_link->uprobes[i].link);
   2374a: 48 8b 45 40                  	movq	64(%rbp), %rax
   2374e: 49 89 dc                     	movq	%rbx, %r12
   23751: 49 c1 e4 04                  	shlq	$4, %r12
   23755: 4a 8b 7c 20 08               	movq	8(%rax,%r12), %rdi
   2375a: e8 61 1c ff ff               	callq	0x153c0 <bpf_link__destroy>
; 		if (!man->has_bpf_cookie) {
   2375f: 41 80 7d 28 00               	cmpb	$0, 40(%r13)
   23764: 75 da                        	jne	0x23740 <bpf_link_usdt_detach+0x20>
; 			(void)bpf_map_delete_elem(bpf_map__fd(man->ip_to_spec_id_map),
   23766: 49 8b 7d 08                  	movq	8(%r13), %rdi
; 						  &usdt_link->uprobes[i].abs_ip);
   2376a: 4c 03 65 40                  	addq	64(%rbp), %r12
; 	for (i = 0; i < usdt_link->uprobe_cnt; i++) {
   2376e: 48 83 c3 01                  	addq	$1, %rbx
; 			(void)bpf_map_delete_elem(bpf_map__fd(man->ip_to_spec_id_map),
   23772: e8 a9 c5 fe ff               	callq	0xfd20 <bpf_map__fd>
   23777: 4c 89 e6                     	movq	%r12, %rsi
   2377a: 89 c7                        	movl	%eax, %edi
   2377c: e8 3f 2f 00 00               	callq	0x266c0 <bpf_map_delete_elem>
; 	for (i = 0; i < usdt_link->uprobe_cnt; i++) {
   23781: 48 39 5d 38                  	cmpq	%rbx, 56(%rbp)
   23785: 77 c3                        	ja	0x2374a <bpf_link_usdt_detach+0x2a>
; 	if (!man->free_spec_ids) {
   23787: 49 8b 7d 10                  	movq	16(%r13), %rdi
; 		man->free_spec_cnt = usdt_link->spec_cnt;
   2378b: 48 8b 5d 28                  	movq	40(%rbp), %rbx
; 	if (!man->free_spec_ids) {
   2378f: 48 85 ff                     	testq	%rdi, %rdi
   23792: 74 5c                        	je	0x237f0 <bpf_link_usdt_detach+0xd0>
; 		size_t new_cnt = man->free_spec_cnt + usdt_link->spec_cnt;
   23794: 49 03 5d 18                  	addq	24(%r13), %rbx
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   23798: 48 89 d8                     	movq	%rbx, %rax
   2379b: 48 8d 34 9d 00 00 00 00      	leaq	(,%rbx,4), %rsi
   237a3: 48 c1 e8 3e                  	shrq	$62, %rax
   237a7: 75 32                        	jne	0x237db <bpf_link_usdt_detach+0xbb>
; 	return realloc(ptr, total);
   237a9: e8 72 23 fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
   237ae: 49 89 c4                     	movq	%rax, %r12
; 		if (new_free_ids) {
   237b1: 48 85 c0                     	testq	%rax, %rax
   237b4: 74 25                        	je	0x237db <bpf_link_usdt_detach+0xbb>
; 			memcpy(new_free_ids + man->free_spec_cnt, usdt_link->spec_ids,
   237b6: 49 8b 45 18                  	movq	24(%r13), %rax
;   return __builtin___memcpy_chk (__dest, __src, __len,
   237ba: 48 8b 75 30                  	movq	48(%rbp), %rsi
; 			memcpy(new_free_ids + man->free_spec_cnt, usdt_link->spec_ids,
   237be: 49 8d 3c 84                  	leaq	(%r12,%rax,4), %rdi
   237c2: 48 8b 45 28                  	movq	40(%rbp), %rax
   237c6: 48 8d 14 85 00 00 00 00      	leaq	(,%rax,4), %rdx
;   return __builtin___memcpy_chk (__dest, __src, __len,
   237ce: e8 6d 22 fe ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 			man->free_spec_ids = new_free_ids;
   237d3: 4d 89 65 10                  	movq	%r12, 16(%r13)
; 			man->free_spec_cnt = new_cnt;
   237d7: 49 89 5d 18                  	movq	%rbx, 24(%r13)
; }
   237db: 48 83 c4 08                  	addq	$8, %rsp
   237df: 31 c0                        	xorl	%eax, %eax
   237e1: 5b                           	popq	%rbx
   237e2: 5d                           	popq	%rbp
   237e3: 41 5c                        	popq	%r12
   237e5: 41 5d                        	popq	%r13
   237e7: c3                           	retq
   237e8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		man->free_spec_ids = usdt_link->spec_ids;
   237f0: 48 8b 45 30                  	movq	48(%rbp), %rax
; 		man->free_spec_cnt = usdt_link->spec_cnt;
   237f4: 49 89 5d 18                  	movq	%rbx, 24(%r13)
; 		man->free_spec_ids = usdt_link->spec_ids;
   237f8: 49 89 45 10                  	movq	%rax, 16(%r13)
; }
   237fc: 31 c0                        	xorl	%eax, %eax
; 		usdt_link->spec_ids = NULL;
   237fe: 48 c7 45 30 00 00 00 00      	movq	$0, 48(%rbp)
; }
   23806: 48 83 c4 08                  	addq	$8, %rsp
   2380a: 5b                           	popq	%rbx
   2380b: 5d                           	popq	%rbp
   2380c: 41 5c                        	popq	%r12
   2380e: 41 5d                        	popq	%r13
   23810: c3                           	retq
   23811: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2381c: 0f 1f 40 00                  	nopl	(%rax)

0000000000023820 <specs_equal_fn>:
; {
   23820: f3 0f 1e fa                  	endbr64
   23824: 48 83 ec 08                  	subq	$8, %rsp
; 	return strcmp(s1, s2) == 0;
   23828: e8 83 21 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   2382d: 85 c0                        	testl	%eax, %eax
   2382f: 0f 94 c0                     	sete	%al
; }
   23832: 48 83 c4 08                  	addq	$8, %rsp
   23836: c3                           	retq
   23837: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000023840 <find_elf_sec_by_name>:
; {
   23840: 41 56                        	pushq	%r14
   23842: 49 89 ce                     	movq	%rcx, %r14
   23845: 41 55                        	pushq	%r13
   23847: 49 89 f5                     	movq	%rsi, %r13
   2384a: 41 54                        	pushq	%r12
   2384c: 49 89 d4                     	movq	%rdx, %r12
   2384f: 55                           	pushq	%rbp
   23850: 53                           	pushq	%rbx
   23851: 48 89 fb                     	movq	%rdi, %rbx
   23854: 48 83 ec 10                  	subq	$16, %rsp
   23858: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   23861: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   23866: 31 c0                        	xorl	%eax, %eax
; 	if (elf_getshdrstrndx(elf, &shstrndx))
   23868: 48 89 e6                     	movq	%rsp, %rsi
   2386b: e8 e0 23 fe ff               	callq	0x5c50 <.plt.sec+0x5e0>
   23870: 85 c0                        	testl	%eax, %eax
   23872: 0f 85 88 00 00 00            	jne	0x23900 <find_elf_sec_by_name+0xc0>
; 	if (!elf_rawdata(elf_getscn(elf, shstrndx), NULL))
   23878: 48 8b 34 24                  	movq	(%rsp), %rsi
   2387c: 48 89 df                     	movq	%rbx, %rdi
   2387f: e8 7c 23 fe ff               	callq	0x5c00 <.plt.sec+0x590>
   23884: 31 f6                        	xorl	%esi, %esi
   23886: 48 89 c7                     	movq	%rax, %rdi
   23889: e8 42 22 fe ff               	callq	0x5ad0 <.plt.sec+0x460>
   2388e: 48 85 c0                     	testq	%rax, %rax
   23891: 74 6d                        	je	0x23900 <find_elf_sec_by_name+0xc0>
; 	Elf_Scn *sec = NULL;
   23893: 31 ed                        	xorl	%ebp, %ebp
   23895: 0f 1f 00                     	nopl	(%rax)
; 	while ((sec = elf_nextscn(elf, sec)) != NULL) {
   23898: 48 89 ee                     	movq	%rbp, %rsi
   2389b: 48 89 df                     	movq	%rbx, %rdi
   2389e: e8 ed 22 fe ff               	callq	0x5b90 <.plt.sec+0x520>
   238a3: 48 89 c5                     	movq	%rax, %rbp
   238a6: 48 85 c0                     	testq	%rax, %rax
   238a9: 74 65                        	je	0x23910 <find_elf_sec_by_name+0xd0>
; 		if (!gelf_getshdr(sec, shdr))
   238ab: 4c 89 e6                     	movq	%r12, %rsi
   238ae: 48 89 ef                     	movq	%rbp, %rdi
   238b1: e8 2a 1e fe ff               	callq	0x56e0 <.plt.sec+0x70>
   238b6: 48 85 c0                     	testq	%rax, %rax
   238b9: 74 45                        	je	0x23900 <find_elf_sec_by_name+0xc0>
; 		name = elf_strptr(elf, shstrndx, shdr->sh_name);
   238bb: 48 8b 34 24                  	movq	(%rsp), %rsi
   238bf: 41 8b 14 24                  	movl	(%r12), %edx
   238c3: 48 89 df                     	movq	%rbx, %rdi
   238c6: e8 a5 1f fe ff               	callq	0x5870 <.plt.sec+0x200>
   238cb: 48 89 c6                     	movq	%rax, %rsi
; 		if (name && strcmp(sec_name, name) == 0) {
   238ce: 48 85 c0                     	testq	%rax, %rax
   238d1: 74 c5                        	je	0x23898 <find_elf_sec_by_name+0x58>
   238d3: 4c 89 ef                     	movq	%r13, %rdi
   238d6: e8 d5 20 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   238db: 85 c0                        	testl	%eax, %eax
   238dd: 75 b9                        	jne	0x23898 <find_elf_sec_by_name+0x58>
; 			*scn = sec;
   238df: 49 89 2e                     	movq	%rbp, (%r14)
; }
   238e2: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   238e7: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   238f0: 75 25                        	jne	0x23917 <find_elf_sec_by_name+0xd7>
   238f2: 48 83 c4 10                  	addq	$16, %rsp
   238f6: 5b                           	popq	%rbx
   238f7: 5d                           	popq	%rbp
   238f8: 41 5c                        	popq	%r12
   238fa: 41 5d                        	popq	%r13
   238fc: 41 5e                        	popq	%r14
   238fe: c3                           	retq
   238ff: 90                           	nop
; 		return -EINVAL;
   23900: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   23905: eb db                        	jmp	0x238e2 <find_elf_sec_by_name+0xa2>
   23907: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	return -ENOENT;
   23910: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
   23915: eb cb                        	jmp	0x238e2 <find_elf_sec_by_name+0xa2>
; }
   23917: e8 e4 1e fe ff               	callq	0x5800 <.plt.sec+0x190>
   2391c: 0f 1f 40 00                  	nopl	(%rax)

0000000000023920 <calc_pt_regs_off>:
; {
   23920: 41 55                        	pushq	%r13
   23922: 48 8d 35 e2 68 01 00         	leaq	92386(%rip), %rsi       # 0x3a20b <CSWTCH.126+0x90b>
; 	for (i = 0; i < ARRAY_SIZE(reg_map); i++) {
   23929: 45 31 ed                     	xorl	%r13d, %r13d
; {
   2392c: 41 54                        	pushq	%r12
   2392e: 49 89 fc                     	movq	%rdi, %r12
   23931: 55                           	pushq	%rbp
   23932: 48 8d 2d 67 2e 02 00         	leaq	142951(%rip), %rbp      # 0x467a0 <reg_map.0+0x20>
   23939: 53                           	pushq	%rbx
   2393a: 48 83 ec 08                  	subq	$8, %rsp
; 			if (strcmp(reg_name, reg_map[i].names[j]) == 0)
   2393e: 4c 89 e7                     	movq	%r12, %rdi
   23941: 48 8d 5d e0                  	leaq	-32(%rbp), %rbx
   23945: e8 66 20 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   2394a: 85 c0                        	testl	%eax, %eax
   2394c: 74 18                        	je	0x23966 <calc_pt_regs_off+0x46>
; 		for (j = 0; j < ARRAY_SIZE(reg_map[i].names); j++) {
   2394e: 48 83 c3 08                  	addq	$8, %rbx
   23952: 48 39 eb                     	cmpq	%rbp, %rbx
   23955: 74 31                        	je	0x23988 <calc_pt_regs_off+0x68>
; 			if (strcmp(reg_name, reg_map[i].names[j]) == 0)
   23957: 48 8b 33                     	movq	(%rbx), %rsi
   2395a: 4c 89 e7                     	movq	%r12, %rdi
   2395d: e8 4e 20 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   23962: 85 c0                        	testl	%eax, %eax
   23964: 75 e8                        	jne	0x2394e <calc_pt_regs_off+0x2e>
; 				return reg_map[i].pt_regs_off;
   23966: 4d 63 ed                     	movslq	%r13d, %r13
   23969: 48 8d 05 10 2e 02 00         	leaq	142864(%rip), %rax      # 0x46780 <reg_map.0>
   23970: 4b 8d 54 ad 00               	leaq	(%r13,%r13,4), %rdx
   23975: 8b 44 d0 20                  	movl	32(%rax,%rdx,8), %eax
; }
   23979: 48 83 c4 08                  	addq	$8, %rsp
   2397d: 5b                           	popq	%rbx
   2397e: 5d                           	popq	%rbp
   2397f: 41 5c                        	popq	%r12
   23981: 41 5d                        	popq	%r13
   23983: c3                           	retq
   23984: 0f 1f 40 00                  	nopl	(%rax)
; 	for (i = 0; i < ARRAY_SIZE(reg_map); i++) {
   23988: 41 83 c5 01                  	addl	$1, %r13d
   2398c: 48 83 c5 28                  	addq	$40, %rbp
   23990: 41 83 fd 11                  	cmpl	$17, %r13d
   23994: 74 0a                        	je	0x239a0 <calc_pt_regs_off+0x80>
; 			if (strcmp(reg_name, reg_map[i].names[j]) == 0)
   23996: 48 8b 75 e0                  	movq	-32(%rbp), %rsi
   2399a: eb a2                        	jmp	0x2393e <calc_pt_regs_off+0x1e>
   2399c: 0f 1f 40 00                  	nopl	(%rax)
; 	pr_warn("usdt: unrecognized register '%s'\n", reg_name);
   239a0: 4c 89 e2                     	movq	%r12, %rdx
   239a3: 31 c0                        	xorl	%eax, %eax
   239a5: 48 8d 35 14 6a 01 00         	leaq	92692(%rip), %rsi       # 0x3a3c0 <CSWTCH.126+0xac0>
   239ac: 31 ff                        	xorl	%edi, %edi
   239ae: e8 1d 47 fe ff               	callq	0x80d0 <libbpf_print>
; }
   239b3: 48 83 c4 08                  	addq	$8, %rsp
; 	pr_warn("usdt: unrecognized register '%s'\n", reg_name);
   239b7: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
; }
   239bc: 5b                           	popq	%rbx
   239bd: 5d                           	popq	%rbp
   239be: 41 5c                        	popq	%r12
   239c0: 41 5d                        	popq	%r13
   239c2: c3                           	retq
   239c3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   239ce: 66 90                        	nop

00000000000239d0 <parse_vma_segs>:
; {
   239d0: 41 57                        	pushq	%r15
   239d2: 41 56                        	pushq	%r14
   239d4: 41 55                        	pushq	%r13
   239d6: 41 54                        	pushq	%r12
   239d8: 55                           	pushq	%rbp
   239d9: 53                           	pushq	%rbx
   239da: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   239e1: 48 83 0c 24 00               	orq	$0, (%rsp)
   239e6: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   239ed: 48 83 0c 24 00               	orq	$0, (%rsp)
   239f2: 48 83 ec 78                  	subq	$120, %rsp
   239f6: 89 7c 24 2c                  	movl	%edi, 44(%rsp)
   239fa: 48 89 f3                     	movq	%rsi, %rbx
; 	if (sscanf(lib_path, "/proc/%d/root%s", &tmp_pid, path) == 2 && pid == tmp_pid)
   239fd: 4c 8d 64 24 60               	leaq	96(%rsp), %r12
; {
   23a02: 41 89 fe                     	movl	%edi, %r14d
   23a05: 48 89 74 24 20               	movq	%rsi, 32(%rsp)
; 	if (sscanf(lib_path, "/proc/%d/root%s", &tmp_pid, path) == 2 && pid == tmp_pid)
   23a0a: 48 89 df                     	movq	%rbx, %rdi
   23a0d: 48 8d 35 fb 67 01 00         	leaq	92155(%rip), %rsi       # 0x3a20f <CSWTCH.126+0x90f>
; {
   23a14: 48 89 54 24 10               	movq	%rdx, 16(%rsp)
; 	if (sscanf(lib_path, "/proc/%d/root%s", &tmp_pid, path) == 2 && pid == tmp_pid)
   23a19: 48 8d 54 24 34               	leaq	52(%rsp), %rdx
; {
   23a1e: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
   23a23: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   23a2c: 48 89 84 24 68 20 00 00      	movq	%rax, 8296(%rsp)
   23a34: 31 c0                        	xorl	%eax, %eax
; 	*seg_cnt = 0;
   23a36: 48 c7 01 00 00 00 00         	movq	$0, (%rcx)
; 	if (sscanf(lib_path, "/proc/%d/root%s", &tmp_pid, path) == 2 && pid == tmp_pid)
   23a3d: 31 c0                        	xorl	%eax, %eax
   23a3f: 4c 89 e1                     	movq	%r12, %rcx
   23a42: e8 59 20 fe ff               	callq	0x5aa0 <.plt.sec+0x430>
   23a47: 83 f8 02                     	cmpl	$2, %eax
   23a4a: 75 07                        	jne	0x23a53 <parse_vma_segs+0x83>
   23a4c: 44 39 74 24 34               	cmpl	%r14d, 52(%rsp)
   23a51: 74 1b                        	je	0x23a6e <parse_vma_segs+0x9e>
;   return __realpath_chk (__name, __resolved, sz);
   23a53: 48 8b 7c 24 20               	movq	32(%rsp), %rdi
   23a58: ba 00 10 00 00               	movl	$4096, %edx             # imm = 0x1000
   23a5d: 4c 89 e6                     	movq	%r12, %rsi
   23a60: e8 ab 1e fe ff               	callq	0x5910 <.plt.sec+0x2a0>
; 	if (!realpath(lib_path, path)) {
   23a65: 48 85 c0                     	testq	%rax, %rax
   23a68: 0f 84 00 02 00 00            	je	0x23c6e <parse_vma_segs+0x29e>
;   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
   23a6e: 44 8b 44 24 2c               	movl	44(%rsp), %r8d
   23a73: 4c 8d ac 24 60 10 00 00      	leaq	4192(%rsp), %r13
   23a7b: ba 00 10 00 00               	movl	$4096, %edx             # imm = 0x1000
   23a80: 31 c0                        	xorl	%eax, %eax
   23a82: 48 8d 0d 96 67 01 00         	leaq	92054(%rip), %rcx       # 0x3a21f <CSWTCH.126+0x91f>
   23a89: be 01 00 00 00               	movl	$1, %esi
   23a8e: 4c 89 ef                     	movq	%r13, %rdi
   23a91: e8 fa 21 fe ff               	callq	0x5c90 <.plt.sec+0x620>
; 	f = fopen(line, "r");
   23a96: 48 8d 35 6c e1 00 00         	leaq	57708(%rip), %rsi       # 0x31c09 <_IO_stdin_used+0x1c09>
   23a9d: 4c 89 ef                     	movq	%r13, %rdi
   23aa0: e8 6b 1f fe ff               	callq	0x5a10 <.plt.sec+0x3a0>
   23aa5: 48 89 c5                     	movq	%rax, %rbp
; 	if (!f) {
   23aa8: 48 85 c0                     	testq	%rax, %rax
   23aab: 0f 84 0a 02 00 00            	je	0x23cbb <parse_vma_segs+0x2eb>
   23ab1: 48 8d 44 24 38               	leaq	56(%rsp), %rax
   23ab6: 48 8d 5c 24 50               	leaq	80(%rsp), %rbx
   23abb: 48 89 04 24                  	movq	%rax, (%rsp)
   23abf: 4c 8d 7c 24 48               	leaq	72(%rsp), %r15
   23ac4: 4c 8d 74 24 40               	leaq	64(%rsp), %r14
   23ac9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	while (fscanf(f, "%zx-%zx %s %zx %*s %*d%[^\n]\n",
   23ad0: 48 83 ec 08                  	subq	$8, %rsp
   23ad4: 4c 89 f1                     	movq	%r14, %rcx
   23ad7: 4d 89 f9                     	movq	%r15, %r9
   23ada: 49 89 d8                     	movq	%rbx, %r8
   23add: 41 55                        	pushq	%r13
   23adf: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   23ae4: 48 8d 35 42 67 01 00         	leaq	91970(%rip), %rsi       # 0x3a22d <CSWTCH.126+0x92d>
   23aeb: 31 c0                        	xorl	%eax, %eax
   23aed: 48 89 ef                     	movq	%rbp, %rdi
   23af0: e8 4b 1c fe ff               	callq	0x5740 <.plt.sec+0xd0>
; 		      &seg_start, &seg_end, mode, &seg_off, line) == 5) {
   23af5: 5a                           	popq	%rdx
   23af6: 59                           	popq	%rcx
   23af7: 83 f8 05                     	cmpl	$5, %eax
   23afa: 0f 85 e4 00 00 00            	jne	0x23be4 <parse_vma_segs+0x214>
; 		while (isblank(line[i]))
   23b00: e8 7b 21 fe ff               	callq	0x5c80 <.plt.sec+0x610>
   23b05: 48 8b 08                     	movq	(%rax), %rcx
   23b08: 31 c0                        	xorl	%eax, %eax
   23b0a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   23b10: 49 0f be 54 05 00            	movsbq	(%r13,%rax), %rdx
   23b16: 48 63 f8                     	movslq	%eax, %rdi
   23b19: 48 83 c0 01                  	addq	$1, %rax
   23b1d: f6 04 51 01                  	testb	$1, (%rcx,%rdx,2)
   23b21: 75 ed                        	jne	0x23b10 <parse_vma_segs+0x140>
; 		if (strcmp(line + i, path) != 0)
   23b23: 4c 01 ef                     	addq	%r13, %rdi
   23b26: 4c 89 e6                     	movq	%r12, %rsi
   23b29: e8 82 1e fe ff               	callq	0x59b0 <.plt.sec+0x340>
   23b2e: 85 c0                        	testl	%eax, %eax
   23b30: 75 9e                        	jne	0x23ad0 <parse_vma_segs+0x100>
; 		pr_debug("usdt: discovered segment for lib '%s': addrs %zx-%zx mode %s offset %zx\n",
   23b32: 48 83 ec 08                  	subq	$8, %rsp
   23b36: bf 02 00 00 00               	movl	$2, %edi
   23b3b: 49 89 d9                     	movq	%rbx, %r9
   23b3e: 4c 89 e2                     	movq	%r12, %rdx
   23b41: ff 74 24 50                  	pushq	80(%rsp)
   23b45: 4c 8b 44 24 50               	movq	80(%rsp), %r8
   23b4a: 48 8d 35 37 69 01 00         	leaq	92471(%rip), %rsi       # 0x3a488 <CSWTCH.126+0xb88>
   23b51: 48 8b 4c 24 48               	movq	72(%rsp), %rcx
   23b56: e8 75 45 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (mode[2] != 'x')
   23b5b: 5e                           	popq	%rsi
   23b5c: 5f                           	popq	%rdi
   23b5d: 80 7c 24 52 78               	cmpb	$120, 82(%rsp)
   23b62: 0f 85 68 ff ff ff            	jne	0x23ad0 <parse_vma_segs+0x100>
; 		tmp = libbpf_reallocarray(*segs, *seg_cnt + 1, sizeof(**segs));
   23b68: 48 8b 44 24 10               	movq	16(%rsp), %rax
   23b6d: 48 8b 38                     	movq	(%rax), %rdi
   23b70: 48 8b 44 24 08               	movq	8(%rsp), %rax
   23b75: 48 8b 00                     	movq	(%rax), %rax
   23b78: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   23b7d: 48 83 c0 01                  	addq	$1, %rax
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   23b81: 48 89 c6                     	movq	%rax, %rsi
   23b84: 48 c1 e6 05                  	shlq	$5, %rsi
   23b88: 48 c1 e8 3b                  	shrq	$59, %rax
   23b8c: 0f 85 d4 00 00 00            	jne	0x23c66 <parse_vma_segs+0x296>
; 	return realloc(ptr, total);
   23b92: e8 89 1f fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 		if (!tmp) {
   23b97: 48 85 c0                     	testq	%rax, %rax
   23b9a: 0f 84 c6 00 00 00            	je	0x23c66 <parse_vma_segs+0x296>
; 		*segs = tmp;
   23ba0: 48 8b 74 24 10               	movq	16(%rsp), %rsi
   23ba5: 48 89 06                     	movq	%rax, (%rsi)
; 		seg = *segs + *seg_cnt;
   23ba8: 48 8b 74 24 08               	movq	8(%rsp), %rsi
   23bad: 48 8b 16                     	movq	(%rsi), %rdx
   23bb0: 48 89 d1                     	movq	%rdx, %rcx
; 		*seg_cnt += 1;
   23bb3: 48 83 c2 01                  	addq	$1, %rdx
   23bb7: 48 89 16                     	movq	%rdx, (%rsi)
; 		seg = *segs + *seg_cnt;
   23bba: 48 c1 e1 05                  	shlq	$5, %rcx
; 		seg->start = seg_start;
   23bbe: 48 8b 54 24 38               	movq	56(%rsp), %rdx
; 		seg = *segs + *seg_cnt;
   23bc3: 48 01 c8                     	addq	%rcx, %rax
; 		seg->start = seg_start;
   23bc6: 48 89 10                     	movq	%rdx, (%rax)
; 		seg->end = seg_end;
   23bc9: 48 8b 54 24 40               	movq	64(%rsp), %rdx
; 		seg->is_exec = true;
   23bce: c6 40 18 01                  	movb	$1, 24(%rax)
; 		seg->end = seg_end;
   23bd2: 48 89 50 08                  	movq	%rdx, 8(%rax)
; 		seg->offset = seg_off;
   23bd6: 48 8b 54 24 48               	movq	72(%rsp), %rdx
   23bdb: 48 89 50 10                  	movq	%rdx, 16(%rax)
; 		seg->is_exec = true;
   23bdf: e9 ec fe ff ff               	jmp	0x23ad0 <parse_vma_segs+0x100>
; 	if (*seg_cnt == 0) {
   23be4: 48 8b 44 24 08               	movq	8(%rsp), %rax
   23be9: 48 8b 30                     	movq	(%rax), %rsi
   23bec: 48 85 f6                     	testq	%rsi, %rsi
   23bef: 74 50                        	je	0x23c41 <parse_vma_segs+0x271>
; 	qsort(*segs, *seg_cnt, sizeof(**segs), cmp_elf_segs);
   23bf1: 48 8b 44 24 10               	movq	16(%rsp), %rax
   23bf6: 48 8d 0d a3 fa ff ff         	leaq	-1373(%rip), %rcx       # 0x236a0 <cmp_elf_segs>
   23bfd: ba 20 00 00 00               	movl	$32, %edx
; 	err = 0;
   23c02: 45 31 e4                     	xorl	%r12d, %r12d
; 	qsort(*segs, *seg_cnt, sizeof(**segs), cmp_elf_segs);
   23c05: 48 8b 38                     	movq	(%rax), %rdi
   23c08: e8 53 1b fe ff               	callq	0x5760 <.plt.sec+0xf0>
; 	fclose(f);
   23c0d: 48 89 ef                     	movq	%rbp, %rdi
   23c10: e8 ab 1b fe ff               	callq	0x57c0 <.plt.sec+0x150>
; }
   23c15: 48 8b 84 24 68 20 00 00      	movq	8296(%rsp), %rax
   23c1d: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   23c26: 0f 85 8a 00 00 00            	jne	0x23cb6 <parse_vma_segs+0x2e6>
   23c2c: 48 81 c4 78 20 00 00         	addq	$8312, %rsp             # imm = 0x2078
   23c33: 44 89 e0                     	movl	%r12d, %eax
   23c36: 5b                           	popq	%rbx
   23c37: 5d                           	popq	%rbp
   23c38: 41 5c                        	popq	%r12
   23c3a: 41 5d                        	popq	%r13
   23c3c: 41 5e                        	popq	%r14
   23c3e: 41 5f                        	popq	%r15
   23c40: c3                           	retq
; 		pr_warn("usdt: failed to find '%s' (resolved to '%s') within PID %d memory mappings\n",
   23c41: 44 8b 44 24 2c               	movl	44(%rsp), %r8d
   23c46: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   23c4b: 4c 89 e1                     	movq	%r12, %rcx
   23c4e: 31 ff                        	xorl	%edi, %edi
   23c50: 48 8d 35 89 68 01 00         	leaq	92297(%rip), %rsi       # 0x3a4e0 <CSWTCH.126+0xbe0>
   23c57: 31 c0                        	xorl	%eax, %eax
; 		err = -ESRCH;
   23c59: 41 bc fd ff ff ff            	movl	$4294967293, %r12d      # imm = 0xFFFFFFFD
; 		pr_warn("usdt: failed to find '%s' (resolved to '%s') within PID %d memory mappings\n",
   23c5f: e8 6c 44 fe ff               	callq	0x80d0 <libbpf_print>
; 		goto err_out;
   23c64: eb a7                        	jmp	0x23c0d <parse_vma_segs+0x23d>
; 			err = -ENOMEM;
   23c66: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
   23c6c: eb 9f                        	jmp	0x23c0d <parse_vma_segs+0x23d>
; 		pr_warn("usdt: failed to get absolute path of '%s' (err %d), using path as is...\n",
   23c6e: e8 7d 1a fe ff               	callq	0x56f0 <.plt.sec+0x80>
   23c73: 48 8b 5c 24 20               	movq	32(%rsp), %rbx
   23c78: 48 8d 35 71 67 01 00         	leaq	92017(%rip), %rsi       # 0x3a3f0 <CSWTCH.126+0xaf0>
   23c7f: 31 ff                        	xorl	%edi, %edi
   23c81: 8b 08                        	movl	(%rax), %ecx
   23c83: 31 c0                        	xorl	%eax, %eax
   23c85: 48 89 da                     	movq	%rbx, %rdx
   23c88: f7 d9                        	negl	%ecx
   23c8a: e8 41 44 fe ff               	callq	0x80d0 <libbpf_print>
; 	for (i = 0; i < sz && src[i]; i++)
   23c8f: 31 c0                        	xorl	%eax, %eax
   23c91: 48 89 d9                     	movq	%rbx, %rcx
   23c94: 0f b6 14 01                  	movzbl	(%rcx,%rax), %edx
   23c98: 84 d2                        	testb	%dl, %dl
   23c9a: 74 10                        	je	0x23cac <parse_vma_segs+0x2dc>
; 		dst[i] = src[i];
   23c9c: 41 88 14 04                  	movb	%dl, (%r12,%rax)
; 	for (i = 0; i < sz && src[i]; i++)
   23ca0: 48 83 c0 01                  	addq	$1, %rax
   23ca4: 48 3d ff 0f 00 00            	cmpq	$4095, %rax             # imm = 0xFFF
   23caa: 75 e8                        	jne	0x23c94 <parse_vma_segs+0x2c4>
; 	dst[i] = '\0';
   23cac: c6 44 04 60 00               	movb	$0, 96(%rsp,%rax)
   23cb1: e9 b8 fd ff ff               	jmp	0x23a6e <parse_vma_segs+0x9e>
; }
   23cb6: e8 45 1b fe ff               	callq	0x5800 <.plt.sec+0x190>
; 		err = -errno;
   23cbb: e8 30 1a fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("usdt: failed to open '%s' to get base addr of '%s': %d\n",
   23cc0: 48 8b 4c 24 20               	movq	32(%rsp), %rcx
   23cc5: 4c 89 ea                     	movq	%r13, %rdx
   23cc8: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
   23cca: 44 8b 20                     	movl	(%rax), %r12d
; 		pr_warn("usdt: failed to open '%s' to get base addr of '%s': %d\n",
   23ccd: 48 8d 35 74 67 01 00         	leaq	92020(%rip), %rsi       # 0x3a448 <CSWTCH.126+0xb48>
   23cd4: 31 c0                        	xorl	%eax, %eax
; 		err = -errno;
   23cd6: 41 f7 dc                     	negl	%r12d
; 		pr_warn("usdt: failed to open '%s' to get base addr of '%s': %d\n",
   23cd9: 45 89 e0                     	movl	%r12d, %r8d
   23cdc: e8 ef 43 fe ff               	callq	0x80d0 <libbpf_print>
; 		return err;
   23ce1: e9 2f ff ff ff               	jmp	0x23c15 <parse_vma_segs+0x245>
   23ce6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000023cf0 <usdt_manager_new>:
; {
   23cf0: f3 0f 1e fa                  	endbr64
   23cf4: 41 55                        	pushq	%r13
; 	specs_map = bpf_object__find_map_by_name(obj, "__bpf_usdt_specs");
   23cf6: 48 8d 35 4d 65 01 00         	leaq	91469(%rip), %rsi       # 0x3a24a <CSWTCH.126+0x94a>
; {
   23cfd: 41 54                        	pushq	%r12
   23cff: 55                           	pushq	%rbp
   23d00: 48 89 fd                     	movq	%rdi, %rbp
   23d03: 53                           	pushq	%rbx
   23d04: 48 83 ec 08                  	subq	$8, %rsp
; 	specs_map = bpf_object__find_map_by_name(obj, "__bpf_usdt_specs");
   23d08: e8 a3 d9 fe ff               	callq	0x116b0 <bpf_object__find_map_by_name>
; 	ip_to_spec_id_map = bpf_object__find_map_by_name(obj, "__bpf_usdt_ip_to_spec_id");
   23d0d: 48 8d 35 47 65 01 00         	leaq	91463(%rip), %rsi       # 0x3a25b <CSWTCH.126+0x95b>
   23d14: 48 89 ef                     	movq	%rbp, %rdi
; 	specs_map = bpf_object__find_map_by_name(obj, "__bpf_usdt_specs");
   23d17: 48 89 c3                     	movq	%rax, %rbx
; 	ip_to_spec_id_map = bpf_object__find_map_by_name(obj, "__bpf_usdt_ip_to_spec_id");
   23d1a: e8 91 d9 fe ff               	callq	0x116b0 <bpf_object__find_map_by_name>
; 	if (!specs_map || !ip_to_spec_id_map) {
   23d1f: 48 85 db                     	testq	%rbx, %rbx
   23d22: 74 5c                        	je	0x23d80 <usdt_manager_new+0x90>
   23d24: 49 89 c5                     	movq	%rax, %r13
   23d27: 48 85 c0                     	testq	%rax, %rax
   23d2a: 74 54                        	je	0x23d80 <usdt_manager_new+0x90>
; 	man = calloc(1, sizeof(*man));
   23d2c: be 30 00 00 00               	movl	$48, %esi
   23d31: bf 01 00 00 00               	movl	$1, %edi
   23d36: e8 55 1c fe ff               	callq	0x5990 <.plt.sec+0x320>
   23d3b: 49 89 c4                     	movq	%rax, %r12
; 	if (!man)
   23d3e: 48 85 c0                     	testq	%rax, %rax
   23d41: 74 62                        	je	0x23da5 <usdt_manager_new+0xb5>
; 	man->specs_map = specs_map;
   23d43: 48 89 18                     	movq	%rbx, (%rax)
; 	man->has_bpf_cookie = kernel_supports(obj, FEAT_BPF_COOKIE);
   23d46: be 10 00 00 00               	movl	$16, %esi
   23d4b: 48 89 ef                     	movq	%rbp, %rdi
; 	man->ip_to_spec_id_map = ip_to_spec_id_map;
   23d4e: 4c 89 68 08                  	movq	%r13, 8(%rax)
; 	man->has_bpf_cookie = kernel_supports(obj, FEAT_BPF_COOKIE);
   23d52: e8 b9 86 fe ff               	callq	0xc410 <kernel_supports>
; 	man->has_sema_refcnt = access(ref_ctr_sysfs_path, F_OK) == 0;
   23d57: 31 f6                        	xorl	%esi, %esi
   23d59: 48 8d 3d 38 68 01 00         	leaq	92216(%rip), %rdi       # 0x3a598 <CSWTCH.126+0xc98>
; 	man->has_bpf_cookie = kernel_supports(obj, FEAT_BPF_COOKIE);
   23d60: 41 88 44 24 28               	movb	%al, 40(%r12)
; 	man->has_sema_refcnt = access(ref_ctr_sysfs_path, F_OK) == 0;
   23d65: e8 36 1e fe ff               	callq	0x5ba0 <.plt.sec+0x530>
   23d6a: 85 c0                        	testl	%eax, %eax
   23d6c: 41 0f 94 44 24 29            	sete	41(%r12)
; }
   23d72: 48 83 c4 08                  	addq	$8, %rsp
   23d76: 4c 89 e0                     	movq	%r12, %rax
   23d79: 5b                           	popq	%rbx
   23d7a: 5d                           	popq	%rbp
   23d7b: 41 5c                        	popq	%r12
   23d7d: 41 5d                        	popq	%r13
   23d7f: c3                           	retq
; 		pr_warn("usdt: failed to find USDT support BPF maps, did you forget to include bpf/usdt.bpf.h?\n");
   23d80: 31 c0                        	xorl	%eax, %eax
   23d82: 48 8d 35 af 67 01 00         	leaq	92079(%rip), %rsi       # 0x3a538 <CSWTCH.126+0xc38>
   23d89: 31 ff                        	xorl	%edi, %edi
; 		return ERR_PTR(-ESRCH);
   23d8b: 49 c7 c4 fd ff ff ff         	movq	$-3, %r12
; 		pr_warn("usdt: failed to find USDT support BPF maps, did you forget to include bpf/usdt.bpf.h?\n");
   23d92: e8 39 43 fe ff               	callq	0x80d0 <libbpf_print>
; }
   23d97: 48 83 c4 08                  	addq	$8, %rsp
   23d9b: 4c 89 e0                     	movq	%r12, %rax
   23d9e: 5b                           	popq	%rbx
   23d9f: 5d                           	popq	%rbp
   23da0: 41 5c                        	popq	%r12
   23da2: 41 5d                        	popq	%r13
   23da4: c3                           	retq
; 		return ERR_PTR(-ENOMEM);
   23da5: 49 c7 c4 f4 ff ff ff         	movq	$-12, %r12
   23dac: eb c4                        	jmp	0x23d72 <usdt_manager_new+0x82>
   23dae: 66 90                        	nop

0000000000023db0 <usdt_manager_free>:
; {
   23db0: f3 0f 1e fa                  	endbr64
; 	if (IS_ERR_OR_NULL(man))
   23db4: 48 85 ff                     	testq	%rdi, %rdi
   23db7: 74 2f                        	je	0x23de8 <usdt_manager_free+0x38>
; {
   23db9: 55                           	pushq	%rbp
   23dba: 48 89 fd                     	movq	%rdi, %rbp
; 	if (IS_ERR_OR_NULL(man))
   23dbd: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   23dc4: 77 1a                        	ja	0x23de0 <usdt_manager_free+0x30>
; 	free(man->free_spec_ids);
   23dc6: 48 8b 7f 10                  	movq	16(%rdi), %rdi
   23dca: e8 f1 18 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(man);
   23dcf: 48 89 ef                     	movq	%rbp, %rdi
; }
   23dd2: 5d                           	popq	%rbp
; 	free(man);
   23dd3: e9 e8 18 fe ff               	jmp	0x56c0 <.plt.sec+0x50>
   23dd8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; }
   23de0: 5d                           	popq	%rbp
   23de1: c3                           	retq
   23de2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   23de8: c3                           	retq
   23de9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000023df0 <usdt_manager_attach_usdt>:
; {
   23df0: f3 0f 1e fa                  	endbr64
   23df4: 41 57                        	pushq	%r15
   23df6: 49 89 ff                     	movq	%rdi, %r15
;   return __builtin___memset_chk (__dest, __ch, __len,
   23df9: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   23dfd: 41 56                        	pushq	%r14
   23dff: 41 55                        	pushq	%r13
   23e01: 41 54                        	pushq	%r12
   23e03: 55                           	pushq	%rbp
   23e04: 53                           	pushq	%rbx
   23e05: 48 89 cb                     	movq	%rcx, %rbx
   23e08: 48 81 ec 58 02 00 00         	subq	$600, %rsp              # imm = 0x258
; 	spec_map_fd = bpf_map__fd(man->specs_map);
   23e0f: 48 8b 3f                     	movq	(%rdi), %rdi
; {
   23e12: 48 89 74 24 58               	movq	%rsi, 88(%rsp)
   23e17: 89 54 24 3c                  	movl	%edx, 60(%rsp)
   23e1b: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
   23e20: 4c 89 44 24 48               	movq	%r8, 72(%rsp)
   23e25: 4c 89 4c 24 68               	movq	%r9, 104(%rsp)
   23e2a: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   23e33: 48 89 84 24 48 02 00 00      	movq	%rax, 584(%rsp)
   23e3b: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   23e3d: 0f 11 84 24 38 01 00 00      	movups	%xmm0, 312(%rsp)
   23e45: 0f 11 84 24 48 01 00 00      	movups	%xmm0, 328(%rsp)
; 	LIBBPF_OPTS(bpf_uprobe_opts, opts);
   23e4d: 48 c7 84 24 30 01 00 00 28 00 00 00  	movq	$40, 304(%rsp)
; 	spec_map_fd = bpf_map__fd(man->specs_map);
   23e59: e8 c2 be fe ff               	callq	0xfd20 <bpf_map__fd>
; 	ip_map_fd = bpf_map__fd(man->ip_to_spec_id_map);
   23e5e: 49 8b 7f 08                  	movq	8(%r15), %rdi
; 	spec_map_fd = bpf_map__fd(man->specs_map);
   23e62: 89 84 24 b4 00 00 00         	movl	%eax, 180(%rsp)
; 	ip_map_fd = bpf_map__fd(man->ip_to_spec_id_map);
   23e69: e8 b2 be fe ff               	callq	0xfd20 <bpf_map__fd>
;       return __open_alias (__path, __oflag, __va_arg_pack ());
   23e6e: 31 f6                        	xorl	%esi, %esi
   23e70: 48 89 df                     	movq	%rbx, %rdi
; 	ip_map_fd = bpf_map__fd(man->ip_to_spec_id_map);
   23e73: 89 84 24 bc 00 00 00         	movl	%eax, 188(%rsp)
;       return __open_alias (__path, __oflag, __va_arg_pack ());
   23e7a: 31 c0                        	xorl	%eax, %eax
   23e7c: e8 df 1c fe ff               	callq	0x5b60 <.plt.sec+0x4f0>
   23e81: 89 84 24 b8 00 00 00         	movl	%eax, 184(%rsp)
; 	if (fd < 0) {
   23e88: 85 c0                        	testl	%eax, %eax
   23e8a: 0f 88 02 10 00 00            	js	0x24e92 <usdt_manager_attach_usdt+0x10a2>
; 	elf = elf_begin(fd, ELF_C_READ_MMAP, NULL);
   23e90: 8b bc 24 b8 00 00 00         	movl	184(%rsp), %edi
   23e97: 31 d2                        	xorl	%edx, %edx
   23e99: be 01 00 00 00               	movl	$1, %esi
   23e9e: e8 5d 1c fe ff               	callq	0x5b00 <.plt.sec+0x490>
   23ea3: 48 89 44 24 70               	movq	%rax, 112(%rsp)
; 	if (!elf) {
   23ea8: 48 85 c0                     	testq	%rax, %rax
   23eab: 0f 84 d3 10 00 00            	je	0x24f84 <usdt_manager_attach_usdt+0x1194>
; 	if (elf_kind(elf) != ELF_K_ELF) {
   23eb1: 48 8b 7c 24 70               	movq	112(%rsp), %rdi
   23eb6: e8 b5 1d fe ff               	callq	0x5c70 <.plt.sec+0x600>
   23ebb: 83 f8 03                     	cmpl	$3, %eax
   23ebe: 0f 85 62 12 00 00            	jne	0x25126 <usdt_manager_attach_usdt+0x1336>
; 	switch (gelf_getclass(elf)) {
   23ec4: 48 8b 7c 24 70               	movq	112(%rsp), %rdi
   23ec9: e8 92 19 fe ff               	callq	0x5860 <.plt.sec+0x1f0>
   23ece: 89 84 24 b0 00 00 00         	movl	%eax, 176(%rsp)
   23ed5: 83 f8 01                     	cmpl	$1, %eax
   23ed8: 0f 84 12 08 00 00            	je	0x246f0 <usdt_manager_attach_usdt+0x900>
   23ede: 83 f8 02                     	cmpl	$2, %eax
   23ee1: 0f 85 69 07 00 00            	jne	0x24650 <usdt_manager_attach_usdt+0x860>
; 	if (!gelf_getehdr(elf, &ehdr))
   23ee7: 48 8b 7c 24 70               	movq	112(%rsp), %rdi
   23eec: 48 8d ac 24 00 02 00 00      	leaq	512(%rsp), %rbp
   23ef4: 48 89 ee                     	movq	%rbp, %rsi
   23ef7: e8 94 17 fe ff               	callq	0x5690 <.plt.sec+0x20>
   23efc: 49 89 c4                     	movq	%rax, %r12
   23eff: 48 85 c0                     	testq	%rax, %rax
   23f02: 0f 84 c0 13 00 00            	je	0x252c8 <usdt_manager_attach_usdt+0x14d8>
; 	if (ehdr.e_type != ET_EXEC && ehdr.e_type != ET_DYN) {
   23f08: 0f b7 84 24 10 02 00 00      	movzwl	528(%rsp), %eax
   23f10: 8d 50 fe                     	leal	-2(%rax), %edx
   23f13: 66 83 fa 01                  	cmpw	$1, %dx
   23f17: 0f 87 8e 13 00 00            	ja	0x252ab <usdt_manager_attach_usdt+0x14bb>
; 	if (endianness != ehdr.e_ident[EI_DATA]) {
   23f1d: 80 bc 24 05 02 00 00 01      	cmpb	$1, 517(%rsp)
   23f25: 0f 85 06 13 00 00            	jne	0x25231 <usdt_manager_attach_usdt+0x1441>
; 	if (pid < 0)
   23f2b: 8b 5c 24 3c                  	movl	60(%rsp), %ebx
   23f2f: 85 db                        	testl	%ebx, %ebx
   23f31: 0f 88 a9 07 00 00            	js	0x246e0 <usdt_manager_attach_usdt+0x8f0>
; 	else if (pid == 0)
   23f37: 0f 84 47 0f 00 00            	je	0x24e84 <usdt_manager_attach_usdt+0x1094>
; 	err = find_elf_sec_by_name(elf, USDT_NOTE_SEC, &notes_shdr, &notes_scn);
   23f3d: 48 8d 84 24 a0 01 00 00      	leaq	416(%rsp), %rax
   23f45: 48 8b 7c 24 70               	movq	112(%rsp), %rdi
   23f4a: 4c 8d 25 2d 63 01 00         	leaq	90925(%rip), %r12       # 0x3a27e <CSWTCH.126+0x97e>
; 	size_t off, name_off, desc_off, seg_cnt = 0, vma_seg_cnt = 0, target_cnt = 0;
   23f51: 48 c7 84 24 f0 00 00 00 00 00 00 00  	movq	$0, 240(%rsp)
; 	err = find_elf_sec_by_name(elf, USDT_NOTE_SEC, &notes_shdr, &notes_scn);
   23f5d: 48 8d 8c 24 00 01 00 00      	leaq	256(%rsp), %rcx
   23f65: 48 89 c2                     	movq	%rax, %rdx
   23f68: 4c 89 e6                     	movq	%r12, %rsi
; 	struct elf_seg *segs = NULL, *vma_segs = NULL;
   23f6b: 48 c7 84 24 f8 00 00 00 00 00 00 00  	movq	$0, 248(%rsp)
; 	err = find_elf_sec_by_name(elf, USDT_NOTE_SEC, &notes_shdr, &notes_scn);
   23f77: 48 89 44 24 60               	movq	%rax, 96(%rsp)
   23f7c: e8 bf f8 ff ff               	callq	0x23840 <find_elf_sec_by_name>
   23f81: 41 89 c5                     	movl	%eax, %r13d
; 	if (err) {
   23f84: 85 c0                        	testl	%eax, %eax
   23f86: 0f 85 94 0e 00 00            	jne	0x24e20 <usdt_manager_attach_usdt+0x1030>
; 	if (notes_shdr.sh_type != SHT_NOTE || !gelf_getehdr(elf, &ehdr)) {
   23f8c: 83 bc 24 a4 01 00 00 07      	cmpl	$7, 420(%rsp)
   23f94: 0f 85 50 11 00 00            	jne	0x250ea <usdt_manager_attach_usdt+0x12fa>
   23f9a: 48 8b 5c 24 70               	movq	112(%rsp), %rbx
   23f9f: 48 89 ee                     	movq	%rbp, %rsi
   23fa2: 48 89 df                     	movq	%rbx, %rdi
   23fa5: e8 e6 16 fe ff               	callq	0x5690 <.plt.sec+0x20>
   23faa: 48 85 c0                     	testq	%rax, %rax
   23fad: 0f 84 37 11 00 00            	je	0x250ea <usdt_manager_attach_usdt+0x12fa>
; 	if (elf_getphdrnum(elf, &n)) {
   23fb3: 48 8d 84 24 20 01 00 00      	leaq	288(%rsp), %rax
   23fbb: 48 89 df                     	movq	%rbx, %rdi
   23fbe: 48 89 c6                     	movq	%rax, %rsi
   23fc1: 48 89 84 24 88 00 00 00      	movq	%rax, 136(%rsp)
   23fc9: e8 e2 1a fe ff               	callq	0x5ab0 <.plt.sec+0x440>
   23fce: 85 c0                        	testl	%eax, %eax
   23fd0: 0f 85 ea 0d 00 00            	jne	0x24dc0 <usdt_manager_attach_usdt+0xfd0>
; 	for (i = 0; i < n; i++) {
   23fd6: 48 83 bc 24 20 01 00 00 00   	cmpq	$0, 288(%rsp)
   23fdf: 0f 84 91 11 00 00            	je	0x25176 <usdt_manager_attach_usdt+0x1386>
; 		pr_debug("usdt: discovered PHDR #%d in '%s': vaddr 0x%lx memsz 0x%lx offset 0x%lx type 0x%lx flags 0x%lx\n",
   23fe5: 4c 89 7c 24 10               	movq	%r15, 16(%rsp)
   23fea: 4c 8b 74 24 70               	movq	112(%rsp), %r14
; 	for (i = 0; i < n; i++) {
   23fef: 31 db                        	xorl	%ebx, %ebx
   23ff1: 4c 8d a4 24 60 01 00 00      	leaq	352(%rsp), %r12
; 	struct elf_seg *segs = NULL, *vma_segs = NULL;
   23ff9: 48 c7 44 24 50 00 00 00 00   	movq	$0, 80(%rsp)
; 		pr_debug("usdt: discovered PHDR #%d in '%s': vaddr 0x%lx memsz 0x%lx offset 0x%lx type 0x%lx flags 0x%lx\n",
   24002: 4c 8b 7c 24 08               	movq	8(%rsp), %r15
   24007: 48 8d 2d ea 67 01 00         	leaq	92138(%rip), %rbp       # 0x3a7f8 <CSWTCH.126+0xef8>
; 	*seg_cnt = 0;
   2400e: 48 c7 44 24 78 00 00 00 00   	movq	$0, 120(%rsp)
   24017: e9 e0 00 00 00               	jmp	0x240fc <usdt_manager_attach_usdt+0x30c>
   2401c: 0f 1f 40 00                  	nopl	(%rax)
; 		pr_debug("usdt: discovered PHDR #%d in '%s': vaddr 0x%lx memsz 0x%lx offset 0x%lx type 0x%lx flags 0x%lx\n",
   24020: 48 83 ec 08                  	subq	$8, %rsp
   24024: 4c 89 f9                     	movq	%r15, %rcx
   24027: 89 da                        	movl	%ebx, %edx
   24029: 48 89 ee                     	movq	%rbp, %rsi
   2402c: 8b 84 24 6c 01 00 00         	movl	364(%rsp), %eax
   24033: bf 02 00 00 00               	movl	$2, %edi
   24038: 50                           	pushq	%rax
   24039: 8b 84 24 70 01 00 00         	movl	368(%rsp), %eax
   24040: 50                           	pushq	%rax
   24041: 31 c0                        	xorl	%eax, %eax
   24043: ff b4 24 80 01 00 00         	pushq	384(%rsp)
   2404a: 4c 8b 8c 24 a8 01 00 00      	movq	424(%rsp), %r9
   24052: 4c 8b 84 24 90 01 00 00      	movq	400(%rsp), %r8
   2405a: e8 71 40 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (phdr.p_type != PT_LOAD)
   2405f: 48 83 c4 20                  	addq	$32, %rsp
   24063: 83 bc 24 60 01 00 00 01      	cmpl	$1, 352(%rsp)
   2406b: 75 7d                        	jne	0x240ea <usdt_manager_attach_usdt+0x2fa>
; 		tmp = libbpf_reallocarray(*segs, *seg_cnt + 1, sizeof(**segs));
   2406d: 4c 8b 6c 24 78               	movq	120(%rsp), %r13
   24072: 49 8d 4d 01                  	leaq	1(%r13), %rcx
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   24076: 48 89 ce                     	movq	%rcx, %rsi
   24079: 48 89 c8                     	movq	%rcx, %rax
   2407c: 48 89 0c 24                  	movq	%rcx, (%rsp)
   24080: 48 c1 e6 05                  	shlq	$5, %rsi
   24084: 48 c1 e8 3b                  	shrq	$59, %rax
   24088: 0f 85 de 0c 00 00            	jne	0x24d6c <usdt_manager_attach_usdt+0xf7c>
; 	return realloc(ptr, total);
   2408e: 48 8b 7c 24 50               	movq	80(%rsp), %rdi
   24093: e8 88 1a fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 		if (!tmp)
   24098: 48 85 c0                     	testq	%rax, %rax
   2409b: 0f 84 cb 0c 00 00            	je	0x24d6c <usdt_manager_attach_usdt+0xf7c>
; 		seg->start = phdr.p_vaddr;
   240a1: 48 8b 94 24 70 01 00 00      	movq	368(%rsp), %rdx
; 		seg = *segs + *seg_cnt;
   240a9: 49 c1 e5 05                  	shlq	$5, %r13
; 		(*seg_cnt)++;
   240ad: 48 8b 0c 24                  	movq	(%rsp), %rcx
; 		seg->is_exec = phdr.p_flags & PF_X;
   240b1: 48 89 44 24 50               	movq	%rax, 80(%rsp)
; 		seg = *segs + *seg_cnt;
   240b6: 49 01 c5                     	addq	%rax, %r13
; 		seg->start = phdr.p_vaddr;
   240b9: 49 89 55 00                  	movq	%rdx, (%r13)
; 		seg->end = phdr.p_vaddr + phdr.p_memsz;
   240bd: 48 03 94 24 88 01 00 00      	addq	392(%rsp), %rdx
   240c5: 49 89 55 08                  	movq	%rdx, 8(%r13)
; 		seg->offset = phdr.p_offset;
   240c9: 48 8b 94 24 68 01 00 00      	movq	360(%rsp), %rdx
; 		(*seg_cnt)++;
   240d1: 48 89 4c 24 78               	movq	%rcx, 120(%rsp)
; 		seg->offset = phdr.p_offset;
   240d6: 49 89 55 10                  	movq	%rdx, 16(%r13)
; 		seg->is_exec = phdr.p_flags & PF_X;
   240da: 8b 94 24 64 01 00 00         	movl	356(%rsp), %edx
   240e1: 41 88 55 18                  	movb	%dl, 24(%r13)
   240e5: 41 80 65 18 01               	andb	$1, 24(%r13)
; 	for (i = 0; i < n; i++) {
   240ea: 48 83 c3 01                  	addq	$1, %rbx
   240ee: 48 39 9c 24 20 01 00 00      	cmpq	%rbx, 288(%rsp)
   240f6: 0f 86 3c 0e 00 00            	jbe	0x24f38 <usdt_manager_attach_usdt+0x1148>
; 		if (!gelf_getphdr(elf, i, &phdr)) {
   240fc: 4c 89 e2                     	movq	%r12, %rdx
   240ff: 89 de                        	movl	%ebx, %esi
   24101: 4c 89 f7                     	movq	%r14, %rdi
   24104: e8 07 17 fe ff               	callq	0x5810 <.plt.sec+0x1a0>
   24109: 48 85 c0                     	testq	%rax, %rax
   2410c: 0f 85 0e ff ff ff            	jne	0x24020 <usdt_manager_attach_usdt+0x230>
; 			err = -errno;
   24112: e8 d9 15 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   24117: 4c 8b 7c 24 10               	movq	16(%rsp), %r15
   2411c: 44 8b 00                     	movl	(%rax), %r8d
   2411f: 41 f7 d8                     	negl	%r8d
; 	if (err) {
   24122: 4c 8d a4 24 60 01 00 00      	leaq	352(%rsp), %r12
   2412a: 45 85 c0                     	testl	%r8d, %r8d
   2412d: 0f 85 44 0c 00 00            	jne	0x24d77 <usdt_manager_attach_usdt+0xf87>
; 	if (find_elf_sec_by_name(elf, USDT_BASE_SEC, &base_shdr, &base_scn) == 0)
   24133: 48 8b 7c 24 70               	movq	112(%rsp), %rdi
   24138: 48 8d 8c 24 08 01 00 00      	leaq	264(%rsp), %rcx
   24140: 4c 89 e2                     	movq	%r12, %rdx
   24143: 48 8d 35 42 61 01 00         	leaq	90434(%rip), %rsi       # 0x3a28c <CSWTCH.126+0x98c>
   2414a: e8 f1 f6 ff ff               	callq	0x23840 <find_elf_sec_by_name>
; 	data = elf_getdata(notes_scn, 0);
   2414f: 48 8b bc 24 00 01 00 00      	movq	256(%rsp), %rdi
; 		base_addr = base_shdr.sh_addr;
   24157: 85 c0                        	testl	%eax, %eax
   24159: b8 00 00 00 00               	movl	$0, %eax
   2415e: 48 0f 44 84 24 70 01 00 00   	cmoveq	368(%rsp), %rax
; 	data = elf_getdata(notes_scn, 0);
   24167: 31 f6                        	xorl	%esi, %esi
; 		base_addr = base_shdr.sh_addr;
   24169: 48 89 84 24 c8 00 00 00      	movq	%rax, 200(%rsp)
; 	data = elf_getdata(notes_scn, 0);
   24171: e8 ca 17 fe ff               	callq	0x5940 <.plt.sec+0x2d0>
; 	size_t off, name_off, desc_off, seg_cnt = 0, vma_seg_cnt = 0, target_cnt = 0;
   24176: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
; 	data = elf_getdata(notes_scn, 0);
   2417e: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	while ((off = gelf_getnote(data, off, &nhdr, &name_off, &desc_off)) > 0) {
   24183: 48 8d 84 24 e8 00 00 00      	leaq	232(%rsp), %rax
   2418b: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   24193: 48 8d 84 24 e0 00 00 00      	leaq	224(%rsp), %rax
; 	struct usdt_target *targets = NULL, *target;
   2419b: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
; 	off = 0;
   241a4: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
   241ad: 48 89 84 24 90 00 00 00      	movq	%rax, 144(%rsp)
   241b5: 4c 89 bc 24 a8 00 00 00      	movq	%r15, 168(%rsp)
   241bd: 0f 1f 00                     	nopl	(%rax)
; 	while ((off = gelf_getnote(data, off, &nhdr, &name_off, &desc_off)) > 0) {
   241c0: 4c 8b 84 24 98 00 00 00      	movq	152(%rsp), %r8
   241c8: 48 8b 8c 24 90 00 00 00      	movq	144(%rsp), %rcx
   241d0: 48 8b 94 24 88 00 00 00      	movq	136(%rsp), %rdx
   241d8: 48 8b 74 24 18               	movq	24(%rsp), %rsi
   241dd: 48 8b 7c 24 28               	movq	40(%rsp), %rdi
   241e2: e8 09 16 fe ff               	callq	0x57f0 <.plt.sec+0x180>
   241e7: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   241ec: 48 85 c0                     	testq	%rax, %rax
   241ef: 0f 84 74 0d 00 00            	je	0x24f69 <usdt_manager_attach_usdt+0x1179>
; 		err = parse_usdt_note(elf, path, &nhdr, data->d_buf, name_off, desc_off, &note);
   241f5: 48 8b 44 24 28               	movq	40(%rsp), %rax
; 	if (strncmp(data + name_off, USDT_NOTE_NAME, nhdr->n_namesz) != 0)
   241fa: 8b 94 24 20 01 00 00         	movl	288(%rsp), %edx
   24201: 48 8d 35 7c 60 01 00         	leaq	90236(%rip), %rsi       # 0x3a284 <CSWTCH.126+0x984>
   24208: 48 8b bc 24 e0 00 00 00      	movq	224(%rsp), %rdi
; 		err = parse_usdt_note(elf, path, &nhdr, data->d_buf, name_off, desc_off, &note);
   24210: 48 8b ac 24 e8 00 00 00      	movq	232(%rsp), %rbp
   24218: 48 8b 18                     	movq	(%rax), %rbx
; 	if (strncmp(data + name_off, USDT_NOTE_NAME, nhdr->n_namesz) != 0)
   2421b: b8 08 00 00 00               	movl	$8, %eax
   24220: 48 39 c2                     	cmpq	%rax, %rdx
   24223: 48 0f 47 d0                  	cmovaq	%rax, %rdx
   24227: 48 01 df                     	addq	%rbx, %rdi
   2422a: e8 f1 14 fe ff               	callq	0x5720 <.plt.sec+0xb0>
   2422f: 85 c0                        	testl	%eax, %eax
   24231: 0f 85 f1 09 00 00            	jne	0x24c28 <usdt_manager_attach_usdt+0xe38>
; 	if (nhdr->n_type != USDT_NOTE_TYPE)
   24237: 83 bc 24 28 01 00 00 03      	cmpl	$3, 296(%rsp)
   2423f: 0f 85 e3 09 00 00            	jne	0x24c28 <usdt_manager_attach_usdt+0xe38>
; 	len = nhdr->n_descsz;
   24245: 8b 94 24 24 01 00 00         	movl	292(%rsp), %edx
; 	data = data + desc_off;
   2424c: 48 01 eb                     	addq	%rbp, %rbx
; 	if (len < sizeof(addrs) + 3)
   2424f: 48 83 fa 1a                  	cmpq	$26, %rdx
   24253: 0f 86 cf 09 00 00            	jbe	0x24c28 <usdt_manager_attach_usdt+0xe38>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   24259: f3 0f 6f 0b                  	movdqu	(%rbx), %xmm1
   2425d: 48 8b 43 10                  	movq	16(%rbx), %rax
; 	provider = data + sizeof(addrs);
   24261: 48 8d 7b 18                  	leaq	24(%rbx), %rdi
; 	name = (const char *)memchr(provider, '\0', data + len - provider);
   24265: 31 f6                        	xorl	%esi, %esi
   24267: 48 01 d3                     	addq	%rdx, %rbx
   2426a: 48 83 ea 18                  	subq	$24, %rdx
; 	provider = data + sizeof(addrs);
   2426e: 48 89 7c 24 30               	movq	%rdi, 48(%rsp)
;   return __builtin___memcpy_chk (__dest, __src, __len,
   24273: 48 89 84 24 f0 01 00 00      	movq	%rax, 496(%rsp)
   2427b: 0f 29 8c 24 e0 01 00 00      	movaps	%xmm1, 480(%rsp)
; 	name = (const char *)memchr(provider, '\0', data + len - provider);
   24283: e8 c8 16 fe ff               	callq	0x5950 <.plt.sec+0x2e0>
; 	if (!name) /* non-zero-terminated provider */
   24288: 48 85 c0                     	testq	%rax, %rax
   2428b: 0f 84 97 09 00 00            	je	0x24c28 <usdt_manager_attach_usdt+0xe38>
; 	name++;
   24291: 48 8d 78 01                  	leaq	1(%rax), %rdi
   24295: 48 89 7c 24 40               	movq	%rdi, 64(%rsp)
; 	if (name >= data + len || *name == '\0') /* missing or empty name */
   2429a: 48 39 fb                     	cmpq	%rdi, %rbx
   2429d: 0f 86 85 09 00 00            	jbe	0x24c28 <usdt_manager_attach_usdt+0xe38>
   242a3: 80 78 01 00                  	cmpb	$0, 1(%rax)
   242a7: 0f 84 7b 09 00 00            	je	0x24c28 <usdt_manager_attach_usdt+0xe38>
; 	args = memchr(name, '\0', data + len - name);
   242ad: 48 89 da                     	movq	%rbx, %rdx
   242b0: 31 f6                        	xorl	%esi, %esi
   242b2: 48 29 fa                     	subq	%rdi, %rdx
   242b5: e8 96 16 fe ff               	callq	0x5950 <.plt.sec+0x2e0>
; 	if (!args) /* non-zero-terminated name */
   242ba: 48 85 c0                     	testq	%rax, %rax
   242bd: 0f 84 65 09 00 00            	je	0x24c28 <usdt_manager_attach_usdt+0xe38>
; 	++args;
   242c3: 48 8d 48 01                  	leaq	1(%rax), %rcx
   242c7: 48 89 4c 24 10               	movq	%rcx, 16(%rsp)
; 	if (args >= data + len) /* missing arguments spec */
   242cc: 48 39 cb                     	cmpq	%rcx, %rbx
   242cf: 0f 86 53 09 00 00            	jbe	0x24c28 <usdt_manager_attach_usdt+0xe38>
; 	if (*args == '\0' || *args == ':')
   242d5: 0f b6 40 01                  	movzbl	1(%rax), %eax
   242d9: 84 c0                        	testb	%al, %al
   242db: 0f 84 27 04 00 00            	je	0x24708 <usdt_manager_attach_usdt+0x918>
   242e1: 3c 3a                        	cmpb	$58, %al
   242e3: 0f 84 1f 04 00 00            	je	0x24708 <usdt_manager_attach_usdt+0x918>
; 		if (strcmp(note.provider, usdt_provider) != 0 || strcmp(note.name, usdt_name) != 0)
   242e9: 48 8b 74 24 48               	movq	72(%rsp), %rsi
   242ee: 48 8b 7c 24 30               	movq	48(%rsp), %rdi
; 	note->loc_addr = addrs[0];
   242f3: 48 8b ac 24 e0 01 00 00      	movq	480(%rsp), %rbp
; 	note->base_addr = addrs[1];
   242fb: 4c 8b a4 24 e8 01 00 00      	movq	488(%rsp), %r12
; 	note->sema_addr = addrs[2];
   24303: 48 8b 9c 24 f0 01 00 00      	movq	496(%rsp), %rbx
; 		if (strcmp(note.provider, usdt_provider) != 0 || strcmp(note.name, usdt_name) != 0)
   2430b: e8 a0 16 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   24310: 85 c0                        	testl	%eax, %eax
   24312: 0f 85 a8 fe ff ff            	jne	0x241c0 <usdt_manager_attach_usdt+0x3d0>
   24318: 48 8b 74 24 68               	movq	104(%rsp), %rsi
   2431d: 48 8b 7c 24 40               	movq	64(%rsp), %rdi
   24322: e8 89 16 fe ff               	callq	0x59b0 <.plt.sec+0x340>
   24327: 85 c0                        	testl	%eax, %eax
   24329: 0f 85 91 fe ff ff            	jne	0x241c0 <usdt_manager_attach_usdt+0x3d0>
; 			usdt_abs_ip += base_addr - note.base_addr;
   2432f: 48 8b 84 24 c8 00 00 00      	movq	200(%rsp), %rax
; 	for (i = 0, seg = segs; i < seg_cnt; i++, seg++) {
   24337: 48 8b 7c 24 78               	movq	120(%rsp), %rdi
; 			usdt_abs_ip += base_addr - note.base_addr;
   2433c: 49 89 c5                     	movq	%rax, %r13
   2433f: 4d 29 e5                     	subq	%r12, %r13
   24342: 49 01 ed                     	addq	%rbp, %r13
   24345: 48 85 c0                     	testq	%rax, %rax
   24348: 4c 0f 44 ed                  	cmoveq	%rbp, %r13
; 	for (i = 0, seg = segs; i < seg_cnt; i++, seg++) {
   2434c: 48 85 ff                     	testq	%rdi, %rdi
   2434f: 74 31                        	je	0x24382 <usdt_manager_attach_usdt+0x592>
   24351: 48 8b 44 24 50               	movq	80(%rsp), %rax
   24356: 31 d2                        	xorl	%edx, %edx
   24358: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		if (seg->start <= virtaddr && virtaddr < seg->end)
   24360: 48 8b 08                     	movq	(%rax), %rcx
   24363: 4c 39 e9                     	cmpq	%r13, %rcx
   24366: 7f 0d                        	jg	0x24375 <usdt_manager_attach_usdt+0x585>
   24368: 48 8b 70 08                  	movq	8(%rax), %rsi
   2436c: 49 39 f5                     	cmpq	%rsi, %r13
   2436f: 0f 8c 03 04 00 00            	jl	0x24778 <usdt_manager_attach_usdt+0x988>
; 	for (i = 0, seg = segs; i < seg_cnt; i++, seg++) {
   24375: 48 83 c2 01                  	addq	$1, %rdx
   24379: 48 83 c0 20                  	addq	$32, %rax
   2437d: 48 39 fa                     	cmpq	%rdi, %rdx
   24380: 75 de                        	jne	0x24360 <usdt_manager_attach_usdt+0x570>
; 			pr_warn("usdt: failed to find ELF program segment for '%s:%s' in '%s' at IP 0x%lx\n",
   24382: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   24387: 48 8b 4c 24 68               	movq	104(%rsp), %rcx
   2438c: 4d 89 e9                     	movq	%r13, %r9
   2438f: 31 ff                        	xorl	%edi, %edi
   24391: 48 8b 54 24 48               	movq	72(%rsp), %rdx
   24396: 48 8d 35 03 6b 01 00         	leaq	92931(%rip), %rsi       # 0x3aea0 <CSWTCH.126+0x15a0>
   2439d: 31 c0                        	xorl	%eax, %eax
   2439f: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   243a7: e8 24 3d fe ff               	callq	0x80d0 <libbpf_print>
; 			err = -ESRCH;
   243ac: 41 b8 fd ff ff ff            	movl	$4294967293, %r8d       # imm = 0xFFFFFFFD
; 	*out_target_cnt = 0;
   243b2: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
; 	*out_targets = NULL;
   243ba: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	free(segs);
   243c3: 48 8b 7c 24 50               	movq	80(%rsp), %rdi
   243c8: 44 89 44 24 10               	movl	%r8d, 16(%rsp)
   243cd: e8 ee 12 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(vma_segs);
   243d2: 48 8b bc 24 f8 00 00 00      	movq	248(%rsp), %rdi
   243da: e8 e1 12 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (err < 0)
   243df: 44 8b 44 24 10               	movl	16(%rsp), %r8d
   243e4: 45 85 c0                     	testl	%r8d, %r8d
   243e7: 0f 88 6a 0a 00 00            	js	0x24e57 <usdt_manager_attach_usdt+0x1067>
; 	if (err <= 0) {
   243ed: 0f 84 4f 0d 00 00            	je	0x25142 <usdt_manager_attach_usdt+0x1352>
; 	specs_hash = hashmap__new(specs_hash_fn, specs_equal_fn, NULL);
   243f3: 31 d2                        	xorl	%edx, %edx
   243f5: 48 8d 35 24 f4 ff ff         	leaq	-3036(%rip), %rsi       # 0x23820 <specs_equal_fn>
   243fc: 48 8d 3d bd f2 ff ff         	leaq	-3395(%rip), %rdi       # 0x236c0 <specs_hash_fn>
   24403: e8 c8 9f ff ff               	callq	0x1e3d0 <hashmap__new>
   24408: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(specs_hash)) {
   2440b: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   24411: 0f 87 e9 09 00 00            	ja	0x24e00 <usdt_manager_attach_usdt+0x1010>
; 	link = calloc(1, sizeof(*link));
   24417: be 48 00 00 00               	movl	$72, %esi
   2441c: bf 01 00 00 00               	movl	$1, %edi
   24421: e8 6a 15 fe ff               	callq	0x5990 <.plt.sec+0x320>
   24426: 48 89 c5                     	movq	%rax, %rbp
; 	if (!link) {
   24429: 48 85 c0                     	testq	%rax, %rax
   2442c: 0f 84 b7 0e 00 00            	je	0x252e9 <usdt_manager_attach_usdt+0x14f9>
; 	link->usdt_man = man;
   24432: 4c 89 78 20                  	movq	%r15, 32(%rax)
; 	link->link.detach = &bpf_link_usdt_detach;
   24436: 48 8d 05 e3 f2 ff ff         	leaq	-3357(%rip), %rax       # 0x23720 <bpf_link_usdt_detach>
; 	link->uprobes = calloc(target_cnt, sizeof(*link->uprobes));
   2443d: 48 8b 3c 24                  	movq	(%rsp), %rdi
   24441: be 10 00 00 00               	movl	$16, %esi
; 	link->link.detach = &bpf_link_usdt_detach;
   24446: 48 89 45 00                  	movq	%rax, (%rbp)
; 	link->link.dealloc = &bpf_link_usdt_dealloc;
   2444a: 48 8d 05 9f f2 ff ff         	leaq	-3425(%rip), %rax       # 0x236f0 <bpf_link_usdt_dealloc>
   24451: 48 89 45 08                  	movq	%rax, 8(%rbp)
; 	link->uprobes = calloc(target_cnt, sizeof(*link->uprobes));
   24455: e8 36 15 fe ff               	callq	0x5990 <.plt.sec+0x320>
   2445a: 48 89 45 40                  	movq	%rax, 64(%rbp)
; 	if (!link->uprobes) {
   2445e: 48 85 c0                     	testq	%rax, %rax
   24461: 0f 84 d4 07 00 00            	je	0x24c3b <usdt_manager_attach_usdt+0xe4b>
; 	for (i = 0; i < target_cnt; i++) {
   24467: 31 db                        	xorl	%ebx, %ebx
; 		if (is_new && bpf_map_update_elem(spec_map_fd, &spec_id, &target->spec, BPF_ANY)) {
   24469: 48 8d 84 24 60 01 00 00      	leaq	352(%rsp), %rax
; 	for (i = 0; i < target_cnt; i++) {
   24471: 48 83 3c 24 00               	cmpq	$0, (%rsp)
   24476: 4c 8b 6c 24 28               	movq	40(%rsp), %r13
; 		if (is_new && bpf_map_update_elem(spec_map_fd, &spec_id, &target->spec, BPF_ANY)) {
   2447b: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	for (i = 0; i < target_cnt; i++) {
   24480: 0f 85 48 01 00 00            	jne	0x245ce <usdt_manager_attach_usdt+0x7de>
   24486: e9 33 0a 00 00               	jmp	0x24ebe <usdt_manager_attach_usdt+0x10ce>
   2448b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	tmp = libbpf_reallocarray(link->spec_ids, link->spec_cnt + 1, sizeof(*link->spec_ids));
   24490: 48 8b 45 28                  	movq	40(%rbp), %rax
   24494: 48 8b 7d 30                  	movq	48(%rbp), %rdi
   24498: 48 83 c0 01                  	addq	$1, %rax
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   2449c: 48 8d 34 85 00 00 00 00      	leaq	(,%rax,4), %rsi
   244a4: 48 c1 e8 3e                  	shrq	$62, %rax
   244a8: 0f 85 8d 07 00 00            	jne	0x24c3b <usdt_manager_attach_usdt+0xe4b>
; 	return realloc(ptr, total);
   244ae: e8 6d 16 fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 	tmp = libbpf_reallocarray(link->spec_ids, link->spec_cnt + 1, sizeof(*link->spec_ids));
   244b3: 48 89 84 24 a0 01 00 00      	movq	%rax, 416(%rsp)
; 	if (!tmp)
   244bb: 48 85 c0                     	testq	%rax, %rax
   244be: 0f 84 77 07 00 00            	je	0x24c3b <usdt_manager_attach_usdt+0xe4b>
; 	link->spec_ids = tmp;
   244c4: 48 89 45 30                  	movq	%rax, 48(%rbp)
; 	if (man->free_spec_cnt) {
   244c8: 49 8b 47 18                  	movq	24(%r15), %rax
   244cc: 48 85 c0                     	testq	%rax, %rax
   244cf: 0f 84 4b 02 00 00            	je	0x24720 <usdt_manager_attach_usdt+0x930>
; 		*spec_id = man->free_spec_ids[man->free_spec_cnt - 1];
   244d5: 49 8b 57 10                  	movq	16(%r15), %rdx
; 	return hashmap__insert(map, key, value, HASHMAP_ADD, NULL, NULL);
   244d9: 49 8b b5 e8 00 00 00         	movq	232(%r13), %rsi
   244e0: 45 31 c9                     	xorl	%r9d, %r9d
   244e3: 31 c9                        	xorl	%ecx, %ecx
   244e5: 45 31 c0                     	xorl	%r8d, %r8d
   244e8: 4c 89 e7                     	movq	%r12, %rdi
; 		*spec_id = man->free_spec_ids[man->free_spec_cnt - 1];
   244eb: 48 63 54 82 fc               	movslq	-4(%rdx,%rax,4), %rdx
   244f0: 89 94 24 60 01 00 00         	movl	%edx, 352(%rsp)
; 	return hashmap__insert(map, key, value, HASHMAP_ADD, NULL, NULL);
   244f7: e8 14 a0 ff ff               	callq	0x1e510 <hashmap__insert>
   244fc: 41 89 c6                     	movl	%eax, %r14d
; 		if (err)
   244ff: 85 c0                        	testl	%eax, %eax
   24501: 0f 85 49 0d 00 00            	jne	0x25250 <usdt_manager_attach_usdt+0x1460>
; 		man->free_spec_cnt--;
   24507: 49 83 6f 18 01               	subq	$1, 24(%r15)
; 	link->spec_ids[link->spec_cnt] = *spec_id;
   2450c: 48 8b 45 28                  	movq	40(%rbp), %rax
   24510: 48 8b 55 30                  	movq	48(%rbp), %rdx
   24514: 8b 8c 24 60 01 00 00         	movl	352(%rsp), %ecx
; 		if (is_new && bpf_map_update_elem(spec_map_fd, &spec_id, &target->spec, BPF_ANY)) {
   2451b: 48 8b 74 24 18               	movq	24(%rsp), %rsi
   24520: 8b bc 24 b4 00 00 00         	movl	180(%rsp), %edi
; 	link->spec_ids[link->spec_cnt] = *spec_id;
   24527: 89 0c 82                     	movl	%ecx, (%rdx,%rax,4)
; 	link->spec_cnt++;
   2452a: 48 83 c0 01                  	addq	$1, %rax
; 		if (is_new && bpf_map_update_elem(spec_map_fd, &spec_id, &target->spec, BPF_ANY)) {
   2452e: 31 c9                        	xorl	%ecx, %ecx
   24530: 49 8d 55 18                  	leaq	24(%r13), %rdx
; 	link->spec_cnt++;
   24534: 48 89 45 28                  	movq	%rax, 40(%rbp)
; 		if (is_new && bpf_map_update_elem(spec_map_fd, &spec_id, &target->spec, BPF_ANY)) {
   24538: e8 b3 1e 00 00               	callq	0x263f0 <bpf_map_update_elem>
   2453d: 85 c0                        	testl	%eax, %eax
   2453f: 0f 85 0e 0b 00 00            	jne	0x25053 <usdt_manager_attach_usdt+0x1263>
; 		if (!man->has_bpf_cookie &&
   24545: 41 80 7f 28 00               	cmpb	$0, 40(%r15)
   2454a: 0f 84 b8 00 00 00            	je	0x24608 <usdt_manager_attach_usdt+0x818>
; 		opts.ref_ctr_offset = target->sema_off;
   24550: 49 8b 45 10                  	movq	16(%r13), %rax
   24554: 48 89 84 24 38 01 00 00      	movq	%rax, 312(%rsp)
; 		opts.bpf_cookie = man->has_bpf_cookie ? spec_id : 0;
   2455c: 48 63 84 24 60 01 00 00      	movslq	352(%rsp), %rax
; 		uprobe_link = bpf_program__attach_uprobe_opts(prog, pid, path,
   24564: 49 8b 4d 08                  	movq	8(%r13), %rcx
   24568: 8b 74 24 3c                  	movl	60(%rsp), %esi
   2456c: 4c 8d 84 24 30 01 00 00      	leaq	304(%rsp), %r8
; 		opts.bpf_cookie = man->has_bpf_cookie ? spec_id : 0;
   24574: 48 89 84 24 40 01 00 00      	movq	%rax, 320(%rsp)
; 		uprobe_link = bpf_program__attach_uprobe_opts(prog, pid, path,
   2457c: 48 8b 7c 24 58               	movq	88(%rsp), %rdi
   24581: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   24586: e8 45 25 ff ff               	callq	0x16ad0 <bpf_program__attach_uprobe_opts>
; 		err = libbpf_get_error(uprobe_link);
   2458b: 48 89 c7                     	movq	%rax, %rdi
; 		uprobe_link = bpf_program__attach_uprobe_opts(prog, pid, path,
   2458e: 49 89 c6                     	movq	%rax, %r14
; 		err = libbpf_get_error(uprobe_link);
   24591: e8 5a 0d ff ff               	callq	0x152f0 <libbpf_get_error>
; 		if (err) {
   24596: 85 c0                        	testl	%eax, %eax
   24598: 0f 85 50 09 00 00            	jne	0x24eee <usdt_manager_attach_usdt+0x10fe>
; 		link->uprobes[i].abs_ip = target->abs_ip;
   2459e: 49 8b 55 00                  	movq	(%r13), %rdx
; 		link->uprobes[i].link = uprobe_link;
   245a2: 48 89 d8                     	movq	%rbx, %rax
; 	for (i = 0; i < target_cnt; i++) {
   245a5: 49 81 c5 f0 00 00 00         	addq	$240, %r13
   245ac: 48 83 c3 01                  	addq	$1, %rbx
; 		link->uprobes[i].link = uprobe_link;
   245b0: 48 c1 e0 04                  	shlq	$4, %rax
   245b4: 48 03 45 40                  	addq	64(%rbp), %rax
   245b8: 4c 89 70 08                  	movq	%r14, 8(%rax)
; 		link->uprobes[i].abs_ip = target->abs_ip;
   245bc: 48 89 10                     	movq	%rdx, (%rax)
; 		link->uprobe_cnt++;
   245bf: 48 83 45 38 01               	addq	$1, 56(%rbp)
; 	for (i = 0; i < target_cnt; i++) {
   245c4: 48 3b 1c 24                  	cmpq	(%rsp), %rbx
   245c8: 0f 84 f0 08 00 00            	je	0x24ebe <usdt_manager_attach_usdt+0x10ce>
; 	if (hashmap__find(specs_hash, target->spec_str, &tmp)) {
   245ce: 49 8b b5 e8 00 00 00         	movq	232(%r13), %rsi
   245d5: 48 8b 54 24 60               	movq	96(%rsp), %rdx
   245da: 4c 89 e7                     	movq	%r12, %rdi
   245dd: 89 5c 24 10                  	movl	%ebx, 16(%rsp)
   245e1: e8 5a a2 ff ff               	callq	0x1e840 <hashmap__find>
   245e6: 84 c0                        	testb	%al, %al
   245e8: 0f 84 a2 fe ff ff            	je	0x24490 <usdt_manager_attach_usdt+0x6a0>
; 		*spec_id = (long)tmp;
   245ee: 48 8b 84 24 a0 01 00 00      	movq	416(%rsp), %rax
; 		if (!man->has_bpf_cookie &&
   245f6: 41 80 7f 28 00               	cmpb	$0, 40(%r15)
; 		*spec_id = (long)tmp;
   245fb: 89 84 24 60 01 00 00         	movl	%eax, 352(%rsp)
; 		if (!man->has_bpf_cookie &&
   24602: 0f 85 48 ff ff ff            	jne	0x24550 <usdt_manager_attach_usdt+0x760>
; 		    bpf_map_update_elem(ip_map_fd, &target->abs_ip, &spec_id, BPF_NOEXIST)) {
   24608: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   2460d: 8b bc 24 bc 00 00 00         	movl	188(%rsp), %edi
   24614: b9 01 00 00 00               	movl	$1, %ecx
   24619: 4c 89 ee                     	movq	%r13, %rsi
   2461c: e8 cf 1d 00 00               	callq	0x263f0 <bpf_map_update_elem>
; 		if (!man->has_bpf_cookie &&
   24621: 85 c0                        	testl	%eax, %eax
   24623: 0f 85 d3 09 00 00            	jne	0x24ffc <usdt_manager_attach_usdt+0x120c>
; 		opts.ref_ctr_offset = target->sema_off;
   24629: 49 8b 45 10                  	movq	16(%r13), %rax
; 		opts.bpf_cookie = man->has_bpf_cookie ? spec_id : 0;
   2462d: 41 80 7f 28 00               	cmpb	$0, 40(%r15)
; 		opts.ref_ctr_offset = target->sema_off;
   24632: 48 89 84 24 38 01 00 00      	movq	%rax, 312(%rsp)
; 		opts.bpf_cookie = man->has_bpf_cookie ? spec_id : 0;
   2463a: 0f 85 1c ff ff ff            	jne	0x2455c <usdt_manager_attach_usdt+0x76c>
   24640: 31 c0                        	xorl	%eax, %eax
   24642: e9 1d ff ff ff               	jmp	0x24564 <usdt_manager_attach_usdt+0x774>
   24647: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		pr_warn("usdt: unsupported ELF class for '%s'\n", path);
   24650: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   24655: 48 8d 35 6c 60 01 00         	leaq	90220(%rip), %rsi       # 0x3a6c8 <CSWTCH.126+0xdc8>
; 			pr_warn("usdt: attaching to 32-bit ELF binary '%s' is not supported\n", path);
   2465c: 31 ff                        	xorl	%edi, %edi
   2465e: 31 c0                        	xorl	%eax, %eax
   24660: e8 6b 3a fe ff               	callq	0x80d0 <libbpf_print>
; 		err = -errno;
   24665: e8 86 10 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   2466a: 45 31 e4                     	xorl	%r12d, %r12d
   2466d: c7 84 24 b0 00 00 00 09 00 00 00     	movl	$9, 176(%rsp)
   24678: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
   24681: 48 89 c3                     	movq	%rax, %rbx
; 	free(targets);
   24684: 48 8b 7c 24 28               	movq	40(%rsp), %rdi
   24689: e8 32 10 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	hashmap__free(specs_hash);
   2468e: 4c 89 e7                     	movq	%r12, %rdi
   24691: e8 1a 9e ff ff               	callq	0x1e4b0 <hashmap__free>
; 		elf_end(elf);
   24696: 48 8b 7c 24 70               	movq	112(%rsp), %rdi
   2469b: e8 90 13 fe ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   246a0: 8b bc 24 b8 00 00 00         	movl	184(%rsp), %edi
   246a7: e8 54 12 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	errno = -err;
   246ac: 8b 84 24 b0 00 00 00         	movl	176(%rsp), %eax
   246b3: 89 03                        	movl	%eax, (%rbx)
; 	return libbpf_err_ptr(err);
   246b5: 31 c0                        	xorl	%eax, %eax
; }
   246b7: 48 8b 94 24 48 02 00 00      	movq	584(%rsp), %rdx
   246bf: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   246c8: 0f 85 33 0c 00 00            	jne	0x25301 <usdt_manager_attach_usdt+0x1511>
   246ce: 48 81 c4 58 02 00 00         	addq	$600, %rsp              # imm = 0x258
   246d5: 5b                           	popq	%rbx
   246d6: 5d                           	popq	%rbp
   246d7: 41 5c                        	popq	%r12
   246d9: 41 5d                        	popq	%r13
   246db: 41 5e                        	popq	%r14
   246dd: 41 5f                        	popq	%r15
   246df: c3                           	retq
; 		pid = -1;
   246e0: c7 44 24 3c ff ff ff ff      	movl	$4294967295, 60(%rsp)   # imm = 0xFFFFFFFF
   246e8: e9 50 f8 ff ff               	jmp	0x23f3d <usdt_manager_attach_usdt+0x14d>
   246ed: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("usdt: attaching to 32-bit ELF binary '%s' is not supported\n", path);
   246f0: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   246f5: 48 8d 35 84 5f 01 00         	leaq	89988(%rip), %rsi       # 0x3a680 <CSWTCH.126+0xd80>
   246fc: e9 5b ff ff ff               	jmp	0x2465c <usdt_manager_attach_usdt+0x86c>
   24701: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		note->args = "";
   24708: 48 8d 05 4e d7 00 00         	leaq	55118(%rip), %rax       # 0x31e5d <_IO_stdin_used+0x1e5d>
   2470f: 48 89 44 24 10               	movq	%rax, 16(%rsp)
   24714: e9 d0 fb ff ff               	jmp	0x242e9 <usdt_manager_attach_usdt+0x4f9>
   24719: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (man->next_free_spec_id >= bpf_map__max_entries(man->specs_map))
   24720: 49 8b 3f                     	movq	(%r15), %rdi
   24723: 4d 8b 77 20                  	movq	32(%r15), %r14
   24727: e8 44 7c fe ff               	callq	0xc370 <bpf_map__max_entries>
   2472c: 89 c0                        	movl	%eax, %eax
   2472e: 49 39 c6                     	cmpq	%rax, %r14
   24731: 0f 83 63 09 00 00            	jae	0x2509a <usdt_manager_attach_usdt+0x12aa>
; 		*spec_id = man->next_free_spec_id;
   24737: 49 8b 57 20                  	movq	32(%r15), %rdx
; 	return hashmap__insert(map, key, value, HASHMAP_ADD, NULL, NULL);
   2473b: 49 8b b5 e8 00 00 00         	movq	232(%r13), %rsi
   24742: 45 31 c9                     	xorl	%r9d, %r9d
   24745: 31 c9                        	xorl	%ecx, %ecx
   24747: 45 31 c0                     	xorl	%r8d, %r8d
   2474a: 4c 89 e7                     	movq	%r12, %rdi
; 		*spec_id = man->next_free_spec_id;
   2474d: 89 94 24 60 01 00 00         	movl	%edx, 352(%rsp)
; 		err = hashmap__add(specs_hash, target->spec_str, (void *)(long)*spec_id);
   24754: 48 63 d2                     	movslq	%edx, %rdx
; 	return hashmap__insert(map, key, value, HASHMAP_ADD, NULL, NULL);
   24757: e8 b4 9d ff ff               	callq	0x1e510 <hashmap__insert>
   2475c: 41 89 c6                     	movl	%eax, %r14d
; 		if (err)
   2475f: 85 c0                        	testl	%eax, %eax
   24761: 0f 85 e9 0a 00 00            	jne	0x25250 <usdt_manager_attach_usdt+0x1460>
; 		man->next_free_spec_id++;
   24767: 49 83 47 20 01               	addq	$1, 32(%r15)
   2476c: e9 9b fd ff ff               	jmp	0x2450c <usdt_manager_attach_usdt+0x71c>
   24771: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		if (!seg->is_exec) {
   24778: 80 78 18 00                  	cmpb	$0, 24(%rax)
   2477c: 0f 84 30 09 00 00            	je	0x250b2 <usdt_manager_attach_usdt+0x12c2>
; 		usdt_rel_ip = usdt_abs_ip - seg->start + seg->offset;
   24782: 48 8b 40 10                  	movq	16(%rax), %rax
   24786: 4c 89 ea                     	movq	%r13, %rdx
   24789: 48 29 ca                     	subq	%rcx, %rdx
   2478c: 4c 8d 34 02                  	leaq	(%rdx,%rax), %r14
; 		if (ehdr.e_type == ET_DYN && !man->has_bpf_cookie) {
   24790: 0f b7 94 24 10 02 00 00      	movzwl	528(%rsp), %edx
   24798: 66 83 fa 03                  	cmpw	$3, %dx
   2479c: 0f 84 9e 03 00 00            	je	0x24b40 <usdt_manager_attach_usdt+0xd50>
; 		pr_debug("usdt: probe for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved abs_ip 0x%lx rel_ip 0x%lx) args '%s' in segment [0x%lx, 0x%lx) at offset 0x%lx\n",
   247a2: 66 83 fa 02                  	cmpw	$2, %dx
   247a6: 4c 8d 05 c7 5a 01 00         	leaq	88775(%rip), %r8        # 0x3a274 <CSWTCH.126+0x974>
   247ad: 48 8d 15 c5 5a 01 00         	leaq	88773(%rip), %rdx       # 0x3a279 <CSWTCH.126+0x979>
   247b4: 4c 0f 45 c2                  	cmovneq	%rdx, %r8
   247b8: 50                           	pushq	%rax
   247b9: bf 02 00 00 00               	movl	$2, %edi
   247be: 31 c0                        	xorl	%eax, %eax
   247c0: 56                           	pushq	%rsi
   247c1: 48 8d 35 48 62 01 00         	leaq	90696(%rip), %rsi       # 0x3aa10 <CSWTCH.126+0x1110>
   247c8: 51                           	pushq	%rcx
   247c9: ff 74 24 28                  	pushq	40(%rsp)
   247cd: 41 56                        	pushq	%r14
   247cf: 41 55                        	pushq	%r13
   247d1: 41 54                        	pushq	%r12
   247d3: 55                           	pushq	%rbp
   247d4: 4c 8b 4c 24 48               	movq	72(%rsp), %r9
   247d9: 48 8b 8c 24 a8 00 00 00      	movq	168(%rsp), %rcx
   247e1: 48 8b 94 24 88 00 00 00      	movq	136(%rsp), %rdx
   247e9: e8 e2 38 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (note.sema_addr) {
   247ee: 48 83 c4 40                  	addq	$64, %rsp
   247f2: 48 85 db                     	testq	%rbx, %rbx
   247f5: 0f 85 65 04 00 00            	jne	0x24c60 <usdt_manager_attach_usdt+0xe70>
; 		tmp = libbpf_reallocarray(targets, target_cnt + 1, sizeof(*targets));
   247fb: 48 8b 04 24                  	movq	(%rsp), %rax
   247ff: 48 8d 48 01                  	leaq	1(%rax), %rcx
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   24803: b8 f0 00 00 00               	movl	$240, %eax
   24808: 48 f7 e1                     	mulq	%rcx
; 		tmp = libbpf_reallocarray(targets, target_cnt + 1, sizeof(*targets));
   2480b: 48 89 8c 24 c0 00 00 00      	movq	%rcx, 192(%rsp)
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   24813: 48 89 c6                     	movq	%rax, %rsi
   24816: 0f 80 4c 0a 00 00            	jo	0x25268 <usdt_manager_attach_usdt+0x1478>
; 	return realloc(ptr, total);
   2481c: 48 8b 7c 24 20               	movq	32(%rsp), %rdi
   24821: e8 fa 12 fe ff               	callq	0x5b20 <.plt.sec+0x4b0>
   24826: 48 89 84 24 a0 00 00 00      	movq	%rax, 160(%rsp)
; 		if (!tmp) {
   2482e: 48 85 c0                     	testq	%rax, %rax
   24831: 0f 84 31 0a 00 00            	je	0x25268 <usdt_manager_attach_usdt+0x1478>
; 		target = &targets[target_cnt];
   24837: 48 8b 04 24                  	movq	(%rsp), %rax
;   return __builtin___memset_chk (__dest, __ch, __len,
   2483b: b9 1b 00 00 00               	movl	$27, %ecx
; 		target = &targets[target_cnt];
   24840: 49 89 c2                     	movq	%rax, %r10
   24843: 49 c1 e2 04                  	shlq	$4, %r10
   24847: 49 29 c2                     	subq	%rax, %r10
   2484a: 48 8b 84 24 a0 00 00 00      	movq	160(%rsp), %rax
   24852: 49 c1 e2 04                  	shlq	$4, %r10
   24856: 4e 8d 3c 10                  	leaq	(%rax,%r10), %r15
;   return __builtin___memset_chk (__dest, __ch, __len,
   2485a: 31 c0                        	xorl	%eax, %eax
   2485c: 49 8d 57 18                  	leaq	24(%r15), %rdx
   24860: 48 89 d7                     	movq	%rdx, %rdi
   24863: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 		target->sema_off = usdt_sema_off;
   24866: 49 89 5f 10                  	movq	%rbx, 16(%r15)
; 		target->spec_str = note.args;
   2486a: 48 8b 44 24 10               	movq	16(%rsp), %rax
; 	spec->usdt_cookie = usdt_cookie;
   2486f: 48 8b 9c 24 90 02 00 00      	movq	656(%rsp), %rbx
; 		target->abs_ip = usdt_abs_ip;
   24877: 4d 89 2f                     	movq	%r13, (%r15)
; 		target->rel_ip = usdt_rel_ip;
   2487a: 4d 89 77 08                  	movq	%r14, 8(%r15)
; 		target->spec_str = note.args;
   2487e: 49 89 87 e8 00 00 00         	movq	%rax, 232(%r15)
; 	spec->usdt_cookie = usdt_cookie;
   24885: 49 89 9f d8 00 00 00         	movq	%rbx, 216(%r15)
; 	while (s[0]) {
   2488c: 80 38 00                     	cmpb	$0, (%rax)
   2488f: 0f 84 8b 02 00 00            	je	0x24b20 <usdt_manager_attach_usdt+0xd30>
   24895: 4c 8b 74 24 10               	movq	16(%rsp), %r14
   2489a: 48 8d 84 24 18 01 00 00      	leaq	280(%rsp), %rax
   248a2: 31 db                        	xorl	%ebx, %ebx
   248a4: 4c 8d a4 24 dc 00 00 00      	leaq	220(%rsp), %r12
   248ac: 48 89 04 24                  	movq	%rax, (%rsp)
   248b0: 4c 8d ac 24 10 01 00 00      	leaq	272(%rsp), %r13
   248b8: 48 8d ac 24 d8 00 00 00      	leaq	216(%rsp), %rbp
; 	switch (arg_sz) {
   248c0: 4c 89 f0                     	movq	%r14, %rax
   248c3: 41 89 de                     	movl	%ebx, %r14d
   248c6: 48 89 c3                     	movq	%rax, %rbx
   248c9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		len = parse_usdt_arg(s, spec->arg_cnt, &spec->args[spec->arg_cnt]);
   248d0: 41 0f bf c6                  	movswl	%r14w, %eax
; 	if (sscanf(arg_str, " %d @ %ld ( %%%m[^)] ) %n", &arg_sz, &off, &reg_name, &len) == 3) {
   248d4: 48 8b 0c 24                  	movq	(%rsp), %rcx
   248d8: 4d 89 e1                     	movq	%r12, %r9
   248db: 4d 89 e8                     	movq	%r13, %r8
; 		len = parse_usdt_arg(s, spec->arg_cnt, &spec->args[spec->arg_cnt]);
   248de: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 	if (sscanf(arg_str, " %d @ %ld ( %%%m[^)] ) %n", &arg_sz, &off, &reg_name, &len) == 3) {
   248e2: 48 89 ea                     	movq	%rbp, %rdx
   248e5: 31 c0                        	xorl	%eax, %eax
   248e7: 48 8d 35 ac 59 01 00         	leaq	88492(%rip), %rsi       # 0x3a29a <CSWTCH.126+0x99a>
; 	char *reg_name = NULL;
   248ee: 48 c7 84 24 10 01 00 00 00 00 00 00  	movq	$0, 272(%rsp)
; 	if (sscanf(arg_str, " %d @ %ld ( %%%m[^)] ) %n", &arg_sz, &off, &reg_name, &len) == 3) {
   248fa: 48 89 df                     	movq	%rbx, %rdi
   248fd: e8 9e 11 fe ff               	callq	0x5aa0 <.plt.sec+0x430>
   24902: 83 f8 03                     	cmpl	$3, %eax
   24905: 0f 84 7d 01 00 00            	je	0x24a88 <usdt_manager_attach_usdt+0xc98>
; 	} else if (sscanf(arg_str, " %d @ %%%ms %n", &arg_sz, &reg_name, &len) == 2) {
   2490b: 31 c0                        	xorl	%eax, %eax
   2490d: 4d 89 e0                     	movq	%r12, %r8
   24910: 4c 89 e9                     	movq	%r13, %rcx
   24913: 48 89 ea                     	movq	%rbp, %rdx
   24916: 48 8d 35 97 59 01 00         	leaq	88471(%rip), %rsi       # 0x3a2b4 <CSWTCH.126+0x9b4>
   2491d: 48 89 df                     	movq	%rbx, %rdi
   24920: e8 7b 11 fe ff               	callq	0x5aa0 <.plt.sec+0x430>
   24925: 83 f8 02                     	cmpl	$2, %eax
   24928: 0f 84 c2 01 00 00            	je	0x24af0 <usdt_manager_attach_usdt+0xd00>
; 	} else if (sscanf(arg_str, " %d @ $%ld %n", &arg_sz, &off, &len) == 2) {
   2492e: 48 8b 0c 24                  	movq	(%rsp), %rcx
   24932: 31 c0                        	xorl	%eax, %eax
   24934: 4d 89 e0                     	movq	%r12, %r8
   24937: 48 89 ea                     	movq	%rbp, %rdx
   2493a: 48 8d 35 82 59 01 00         	leaq	88450(%rip), %rsi       # 0x3a2c3 <CSWTCH.126+0x9c3>
   24941: 48 89 df                     	movq	%rbx, %rdi
   24944: e8 57 11 fe ff               	callq	0x5aa0 <.plt.sec+0x430>
   24949: 83 f8 02                     	cmpl	$2, %eax
   2494c: 0f 85 73 06 00 00            	jne	0x24fc5 <usdt_manager_attach_usdt+0x11d5>
; 		arg->arg_type = USDT_ARG_CONST;
   24952: 49 0f bf d6                  	movswq	%r14w, %rdx
; 		arg->val_off = off;
   24956: 48 8b 8c 24 18 01 00 00      	movq	280(%rsp), %rcx
   2495e: 48 89 d0                     	movq	%rdx, %rax
   24961: 48 c1 e0 04                  	shlq	$4, %rax
   24965: 4c 01 f8                     	addq	%r15, %rax
; 		arg->arg_type = USDT_ARG_CONST;
   24968: c7 40 20 00 00 00 00         	movl	$0, 32(%rax)
; 		arg->val_off = off;
   2496f: 48 89 48 18                  	movq	%rcx, 24(%rax)
; 		arg->reg_off = 0;
   24973: 31 c0                        	xorl	%eax, %eax
; 	arg->arg_signed = arg_sz < 0;
   24975: 44 8b 84 24 d8 00 00 00      	movl	216(%rsp), %r8d
   2497d: 48 c1 e2 04                  	shlq	$4, %rdx
   24981: 4c 01 fa                     	addq	%r15, %rdx
; 		arg->reg_off = reg_off;
   24984: 66 89 42 24                  	movw	%ax, 36(%rdx)
; 	arg->arg_signed = arg_sz < 0;
   24988: 44 89 c0                     	movl	%r8d, %eax
   2498b: c1 e8 1f                     	shrl	$31, %eax
   2498e: 88 42 26                     	movb	%al, 38(%rdx)
; 	if (arg_sz < 0)
   24991: 45 85 c0                     	testl	%r8d, %r8d
   24994: 79 0b                        	jns	0x249a1 <usdt_manager_attach_usdt+0xbb1>
; 		arg_sz = -arg_sz;
   24996: 41 f7 d8                     	negl	%r8d
   24999: 44 89 84 24 d8 00 00 00      	movl	%r8d, 216(%rsp)
; 	switch (arg_sz) {
   249a1: 41 83 f8 08                  	cmpl	$8, %r8d
   249a5: 77 0b                        	ja	0x249b2 <usdt_manager_attach_usdt+0xbc2>
   249a7: b8 16 01 00 00               	movl	$278, %eax              # imm = 0x116
   249ac: 4c 0f a3 c0                  	btq	%r8, %rax
   249b0: 72 3e                        	jb	0x249f0 <usdt_manager_attach_usdt+0xc00>
; 		pr_warn("usdt: unsupported arg #%d (spec '%s') size: %d\n",
   249b2: 8b 54 24 20                  	movl	32(%rsp), %edx
   249b6: 31 c0                        	xorl	%eax, %eax
   249b8: 48 89 d9                     	movq	%rbx, %rcx
   249bb: 48 8d 35 b6 62 01 00         	leaq	90806(%rip), %rsi       # 0x3ac78 <CSWTCH.126+0x1378>
   249c2: 31 ff                        	xorl	%edi, %edi
   249c4: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   249cc: e8 ff 36 fe ff               	callq	0x80d0 <libbpf_print>
; 		if (len < 0)
   249d1: 48 8b 84 24 a0 00 00 00      	movq	160(%rsp), %rax
; 		return -EINVAL;
   249d9: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
   249df: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   249e4: e9 c9 f9 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
   249e9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		arg->arg_bitshift = 64 - arg_sz * 8;
   249f0: b8 08 00 00 00               	movl	$8, %eax
; 	return len;
   249f5: 44 8b b4 24 dc 00 00 00      	movl	220(%rsp), %r14d
; 		arg->arg_bitshift = 64 - arg_sz * 8;
   249fd: 44 29 c0                     	subl	%r8d, %eax
   24a00: c1 e0 03                     	shll	$3, %eax
   24a03: 88 42 27                     	movb	%al, 39(%rdx)
; 		if (len < 0)
   24a06: 45 85 f6                     	testl	%r14d, %r14d
   24a09: 0f 88 31 03 00 00            	js	0x24d40 <usdt_manager_attach_usdt+0xf50>
; 		s += len;
   24a0f: 49 63 c6                     	movslq	%r14d, %rax
   24a12: 48 01 c3                     	addq	%rax, %rbx
; 		spec->arg_cnt++;
   24a15: 41 0f b7 87 e0 00 00 00      	movzwl	224(%r15), %eax
   24a1d: 44 8d 70 01                  	leal	1(%rax), %r14d
   24a21: 66 45 89 b7 e0 00 00 00      	movw	%r14w, 224(%r15)
; 	while (s[0]) {
   24a29: 80 3b 00                     	cmpb	$0, (%rbx)
   24a2c: 0f 84 ee 00 00 00            	je	0x24b20 <usdt_manager_attach_usdt+0xd30>
; 		if (spec->arg_cnt >= USDT_MAX_ARG_CNT) {
   24a32: 66 41 83 fe 0b               	cmpw	$11, %r14w
   24a37: 0f 8e 93 fe ff ff            	jle	0x248d0 <usdt_manager_attach_usdt+0xae0>
; 			pr_warn("usdt: too many USDT arguments (> %d) for '%s:%s' with args spec '%s'\n",
   24a3d: 4c 8b 44 24 40               	movq	64(%rsp), %r8
   24a42: 4c 8b 4c 24 10               	movq	16(%rsp), %r9
   24a47: 31 c0                        	xorl	%eax, %eax
   24a49: 31 ff                        	xorl	%edi, %edi
   24a4b: 48 8b 4c 24 30               	movq	48(%rsp), %rcx
   24a50: ba 0c 00 00 00               	movl	$12, %edx
   24a55: 48 8d 35 9c 61 01 00         	leaq	90524(%rip), %rsi       # 0x3abf8 <CSWTCH.126+0x12f8>
   24a5c: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   24a64: e8 67 36 fe ff               	callq	0x80d0 <libbpf_print>
; 	return realloc(ptr, total);
   24a69: 48 8b 84 24 a0 00 00 00      	movq	160(%rsp), %rax
; 			return -E2BIG;
   24a71: 41 b8 f9 ff ff ff            	movl	$4294967289, %r8d       # imm = 0xFFFFFFF9
; 	return realloc(ptr, total);
   24a77: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   24a7c: e9 31 f9 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
   24a81: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		arg->arg_type = USDT_ARG_REG_DEREF;
   24a88: 49 0f bf d6                  	movswq	%r14w, %rdx
; 		arg->val_off = off;
   24a8c: 48 8b 8c 24 18 01 00 00      	movq	280(%rsp), %rcx
   24a94: 48 89 d0                     	movq	%rdx, %rax
   24a97: 48 89 94 24 80 00 00 00      	movq	%rdx, 128(%rsp)
   24a9f: 48 c1 e0 04                  	shlq	$4, %rax
   24aa3: 4c 01 f8                     	addq	%r15, %rax
; 		arg->arg_type = USDT_ARG_REG_DEREF;
   24aa6: c7 40 20 02 00 00 00         	movl	$2, 32(%rax)
; 		arg->val_off = off;
   24aad: 48 89 48 18                  	movq	%rcx, 24(%rax)
; 		reg_off = calc_pt_regs_off(reg_name);
   24ab1: 48 8b bc 24 10 01 00 00      	movq	272(%rsp), %rdi
   24ab9: e8 62 ee ff ff               	callq	0x23920 <calc_pt_regs_off>
; 		free(reg_name);
   24abe: 48 8b bc 24 10 01 00 00      	movq	272(%rsp), %rdi
; 		reg_off = calc_pt_regs_off(reg_name);
   24ac6: 41 89 c6                     	movl	%eax, %r14d
; 		free(reg_name);
   24ac9: e8 f2 0b fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		if (reg_off < 0)
   24ace: 45 85 f6                     	testl	%r14d, %r14d
   24ad1: 0f 88 69 02 00 00            	js	0x24d40 <usdt_manager_attach_usdt+0xf50>
; 		arg->reg_off = reg_off;
   24ad7: 48 8b 94 24 80 00 00 00      	movq	128(%rsp), %rdx
   24adf: 44 89 f0                     	movl	%r14d, %eax
   24ae2: e9 8e fe ff ff               	jmp	0x24975 <usdt_manager_attach_usdt+0xb85>
   24ae7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		arg->arg_type = USDT_ARG_REG;
   24af0: 49 0f bf d6                  	movswq	%r14w, %rdx
   24af4: 48 89 d0                     	movq	%rdx, %rax
   24af7: 48 89 94 24 80 00 00 00      	movq	%rdx, 128(%rsp)
   24aff: 48 c1 e0 04                  	shlq	$4, %rax
   24b03: 4c 01 f8                     	addq	%r15, %rax
   24b06: c7 40 20 01 00 00 00         	movl	$1, 32(%rax)
; 		arg->val_off = 0;
   24b0d: 48 c7 40 18 00 00 00 00      	movq	$0, 24(%rax)
   24b15: eb 9a                        	jmp	0x24ab1 <usdt_manager_attach_usdt+0xcc1>
   24b17: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		target_cnt++;
   24b20: 48 8b 84 24 a0 00 00 00      	movq	160(%rsp), %rax
   24b28: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   24b2d: 48 8b 84 24 c0 00 00 00      	movq	192(%rsp), %rax
   24b35: 48 89 04 24                  	movq	%rax, (%rsp)
   24b39: e9 82 f6 ff ff               	jmp	0x241c0 <usdt_manager_attach_usdt+0x3d0>
   24b3e: 66 90                        	nop
; 		if (ehdr.e_type == ET_DYN && !man->has_bpf_cookie) {
   24b40: 48 8b bc 24 a8 00 00 00      	movq	168(%rsp), %rdi
   24b48: 80 7f 28 00                  	cmpb	$0, 40(%rdi)
   24b4c: 0f 85 0e 02 00 00            	jne	0x24d60 <usdt_manager_attach_usdt+0xf70>
; 			if (pid < 0) {
   24b52: 44 8b 5c 24 3c               	movl	60(%rsp), %r11d
   24b57: 45 85 db                     	testl	%r11d, %r11d
   24b5a: 0f 88 b3 06 00 00            	js	0x25213 <usdt_manager_attach_usdt+0x1423>
; 			if (vma_seg_cnt == 0) {
   24b60: 4c 8b 8c 24 f0 00 00 00      	movq	240(%rsp), %r9
; 			seg = find_vma_seg(vma_segs, vma_seg_cnt, usdt_rel_ip);
   24b68: 48 8b 94 24 f8 00 00 00      	movq	248(%rsp), %rdx
; 			if (vma_seg_cnt == 0) {
   24b70: 4d 85 c9                     	testq	%r9, %r9
   24b73: 74 6f                        	je	0x24be4 <usdt_manager_attach_usdt+0xdf4>
; 	for (i = 0, seg = segs; i < seg_cnt; i++, seg++) {
   24b75: 31 ff                        	xorl	%edi, %edi
   24b77: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		if (seg->offset <= offset && offset < seg->offset + (seg->end - seg->start))
   24b80: 48 8b 42 10                  	movq	16(%rdx), %rax
   24b84: 49 39 c6                     	cmpq	%rax, %r14
   24b87: 7c 19                        	jl	0x24ba2 <usdt_manager_attach_usdt+0xdb2>
   24b89: 48 8b 72 08                  	movq	8(%rdx), %rsi
   24b8d: 48 8b 0a                     	movq	(%rdx), %rcx
   24b90: 49 89 f0                     	movq	%rsi, %r8
   24b93: 49 29 c8                     	subq	%rcx, %r8
   24b96: 49 01 c0                     	addq	%rax, %r8
   24b99: 4d 39 c6                     	cmpq	%r8, %r14
   24b9c: 0f 8c 40 02 00 00            	jl	0x24de2 <usdt_manager_attach_usdt+0xff2>
; 	for (i = 0, seg = segs; i < seg_cnt; i++, seg++) {
   24ba2: 48 83 c7 01                  	addq	$1, %rdi
   24ba6: 48 83 c2 20                  	addq	$32, %rdx
   24baa: 4c 39 cf                     	cmpq	%r9, %rdi
   24bad: 72 d1                        	jb	0x24b80 <usdt_manager_attach_usdt+0xd90>
; 				pr_warn("usdt: failed to find shared lib memory segment for '%s:%s' in '%s' at relative IP 0x%lx\n",
   24baf: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   24bb4: 48 8b 4c 24 68               	movq	104(%rsp), %rcx
   24bb9: 4d 89 f1                     	movq	%r14, %r9
   24bbc: 31 ff                        	xorl	%edi, %edi
   24bbe: 48 8b 54 24 48               	movq	72(%rsp), %rdx
   24bc3: 48 8d 35 6e 62 01 00         	leaq	90734(%rip), %rsi       # 0x3ae38 <CSWTCH.126+0x1538>
   24bca: 31 c0                        	xorl	%eax, %eax
   24bcc: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   24bd4: e8 f7 34 fe ff               	callq	0x80d0 <libbpf_print>
; 				err = -ESRCH;
   24bd9: 41 b8 fd ff ff ff            	movl	$4294967293, %r8d       # imm = 0xFFFFFFFD
; 				goto err_out;
   24bdf: e9 ce f7 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 				err = parse_vma_segs(pid, path, &vma_segs, &vma_seg_cnt);
   24be4: 48 8b 74 24 08               	movq	8(%rsp), %rsi
   24be9: 8b 7c 24 3c                  	movl	60(%rsp), %edi
   24bed: 48 8d 8c 24 f0 00 00 00      	leaq	240(%rsp), %rcx
   24bf5: 48 8d 94 24 f8 00 00 00      	leaq	248(%rsp), %rdx
   24bfd: e8 ce ed ff ff               	callq	0x239d0 <parse_vma_segs>
; 				if (err) {
   24c02: 85 c0                        	testl	%eax, %eax
   24c04: 0f 85 71 06 00 00            	jne	0x2527b <usdt_manager_attach_usdt+0x148b>
; 			seg = find_vma_seg(vma_segs, vma_seg_cnt, usdt_rel_ip);
   24c0a: 4c 8b 8c 24 f0 00 00 00      	movq	240(%rsp), %r9
   24c12: 48 8b 94 24 f8 00 00 00      	movq	248(%rsp), %rdx
; 	for (i = 0, seg = segs; i < seg_cnt; i++, seg++) {
   24c1a: 4d 85 c9                     	testq	%r9, %r9
   24c1d: 0f 85 52 ff ff ff            	jne	0x24b75 <usdt_manager_attach_usdt+0xd85>
   24c23: eb 8a                        	jmp	0x24baf <usdt_manager_attach_usdt+0xdbf>
   24c25: 0f 1f 00                     	nopl	(%rax)
; 		return -EINVAL;
   24c28: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   24c30: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
   24c36: e9 77 f7 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 		err = -errno;
   24c3b: e8 b0 0a fe ff               	callq	0x56f0 <.plt.sec+0x80>
   24c40: c7 84 24 b0 00 00 00 0c 00 00 00     	movl	$12, 176(%rsp)
   24c4b: 48 89 c3                     	movq	%rax, %rbx
; 		bpf_link__destroy(&link->link);
   24c4e: 48 89 ef                     	movq	%rbp, %rdi
   24c51: e8 6a 07 ff ff               	callq	0x153c0 <bpf_link__destroy>
   24c56: e9 29 fa ff ff               	jmp	0x24684 <usdt_manager_attach_usdt+0x894>
   24c5b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			if (!man->has_sema_refcnt) {
   24c60: 48 8b 84 24 a8 00 00 00      	movq	168(%rsp), %rax
   24c68: 80 78 29 00                  	cmpb	$0, 41(%rax)
   24c6c: 0f 84 50 05 00 00            	je	0x251c2 <usdt_manager_attach_usdt+0x13d2>
   24c72: 48 8b 44 24 50               	movq	80(%rsp), %rax
   24c77: 48 8b 74 24 78               	movq	120(%rsp), %rsi
   24c7c: 31 d2                        	xorl	%edx, %edx
   24c7e: 66 90                        	nop
; 		if (seg->start <= virtaddr && virtaddr < seg->end)
   24c80: 48 8b 08                     	movq	(%rax), %rcx
   24c83: 48 39 d9                     	cmpq	%rbx, %rcx
   24c86: 7f 09                        	jg	0x24c91 <usdt_manager_attach_usdt+0xea1>
   24c88: 4c 8b 40 08                  	movq	8(%rax), %r8
   24c8c: 49 39 d8                     	cmpq	%rbx, %r8
   24c8f: 7f 42                        	jg	0x24cd3 <usdt_manager_attach_usdt+0xee3>
; 	for (i = 0, seg = segs; i < seg_cnt; i++, seg++) {
   24c91: 48 83 c2 01                  	addq	$1, %rdx
   24c95: 48 83 c0 20                  	addq	$32, %rax
   24c99: 48 39 f2                     	cmpq	%rsi, %rdx
   24c9c: 75 e2                        	jne	0x24c80 <usdt_manager_attach_usdt+0xe90>
; 				pr_warn("usdt: failed to find ELF loadable segment with semaphore of '%s:%s' in '%s' at 0x%lx\n",
   24c9e: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   24ca3: 48 8b 4c 24 68               	movq	104(%rsp), %rcx
   24ca8: 49 89 d9                     	movq	%rbx, %r9
   24cab: 31 ff                        	xorl	%edi, %edi
   24cad: 48 8b 54 24 48               	movq	72(%rsp), %rdx
   24cb2: 48 8d 35 1f 61 01 00         	leaq	90399(%rip), %rsi       # 0x3add8 <CSWTCH.126+0x14d8>
   24cb9: 31 c0                        	xorl	%eax, %eax
   24cbb: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   24cc3: e8 08 34 fe ff               	callq	0x80d0 <libbpf_print>
; 				err = -ESRCH;
   24cc8: 41 b8 fd ff ff ff            	movl	$4294967293, %r8d       # imm = 0xFFFFFFFD
; 				goto err_out;
   24cce: e9 df f6 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 			if (seg->is_exec) {
   24cd3: 80 78 18 00                  	cmpb	$0, 24(%rax)
   24cd7: 0f 85 c2 04 00 00            	jne	0x2519f <usdt_manager_attach_usdt+0x13af>
; 			usdt_sema_off = note.sema_addr - seg->start + seg->offset;
   24cdd: 48 8b 40 10                  	movq	16(%rax), %rax
   24ce1: 48 89 da                     	movq	%rbx, %rdx
; 			pr_debug("usdt: sema  for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved 0x%lx) in segment [0x%lx, 0x%lx] at offset 0x%lx\n",
   24ce4: bf 02 00 00 00               	movl	$2, %edi
   24ce9: 48 8d 35 88 5e 01 00         	leaq	89736(%rip), %rsi       # 0x3ab78 <CSWTCH.126+0x1278>
; 			usdt_sema_off = note.sema_addr - seg->start + seg->offset;
   24cf0: 48 29 ca                     	subq	%rcx, %rdx
; 			pr_debug("usdt: sema  for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved 0x%lx) in segment [0x%lx, 0x%lx] at offset 0x%lx\n",
   24cf3: 66 83 bc 24 10 02 00 00 02   	cmpw	$2, 528(%rsp)
; 			usdt_sema_off = note.sema_addr - seg->start + seg->offset;
   24cfc: 48 8d 2c 02                  	leaq	(%rdx,%rax), %rbp
; 			pr_debug("usdt: sema  for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved 0x%lx) in segment [0x%lx, 0x%lx] at offset 0x%lx\n",
   24d00: 50                           	pushq	%rax
   24d01: 48 8d 05 71 55 01 00         	leaq	87409(%rip), %rax       # 0x3a279 <CSWTCH.126+0x979>
   24d08: 41 50                        	pushq	%r8
   24d0a: 4c 8d 05 63 55 01 00         	leaq	87395(%rip), %r8        # 0x3a274 <CSWTCH.126+0x974>
   24d11: 51                           	pushq	%rcx
   24d12: 4c 0f 45 c0                  	cmovneq	%rax, %r8
   24d16: 31 c0                        	xorl	%eax, %eax
   24d18: 55                           	pushq	%rbp
   24d19: 41 54                        	pushq	%r12
   24d1b: 53                           	pushq	%rbx
   24d1c: 4c 8b 4c 24 38               	movq	56(%rsp), %r9
; 			usdt_sema_off = note.sema_addr - seg->start + seg->offset;
   24d21: 48 89 eb                     	movq	%rbp, %rbx
; 			pr_debug("usdt: sema  for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved 0x%lx) in segment [0x%lx, 0x%lx] at offset 0x%lx\n",
   24d24: 48 8b 8c 24 98 00 00 00      	movq	152(%rsp), %rcx
   24d2c: 48 8b 54 24 78               	movq	120(%rsp), %rdx
   24d31: e8 9a 33 fe ff               	callq	0x80d0 <libbpf_print>
   24d36: 48 83 c4 30                  	addq	$48, %rsp
   24d3a: e9 bc fa ff ff               	jmp	0x247fb <usdt_manager_attach_usdt+0xa0b>
   24d3f: 90                           	nop
   24d40: 48 8b 84 24 a0 00 00 00      	movq	160(%rsp), %rax
   24d48: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   24d50: 45 89 f0                     	movl	%r14d, %r8d
   24d53: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   24d58: e9 55 f6 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
   24d5d: 0f 1f 00                     	nopl	(%rax)
; 		pr_debug("usdt: probe for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved abs_ip 0x%lx rel_ip 0x%lx) args '%s' in segment [0x%lx, 0x%lx) at offset 0x%lx\n",
   24d60: 4c 8d 05 12 55 01 00         	leaq	87314(%rip), %r8        # 0x3a279 <CSWTCH.126+0x979>
   24d67: e9 4c fa ff ff               	jmp	0x247b8 <usdt_manager_attach_usdt+0x9c8>
   24d6c: 4c 8b 7c 24 10               	movq	16(%rsp), %r15
; 	if (err) {
   24d71: 41 b8 f4 ff ff ff            	movl	$4294967284, %r8d       # imm = 0xFFFFFFF4
; 		pr_warn("usdt: failed to process ELF program segments for '%s': %d\n", path, err);
   24d77: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   24d7c: 44 89 c1                     	movl	%r8d, %ecx
   24d7f: 31 ff                        	xorl	%edi, %edi
   24d81: 31 c0                        	xorl	%eax, %eax
   24d83: 48 8d 35 16 5b 01 00         	leaq	88854(%rip), %rsi       # 0x3a8a0 <CSWTCH.126+0xfa0>
   24d8a: 44 89 44 24 10               	movl	%r8d, 16(%rsp)
   24d8f: e8 3c 33 fe ff               	callq	0x80d0 <libbpf_print>
; 	*out_target_cnt = 0;
   24d94: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
; 		goto err_out;
   24d9c: 44 8b 44 24 10               	movl	16(%rsp), %r8d
; 	*out_targets = NULL;
   24da1: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	struct usdt_target *targets = NULL, *target;
   24daa: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
; 		goto err_out;
   24db3: e9 0b f6 ff ff               	jmp	0x243c3 <usdt_manager_attach_usdt+0x5d3>
   24db8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		err = -errno;
   24dc0: e8 2b 09 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	struct elf_seg *segs = NULL, *vma_segs = NULL;
   24dc5: 48 c7 44 24 50 00 00 00 00   	movq	$0, 80(%rsp)
; 	*seg_cnt = 0;
   24dce: 48 c7 44 24 78 00 00 00 00   	movq	$0, 120(%rsp)
; 		err = -errno;
   24dd7: 44 8b 00                     	movl	(%rax), %r8d
   24dda: 41 f7 d8                     	negl	%r8d
; 		return err;
   24ddd: e9 40 f3 ff ff               	jmp	0x24122 <usdt_manager_attach_usdt+0x332>
; 			usdt_abs_ip = seg->start - seg->offset + usdt_rel_ip;
   24de2: 49 89 cd                     	movq	%rcx, %r13
; 		pr_debug("usdt: probe for '%s:%s' in %s '%s': addr 0x%lx base 0x%lx (resolved abs_ip 0x%lx rel_ip 0x%lx) args '%s' in segment [0x%lx, 0x%lx) at offset 0x%lx\n",
   24de5: 0f b7 94 24 10 02 00 00      	movzwl	528(%rsp), %edx
; 			usdt_abs_ip = seg->start - seg->offset + usdt_rel_ip;
   24ded: 49 29 c5                     	subq	%rax, %r13
   24df0: 4d 01 f5                     	addq	%r14, %r13
   24df3: e9 aa f9 ff ff               	jmp	0x247a2 <usdt_manager_attach_usdt+0x9b2>
   24df8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		err = -errno;
   24e00: e8 eb 08 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   24e05: 48 89 c3                     	movq	%rax, %rbx
; 	errno = -err;
   24e08: 44 89 e0                     	movl	%r12d, %eax
   24e0b: f7 d8                        	negl	%eax
   24e0d: 89 84 24 b0 00 00 00         	movl	%eax, 176(%rsp)
   24e14: e9 6b f8 ff ff               	jmp	0x24684 <usdt_manager_attach_usdt+0x894>
   24e19: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("usdt: no USDT notes section (%s) found in '%s'\n", USDT_NOTE_SEC, path);
   24e20: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   24e25: 31 ff                        	xorl	%edi, %edi
   24e27: 31 c0                        	xorl	%eax, %eax
   24e29: 4c 89 e2                     	movq	%r12, %rdx
   24e2c: 48 8d 35 55 59 01 00         	leaq	88405(%rip), %rsi       # 0x3a788 <CSWTCH.126+0xe88>
   24e33: e8 98 32 fe ff               	callq	0x80d0 <libbpf_print>
; 	if (err <= 0) {
   24e38: 45 85 ed                     	testl	%r13d, %r13d
   24e3b: 0f 8e ae 03 00 00            	jle	0x251ef <usdt_manager_attach_usdt+0x13ff>
; 	*out_target_cnt = 0;
   24e41: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
; 	*out_targets = NULL;
   24e49: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
   24e52: e9 9c f5 ff ff               	jmp	0x243f3 <usdt_manager_attach_usdt+0x603>
; 		free(targets);
   24e57: 48 8b 7c 24 20               	movq	32(%rsp), %rdi
   24e5c: 44 89 04 24                  	movl	%r8d, (%rsp)
; 	errno = -err;
   24e60: 45 31 e4                     	xorl	%r12d, %r12d
; 		free(targets);
   24e63: e8 58 08 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 		err = -errno;
   24e68: e8 83 08 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	errno = -err;
   24e6d: 44 8b 04 24                  	movl	(%rsp), %r8d
; 		err = -errno;
   24e71: 48 89 c3                     	movq	%rax, %rbx
; 	errno = -err;
   24e74: 41 f7 d8                     	negl	%r8d
   24e77: 44 89 84 24 b0 00 00 00      	movl	%r8d, 176(%rsp)
   24e7f: e9 00 f8 ff ff               	jmp	0x24684 <usdt_manager_attach_usdt+0x894>
; 		pid = getpid();
   24e84: e8 17 09 fe ff               	callq	0x57a0 <.plt.sec+0x130>
   24e89: 89 44 24 3c                  	movl	%eax, 60(%rsp)
   24e8d: e9 ab f0 ff ff               	jmp	0x23f3d <usdt_manager_attach_usdt+0x14d>
; 		err = -errno;
   24e92: e8 59 08 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("usdt: failed to open ELF binary '%s': %d\n", path, err);
   24e97: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   24e9c: 48 8d 35 35 57 01 00         	leaq	87861(%rip), %rsi       # 0x3a5d8 <CSWTCH.126+0xcd8>
   24ea3: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
   24ea5: 8b 28                        	movl	(%rax), %ebp
   24ea7: 48 89 c3                     	movq	%rax, %rbx
; 		pr_warn("usdt: failed to open ELF binary '%s': %d\n", path, err);
   24eaa: 31 c0                        	xorl	%eax, %eax
; 		err = -errno;
   24eac: 89 e9                        	movl	%ebp, %ecx
   24eae: f7 d9                        	negl	%ecx
; 		pr_warn("usdt: failed to open ELF binary '%s': %d\n", path, err);
   24eb0: e8 1b 32 fe ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   24eb5: 89 2b                        	movl	%ebp, (%rbx)
; 		return libbpf_err_ptr(err);
   24eb7: 31 c0                        	xorl	%eax, %eax
   24eb9: e9 f9 f7 ff ff               	jmp	0x246b7 <usdt_manager_attach_usdt+0x8c7>
; 	free(targets);
   24ebe: 48 8b 7c 24 28               	movq	40(%rsp), %rdi
   24ec3: e8 f8 07 fe ff               	callq	0x56c0 <.plt.sec+0x50>
; 	hashmap__free(specs_hash);
   24ec8: 4c 89 e7                     	movq	%r12, %rdi
   24ecb: e8 e0 95 ff ff               	callq	0x1e4b0 <hashmap__free>
; 	elf_end(elf);
   24ed0: 48 8b 7c 24 70               	movq	112(%rsp), %rdi
   24ed5: e8 56 0b fe ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   24eda: 8b bc 24 b8 00 00 00         	movl	184(%rsp), %edi
   24ee1: e8 1a 0a fe ff               	callq	0x5900 <.plt.sec+0x290>
; 	return &link->link;
   24ee6: 48 89 e8                     	movq	%rbp, %rax
   24ee9: e9 c9 f7 ff ff               	jmp	0x246b7 <usdt_manager_attach_usdt+0x8c7>
; 			pr_warn("usdt: failed to attach uprobe #%d for '%s:%s' in '%s': %d\n",
   24eee: 89 04 24                     	movl	%eax, (%rsp)
   24ef1: 48 83 ec 08                  	subq	$8, %rsp
   24ef5: 48 8d 35 94 5e 01 00         	leaq	89748(%rip), %rsi       # 0x3ad90 <CSWTCH.126+0x1490>
   24efc: 31 ff                        	xorl	%edi, %edi
   24efe: 50                           	pushq	%rax
   24eff: 4c 8b 4c 24 18               	movq	24(%rsp), %r9
   24f04: 31 c0                        	xorl	%eax, %eax
   24f06: 4c 8b 44 24 78               	movq	120(%rsp), %r8
   24f0b: 48 8b 4c 24 58               	movq	88(%rsp), %rcx
   24f10: 8b 54 24 20                  	movl	32(%rsp), %edx
   24f14: e8 b7 31 fe ff               	callq	0x80d0 <libbpf_print>
; 		err = -errno;
   24f19: e8 d2 07 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	errno = -err;
   24f1e: 44 8b 54 24 10               	movl	16(%rsp), %r10d
; 		err = -errno;
   24f23: 48 89 c3                     	movq	%rax, %rbx
; 	errno = -err;
   24f26: 41 f7 da                     	negl	%r10d
   24f29: 44 89 94 24 c0 00 00 00      	movl	%r10d, 192(%rsp)
; 			goto err_out;
   24f31: 59                           	popq	%rcx
   24f32: 5e                           	popq	%rsi
   24f33: e9 16 fd ff ff               	jmp	0x24c4e <usdt_manager_attach_usdt+0xe5e>
; 	if (*seg_cnt == 0) {
   24f38: 48 83 7c 24 78 00            	cmpq	$0, 120(%rsp)
   24f3e: 4c 8b 7c 24 10               	movq	16(%rsp), %r15
   24f43: 0f 84 36 02 00 00            	je	0x2517f <usdt_manager_attach_usdt+0x138f>
; 	qsort(*segs, *seg_cnt, sizeof(**segs), cmp_elf_segs);
   24f49: 48 8b 74 24 78               	movq	120(%rsp), %rsi
   24f4e: 48 8b 7c 24 50               	movq	80(%rsp), %rdi
   24f53: ba 20 00 00 00               	movl	$32, %edx
   24f58: 48 8d 0d 41 e7 ff ff         	leaq	-6335(%rip), %rcx       # 0x236a0 <cmp_elf_segs>
   24f5f: e8 fc 07 fe ff               	callq	0x5760 <.plt.sec+0xf0>
; 	if (err) {
   24f64: e9 ca f1 ff ff               	jmp	0x24133 <usdt_manager_attach_usdt+0x343>
; 	err = target_cnt;
   24f69: 48 8b 44 24 20               	movq	32(%rsp), %rax
   24f6e: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   24f76: 44 8b 04 24                  	movl	(%rsp), %r8d
   24f7a: 48 89 44 24 28               	movq	%rax, 40(%rsp)
   24f7f: e9 3f f4 ff ff               	jmp	0x243c3 <usdt_manager_attach_usdt+0x5d3>
; 		pr_warn("usdt: failed to parse ELF binary '%s': %s\n", path, elf_errmsg(-1));
   24f84: bf ff ff ff ff               	movl	$4294967295, %edi       # imm = 0xFFFFFFFF
   24f89: e8 d2 0a fe ff               	callq	0x5a60 <.plt.sec+0x3f0>
   24f8e: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   24f93: 48 8d 35 76 56 01 00         	leaq	87670(%rip), %rsi       # 0x3a610 <CSWTCH.126+0xd10>
   24f9a: 31 ff                        	xorl	%edi, %edi
   24f9c: 48 89 c1                     	movq	%rax, %rcx
   24f9f: 31 c0                        	xorl	%eax, %eax
   24fa1: e8 2a 31 fe ff               	callq	0x80d0 <libbpf_print>
; 	hashmap__free(specs_hash);
   24fa6: 31 ff                        	xorl	%edi, %edi
   24fa8: e8 03 95 ff ff               	callq	0x1e4b0 <hashmap__free>
; 		err = -errno;
   24fad: e8 3e 07 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   24fb2: c7 84 24 b0 00 00 00 09 00 00 00     	movl	$9, 176(%rsp)
   24fbd: 48 89 c3                     	movq	%rax, %rbx
   24fc0: e9 db f6 ff ff               	jmp	0x246a0 <usdt_manager_attach_usdt+0x8b0>
; 		pr_warn("usdt: unrecognized arg #%d spec '%s'\n", arg_num, arg_str);
   24fc5: 8b 54 24 20                  	movl	32(%rsp), %edx
   24fc9: 31 c0                        	xorl	%eax, %eax
   24fcb: 48 89 d9                     	movq	%rbx, %rcx
   24fce: 48 8d 35 73 5c 01 00         	leaq	89203(%rip), %rsi       # 0x3ac48 <CSWTCH.126+0x1348>
   24fd5: 31 ff                        	xorl	%edi, %edi
   24fd7: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   24fdf: e8 ec 30 fe ff               	callq	0x80d0 <libbpf_print>
; 	return realloc(ptr, total);
   24fe4: 48 8b 84 24 a0 00 00 00      	movq	160(%rsp), %rax
; 		return -EINVAL;
   24fec: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
; 	return realloc(ptr, total);
   24ff2: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   24ff7: e9 b6 f3 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 			err = -errno;
   24ffc: e8 ef 06 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 				pr_warn("usdt: IP collision detected for spec #%d for '%s:%s' in '%s'\n",
   25001: 8b 94 24 60 01 00 00         	movl	352(%rsp), %edx
; 			err = -errno;
   25008: 48 89 c3                     	movq	%rax, %rbx
   2500b: 8b 00                        	movl	(%rax), %eax
   2500d: 89 84 24 b0 00 00 00         	movl	%eax, 176(%rsp)
; 			if (err == -EEXIST) {
   25014: 83 f8 11                     	cmpl	$17, %eax
   25017: 0f 84 35 01 00 00            	je	0x25152 <usdt_manager_attach_usdt+0x1362>
; 			err = -errno;
   2501d: 8b 84 24 b0 00 00 00         	movl	176(%rsp), %eax
; 				pr_warn("usdt: failed to map IP 0x%lx to spec #%d for '%s:%s' in '%s': %d\n",
   25024: 89 d1                        	movl	%edx, %ecx
   25026: 31 ff                        	xorl	%edi, %edi
   25028: 49 8b 55 00                  	movq	(%r13), %rdx
   2502c: 48 8d 35 0d 5d 01 00         	leaq	89357(%rip), %rsi       # 0x3ad40 <CSWTCH.126+0x1440>
; 			err = -errno;
   25033: f7 d8                        	negl	%eax
; 				pr_warn("usdt: failed to map IP 0x%lx to spec #%d for '%s:%s' in '%s': %d\n",
   25035: 50                           	pushq	%rax
   25036: 31 c0                        	xorl	%eax, %eax
   25038: ff 74 24 10                  	pushq	16(%rsp)
   2503c: 4c 8b 4c 24 78               	movq	120(%rsp), %r9
   25041: 4c 8b 44 24 58               	movq	88(%rsp), %r8
   25046: e8 85 30 fe ff               	callq	0x80d0 <libbpf_print>
   2504b: 5f                           	popq	%rdi
   2504c: 41 58                        	popq	%r8
   2504e: e9 fb fb ff ff               	jmp	0x24c4e <usdt_manager_attach_usdt+0xe5e>
; 			err = -errno;
   25053: e8 98 06 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 			pr_warn("usdt: failed to set USDT spec #%d for '%s:%s' in '%s': %d\n",
   25058: 48 83 ec 08                  	subq	$8, %rsp
   2505c: 48 8d 35 4d 5c 01 00         	leaq	89165(%rip), %rsi       # 0x3acb0 <CSWTCH.126+0x13b0>
   25063: 31 ff                        	xorl	%edi, %edi
; 			err = -errno;
   25065: 48 89 c3                     	movq	%rax, %rbx
   25068: 8b 00                        	movl	(%rax), %eax
   2506a: 89 84 24 b8 00 00 00         	movl	%eax, 184(%rsp)
   25071: f7 d8                        	negl	%eax
; 			pr_warn("usdt: failed to set USDT spec #%d for '%s:%s' in '%s': %d\n",
   25073: 50                           	pushq	%rax
   25074: 4c 8b 4c 24 18               	movq	24(%rsp), %r9
   25079: 31 c0                        	xorl	%eax, %eax
   2507b: 4c 8b 44 24 78               	movq	120(%rsp), %r8
   25080: 48 8b 4c 24 58               	movq	88(%rsp), %rcx
   25085: 8b 94 24 70 01 00 00         	movl	368(%rsp), %edx
   2508c: e8 3f 30 fe ff               	callq	0x80d0 <libbpf_print>
; 			goto err_out;
   25091: 41 59                        	popq	%r9
   25093: 41 5a                        	popq	%r10
   25095: e9 b4 fb ff ff               	jmp	0x24c4e <usdt_manager_attach_usdt+0xe5e>
; 		err = -errno;
   2509a: e8 51 06 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   2509f: c7 84 24 b0 00 00 00 07 00 00 00     	movl	$7, 176(%rsp)
   250aa: 48 89 c3                     	movq	%rax, %rbx
   250ad: e9 9c fb ff ff               	jmp	0x24c4e <usdt_manager_attach_usdt+0xe5e>
   250b2: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
; 			pr_warn("usdt: matched ELF binary '%s' segment [0x%lx, 0x%lx) for '%s:%s' at IP 0x%lx is not executable\n",
   250ba: 41 55                        	pushq	%r13
   250bc: 49 89 f0                     	movq	%rsi, %r8
   250bf: 48 8d 35 22 58 01 00         	leaq	88098(%rip), %rsi       # 0x3a8e8 <CSWTCH.126+0xfe8>
   250c6: ff 74 24 70                  	pushq	112(%rsp)
   250ca: 4c 8b 4c 24 58               	movq	88(%rsp), %r9
   250cf: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   250d4: 31 c0                        	xorl	%eax, %eax
   250d6: 31 ff                        	xorl	%edi, %edi
   250d8: e8 f3 2f fe ff               	callq	0x80d0 <libbpf_print>
; 			goto err_out;
   250dd: 58                           	popq	%rax
; 			err = -ESRCH;
   250de: 41 b8 fd ff ff ff            	movl	$4294967293, %r8d       # imm = 0xFFFFFFFD
; 			goto err_out;
   250e4: 5a                           	popq	%rdx
   250e5: e9 c8 f2 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 		pr_warn("usdt: invalid USDT notes section (%s) in '%s'\n", USDT_NOTE_SEC, path);
   250ea: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   250ef: 4c 89 e2                     	movq	%r12, %rdx
   250f2: 31 ff                        	xorl	%edi, %edi
   250f4: 31 c0                        	xorl	%eax, %eax
   250f6: 48 8d 35 c3 56 01 00         	leaq	87747(%rip), %rsi       # 0x3a7c0 <CSWTCH.126+0xec0>
; 		err = -errno;
   250fd: 45 31 e4                     	xorl	%r12d, %r12d
; 		pr_warn("usdt: invalid USDT notes section (%s) in '%s'\n", USDT_NOTE_SEC, path);
   25100: e8 cb 2f fe ff               	callq	0x80d0 <libbpf_print>
; 		err = -errno;
   25105: e8 e6 05 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   2510a: c7 84 24 b0 00 00 00 16 00 00 00     	movl	$22, 176(%rsp)
; 	*out_targets = NULL;
   25115: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 		err = -errno;
   2511e: 48 89 c3                     	movq	%rax, %rbx
   25121: e9 5e f5 ff ff               	jmp	0x24684 <usdt_manager_attach_usdt+0x894>
; 		pr_warn("usdt: unrecognized ELF kind %d for '%s'\n", elf_kind(elf), path);
   25126: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   2512b: 89 c2                        	movl	%eax, %edx
   2512d: 48 8d 35 14 55 01 00         	leaq	87316(%rip), %rsi       # 0x3a648 <CSWTCH.126+0xd48>
   25134: 31 ff                        	xorl	%edi, %edi
   25136: 31 c0                        	xorl	%eax, %eax
   25138: e8 93 2f fe ff               	callq	0x80d0 <libbpf_print>
; 	if (link)
   2513d: e9 23 f5 ff ff               	jmp	0x24665 <usdt_manager_attach_usdt+0x875>
; 		err = -errno;
   25142: e8 a9 05 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	struct hashmap *specs_hash = NULL;
   25147: 45 31 e4                     	xorl	%r12d, %r12d
; 		err = -errno;
   2514a: 48 89 c3                     	movq	%rax, %rbx
   2514d: e9 32 f5 ff ff               	jmp	0x24684 <usdt_manager_attach_usdt+0x894>
; 				pr_warn("usdt: IP collision detected for spec #%d for '%s:%s' in '%s'\n",
   25152: 4c 8b 4c 24 08               	movq	8(%rsp), %r9
   25157: 4c 8b 44 24 68               	movq	104(%rsp), %r8
   2515c: 31 ff                        	xorl	%edi, %edi
   2515e: 31 c0                        	xorl	%eax, %eax
   25160: 48 8b 4c 24 48               	movq	72(%rsp), %rcx
   25165: 48 8d 35 8c 5b 01 00         	leaq	88972(%rip), %rsi       # 0x3acf8 <CSWTCH.126+0x13f8>
   2516c: e8 5f 2f fe ff               	callq	0x80d0 <libbpf_print>
   25171: e9 d8 fa ff ff               	jmp	0x24c4e <usdt_manager_attach_usdt+0xe5e>
; 	struct elf_seg *segs = NULL, *vma_segs = NULL;
   25176: 48 c7 44 24 50 00 00 00 00   	movq	$0, 80(%rsp)
; 		pr_warn("usdt: failed to find PT_LOAD program headers in '%s'\n", path);
   2517f: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   25184: 48 8d 35 d5 56 01 00         	leaq	87765(%rip), %rsi       # 0x3a860 <CSWTCH.126+0xf60>
   2518b: 31 ff                        	xorl	%edi, %edi
   2518d: 31 c0                        	xorl	%eax, %eax
   2518f: e8 3c 2f fe ff               	callq	0x80d0 <libbpf_print>
; 		return -ESRCH;
   25194: 41 b8 fd ff ff ff            	movl	$4294967293, %r8d       # imm = 0xFFFFFFFD
   2519a: e9 d8 fb ff ff               	jmp	0x24d77 <usdt_manager_attach_usdt+0xf87>
   2519f: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
; 				pr_warn("usdt: matched ELF binary '%s' segment [0x%lx, 0x%lx] for semaphore of '%s:%s' at 0x%lx is executable\n",
   251a7: 48 8d 35 5a 59 01 00         	leaq	88410(%rip), %rsi       # 0x3ab08 <CSWTCH.126+0x1208>
   251ae: 53                           	pushq	%rbx
   251af: ff 74 24 70                  	pushq	112(%rsp)
   251b3: 4c 8b 4c 24 58               	movq	88(%rsp), %r9
   251b8: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   251bd: e9 12 ff ff ff               	jmp	0x250d4 <usdt_manager_attach_usdt+0x12e4>
; 				pr_warn("usdt: kernel doesn't support USDT semaphore refcounting for '%s:%s' in '%s'\n",
   251c2: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   251c7: 48 8b 4c 24 68               	movq	104(%rsp), %rcx
   251cc: 49 89 c7                     	movq	%rax, %r15
   251cf: 31 ff                        	xorl	%edi, %edi
   251d1: 48 8b 54 24 48               	movq	72(%rsp), %rdx
   251d6: 48 8d 35 d3 58 01 00         	leaq	88275(%rip), %rsi       # 0x3aab0 <CSWTCH.126+0x11b0>
   251dd: 31 c0                        	xorl	%eax, %eax
   251df: e8 ec 2e fe ff               	callq	0x80d0 <libbpf_print>
; 				err = -ENOTSUP;
   251e4: 41 b8 a1 ff ff ff            	movl	$4294967201, %r8d       # imm = 0xFFFFFFA1
; 				goto err_out;
   251ea: e9 c3 f1 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 		err = -errno;
   251ef: e8 fc 04 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	errno = -err;
   251f4: 41 f7 dd                     	negl	%r13d
   251f7: 45 31 e4                     	xorl	%r12d, %r12d
; 	*out_targets = NULL;
   251fa: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	errno = -err;
   25203: 44 89 ac 24 b0 00 00 00      	movl	%r13d, 176(%rsp)
; 		err = -errno;
   2520b: 48 89 c3                     	movq	%rax, %rbx
   2520e: e9 71 f4 ff ff               	jmp	0x24684 <usdt_manager_attach_usdt+0x894>
; 				pr_warn("usdt: attaching to shared libraries without specific PID is not supported on current kernel\n");
   25213: 49 89 ff                     	movq	%rdi, %r15
   25216: 48 8d 35 33 57 01 00         	leaq	87859(%rip), %rsi       # 0x3a950 <CSWTCH.126+0x1050>
   2521d: 31 ff                        	xorl	%edi, %edi
   2521f: 31 c0                        	xorl	%eax, %eax
   25221: e8 aa 2e fe ff               	callq	0x80d0 <libbpf_print>
; 				err = -ENOTSUP;
   25226: 41 b8 a1 ff ff ff            	movl	$4294967201, %r8d       # imm = 0xFFFFFFA1
; 				goto err_out;
   2522c: e9 81 f1 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 		pr_warn("usdt: ELF endianness mismatch for '%s'\n", path);
   25231: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   25236: 48 8d 35 1b 55 01 00         	leaq	87323(%rip), %rsi       # 0x3a758 <CSWTCH.126+0xe58>
   2523d: 31 ff                        	xorl	%edi, %edi
   2523f: 31 c0                        	xorl	%eax, %eax
   25241: e8 8a 2e fe ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
   25246: e9 1a f4 ff ff               	jmp	0x24665 <usdt_manager_attach_usdt+0x875>
   2524b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		err = -errno;
   25250: e8 9b 04 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	errno = -err;
   25255: 41 f7 de                     	negl	%r14d
   25258: 44 89 b4 24 b0 00 00 00      	movl	%r14d, 176(%rsp)
; 		err = -errno;
   25260: 48 89 c3                     	movq	%rax, %rbx
   25263: e9 e6 f9 ff ff               	jmp	0x24c4e <usdt_manager_attach_usdt+0xe5e>
; 			err = -ENOMEM;
   25268: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   25270: 41 b8 f4 ff ff ff            	movl	$4294967284, %r8d       # imm = 0xFFFFFFF4
   25276: e9 37 f1 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 					pr_warn("usdt: failed to get memory segments in PID %d for shared library '%s': %d\n",
   2527b: 48 8b 4c 24 08               	movq	8(%rsp), %rcx
   25280: 8b 54 24 3c                  	movl	60(%rsp), %edx
   25284: 41 89 c0                     	movl	%eax, %r8d
   25287: 89 04 24                     	movl	%eax, (%rsp)
   2528a: 48 8d 35 27 57 01 00         	leaq	87847(%rip), %rsi       # 0x3a9b8 <CSWTCH.126+0x10b8>
   25291: 31 ff                        	xorl	%edi, %edi
   25293: 31 c0                        	xorl	%eax, %eax
   25295: 4c 8b bc 24 a8 00 00 00      	movq	168(%rsp), %r15
   2529d: e8 2e 2e fe ff               	callq	0x80d0 <libbpf_print>
; 					goto err_out;
   252a2: 44 8b 04 24                  	movl	(%rsp), %r8d
   252a6: e9 07 f1 ff ff               	jmp	0x243b2 <usdt_manager_attach_usdt+0x5c2>
; 		pr_warn("usdt: unsupported type of ELF binary '%s' (%d), only ET_EXEC and ET_DYN are supported\n",
   252ab: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   252b0: 0f b7 c8                     	movzwl	%ax, %ecx
   252b3: 48 8d 35 3e 54 01 00         	leaq	87102(%rip), %rsi       # 0x3a6f8 <CSWTCH.126+0xdf8>
   252ba: 31 ff                        	xorl	%edi, %edi
   252bc: 31 c0                        	xorl	%eax, %eax
   252be: e8 0d 2e fe ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
   252c3: e9 9d f3 ff ff               	jmp	0x24665 <usdt_manager_attach_usdt+0x875>
; 		err = -errno;
   252c8: e8 23 04 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   252cd: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
   252d6: c7 84 24 b0 00 00 00 16 00 00 00     	movl	$22, 176(%rsp)
   252e1: 48 89 c3                     	movq	%rax, %rbx
   252e4: e9 9b f3 ff ff               	jmp	0x24684 <usdt_manager_attach_usdt+0x894>
   252e9: e8 02 04 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   252ee: c7 84 24 b0 00 00 00 0c 00 00 00     	movl	$12, 176(%rsp)
   252f9: 48 89 c3                     	movq	%rax, %rbx
   252fc: e9 83 f3 ff ff               	jmp	0x24684 <usdt_manager_attach_usdt+0x894>
; }
   25301: e8 fa 04 fe ff               	callq	0x5800 <.plt.sec+0x190>
   25306: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000025310 <alloc_zero_tailing_info>:
; {
   25310: 41 57                        	pushq	%r15
   25312: 41 56                        	pushq	%r14
   25314: 49 89 fe                     	movq	%rdi, %r14
   25317: 89 f7                        	movl	%esi, %edi
   25319: 41 55                        	pushq	%r13
   2531b: 49 89 ff                     	movq	%rdi, %r15
   2531e: 41 54                        	pushq	%r12
   25320: 55                           	pushq	%rbp
   25321: 89 d5                        	movl	%edx, %ebp
   25323: 53                           	pushq	%rbx
   25324: 89 cb                        	movl	%ecx, %ebx
   25326: 48 83 ec 18                  	subq	$24, %rsp
   2532a: 89 7c 24 04                  	movl	%edi, 4(%rsp)
; 	__u64 info_len = (__u64)actual_rec_size * cnt;
   2532e: 48 0f af fd                  	imulq	%rbp, %rdi
; 	info = malloc(info_len);
   25332: e8 59 07 fe ff               	callq	0x5a90 <.plt.sec+0x420>
   25337: 48 89 44 24 08               	movq	%rax, 8(%rsp)
; 	if (!info)
   2533c: 48 85 c0                     	testq	%rax, %rax
   2533f: 74 44                        	je	0x25385 <alloc_zero_tailing_info+0x75>
; 	for (i = 0; i < cnt; i++) {
   25341: 45 85 ff                     	testl	%r15d, %r15d
   25344: 74 3f                        	je	0x25385 <alloc_zero_tailing_info+0x75>
   25346: 49 89 ed                     	movq	%rbp, %r13
; 		memcpy(nrecord, orecord, expected_rec_size);
   25349: 41 89 dc                     	movl	%ebx, %r12d
; 	for (i = 0; i < cnt; i++) {
   2534c: 45 31 ff                     	xorl	%r15d, %r15d
; 		memset(nrecord + expected_rec_size, 0,
   2534f: 41 29 dd                     	subl	%ebx, %r13d
   25352: 48 89 c3                     	movq	%rax, %rbx
   25355: 0f 1f 00                     	nopl	(%rax)
;   return __builtin___memcpy_chk (__dest, __src, __len,
   25358: 4c 89 f6                     	movq	%r14, %rsi
   2535b: 48 89 df                     	movq	%rbx, %rdi
   2535e: 4c 89 e2                     	movq	%r12, %rdx
; 		orecord += actual_rec_size;
   25361: 49 01 ee                     	addq	%rbp, %r14
;   return __builtin___memcpy_chk (__dest, __src, __len,
   25364: e8 d7 06 fe ff               	callq	0x5a40 <.plt.sec+0x3d0>
;   return __builtin___memset_chk (__dest, __ch, __len,
   25369: 4a 8d 3c 23                  	leaq	(%rbx,%r12), %rdi
   2536d: 4c 89 ea                     	movq	%r13, %rdx
   25370: 31 f6                        	xorl	%esi, %esi
   25372: e8 49 05 fe ff               	callq	0x58c0 <.plt.sec+0x250>
; 		nrecord += actual_rec_size;
   25377: 48 01 eb                     	addq	%rbp, %rbx
; 	for (i = 0; i < cnt; i++) {
   2537a: 41 83 c7 01                  	addl	$1, %r15d
   2537e: 44 39 7c 24 04               	cmpl	%r15d, 4(%rsp)
   25383: 75 d3                        	jne	0x25358 <alloc_zero_tailing_info+0x48>
; }
   25385: 48 8b 44 24 08               	movq	8(%rsp), %rax
   2538a: 48 83 c4 18                  	addq	$24, %rsp
   2538e: 5b                           	popq	%rbx
   2538f: 5d                           	popq	%rbp
   25390: 41 5c                        	popq	%r12
   25392: 41 5d                        	popq	%r13
   25394: 41 5e                        	popq	%r14
   25396: 41 5f                        	popq	%r15
   25398: c3                           	retq
   25399: 0f 1f 80 00 00 00 00         	nopl	(%rax)

00000000000253a0 <bpf_obj_get_next_id>:
; {
   253a0: 53                           	pushq	%rbx
; 	return syscall(__NR_bpf, cmd, attr, size);
   253a1: b9 0c 00 00 00               	movl	$12, %ecx
; {
   253a6: 48 89 f3                     	movq	%rsi, %rbx
   253a9: 89 d6                        	movl	%edx, %esi
   253ab: 48 81 ec a0 00 00 00         	subq	$160, %rsp
   253b2: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   253bb: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   253c3: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   253c5: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.start_id = start_id;
   253c8: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   253cb: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   253d0: 48 c7 44 24 04 00 00 00 00   	movq	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   253d9: e8 02 06 fe ff               	callq	0x59e0 <.plt.sec+0x370>
   253de: 41 89 c0                     	movl	%eax, %r8d
; 	if (!err)
   253e1: 85 c0                        	testl	%eax, %eax
   253e3: 75 2b                        	jne	0x25410 <bpf_obj_get_next_id+0x70>
; 		*next_id = attr.next_id;
   253e5: 8b 44 24 04                  	movl	4(%rsp), %eax
   253e9: 89 03                        	movl	%eax, (%rbx)
; }
   253eb: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   253f3: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   253fc: 75 21                        	jne	0x2541f <bpf_obj_get_next_id+0x7f>
   253fe: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
   25405: 44 89 c0                     	movl	%r8d, %eax
   25408: 5b                           	popq	%rbx
   25409: c3                           	retq
   2540a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return ret < 0 ? -errno : ret;
   25410: 79 d9                        	jns	0x253eb <bpf_obj_get_next_id+0x4b>
   25412: e8 d9 02 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   25417: 44 8b 00                     	movl	(%rax), %r8d
   2541a: 41 f7 d8                     	negl	%r8d
; 	return libbpf_err_errno(err);
   2541d: eb cc                        	jmp	0x253eb <bpf_obj_get_next_id+0x4b>
; }
   2541f: e8 dc 03 fe ff               	callq	0x5800 <.plt.sec+0x190>
   25424: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2542f: 90                           	nop

0000000000025430 <bpf_map_batch_common>:
; {
   25430: 41 54                        	pushq	%r12
   25432: 41 89 fa                     	movl	%edi, %r10d
   25435: 89 f7                        	movl	%esi, %edi
   25437: 48 89 d6                     	movq	%rdx, %rsi
   2543a: 53                           	pushq	%rbx
   2543b: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   25442: 48 8b 94 24 c8 00 00 00      	movq	200(%rsp), %rdx
   2544a: 48 8b 9c 24 c0 00 00 00      	movq	192(%rsp), %rbx
   25452: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2545b: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   25463: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_map_batch_opts))
   25465: 48 85 d2                     	testq	%rdx, %rdx
   25468: 0f 84 fa 00 00 00            	je	0x25568 <bpf_map_batch_common+0x138>
   2546e: 4c 8b 22                     	movq	(%rdx), %r12
; 	if (user_sz < sizeof(size_t)) {
   25471: 49 83 fc 07                  	cmpq	$7, %r12
   25475: 0f 86 1d 01 00 00            	jbe	0x25598 <bpf_map_batch_common+0x168>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   2547b: 4d 8d 5c 24 e8               	leaq	-24(%r12), %r11
   25480: 48 8d 42 18                  	leaq	24(%rdx), %rax
; 	while (len > 0) {
   25484: 4d 85 db                     	testq	%r11, %r11
   25487: 7e 47                        	jle	0x254d0 <bpf_map_batch_common+0xa0>
   25489: 4e 8d 1c 22                  	leaq	(%rdx,%r12), %r11
   2548d: eb 0a                        	jmp	0x25499 <bpf_map_batch_common+0x69>
   2548f: 90                           	nop
; 		p++;
   25490: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   25494: 49 39 c3                     	cmpq	%rax, %r11
   25497: 74 37                        	je	0x254d0 <bpf_map_batch_common+0xa0>
; 		if (*p)
   25499: 80 38 00                     	cmpb	$0, (%rax)
   2549c: 74 f2                        	je	0x25490 <bpf_map_batch_common+0x60>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   2549e: 48 8d 15 4d 5a 01 00         	leaq	88653(%rip), %rdx       # 0x3aef2 <CSWTCH.126+0x15f2>
   254a5: 48 8d 35 64 eb 00 00         	leaq	60260(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   254ac: 31 ff                        	xorl	%edi, %edi
   254ae: 31 c0                        	xorl	%eax, %eax
   254b0: e8 1b 2c fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   254b5: e8 36 02 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   254ba: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
; 		errno = -ret;
   254c0: c7 00 16 00 00 00            	movl	$22, (%rax)
   254c6: eb 78                        	jmp	0x25540 <bpf_map_batch_common+0x110>
   254c8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	attr.batch.count = *count;
   254d0: 8b 03                        	movl	(%rbx), %eax
; 	attr.batch.map_fd = fd;
   254d2: 89 7c 24 24                  	movl	%edi, 36(%rsp)
; 	attr.batch.in_batch = ptr_to_u64(in_batch);
   254d6: 48 89 34 24                  	movq	%rsi, (%rsp)
; 	attr.batch.count = *count;
   254da: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 	attr.batch.elem_flags  = OPTS_GET(opts, elem_flags, 0);
   254de: 31 c0                        	xorl	%eax, %eax
; 	attr.batch.out_batch = ptr_to_u64(out_batch);
   254e0: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
; 	attr.batch.keys = ptr_to_u64(keys);
   254e5: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
; 	attr.batch.values = ptr_to_u64(values);
   254ea: 4c 89 4c 24 18               	movq	%r9, 24(%rsp)
; 	attr.batch.elem_flags  = OPTS_GET(opts, elem_flags, 0);
   254ef: 49 83 fc 0f                  	cmpq	$15, %r12
   254f3: 76 04                        	jbe	0x254f9 <bpf_map_batch_common+0xc9>
   254f5: 48 8b 42 08                  	movq	8(%rdx), %rax
   254f9: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 	attr.batch.flags = OPTS_GET(opts, flags, 0);
   254fe: 49 83 fc 17                  	cmpq	$23, %r12
   25502: 0f 86 86 00 00 00            	jbe	0x2558e <bpf_map_batch_common+0x15e>
   25508: 48 8b 42 10                  	movq	16(%rdx), %rax
   2550c: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   25511: 48 89 e2                     	movq	%rsp, %rdx
   25514: b9 38 00 00 00               	movl	$56, %ecx
   25519: 44 89 d6                     	movl	%r10d, %esi
   2551c: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   25521: 31 c0                        	xorl	%eax, %eax
   25523: e8 b8 04 fe ff               	callq	0x59e0 <.plt.sec+0x370>
; 	*count = attr.batch.count;
   25528: 8b 54 24 20                  	movl	32(%rsp), %edx
; 	return syscall(__NR_bpf, cmd, attr, size);
   2552c: 41 89 c0                     	movl	%eax, %r8d
; 	*count = attr.batch.count;
   2552f: 89 13                        	movl	%edx, (%rbx)
; 	return ret < 0 ? -errno : ret;
   25531: 85 c0                        	testl	%eax, %eax
   25533: 79 0b                        	jns	0x25540 <bpf_map_batch_common+0x110>
   25535: e8 b6 01 fe ff               	callq	0x56f0 <.plt.sec+0x80>
   2553a: 44 8b 00                     	movl	(%rax), %r8d
   2553d: 41 f7 d8                     	negl	%r8d
; }
   25540: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   25548: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   25551: 75 62                        	jne	0x255b5 <bpf_map_batch_common+0x185>
   25553: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   2555a: 44 89 c0                     	movl	%r8d, %eax
   2555d: 5b                           	popq	%rbx
   2555e: 41 5c                        	popq	%r12
   25560: c3                           	retq
   25561: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	attr.batch.count = *count;
   25568: 8b 03                        	movl	(%rbx), %eax
; 	attr.batch.map_fd = fd;
   2556a: 89 7c 24 24                  	movl	%edi, 36(%rsp)
; 	attr.batch.in_batch = ptr_to_u64(in_batch);
   2556e: 48 89 34 24                  	movq	%rsi, (%rsp)
; 	attr.batch.out_batch = ptr_to_u64(out_batch);
   25572: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
; 	attr.batch.keys = ptr_to_u64(keys);
   25577: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
; 	attr.batch.values = ptr_to_u64(values);
   2557c: 4c 89 4c 24 18               	movq	%r9, 24(%rsp)
; 	attr.batch.count = *count;
   25581: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 	attr.batch.elem_flags  = OPTS_GET(opts, elem_flags, 0);
   25585: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	attr.batch.flags = OPTS_GET(opts, flags, 0);
   2558e: 31 c0                        	xorl	%eax, %eax
   25590: e9 77 ff ff ff               	jmp	0x2550c <bpf_map_batch_common+0xdc>
   25595: 0f 1f 00                     	nopl	(%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   25598: 4c 89 e1                     	movq	%r12, %rcx
   2559b: 48 8d 15 50 59 01 00         	leaq	88400(%rip), %rdx       # 0x3aef2 <CSWTCH.126+0x15f2>
   255a2: 48 8d 35 0f ea 00 00         	leaq	59919(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   255a9: 31 ff                        	xorl	%edi, %edi
   255ab: e8 20 2b fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   255b0: e9 00 ff ff ff               	jmp	0x254b5 <bpf_map_batch_common+0x85>
; }
   255b5: e8 46 02 fe ff               	callq	0x5800 <.plt.sec+0x190>
   255ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

00000000000255c0 <sys_bpf_prog_load>:
; {
   255c0: f3 0f 1e fa                  	endbr64
   255c4: 41 57                        	pushq	%r15
   255c6: 41 56                        	pushq	%r14
   255c8: 41 55                        	pushq	%r13
   255ca: 41 54                        	pushq	%r12
   255cc: 49 89 fc                     	movq	%rdi, %r12
   255cf: 55                           	pushq	%rbp
   255d0: 89 f5                        	movl	%esi, %ebp
   255d2: 53                           	pushq	%rbx
   255d3: 89 d3                        	movl	%edx, %ebx
   255d5: 48 83 ec 18                  	subq	$24, %rsp
   255d9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return syscall(__NR_bpf, cmd, attr, size);
   255e0: 89 e9                        	movl	%ebp, %ecx
   255e2: 4c 89 e2                     	movq	%r12, %rdx
   255e5: be 05 00 00 00               	movl	$5, %esi
   255ea: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   255ef: 31 c0                        	xorl	%eax, %eax
   255f1: e8 ea 03 fe ff               	callq	0x59e0 <.plt.sec+0x370>
   255f6: 41 89 c6                     	movl	%eax, %r14d
; 	if (fd < 0)
   255f9: 85 c0                        	testl	%eax, %eax
   255fb: 78 1b                        	js	0x25618 <sys_bpf_prog_load+0x58>
; 	if (fd < 3) {
   255fd: 83 f8 02                     	cmpl	$2, %eax
   25600: 7e 2e                        	jle	0x25630 <sys_bpf_prog_load+0x70>
; }
   25602: 48 83 c4 18                  	addq	$24, %rsp
   25606: 44 89 f0                     	movl	%r14d, %eax
   25609: 5b                           	popq	%rbx
   2560a: 5d                           	popq	%rbp
   2560b: 41 5c                        	popq	%r12
   2560d: 41 5d                        	popq	%r13
   2560f: 41 5e                        	popq	%r14
   25611: 41 5f                        	popq	%r15
   25613: c3                           	retq
   25614: 0f 1f 40 00                  	nopl	(%rax)
; 		saved_errno = errno;
   25618: e8 d3 00 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 	} while (fd < 0 && errno == EAGAIN && --attempts > 0);
   2561d: 44 8b 38                     	movl	(%rax), %r15d
   25620: 41 83 ff 0b                  	cmpl	$11, %r15d
   25624: 75 dc                        	jne	0x25602 <sys_bpf_prog_load+0x42>
   25626: 83 eb 01                     	subl	$1, %ebx
   25629: 85 db                        	testl	%ebx, %ebx
   2562b: 7f b3                        	jg	0x255e0 <sys_bpf_prog_load+0x20>
   2562d: eb d3                        	jmp	0x25602 <sys_bpf_prog_load+0x42>
   2562f: 90                           	nop
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   25630: 89 c7                        	movl	%eax, %edi
   25632: ba 03 00 00 00               	movl	$3, %edx
   25637: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   2563c: 31 c0                        	xorl	%eax, %eax
   2563e: e8 2d 05 fe ff               	callq	0x5b70 <.plt.sec+0x500>
   25643: 41 89 c5                     	movl	%eax, %r13d
; 		saved_errno = errno;
   25646: e8 a5 00 fe ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   2564b: 44 89 f7                     	movl	%r14d, %edi
; 		saved_errno = errno;
   2564e: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   25653: 44 8b 38                     	movl	(%rax), %r15d
; 		close(old_fd);
   25656: e8 a5 02 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   2565b: 45 85 ed                     	testl	%r13d, %r13d
   2565e: 78 08                        	js	0x25668 <sys_bpf_prog_load+0xa8>
   25660: 45 89 ee                     	movl	%r13d, %r14d
; 	return fd;
   25663: eb 9d                        	jmp	0x25602 <sys_bpf_prog_load+0x42>
   25665: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   25668: 44 89 f9                     	movl	%r15d, %ecx
   2566b: 44 89 f2                     	movl	%r14d, %edx
   2566e: 31 c0                        	xorl	%eax, %eax
   25670: 31 ff                        	xorl	%edi, %edi
   25672: f7 d9                        	negl	%ecx
   25674: 48 8d 35 4d 59 01 00         	leaq	88397(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
; 			errno = saved_errno;
   2567b: 45 89 ee                     	movl	%r13d, %r14d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   2567e: e8 4d 2a fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   25683: 48 8b 44 24 08               	movq	8(%rsp), %rax
   25688: 44 89 38                     	movl	%r15d, (%rax)
   2568b: eb 93                        	jmp	0x25620 <sys_bpf_prog_load+0x60>
   2568d: 0f 1f 00                     	nopl	(%rax)

0000000000025690 <probe_memcg_account>:
; {
   25690: f3 0f 1e fa                  	endbr64
   25694: 41 56                        	pushq	%r14
;   return __builtin___memset_chk (__dest, __ch, __len,
   25696: b9 0b 00 00 00               	movl	$11, %ecx
; 	return syscall(__NR_bpf, cmd, attr, size);
   2569b: be 05 00 00 00               	movl	$5, %esi
; {
   256a0: 41 55                        	pushq	%r13
   256a2: 41 54                        	pushq	%r12
; 	return 0;
   256a4: 45 31 e4                     	xorl	%r12d, %r12d
; {
   256a7: 55                           	pushq	%rbp
   256a8: 53                           	pushq	%rbx
   256a9: 48 81 ec b0 00 00 00         	subq	$176, %rsp
; 	struct bpf_insn insns[] = {
   256b0: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   256b9: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
   256c1: 48 b8 85 00 00 00 a0 00 00 00	movabsq	$687194767493, %rax     # imm = 0xA000000085
;   return __builtin___memset_chk (__dest, __ch, __len,
   256cb: 48 8d 54 24 28               	leaq	40(%rsp), %rdx
   256d0: 4c 8d 44 24 10               	leaq	16(%rsp), %r8
; 	struct bpf_insn insns[] = {
   256d5: 48 c7 44 24 08 95 00 00 00   	movq	$149, 8(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   256de: 48 89 d7                     	movq	%rdx, %rdi
; 	return syscall(__NR_bpf, cmd, attr, size);
   256e1: 4c 89 c2                     	movq	%r8, %rdx
; 	struct bpf_insn insns[] = {
   256e4: 48 89 04 24                  	movq	%rax, (%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   256e8: 31 c0                        	xorl	%eax, %eax
   256ea: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	return (__u64) (unsigned long) ptr;
   256ed: 48 89 e0                     	movq	%rsp, %rax
; 	return syscall(__NR_bpf, cmd, attr, size);
   256f0: b9 74 00 00 00               	movl	$116, %ecx
; 	return (__u64) (unsigned long) ptr;
   256f5: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	attr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;
   256fa: 48 b8 01 00 00 00 02 00 00 00	movabsq	$8589934593, %rax       # imm = 0x200000001
   25704: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	attr.license = ptr_to_u64("GPL");
   25709: 48 8d 05 2a c5 00 00         	leaq	50474(%rip), %rax       # 0x31c3a <_IO_stdin_used+0x1c3a>
   25710: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   25715: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   25717: c7 07 00 00 00 00            	movl	$0, (%rdi)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2571d: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   25722: e8 b9 02 fe ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   25727: 85 c0                        	testl	%eax, %eax
   25729: 78 15                        	js	0x25740 <probe_memcg_account+0xb0>
   2572b: 89 c5                        	movl	%eax, %ebp
; 	if (fd < 3) {
   2572d: 83 f8 02                     	cmpl	$2, %eax
   25730: 7e 3e                        	jle	0x25770 <probe_memcg_account+0xe0>
; 		close(prog_fd);
   25732: 89 ef                        	movl	%ebp, %edi
; 		return 1;
   25734: 41 bc 01 00 00 00            	movl	$1, %r12d
; 		close(prog_fd);
   2573a: e8 c1 01 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 		return 1;
   2573f: 90                           	nop
; }
   25740: 48 8b 84 24 a8 00 00 00      	movq	168(%rsp), %rax
   25748: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   25751: 75 7d                        	jne	0x257d0 <probe_memcg_account+0x140>
   25753: 48 81 c4 b0 00 00 00         	addq	$176, %rsp
   2575a: 44 89 e0                     	movl	%r12d, %eax
   2575d: 5b                           	popq	%rbx
   2575e: 5d                           	popq	%rbp
   2575f: 41 5c                        	popq	%r12
   25761: 41 5d                        	popq	%r13
   25763: 41 5e                        	popq	%r14
   25765: c3                           	retq
   25766: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   25770: 89 c7                        	movl	%eax, %edi
   25772: ba 03 00 00 00               	movl	$3, %edx
   25777: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   2577c: 31 c0                        	xorl	%eax, %eax
   2577e: e8 ed 03 fe ff               	callq	0x5b70 <.plt.sec+0x500>
   25783: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   25785: e8 66 ff fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   2578a: 89 ef                        	movl	%ebp, %edi
; 		saved_errno = errno;
   2578c: 44 8b 30                     	movl	(%rax), %r14d
   2578f: 49 89 c5                     	movq	%rax, %r13
; 		close(old_fd);
   25792: e8 69 01 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   25797: 85 db                        	testl	%ebx, %ebx
   25799: 78 15                        	js	0x257b0 <probe_memcg_account+0x120>
   2579b: 89 dd                        	movl	%ebx, %ebp
; 		return 1;
   2579d: 41 bc 01 00 00 00            	movl	$1, %r12d
; 		close(prog_fd);
   257a3: 89 ef                        	movl	%ebp, %edi
   257a5: e8 56 01 fe ff               	callq	0x5900 <.plt.sec+0x290>
; 		return 1;
   257aa: eb 94                        	jmp	0x25740 <probe_memcg_account+0xb0>
   257ac: 0f 1f 40 00                  	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   257b0: 44 89 f1                     	movl	%r14d, %ecx
   257b3: 89 ea                        	movl	%ebp, %edx
   257b5: 48 8d 35 0c 58 01 00         	leaq	88076(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   257bc: 31 ff                        	xorl	%edi, %edi
   257be: f7 d9                        	negl	%ecx
   257c0: 31 c0                        	xorl	%eax, %eax
   257c2: e8 09 29 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   257c7: 45 89 75 00                  	movl	%r14d, (%r13)
   257cb: e9 70 ff ff ff               	jmp	0x25740 <probe_memcg_account+0xb0>
; }
   257d0: e8 2b 00 fe ff               	callq	0x5800 <.plt.sec+0x190>
   257d5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

00000000000257e0 <libbpf_set_memlock_rlim>:
; {
   257e0: f3 0f 1e fa                  	endbr64
; 	if (memlock_bumped)
   257e4: 80 3d 9d 1a 02 00 00         	cmpb	$0, 137885(%rip)        # 0x47288 <memlock_bumped>
   257eb: 75 0a                        	jne	0x257f7 <libbpf_set_memlock_rlim+0x17>
; 	memlock_rlim = memlock_bytes;
   257ed: 48 89 3d fc 19 02 00         	movq	%rdi, 137724(%rip)      # 0x471f0 <memlock_rlim>
; 	return 0;
   257f4: 31 c0                        	xorl	%eax, %eax
; }
   257f6: c3                           	retq
; {
   257f7: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   257fb: e8 f0 fe fd ff               	callq	0x56f0 <.plt.sec+0x80>
   25800: c7 00 10 00 00 00            	movl	$16, (%rax)
; 		return libbpf_err(-EBUSY);
   25806: b8 f0 ff ff ff               	movl	$4294967280, %eax       # imm = 0xFFFFFFF0
; }
   2580b: 48 83 c4 08                  	addq	$8, %rsp
   2580f: c3                           	retq

0000000000025810 <bump_rlimit_memlock>:
; {
   25810: f3 0f 1e fa                  	endbr64
   25814: 48 83 ec 28                  	subq	$40, %rsp
   25818: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   25821: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   25826: 31 c0                        	xorl	%eax, %eax
; 	if (memlock_bumped || kernel_supports(NULL, FEAT_MEMCG_ACCOUNT))
   25828: 80 3d 59 1a 02 00 00         	cmpb	$0, 137817(%rip)        # 0x47288 <memlock_bumped>
   2582f: 74 1f                        	je	0x25850 <bump_rlimit_memlock+0x40>
; 		return 0;
   25831: 31 c0                        	xorl	%eax, %eax
; }
   25833: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   25838: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   25841: 75 55                        	jne	0x25898 <bump_rlimit_memlock+0x88>
   25843: 48 83 c4 28                  	addq	$40, %rsp
   25847: c3                           	retq
   25848: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (memlock_bumped || kernel_supports(NULL, FEAT_MEMCG_ACCOUNT))
   25850: 31 ff                        	xorl	%edi, %edi
   25852: be 0f 00 00 00               	movl	$15, %esi
   25857: e8 b4 6b fe ff               	callq	0xc410 <kernel_supports>
   2585c: 84 c0                        	testb	%al, %al
   2585e: 75 d1                        	jne	0x25831 <bump_rlimit_memlock+0x21>
; 	if (memlock_rlim == 0)
   25860: 48 8b 05 89 19 02 00         	movq	137609(%rip), %rax      # 0x471f0 <memlock_rlim>
; 	memlock_bumped = true;
   25867: c6 05 1a 1a 02 00 01         	movb	$1, 137754(%rip)        # 0x47288 <memlock_bumped>
; 	if (memlock_rlim == 0)
   2586e: 48 85 c0                     	testq	%rax, %rax
   25871: 74 be                        	je	0x25831 <bump_rlimit_memlock+0x21>
; 	if (setrlimit(RLIMIT_MEMLOCK, &rlim))
   25873: 48 89 e6                     	movq	%rsp, %rsi
   25876: bf 08 00 00 00               	movl	$8, %edi
; 	rlim.rlim_cur = rlim.rlim_max = memlock_rlim;
   2587b: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   25880: 48 89 04 24                  	movq	%rax, (%rsp)
; 	if (setrlimit(RLIMIT_MEMLOCK, &rlim))
   25884: e8 17 00 fe ff               	callq	0x58a0 <.plt.sec+0x230>
   25889: 85 c0                        	testl	%eax, %eax
   2588b: 74 a4                        	je	0x25831 <bump_rlimit_memlock+0x21>
; 		return -errno;
   2588d: e8 5e fe fd ff               	callq	0x56f0 <.plt.sec+0x80>
   25892: 8b 00                        	movl	(%rax), %eax
   25894: f7 d8                        	negl	%eax
   25896: eb 9b                        	jmp	0x25833 <bump_rlimit_memlock+0x23>
; }
   25898: e8 63 ff fd ff               	callq	0x5800 <.plt.sec+0x190>
   2589d: 0f 1f 00                     	nopl	(%rax)

00000000000258a0 <bpf_map_create>:
; {
   258a0: f3 0f 1e fa                  	endbr64
   258a4: 41 57                        	pushq	%r15
   258a6: 49 89 f7                     	movq	%rsi, %r15
   258a9: 41 56                        	pushq	%r14
   258ab: 41 89 fe                     	movl	%edi, %r14d
   258ae: 41 55                        	pushq	%r13
   258b0: 45 89 c5                     	movl	%r8d, %r13d
   258b3: 41 54                        	pushq	%r12
   258b5: 41 89 cc                     	movl	%ecx, %r12d
   258b8: 55                           	pushq	%rbp
   258b9: 89 d5                        	movl	%edx, %ebp
   258bb: 53                           	pushq	%rbx
   258bc: 4c 89 cb                     	movq	%r9, %rbx
   258bf: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   258c6: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   258cf: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   258d7: 31 c0                        	xorl	%eax, %eax
; 	bump_rlimit_memlock();
   258d9: e8 32 ff ff ff               	callq	0x25810 <bump_rlimit_memlock>
;   return __builtin___memset_chk (__dest, __ch, __len,
   258de: 66 0f ef c0                  	pxor	%xmm0, %xmm0
   258e2: 48 c7 44 24 40 00 00 00 00   	movq	$0, 64(%rsp)
   258eb: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
   258ef: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
   258f4: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   258f9: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	if (!OPTS_VALID(opts, bpf_map_create_opts))
   258fe: 48 85 db                     	testq	%rbx, %rbx
   25901: 74 6d                        	je	0x25970 <bpf_map_create+0xd0>
   25903: 48 8b 0b                     	movq	(%rbx), %rcx
; 	if (user_sz < sizeof(size_t)) {
   25906: 48 83 f9 07                  	cmpq	$7, %rcx
   2590a: 0f 86 e0 02 00 00            	jbe	0x25bf0 <bpf_map_create+0x350>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   25910: 48 8d 51 d0                  	leaq	-48(%rcx), %rdx
   25914: 48 8d 43 30                  	leaq	48(%rbx), %rax
; 	while (len > 0) {
   25918: 48 85 d2                     	testq	%rdx, %rdx
   2591b: 0f 8e 9f 01 00 00            	jle	0x25ac0 <bpf_map_create+0x220>
   25921: 48 8d 14 0b                  	leaq	(%rbx,%rcx), %rdx
   25925: eb 16                        	jmp	0x2593d <bpf_map_create+0x9d>
   25927: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		p++;
   25930: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   25934: 48 39 c2                     	cmpq	%rax, %rdx
   25937: 0f 84 83 01 00 00            	je	0x25ac0 <bpf_map_create+0x220>
; 		if (*p)
   2593d: 80 38 00                     	cmpb	$0, (%rax)
   25940: 74 ee                        	je	0x25930 <bpf_map_create+0x90>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   25942: 48 8d 15 bc 55 01 00         	leaq	87484(%rip), %rdx       # 0x3af05 <CSWTCH.126+0x1605>
   25949: 48 8d 35 c0 e6 00 00         	leaq	59072(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   25950: 31 ff                        	xorl	%edi, %edi
   25952: 31 c0                        	xorl	%eax, %eax
   25954: e8 77 27 fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   25959: e8 92 fd fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   2595e: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   25964: c7 00 16 00 00 00            	movl	$22, (%rax)
   2596a: e9 1b 01 00 00               	jmp	0x25a8a <bpf_map_create+0x1ea>
   2596f: 90                           	nop
; 	attr.map_type = map_type;
   25970: 44 89 34 24                  	movl	%r14d, (%rsp)
; 	if (map_name && kernel_supports(NULL, FEAT_PROG_NAME))
   25974: 4d 85 ff                     	testq	%r15, %r15
   25977: 0f 84 a3 00 00 00            	je	0x25a20 <bpf_map_create+0x180>
   2597d: 31 f6                        	xorl	%esi, %esi
   2597f: 31 ff                        	xorl	%edi, %edi
   25981: e8 8a 6a fe ff               	callq	0xc410 <kernel_supports>
   25986: 84 c0                        	testb	%al, %al
   25988: 0f 84 92 00 00 00            	je	0x25a20 <bpf_map_create+0x180>
; 	for (i = 0; i < sz && src[i]; i++)
   2598e: 31 c0                        	xorl	%eax, %eax
; 		dst[i] = src[i];
   25990: 48 8d 4c 24 1c               	leaq	28(%rsp), %rcx
   25995: 0f 1f 00                     	nopl	(%rax)
; 	for (i = 0; i < sz && src[i]; i++)
   25998: 41 0f b6 14 07               	movzbl	(%r15,%rax), %edx
   2599d: 84 d2                        	testb	%dl, %dl
   2599f: 74 0d                        	je	0x259ae <bpf_map_create+0x10e>
; 		dst[i] = src[i];
   259a1: 88 14 01                     	movb	%dl, (%rcx,%rax)
; 	for (i = 0; i < sz && src[i]; i++)
   259a4: 48 83 c0 01                  	addq	$1, %rax
   259a8: 48 83 f8 0f                  	cmpq	$15, %rax
   259ac: 75 ea                        	jne	0x25998 <bpf_map_create+0xf8>
; 	dst[i] = '\0';
   259ae: c6 44 04 1c 00               	movb	$0, 28(%rsp,%rax)
; 	attr.key_size = key_size;
   259b3: 89 6c 24 04                  	movl	%ebp, 4(%rsp)
; 	attr.value_size = value_size;
   259b7: 44 89 64 24 08               	movl	%r12d, 8(%rsp)
; 	attr.max_entries = max_entries;
   259bc: 44 89 6c 24 0c               	movl	%r13d, 12(%rsp)
; 	attr.btf_fd = OPTS_GET(opts, btf_fd, 0);
   259c1: 48 85 db                     	testq	%rbx, %rbx
   259c4: 74 68                        	je	0x25a2e <bpf_map_create+0x18e>
   259c6: 48 8b 0b                     	movq	(%rbx), %rcx
   259c9: 48 83 f9 0b                  	cmpq	$11, %rcx
   259cd: 0f 87 26 01 00 00            	ja	0x25af9 <bpf_map_create+0x259>
   259d3: c7 44 24 30 00 00 00 00      	movl	$0, 48(%rsp)
; 	attr.btf_key_type_id = OPTS_GET(opts, btf_key_type_id, 0);
   259db: c7 44 24 34 00 00 00 00      	movl	$0, 52(%rsp)
; 	attr.btf_value_type_id = OPTS_GET(opts, btf_value_type_id, 0);
   259e3: c7 44 24 38 00 00 00 00      	movl	$0, 56(%rsp)
; 	attr.btf_vmlinux_value_type_id = OPTS_GET(opts, btf_vmlinux_value_type_id, 0);
   259eb: c7 44 24 3c 00 00 00 00      	movl	$0, 60(%rsp)
; 	attr.inner_map_fd = OPTS_GET(opts, inner_map_fd, 0);
   259f3: c7 44 24 14 00 00 00 00      	movl	$0, 20(%rsp)
; 	attr.map_flags = OPTS_GET(opts, map_flags, 0);
   259fb: c7 44 24 10 00 00 00 00      	movl	$0, 16(%rsp)
; 	attr.map_extra = OPTS_GET(opts, map_extra, 0);
   25a03: 48 c7 44 24 40 00 00 00 00   	movq	$0, 64(%rsp)
; 	attr.numa_node = OPTS_GET(opts, numa_node, 0);
   25a0c: c7 44 24 18 00 00 00 00      	movl	$0, 24(%rsp)
; 	attr.map_ifindex = OPTS_GET(opts, map_ifindex, 0);
   25a14: 31 c0                        	xorl	%eax, %eax
   25a16: eb 44                        	jmp	0x25a5c <bpf_map_create+0x1bc>
   25a18: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	attr.key_size = key_size;
   25a20: 89 6c 24 04                  	movl	%ebp, 4(%rsp)
; 	attr.value_size = value_size;
   25a24: 44 89 64 24 08               	movl	%r12d, 8(%rsp)
; 	attr.max_entries = max_entries;
   25a29: 44 89 6c 24 0c               	movl	%r13d, 12(%rsp)
; 	attr.btf_fd = OPTS_GET(opts, btf_fd, 0);
   25a2e: 48 c7 44 24 30 00 00 00 00   	movq	$0, 48(%rsp)
; 	attr.map_ifindex = OPTS_GET(opts, map_ifindex, 0);
   25a37: 31 c0                        	xorl	%eax, %eax
; 	attr.btf_value_type_id = OPTS_GET(opts, btf_value_type_id, 0);
   25a39: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
; 	attr.map_extra = OPTS_GET(opts, map_extra, 0);
   25a42: 48 c7 44 24 40 00 00 00 00   	movq	$0, 64(%rsp)
; 	attr.map_flags = OPTS_GET(opts, map_flags, 0);
   25a4b: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 	attr.numa_node = OPTS_GET(opts, numa_node, 0);
   25a54: c7 44 24 18 00 00 00 00      	movl	$0, 24(%rsp)
; 	attr.map_ifindex = OPTS_GET(opts, map_ifindex, 0);
   25a5c: 89 44 24 2c                  	movl	%eax, 44(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   25a60: 48 89 e2                     	movq	%rsp, %rdx
   25a63: b9 48 00 00 00               	movl	$72, %ecx
   25a68: 31 f6                        	xorl	%esi, %esi
   25a6a: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   25a6f: 31 c0                        	xorl	%eax, %eax
   25a71: e8 6a ff fd ff               	callq	0x59e0 <.plt.sec+0x370>
   25a76: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 0)
   25a79: 85 c0                        	testl	%eax, %eax
   25a7b: 0f 88 0f 01 00 00            	js	0x25b90 <bpf_map_create+0x2f0>
; 	if (fd < 3) {
   25a81: 83 f8 02                     	cmpl	$2, %eax
   25a84: 0f 8e 16 01 00 00            	jle	0x25ba0 <bpf_map_create+0x300>
; }
   25a8a: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   25a92: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   25a9b: 0f 85 95 01 00 00            	jne	0x25c36 <bpf_map_create+0x396>
   25aa1: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   25aa8: 44 89 e0                     	movl	%r12d, %eax
   25aab: 5b                           	popq	%rbx
   25aac: 5d                           	popq	%rbp
   25aad: 41 5c                        	popq	%r12
   25aaf: 41 5d                        	popq	%r13
   25ab1: 41 5e                        	popq	%r14
   25ab3: 41 5f                        	popq	%r15
   25ab5: c3                           	retq
   25ab6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	attr.map_type = map_type;
   25ac0: 44 89 34 24                  	movl	%r14d, (%rsp)
; 	if (map_name && kernel_supports(NULL, FEAT_PROG_NAME))
   25ac4: 4d 85 ff                     	testq	%r15, %r15
   25ac7: 0f 84 0b 01 00 00            	je	0x25bd8 <bpf_map_create+0x338>
   25acd: 31 f6                        	xorl	%esi, %esi
   25acf: 31 ff                        	xorl	%edi, %edi
   25ad1: e8 3a 69 fe ff               	callq	0xc410 <kernel_supports>
   25ad6: 84 c0                        	testb	%al, %al
   25ad8: 0f 85 b0 fe ff ff            	jne	0x2598e <bpf_map_create+0xee>
; 	attr.key_size = key_size;
   25ade: 89 6c 24 04                  	movl	%ebp, 4(%rsp)
; 	attr.btf_fd = OPTS_GET(opts, btf_fd, 0);
   25ae2: 48 8b 0b                     	movq	(%rbx), %rcx
; 	attr.value_size = value_size;
   25ae5: 44 89 64 24 08               	movl	%r12d, 8(%rsp)
; 	attr.max_entries = max_entries;
   25aea: 44 89 6c 24 0c               	movl	%r13d, 12(%rsp)
; 	attr.btf_fd = OPTS_GET(opts, btf_fd, 0);
   25aef: 48 83 f9 0b                  	cmpq	$11, %rcx
   25af3: 0f 86 da fe ff ff            	jbe	0x259d3 <bpf_map_create+0x133>
   25af9: 8b 43 08                     	movl	8(%rbx), %eax
   25afc: 89 44 24 30                  	movl	%eax, 48(%rsp)
; 	attr.btf_key_type_id = OPTS_GET(opts, btf_key_type_id, 0);
   25b00: 48 83 f9 0f                  	cmpq	$15, %rcx
   25b04: 0f 86 d1 fe ff ff            	jbe	0x259db <bpf_map_create+0x13b>
   25b0a: 8b 43 0c                     	movl	12(%rbx), %eax
   25b0d: 89 44 24 34                  	movl	%eax, 52(%rsp)
; 	attr.btf_value_type_id = OPTS_GET(opts, btf_value_type_id, 0);
   25b11: 48 83 f9 13                  	cmpq	$19, %rcx
   25b15: 0f 86 c8 fe ff ff            	jbe	0x259e3 <bpf_map_create+0x143>
   25b1b: 8b 43 10                     	movl	16(%rbx), %eax
   25b1e: 89 44 24 38                  	movl	%eax, 56(%rsp)
; 	attr.btf_vmlinux_value_type_id = OPTS_GET(opts, btf_vmlinux_value_type_id, 0);
   25b22: 48 83 f9 17                  	cmpq	$23, %rcx
   25b26: 0f 86 bf fe ff ff            	jbe	0x259eb <bpf_map_create+0x14b>
   25b2c: 8b 43 14                     	movl	20(%rbx), %eax
   25b2f: 89 44 24 3c                  	movl	%eax, 60(%rsp)
; 	attr.inner_map_fd = OPTS_GET(opts, inner_map_fd, 0);
   25b33: 48 83 f9 1b                  	cmpq	$27, %rcx
   25b37: 0f 86 b6 fe ff ff            	jbe	0x259f3 <bpf_map_create+0x153>
   25b3d: 8b 43 18                     	movl	24(%rbx), %eax
   25b40: 89 44 24 14                  	movl	%eax, 20(%rsp)
; 	attr.map_flags = OPTS_GET(opts, map_flags, 0);
   25b44: 48 83 f9 1f                  	cmpq	$31, %rcx
   25b48: 0f 86 ad fe ff ff            	jbe	0x259fb <bpf_map_create+0x15b>
   25b4e: 8b 43 1c                     	movl	28(%rbx), %eax
   25b51: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 	attr.map_extra = OPTS_GET(opts, map_extra, 0);
   25b55: 48 83 f9 27                  	cmpq	$39, %rcx
   25b59: 0f 86 a4 fe ff ff            	jbe	0x25a03 <bpf_map_create+0x163>
   25b5f: 48 8b 43 20                  	movq	32(%rbx), %rax
   25b63: 48 89 44 24 40               	movq	%rax, 64(%rsp)
; 	attr.numa_node = OPTS_GET(opts, numa_node, 0);
   25b68: 48 83 f9 2b                  	cmpq	$43, %rcx
   25b6c: 0f 86 9a fe ff ff            	jbe	0x25a0c <bpf_map_create+0x16c>
   25b72: 8b 43 28                     	movl	40(%rbx), %eax
   25b75: 89 44 24 18                  	movl	%eax, 24(%rsp)
; 	attr.map_ifindex = OPTS_GET(opts, map_ifindex, 0);
   25b79: 48 83 f9 2f                  	cmpq	$47, %rcx
   25b7d: 0f 86 b8 00 00 00            	jbe	0x25c3b <bpf_map_create+0x39b>
   25b83: 8b 43 2c                     	movl	44(%rbx), %eax
   25b86: e9 d1 fe ff ff               	jmp	0x25a5c <bpf_map_create+0x1bc>
   25b8b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		errno = -ret;
   25b90: e8 5b fb fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   25b95: 44 8b 20                     	movl	(%rax), %r12d
   25b98: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   25b9b: e9 ea fe ff ff               	jmp	0x25a8a <bpf_map_create+0x1ea>
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   25ba0: 89 c7                        	movl	%eax, %edi
   25ba2: ba 03 00 00 00               	movl	$3, %edx
   25ba7: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   25bac: 31 c0                        	xorl	%eax, %eax
   25bae: e8 bd ff fd ff               	callq	0x5b70 <.plt.sec+0x500>
   25bb3: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   25bb5: e8 36 fb fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   25bba: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   25bbd: 44 8b 28                     	movl	(%rax), %r13d
   25bc0: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   25bc3: e8 38 fd fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   25bc8: 85 db                        	testl	%ebx, %ebx
   25bca: 78 44                        	js	0x25c10 <bpf_map_create+0x370>
   25bcc: 41 89 dc                     	movl	%ebx, %r12d
   25bcf: e9 b6 fe ff ff               	jmp	0x25a8a <bpf_map_create+0x1ea>
   25bd4: 0f 1f 40 00                  	nopl	(%rax)
; 	attr.key_size = key_size;
   25bd8: 89 6c 24 04                  	movl	%ebp, 4(%rsp)
; 	attr.value_size = value_size;
   25bdc: 44 89 64 24 08               	movl	%r12d, 8(%rsp)
; 	attr.max_entries = max_entries;
   25be1: 44 89 6c 24 0c               	movl	%r13d, 12(%rsp)
; 	attr.btf_fd = OPTS_GET(opts, btf_fd, 0);
   25be6: e9 04 ff ff ff               	jmp	0x25aef <bpf_map_create+0x24f>
   25beb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   25bf0: 48 8d 15 0e 53 01 00         	leaq	86798(%rip), %rdx       # 0x3af05 <CSWTCH.126+0x1605>
   25bf7: 48 8d 35 ba e3 00 00         	leaq	58298(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   25bfe: 31 ff                        	xorl	%edi, %edi
   25c00: 31 c0                        	xorl	%eax, %eax
   25c02: e8 c9 24 fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   25c07: e9 4d fd ff ff               	jmp	0x25959 <bpf_map_create+0xb9>
   25c0c: 0f 1f 40 00                  	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   25c10: 44 89 eb                     	movl	%r13d, %ebx
   25c13: 44 89 e2                     	movl	%r12d, %edx
   25c16: 48 8d 35 ab 53 01 00         	leaq	86955(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   25c1d: 31 ff                        	xorl	%edi, %edi
   25c1f: f7 db                        	negl	%ebx
   25c21: 31 c0                        	xorl	%eax, %eax
   25c23: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   25c25: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   25c28: e8 a3 24 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   25c2d: 44 89 6d 00                  	movl	%r13d, (%rbp)
   25c31: e9 54 fe ff ff               	jmp	0x25a8a <bpf_map_create+0x1ea>
; }
   25c36: e8 c5 fb fd ff               	callq	0x5800 <.plt.sec+0x190>
; 	attr.map_ifindex = OPTS_GET(opts, map_ifindex, 0);
   25c3b: 31 c0                        	xorl	%eax, %eax
   25c3d: e9 1a fe ff ff               	jmp	0x25a5c <bpf_map_create+0x1bc>
   25c42: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   25c4d: 0f 1f 00                     	nopl	(%rax)

0000000000025c50 <bpf_prog_load>:
; {
   25c50: f3 0f 1e fa                  	endbr64
   25c54: 41 57                        	pushq	%r15
   25c56: 49 89 f7                     	movq	%rsi, %r15
   25c59: 41 56                        	pushq	%r14
   25c5b: 4d 89 ce                     	movq	%r9, %r14
   25c5e: 41 55                        	pushq	%r13
   25c60: 41 54                        	pushq	%r12
   25c62: 55                           	pushq	%rbp
   25c63: 48 89 d5                     	movq	%rdx, %rbp
   25c66: 53                           	pushq	%rbx
   25c67: 4c 89 c3                     	movq	%r8, %rbx
   25c6a: 48 81 ec d8 00 00 00         	subq	$216, %rsp
   25c71: 89 3c 24                     	movl	%edi, (%rsp)
   25c74: 48 89 4c 24 08               	movq	%rcx, 8(%rsp)
   25c79: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   25c82: 48 89 84 24 c8 00 00 00      	movq	%rax, 200(%rsp)
   25c8a: 31 c0                        	xorl	%eax, %eax
; 	bump_rlimit_memlock();
   25c8c: e8 7f fb ff ff               	callq	0x25810 <bump_rlimit_memlock>
; 	if (!OPTS_VALID(opts, bpf_prog_load_opts))
   25c91: 4d 85 f6                     	testq	%r14, %r14
   25c94: 0f 84 66 03 00 00            	je	0x26000 <bpf_prog_load+0x3b0>
   25c9a: 4d 8b 06                     	movq	(%r14), %r8
; 	if (user_sz < sizeof(size_t)) {
   25c9d: 49 83 f8 07                  	cmpq	$7, %r8
   25ca1: 0f 86 f9 05 00 00            	jbe	0x262a0 <bpf_prog_load+0x650>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   25ca7: 49 8d 40 98                  	leaq	-104(%r8), %rax
   25cab: 49 8d 56 68                  	leaq	104(%r14), %rdx
; 	while (len > 0) {
   25caf: 48 85 c0                     	testq	%rax, %rax
   25cb2: 7e 74                        	jle	0x25d28 <bpf_prog_load+0xd8>
   25cb4: 4b 8d 04 06                  	leaq	(%r14,%r8), %rax
   25cb8: eb 0f                        	jmp	0x25cc9 <bpf_prog_load+0x79>
   25cba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		p++;
   25cc0: 48 83 c2 01                  	addq	$1, %rdx
; 	while (len > 0) {
   25cc4: 48 39 c2                     	cmpq	%rax, %rdx
   25cc7: 74 5f                        	je	0x25d28 <bpf_prog_load+0xd8>
; 		if (*p)
   25cc9: 80 3a 00                     	cmpb	$0, (%rdx)
   25ccc: 74 f2                        	je	0x25cc0 <bpf_prog_load+0x70>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   25cce: 48 8d 15 44 52 01 00         	leaq	86596(%rip), %rdx       # 0x3af19 <CSWTCH.126+0x1619>
   25cd5: 48 8d 35 34 e3 00 00         	leaq	58164(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   25cdc: 31 ff                        	xorl	%edi, %edi
   25cde: 31 c0                        	xorl	%eax, %eax
   25ce0: e8 eb 23 fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   25ce5: e8 06 fa fd ff               	callq	0x56f0 <.plt.sec+0x80>
   25cea: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   25cf0: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   25cf5: 0f 1f 00                     	nopl	(%rax)
; }
   25cf8: 48 8b 94 24 c8 00 00 00      	movq	200(%rsp), %rdx
   25d00: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   25d09: 0f 85 5b 06 00 00            	jne	0x2636a <bpf_prog_load+0x71a>
   25d0f: 48 81 c4 d8 00 00 00         	addq	$216, %rsp
   25d16: 5b                           	popq	%rbx
   25d17: 5d                           	popq	%rbp
   25d18: 41 5c                        	popq	%r12
   25d1a: 41 5d                        	popq	%r13
   25d1c: 41 5e                        	popq	%r14
   25d1e: 41 5f                        	popq	%r15
   25d20: c3                           	retq
   25d21: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	attempts = OPTS_GET(opts, attempts, 0);
   25d28: 49 83 f8 0b                  	cmpq	$11, %r8
   25d2c: 0f 86 fe 02 00 00            	jbe	0x26030 <bpf_prog_load+0x3e0>
   25d32: 45 8b 6e 08                  	movl	8(%r14), %r13d
; 	if (attempts < 0)
   25d36: 45 85 ed                     	testl	%r13d, %r13d
   25d39: 78 aa                        	js	0x25ce5 <bpf_prog_load+0x95>
; 	if (attempts == 0)
   25d3b: 0f 84 ef 02 00 00            	je	0x26030 <bpf_prog_load+0x3e0>
;   return __builtin___memset_chk (__dest, __ch, __len,
   25d41: 4c 8d 64 24 30               	leaq	48(%rsp), %r12
   25d46: b9 10 00 00 00               	movl	$16, %ecx
   25d4b: 31 c0                        	xorl	%eax, %eax
   25d4d: 4c 89 e7                     	movq	%r12, %rdi
   25d50: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	attr.prog_type = prog_type;
   25d53: 8b 04 24                     	movl	(%rsp), %eax
   25d56: 89 44 24 30                  	movl	%eax, 48(%rsp)
; 	attr.expected_attach_type = OPTS_GET(opts, expected_attach_type, 0);
   25d5a: 31 c0                        	xorl	%eax, %eax
   25d5c: 49 83 f8 0f                  	cmpq	$15, %r8
   25d60: 76 04                        	jbe	0x25d66 <bpf_prog_load+0x116>
   25d62: 41 8b 46 0c                  	movl	12(%r14), %eax
   25d66: 89 44 24 74                  	movl	%eax, 116(%rsp)
; 	attr.prog_btf_fd = OPTS_GET(opts, prog_btf_fd, 0);
   25d6a: 31 c0                        	xorl	%eax, %eax
   25d6c: 49 83 f8 13                  	cmpq	$19, %r8
   25d70: 76 04                        	jbe	0x25d76 <bpf_prog_load+0x126>
   25d72: 41 8b 46 10                  	movl	16(%r14), %eax
   25d76: 89 44 24 78                  	movl	%eax, 120(%rsp)
; 	attr.prog_flags = OPTS_GET(opts, prog_flags, 0);
   25d7a: 31 c0                        	xorl	%eax, %eax
   25d7c: 49 83 f8 17                  	cmpq	$23, %r8
   25d80: 76 04                        	jbe	0x25d86 <bpf_prog_load+0x136>
   25d82: 41 8b 46 14                  	movl	20(%r14), %eax
   25d86: 89 44 24 5c                  	movl	%eax, 92(%rsp)
; 	attr.prog_ifindex = OPTS_GET(opts, prog_ifindex, 0);
   25d8a: 31 c0                        	xorl	%eax, %eax
   25d8c: 49 83 f8 1b                  	cmpq	$27, %r8
   25d90: 76 04                        	jbe	0x25d96 <bpf_prog_load+0x146>
   25d92: 41 8b 46 18                  	movl	24(%r14), %eax
   25d96: 89 44 24 70                  	movl	%eax, 112(%rsp)
; 	attr.kern_version = OPTS_GET(opts, kern_version, 0);
   25d9a: 49 83 f8 1f                  	cmpq	$31, %r8
   25d9e: 0f 86 7c 02 00 00            	jbe	0x26020 <bpf_prog_load+0x3d0>
   25da4: 41 8b 46 1c                  	movl	28(%r14), %eax
   25da8: 89 44 24 58                  	movl	%eax, 88(%rsp)
; 	if (prog_name && kernel_supports(NULL, FEAT_PROG_NAME))
   25dac: 4d 85 ff                     	testq	%r15, %r15
   25daf: 74 11                        	je	0x25dc2 <bpf_prog_load+0x172>
   25db1: 31 f6                        	xorl	%esi, %esi
   25db3: 31 ff                        	xorl	%edi, %edi
   25db5: e8 56 66 fe ff               	callq	0xc410 <kernel_supports>
   25dba: 84 c0                        	testb	%al, %al
   25dbc: 0f 85 16 05 00 00            	jne	0x262d8 <bpf_prog_load+0x688>
; 	if (insn_cnt > UINT_MAX)
   25dc2: 48 89 d8                     	movq	%rbx, %rax
; 	attr.license = ptr_to_u64(license);
   25dc5: 48 89 6c 24 40               	movq	%rbp, 64(%rsp)
; 	if (insn_cnt > UINT_MAX)
   25dca: 48 c1 e8 20                  	shrq	$32, %rax
   25dce: 0f 85 7a 05 00 00            	jne	0x2634e <bpf_prog_load+0x6fe>
; 	attr.insns = ptr_to_u64(insns);
   25dd4: 48 8b 44 24 08               	movq	8(%rsp), %rax
; 	attr.insn_cnt = (__u32)insn_cnt;
   25dd9: 89 5c 24 34                  	movl	%ebx, 52(%rsp)
; 	attr.insns = ptr_to_u64(insns);
   25ddd: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 	attach_prog_fd = OPTS_GET(opts, attach_prog_fd, 0);
   25de2: 4d 85 f6                     	testq	%r14, %r14
   25de5: 0f 84 2d 03 00 00            	je	0x26118 <bpf_prog_load+0x4c8>
   25deb: 49 8b 06                     	movq	(%r14), %rax
   25dee: 48 83 f8 27                  	cmpq	$39, %rax
   25df2: 0f 86 f8 02 00 00            	jbe	0x260f0 <bpf_prog_load+0x4a0>
   25df8: 41 8b 56 24                  	movl	36(%r14), %edx
; 	attach_btf_obj_fd = OPTS_GET(opts, attach_btf_obj_fd, 0);
   25dfc: 48 83 f8 2b                  	cmpq	$43, %rax
   25e00: 0f 86 5d 05 00 00            	jbe	0x26363 <bpf_prog_load+0x713>
   25e06: 41 8b 4e 28                  	movl	40(%r14), %ecx
; 	if (attach_prog_fd && attach_btf_obj_fd)
   25e0a: 85 c9                        	testl	%ecx, %ecx
   25e0c: 74 08                        	je	0x25e16 <bpf_prog_load+0x1c6>
   25e0e: 85 d2                        	testl	%edx, %edx
   25e10: 0f 85 cf fe ff ff            	jne	0x25ce5 <bpf_prog_load+0x95>
; 	attr.attach_btf_id = OPTS_GET(opts, attach_btf_id, 0);
   25e16: 41 8b 76 20                  	movl	32(%r14), %esi
   25e1a: 89 b4 24 9c 00 00 00         	movl	%esi, 156(%rsp)
; 	if (attach_prog_fd)
   25e21: 85 d2                        	testl	%edx, %edx
   25e23: 0f 84 de 02 00 00            	je	0x26107 <bpf_prog_load+0x4b7>
; 		attr.attach_prog_fd = attach_prog_fd;
   25e29: 89 94 24 a0 00 00 00         	movl	%edx, 160(%rsp)
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   25e30: 48 83 f8 67                  	cmpq	$103, %rax
   25e34: 0f 86 16 02 00 00            	jbe	0x26050 <bpf_prog_load+0x400>
   25e3a: 49 8b 5e 60                  	movq	96(%r14), %rbx
   25e3e: 48 89 5c 24 18               	movq	%rbx, 24(%rsp)
; 	log_size = OPTS_GET(opts, log_size, 0);
   25e43: 41 8b 7e 5c                  	movl	92(%r14), %edi
; 	log_level = OPTS_GET(opts, log_level, 0);
   25e47: 41 8b 5e 58                  	movl	88(%r14), %ebx
; 	if (!!log_buf != !!log_size)
   25e4b: 48 83 7c 24 18 00            	cmpq	$0, 24(%rsp)
   25e51: 0f 95 44 24 23               	setne	35(%rsp)
   25e56: 85 ff                        	testl	%edi, %edi
; 	log_level = OPTS_GET(opts, log_level, 0);
   25e58: 89 5c 24 08                  	movl	%ebx, 8(%rsp)
; 	if (!!log_buf != !!log_size)
   25e5c: 0f b6 5c 24 23               	movzbl	35(%rsp), %ebx
   25e61: 0f 95 c2                     	setne	%dl
; 	log_size = OPTS_GET(opts, log_size, 0);
   25e64: 89 7c 24 24                  	movl	%edi, 36(%rsp)
; 	if (!!log_buf != !!log_size)
   25e68: 38 d3                        	cmpb	%dl, %bl
   25e6a: 0f 85 75 fe ff ff            	jne	0x25ce5 <bpf_prog_load+0x95>
; 	if (log_level > (4 | 2 | 1))
   25e70: 83 7c 24 08 07               	cmpl	$7, 8(%rsp)
   25e75: 0f 87 6a fe ff ff            	ja	0x25ce5 <bpf_prog_load+0x95>
; 	if (log_level && !log_buf)
   25e7b: 8b 54 24 08                  	movl	8(%rsp), %edx
   25e7f: 85 d2                        	testl	%edx, %edx
   25e81: 74 0c                        	je	0x25e8f <bpf_prog_load+0x23f>
   25e83: 48 83 7c 24 18 00            	cmpq	$0, 24(%rsp)
   25e89: 0f 84 56 fe ff ff            	je	0x25ce5 <bpf_prog_load+0x95>
; 	func_info_rec_size = OPTS_GET(opts, func_info_rec_size, 0);
   25e8f: 41 8b 5e 44                  	movl	68(%r14), %ebx
   25e93: 89 5c 24 14                  	movl	%ebx, 20(%rsp)
; 	func_info = OPTS_GET(opts, func_info, NULL);
   25e97: 49 8b 7e 38                  	movq	56(%r14), %rdi
; 	attr.func_info_rec_size = func_info_rec_size;
   25e9b: 8b 5c 24 14                  	movl	20(%rsp), %ebx
; 	func_info = OPTS_GET(opts, func_info, NULL);
   25e9f: 48 89 7c 24 28               	movq	%rdi, 40(%rsp)
; 	attr.func_info_rec_size = func_info_rec_size;
   25ea4: 89 5c 24 7c                  	movl	%ebx, 124(%rsp)
; 	attr.func_info = ptr_to_u64(func_info);
   25ea8: 48 89 bc 24 80 00 00 00      	movq	%rdi, 128(%rsp)
; 	attr.func_info_cnt = OPTS_GET(opts, func_info_cnt, 0);
   25eb0: 48 83 f8 43                  	cmpq	$67, %rax
   25eb4: 0f 86 96 03 00 00            	jbe	0x26250 <bpf_prog_load+0x600>
   25eba: 41 8b 56 40                  	movl	64(%r14), %edx
   25ebe: 89 94 24 88 00 00 00         	movl	%edx, 136(%rsp)
; 	line_info_rec_size = OPTS_GET(opts, line_info_rec_size, 0);
   25ec5: 48 83 f8 57                  	cmpq	$87, %rax
   25ec9: 0f 86 8c 03 00 00            	jbe	0x2625b <bpf_prog_load+0x60b>
   25ecf: 41 8b 5e 54                  	movl	84(%r14), %ebx
; 	line_info = OPTS_GET(opts, line_info, NULL);
   25ed3: 4d 8b 7e 48                  	movq	72(%r14), %r15
; 	attr.line_info_rec_size = line_info_rec_size;
   25ed7: 89 9c 24 8c 00 00 00         	movl	%ebx, 140(%rsp)
; 	attr.line_info = ptr_to_u64(line_info);
   25ede: 4c 89 bc 24 90 00 00 00      	movq	%r15, 144(%rsp)
; 	attr.line_info_cnt = OPTS_GET(opts, line_info_cnt, 0);
   25ee6: 41 8b 46 50                  	movl	80(%r14), %eax
   25eea: 89 84 24 98 00 00 00         	movl	%eax, 152(%rsp)
; 	return (__u64) (unsigned long) ptr;
   25ef1: 49 8b 46 30                  	movq	48(%r14), %rax
; 	attr.fd_array = ptr_to_u64(OPTS_GET(opts, fd_array, NULL));
   25ef5: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
; 	if (log_level) {
   25efd: 8b 44 24 08                  	movl	8(%rsp), %eax
   25f01: 85 c0                        	testl	%eax, %eax
   25f03: 74 16                        	je	0x25f1b <bpf_prog_load+0x2cb>
; 		attr.log_buf = ptr_to_u64(log_buf);
   25f05: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
; 		attr.log_level = log_level;
   25f0a: 89 44 24 48                  	movl	%eax, 72(%rsp)
; 		attr.log_buf = ptr_to_u64(log_buf);
   25f0e: 48 89 7c 24 50               	movq	%rdi, 80(%rsp)
; 		attr.log_size = log_size;
   25f13: 8b 7c 24 24                  	movl	36(%rsp), %edi
   25f17: 89 7c 24 4c                  	movl	%edi, 76(%rsp)
; 	fd = sys_bpf_prog_load(&attr, attr_sz, attempts);
   25f1b: 44 89 ea                     	movl	%r13d, %edx
   25f1e: be 80 00 00 00               	movl	$128, %esi
   25f23: 4c 89 e7                     	movq	%r12, %rdi
   25f26: e8 95 f6 ff ff               	callq	0x255c0 <sys_bpf_prog_load>
; 	if (fd >= 0)
   25f2b: 85 c0                        	testl	%eax, %eax
   25f2d: 0f 89 c5 fd ff ff            	jns	0x25cf8 <bpf_prog_load+0xa8>
; 	while (errno == E2BIG && (!finfo || !linfo)) {
   25f33: e8 b8 f7 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	void *finfo = NULL, *linfo = NULL;
   25f38: 45 31 f6                     	xorl	%r14d, %r14d
   25f3b: 31 ed                        	xorl	%ebp, %ebp
; 	while (errno == E2BIG && (!finfo || !linfo)) {
   25f3d: 48 89 04 24                  	movq	%rax, (%rsp)
   25f41: 4c 89 f8                     	movq	%r15, %rax
   25f44: 4d 89 f7                     	movq	%r14, %r15
   25f47: 49 89 c6                     	movq	%rax, %r14
   25f4a: e9 7e 00 00 00               	jmp	0x25fcd <bpf_prog_load+0x37d>
   25f4f: 90                           	nop
; 		if (!finfo && attr.func_info_cnt &&
   25f50: 8b b4 24 88 00 00 00         	movl	136(%rsp), %esi
   25f57: 85 f6                        	testl	%esi, %esi
   25f59: 74 0e                        	je	0x25f69 <bpf_prog_load+0x319>
; 		    attr.func_info_rec_size < func_info_rec_size) {
   25f5b: 8b 4c 24 7c                  	movl	124(%rsp), %ecx
; 		if (!finfo && attr.func_info_cnt &&
   25f5f: 3b 4c 24 14                  	cmpl	20(%rsp), %ecx
   25f63: 0f 82 b7 02 00 00            	jb	0x26220 <bpf_prog_load+0x5d0>
; 		} else if (!linfo && attr.line_info_cnt &&
   25f69: 4d 85 ff                     	testq	%r15, %r15
   25f6c: 0f 85 2e 02 00 00            	jne	0x261a0 <bpf_prog_load+0x550>
   25f72: 8b b4 24 98 00 00 00         	movl	152(%rsp), %esi
   25f79: 85 f6                        	testl	%esi, %esi
   25f7b: 0f 84 7f 03 00 00            	je	0x26300 <bpf_prog_load+0x6b0>
; 			   attr.line_info_rec_size < line_info_rec_size) {
   25f81: 8b 8c 24 8c 00 00 00         	movl	140(%rsp), %ecx
; 		} else if (!linfo && attr.line_info_cnt &&
   25f88: 39 d9                        	cmpl	%ebx, %ecx
   25f8a: 0f 83 70 03 00 00            	jae	0x26300 <bpf_prog_load+0x6b0>
; 			linfo = alloc_zero_tailing_info(line_info,
   25f90: 89 da                        	movl	%ebx, %edx
   25f92: 4c 89 f7                     	movq	%r14, %rdi
   25f95: e8 76 f3 ff ff               	callq	0x25310 <alloc_zero_tailing_info>
   25f9a: 49 89 c7                     	movq	%rax, %r15
; 			if (!linfo) {
   25f9d: 48 85 c0                     	testq	%rax, %rax
   25fa0: 0f 84 1a 03 00 00            	je	0x262c0 <bpf_prog_load+0x670>
; 			attr.line_info = ptr_to_u64(linfo);
   25fa6: 48 89 84 24 90 00 00 00      	movq	%rax, 144(%rsp)
; 			attr.line_info_rec_size = line_info_rec_size;
   25fae: 89 9c 24 8c 00 00 00         	movl	%ebx, 140(%rsp)
; 		fd = sys_bpf_prog_load(&attr, attr_sz, attempts);
   25fb5: 44 89 ea                     	movl	%r13d, %edx
   25fb8: be 80 00 00 00               	movl	$128, %esi
   25fbd: 4c 89 e7                     	movq	%r12, %rdi
   25fc0: e8 fb f5 ff ff               	callq	0x255c0 <sys_bpf_prog_load>
; 		if (fd >= 0)
   25fc5: 85 c0                        	testl	%eax, %eax
   25fc7: 0f 89 43 03 00 00            	jns	0x26310 <bpf_prog_load+0x6c0>
; 	while (errno == E2BIG && (!finfo || !linfo)) {
   25fcd: 48 8b 04 24                  	movq	(%rsp), %rax
   25fd1: 83 38 07                     	cmpl	$7, (%rax)
   25fd4: 0f 85 c6 01 00 00            	jne	0x261a0 <bpf_prog_load+0x550>
   25fda: 48 85 ed                     	testq	%rbp, %rbp
   25fdd: 0f 84 6d ff ff ff            	je	0x25f50 <bpf_prog_load+0x300>
   25fe3: 4d 85 ff                     	testq	%r15, %r15
   25fe6: 0f 85 b4 01 00 00            	jne	0x261a0 <bpf_prog_load+0x550>
; 		if (!finfo && attr.func_info_cnt &&
   25fec: 48 85 ed                     	testq	%rbp, %rbp
   25fef: 75 81                        	jne	0x25f72 <bpf_prog_load+0x322>
   25ff1: e9 5a ff ff ff               	jmp	0x25f50 <bpf_prog_load+0x300>
   25ff6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26000: 4c 8d 64 24 30               	leaq	48(%rsp), %r12
   26005: 4c 89 f0                     	movq	%r14, %rax
   26008: b9 10 00 00 00               	movl	$16, %ecx
; 		attempts = PROG_LOAD_ATTEMPTS;
   2600d: 41 bd 05 00 00 00            	movl	$5, %r13d
;   return __builtin___memset_chk (__dest, __ch, __len,
   26013: 4c 89 e7                     	movq	%r12, %rdi
   26016: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	attr.prog_type = prog_type;
   26019: 8b 04 24                     	movl	(%rsp), %eax
   2601c: 89 44 24 30                  	movl	%eax, 48(%rsp)
; 	attr.kern_version = OPTS_GET(opts, kern_version, 0);
   26020: 31 c0                        	xorl	%eax, %eax
   26022: e9 81 fd ff ff               	jmp	0x25da8 <bpf_prog_load+0x158>
   26027: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26030: 4c 8d 64 24 30               	leaq	48(%rsp), %r12
   26035: b9 10 00 00 00               	movl	$16, %ecx
   2603a: 31 c0                        	xorl	%eax, %eax
; 		attempts = PROG_LOAD_ATTEMPTS;
   2603c: 41 bd 05 00 00 00            	movl	$5, %r13d
;   return __builtin___memset_chk (__dest, __ch, __len,
   26042: 4c 89 e7                     	movq	%r12, %rdi
   26045: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
; 	attr.expected_attach_type = OPTS_GET(opts, expected_attach_type, 0);
   26048: e9 06 fd ff ff               	jmp	0x25d53 <bpf_prog_load+0x103>
   2604d: 0f 1f 00                     	nopl	(%rax)
; 	log_size = OPTS_GET(opts, log_size, 0);
   26050: 48 83 f8 5f                  	cmpq	$95, %rax
   26054: 0f 87 15 03 00 00            	ja	0x2636f <bpf_prog_load+0x71f>
; 	log_level = OPTS_GET(opts, log_level, 0);
   2605a: 48 83 f8 5b                  	cmpq	$91, %rax
   2605e: 0f 87 55 03 00 00            	ja	0x263b9 <bpf_prog_load+0x769>
; 	func_info_rec_size = OPTS_GET(opts, func_info_rec_size, 0);
   26064: 48 83 f8 47                  	cmpq	$71, %rax
   26068: 0f 87 bd 02 00 00            	ja	0x2632b <bpf_prog_load+0x6db>
; 	func_info = OPTS_GET(opts, func_info, NULL);
   2606e: 48 83 f8 3f                  	cmpq	$63, %rax
   26072: 0f 87 0c 03 00 00            	ja	0x26384 <bpf_prog_load+0x734>
; 	attr.func_info_rec_size = func_info_rec_size;
   26078: 48 c7 44 24 7c 00 00 00 00   	movq	$0, 124(%rsp)
; 	attr.func_info = ptr_to_u64(func_info);
   26081: 48 c7 84 24 84 00 00 00 00 00 00 00  	movq	$0, 132(%rsp)
; 	log_size = OPTS_GET(opts, log_size, 0);
   2608d: c7 44 24 24 00 00 00 00      	movl	$0, 36(%rsp)
; 	func_info = OPTS_GET(opts, func_info, NULL);
   26095: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	func_info_rec_size = OPTS_GET(opts, func_info_rec_size, 0);
   2609e: c7 44 24 14 00 00 00 00      	movl	$0, 20(%rsp)
; 	log_level = OPTS_GET(opts, log_level, 0);
   260a6: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	attr.func_info = ptr_to_u64(func_info);
   260ae: c6 44 24 23 00               	movb	$0, 35(%rsp)
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   260b3: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 	attr.line_info_rec_size = line_info_rec_size;
   260bc: 48 c7 84 24 8c 00 00 00 00 00 00 00  	movq	$0, 140(%rsp)
; 	attr.line_info = ptr_to_u64(line_info);
   260c8: 48 c7 84 24 94 00 00 00 00 00 00 00  	movq	$0, 148(%rsp)
; 	attr.fd_array = ptr_to_u64(OPTS_GET(opts, fd_array, NULL));
   260d4: 48 83 f8 37                  	cmpq	$55, %rax
   260d8: 0f 87 d1 02 00 00            	ja	0x263af <bpf_prog_load+0x75f>
   260de: 31 c0                        	xorl	%eax, %eax
; 	line_info = OPTS_GET(opts, line_info, NULL);
   260e0: 45 31 ff                     	xorl	%r15d, %r15d
; 	line_info_rec_size = OPTS_GET(opts, line_info_rec_size, 0);
   260e3: 31 db                        	xorl	%ebx, %ebx
   260e5: e9 0b fe ff ff               	jmp	0x25ef5 <bpf_prog_load+0x2a5>
   260ea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	attr.attach_btf_id = OPTS_GET(opts, attach_btf_id, 0);
   260f0: 48 83 f8 23                  	cmpq	$35, %rax
   260f4: 0f 87 e2 02 00 00            	ja	0x263dc <bpf_prog_load+0x78c>
   260fa: c7 84 24 9c 00 00 00 00 00 00 00     	movl	$0, 156(%rsp)
; 	attach_btf_obj_fd = OPTS_GET(opts, attach_btf_obj_fd, 0);
   26105: 31 c9                        	xorl	%ecx, %ecx
; 		attr.attach_btf_obj_fd = attach_btf_obj_fd;
   26107: 89 8c 24 a0 00 00 00         	movl	%ecx, 160(%rsp)
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   2610e: e9 1d fd ff ff               	jmp	0x25e30 <bpf_prog_load+0x1e0>
   26113: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	attr.func_info_rec_size = func_info_rec_size;
   26118: 48 c7 44 24 7c 00 00 00 00   	movq	$0, 124(%rsp)
; 	line_info = OPTS_GET(opts, line_info, NULL);
   26121: 45 31 ff                     	xorl	%r15d, %r15d
; 	line_info_rec_size = OPTS_GET(opts, line_info_rec_size, 0);
   26124: 31 db                        	xorl	%ebx, %ebx
; 	attr.func_info = ptr_to_u64(func_info);
   26126: 48 c7 84 24 84 00 00 00 00 00 00 00  	movq	$0, 132(%rsp)
; 	attr.line_info_rec_size = line_info_rec_size;
   26132: 48 c7 84 24 8c 00 00 00 00 00 00 00  	movq	$0, 140(%rsp)
; 	attr.line_info = ptr_to_u64(line_info);
   2613e: 48 c7 84 24 94 00 00 00 00 00 00 00  	movq	$0, 148(%rsp)
; 	attr.attach_btf_id = OPTS_GET(opts, attach_btf_id, 0);
   2614a: 48 c7 84 24 9c 00 00 00 00 00 00 00  	movq	$0, 156(%rsp)
; 	attr.fd_array = ptr_to_u64(OPTS_GET(opts, fd_array, NULL));
   26156: 48 c7 84 24 a8 00 00 00 00 00 00 00  	movq	$0, 168(%rsp)
; 	func_info = OPTS_GET(opts, func_info, NULL);
   26162: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   2616b: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 	attr.fd_array = ptr_to_u64(OPTS_GET(opts, fd_array, NULL));
   26174: c6 44 24 23 00               	movb	$0, 35(%rsp)
; 	log_level = OPTS_GET(opts, log_level, 0);
   26179: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	func_info_rec_size = OPTS_GET(opts, func_info_rec_size, 0);
   26181: c7 44 24 14 00 00 00 00      	movl	$0, 20(%rsp)
; 	log_size = OPTS_GET(opts, log_size, 0);
   26189: c7 44 24 24 00 00 00 00      	movl	$0, 36(%rsp)
   26191: e9 85 fd ff ff               	jmp	0x25f1b <bpf_prog_load+0x2cb>
   26196: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   261a0: 4d 89 fe                     	movq	%r15, %r14
; 	if (log_level == 0 && log_buf) {
   261a3: 8b 4c 24 08                  	movl	8(%rsp), %ecx
   261a7: 85 c9                        	testl	%ecx, %ecx
   261a9: 75 07                        	jne	0x261b2 <bpf_prog_load+0x562>
   261ab: 80 7c 24 23 00               	cmpb	$0, 35(%rsp)
   261b0: 75 1e                        	jne	0x261d0 <bpf_prog_load+0x580>
; 	free(finfo);
   261b2: 48 89 ef                     	movq	%rbp, %rdi
   261b5: e8 06 f5 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(linfo);
   261ba: 4c 89 f7                     	movq	%r14, %rdi
   261bd: e8 fe f4 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return ret < 0 ? -errno : ret;
   261c2: 48 8b 04 24                  	movq	(%rsp), %rax
   261c6: 8b 00                        	movl	(%rax), %eax
   261c8: f7 d8                        	negl	%eax
   261ca: e9 29 fb ff ff               	jmp	0x25cf8 <bpf_prog_load+0xa8>
   261cf: 90                           	nop
; 		attr.log_buf = ptr_to_u64(log_buf);
   261d0: 48 8b 44 24 18               	movq	24(%rsp), %rax
; 		fd = sys_bpf_prog_load(&attr, attr_sz, attempts);
   261d5: 44 89 ea                     	movl	%r13d, %edx
   261d8: be 80 00 00 00               	movl	$128, %esi
   261dd: 4c 89 e7                     	movq	%r12, %rdi
; 		attr.log_level = 1;
   261e0: c7 44 24 48 01 00 00 00      	movl	$1, 72(%rsp)
; 		attr.log_buf = ptr_to_u64(log_buf);
   261e8: 48 89 44 24 50               	movq	%rax, 80(%rsp)
; 		attr.log_size = log_size;
   261ed: 8b 44 24 24                  	movl	36(%rsp), %eax
   261f1: 89 44 24 4c                  	movl	%eax, 76(%rsp)
; 		fd = sys_bpf_prog_load(&attr, attr_sz, attempts);
   261f5: e8 c6 f3 ff ff               	callq	0x255c0 <sys_bpf_prog_load>
; 	free(finfo);
   261fa: 48 89 ef                     	movq	%rbp, %rdi
; 		fd = sys_bpf_prog_load(&attr, attr_sz, attempts);
   261fd: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	free(finfo);
   26201: e8 ba f4 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(linfo);
   26206: 4c 89 f7                     	movq	%r14, %rdi
   26209: e8 b2 f4 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return ret < 0 ? -errno : ret;
   2620e: 8b 44 24 08                  	movl	8(%rsp), %eax
   26212: 85 c0                        	testl	%eax, %eax
   26214: 0f 89 de fa ff ff            	jns	0x25cf8 <bpf_prog_load+0xa8>
   2621a: eb a6                        	jmp	0x261c2 <bpf_prog_load+0x572>
   2621c: 0f 1f 40 00                  	nopl	(%rax)
; 			finfo = alloc_zero_tailing_info(func_info,
   26220: 8b 54 24 14                  	movl	20(%rsp), %edx
   26224: 48 8b 7c 24 28               	movq	40(%rsp), %rdi
   26229: e8 e2 f0 ff ff               	callq	0x25310 <alloc_zero_tailing_info>
   2622e: 48 89 c5                     	movq	%rax, %rbp
; 			if (!finfo) {
   26231: 48 85 c0                     	testq	%rax, %rax
   26234: 0f 84 86 00 00 00            	je	0x262c0 <bpf_prog_load+0x670>
; 			attr.func_info = ptr_to_u64(finfo);
   2623a: 48 89 84 24 80 00 00 00      	movq	%rax, 128(%rsp)
; 			attr.func_info_rec_size = func_info_rec_size;
   26242: 8b 44 24 14                  	movl	20(%rsp), %eax
   26246: 89 44 24 7c                  	movl	%eax, 124(%rsp)
   2624a: e9 66 fd ff ff               	jmp	0x25fb5 <bpf_prog_load+0x365>
   2624f: 90                           	nop
; 	attr.func_info_cnt = OPTS_GET(opts, func_info_cnt, 0);
   26250: c7 84 24 88 00 00 00 00 00 00 00     	movl	$0, 136(%rsp)
; 	line_info = OPTS_GET(opts, line_info, NULL);
   2625b: 48 83 f8 4f                  	cmpq	$79, %rax
   2625f: 0f 86 57 fe ff ff            	jbe	0x260bc <bpf_prog_load+0x46c>
; 	attr.line_info_rec_size = line_info_rec_size;
   26265: c7 84 24 8c 00 00 00 00 00 00 00     	movl	$0, 140(%rsp)
; 	line_info = OPTS_GET(opts, line_info, NULL);
   26270: 4d 8b 7e 48                  	movq	72(%r14), %r15
; 	attr.line_info = ptr_to_u64(line_info);
   26274: 4c 89 bc 24 90 00 00 00      	movq	%r15, 144(%rsp)
; 	attr.line_info_cnt = OPTS_GET(opts, line_info_cnt, 0);
   2627c: 48 83 f8 53                  	cmpq	$83, %rax
   26280: 0f 87 f7 00 00 00            	ja	0x2637d <bpf_prog_load+0x72d>
   26286: c7 84 24 98 00 00 00 00 00 00 00     	movl	$0, 152(%rsp)
; 	line_info_rec_size = OPTS_GET(opts, line_info_rec_size, 0);
   26291: 31 db                        	xorl	%ebx, %ebx
   26293: e9 59 fc ff ff               	jmp	0x25ef1 <bpf_prog_load+0x2a1>
   26298: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   262a0: 4c 89 c1                     	movq	%r8, %rcx
   262a3: 48 8d 15 6f 4c 01 00         	leaq	85103(%rip), %rdx       # 0x3af19 <CSWTCH.126+0x1619>
   262aa: 31 ff                        	xorl	%edi, %edi
   262ac: 31 c0                        	xorl	%eax, %eax
   262ae: 48 8d 35 03 dd 00 00         	leaq	56579(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   262b5: e8 16 1e fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   262ba: e9 26 fa ff ff               	jmp	0x25ce5 <bpf_prog_load+0x95>
   262bf: 90                           	nop
; 				errno = E2BIG;
   262c0: 48 8b 04 24                  	movq	(%rsp), %rax
   262c4: 4d 89 fe                     	movq	%r15, %r14
   262c7: c7 00 07 00 00 00            	movl	$7, (%rax)
; 				goto done;
   262cd: e9 e0 fe ff ff               	jmp	0x261b2 <bpf_prog_load+0x562>
   262d2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	for (i = 0; i < sz && src[i]; i++)
   262d8: 31 d2                        	xorl	%edx, %edx
; 		dst[i] = src[i];
   262da: 48 8d 4c 24 60               	leaq	96(%rsp), %rcx
   262df: 90                           	nop
; 	for (i = 0; i < sz && src[i]; i++)
   262e0: 41 0f b6 04 17               	movzbl	(%r15,%rdx), %eax
   262e5: 84 c0                        	testb	%al, %al
   262e7: 74 0d                        	je	0x262f6 <bpf_prog_load+0x6a6>
; 		dst[i] = src[i];
   262e9: 88 04 11                     	movb	%al, (%rcx,%rdx)
; 	for (i = 0; i < sz && src[i]; i++)
   262ec: 48 83 c2 01                  	addq	$1, %rdx
   262f0: 48 83 fa 0f                  	cmpq	$15, %rdx
   262f4: 75 ea                        	jne	0x262e0 <bpf_prog_load+0x690>
; 	dst[i] = '\0';
   262f6: c6 44 14 60 00               	movb	$0, 96(%rsp,%rdx)
   262fb: e9 c2 fa ff ff               	jmp	0x25dc2 <bpf_prog_load+0x172>
   26300: 45 31 f6                     	xorl	%r14d, %r14d
   26303: e9 9b fe ff ff               	jmp	0x261a3 <bpf_prog_load+0x553>
   26308: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	free(finfo);
   26310: 48 89 ef                     	movq	%rbp, %rdi
   26313: 89 04 24                     	movl	%eax, (%rsp)
   26316: e8 a5 f3 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(linfo);
   2631b: 4c 89 ff                     	movq	%r15, %rdi
   2631e: e8 9d f3 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return ret < 0 ? -errno : ret;
   26323: 8b 04 24                     	movl	(%rsp), %eax
   26326: e9 cd f9 ff ff               	jmp	0x25cf8 <bpf_prog_load+0xa8>
   2632b: c6 44 24 23 00               	movb	$0, 35(%rsp)
; 	log_level = OPTS_GET(opts, log_level, 0);
   26330: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   26338: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 	log_size = OPTS_GET(opts, log_size, 0);
   26341: c7 44 24 24 00 00 00 00      	movl	$0, 36(%rsp)
   26349: e9 41 fb ff ff               	jmp	0x25e8f <bpf_prog_load+0x23f>
; 		errno = -ret;
   2634e: e8 9d f3 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   26353: c7 00 07 00 00 00            	movl	$7, (%rax)
; 		return libbpf_err(-E2BIG);
   26359: b8 f9 ff ff ff               	movl	$4294967289, %eax       # imm = 0xFFFFFFF9
   2635e: e9 95 f9 ff ff               	jmp	0x25cf8 <bpf_prog_load+0xa8>
; 	attach_btf_obj_fd = OPTS_GET(opts, attach_btf_obj_fd, 0);
   26363: 31 c9                        	xorl	%ecx, %ecx
   26365: e9 ac fa ff ff               	jmp	0x25e16 <bpf_prog_load+0x1c6>
; }
   2636a: e8 91 f4 fd ff               	callq	0x5800 <.plt.sec+0x190>
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   2636f: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
   26378: e9 c6 fa ff ff               	jmp	0x25e43 <bpf_prog_load+0x1f3>
; 	line_info_rec_size = OPTS_GET(opts, line_info_rec_size, 0);
   2637d: 31 db                        	xorl	%ebx, %ebx
   2637f: e9 62 fb ff ff               	jmp	0x25ee6 <bpf_prog_load+0x296>
   26384: c6 44 24 23 00               	movb	$0, 35(%rsp)
; 	log_level = OPTS_GET(opts, log_level, 0);
   26389: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   26391: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 	log_size = OPTS_GET(opts, log_size, 0);
   2639a: c7 44 24 24 00 00 00 00      	movl	$0, 36(%rsp)
; 	func_info_rec_size = OPTS_GET(opts, func_info_rec_size, 0);
   263a2: c7 44 24 14 00 00 00 00      	movl	$0, 20(%rsp)
   263aa: e9 e8 fa ff ff               	jmp	0x25e97 <bpf_prog_load+0x247>
; 	line_info_rec_size = OPTS_GET(opts, line_info_rec_size, 0);
   263af: 31 db                        	xorl	%ebx, %ebx
; 	line_info = OPTS_GET(opts, line_info, NULL);
   263b1: 45 31 ff                     	xorl	%r15d, %r15d
   263b4: e9 38 fb ff ff               	jmp	0x25ef1 <bpf_prog_load+0x2a1>
; 	log_level = OPTS_GET(opts, log_level, 0);
   263b9: 41 8b 7e 58                  	movl	88(%r14), %edi
; 	log_size = OPTS_GET(opts, log_size, 0);
   263bd: c7 44 24 24 00 00 00 00      	movl	$0, 36(%rsp)
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   263c5: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 	log_level = OPTS_GET(opts, log_level, 0);
   263ce: 89 7c 24 08                  	movl	%edi, 8(%rsp)
; 	if (!!log_buf != !!log_size)
   263d2: c6 44 24 23 00               	movb	$0, 35(%rsp)
   263d7: e9 94 fa ff ff               	jmp	0x25e70 <bpf_prog_load+0x220>
; 	attr.attach_btf_id = OPTS_GET(opts, attach_btf_id, 0);
   263dc: 41 8b 56 20                  	movl	32(%r14), %edx
; 	attach_btf_obj_fd = OPTS_GET(opts, attach_btf_obj_fd, 0);
   263e0: 31 c9                        	xorl	%ecx, %ecx
; 	attr.attach_btf_id = OPTS_GET(opts, attach_btf_id, 0);
   263e2: 89 94 24 9c 00 00 00         	movl	%edx, 156(%rsp)
; 	if (attach_prog_fd)
   263e9: e9 19 fd ff ff               	jmp	0x26107 <bpf_prog_load+0x4b7>
   263ee: 66 90                        	nop

00000000000263f0 <bpf_map_update_elem>:
; {
   263f0: f3 0f 1e fa                  	endbr64
   263f4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   263fb: 49 89 d0                     	movq	%rdx, %r8
   263fe: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26407: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2640f: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   26411: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.map_fd = fd;
   26414: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26417: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.key = ptr_to_u64(key);
   2641c: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26421: be 02 00 00 00               	movl	$2, %esi
; 	attr.flags = flags;
   26426: 48 89 4c 24 18               	movq	%rcx, 24(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2642b: b9 20 00 00 00               	movl	$32, %ecx
; 	attr.value = ptr_to_u64(value);
   26430: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26435: c7 44 24 04 00 00 00 00      	movl	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2643d: e8 9e f5 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26442: 41 89 c0                     	movl	%eax, %r8d
   26445: 85 c0                        	testl	%eax, %eax
   26447: 79 0b                        	jns	0x26454 <bpf_map_update_elem+0x64>
   26449: e8 a2 f2 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2644e: 44 8b 00                     	movl	(%rax), %r8d
   26451: 41 f7 d8                     	negl	%r8d
; }
   26454: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   2645c: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26465: 75 0b                        	jne	0x26472 <bpf_map_update_elem+0x82>
   26467: 44 89 c0                     	movl	%r8d, %eax
   2646a: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26471: c3                           	retq
   26472: e8 89 f3 fd ff               	callq	0x5800 <.plt.sec+0x190>
   26477: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000026480 <bpf_map_lookup_elem>:
; {
   26480: f3 0f 1e fa                  	endbr64
   26484: 48 81 ec a8 00 00 00         	subq	$168, %rsp
;   return __builtin___memset_chk (__dest, __ch, __len,
   2648b: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   2648f: 49 89 d0                     	movq	%rdx, %r8
; 	return syscall(__NR_bpf, cmd, attr, size);
   26492: b9 20 00 00 00               	movl	$32, %ecx
; {
   26497: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   264a0: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   264a8: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   264aa: 48 89 e2                     	movq	%rsp, %rdx
   264ad: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
; 	attr.map_fd = fd;
   264b1: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   264b4: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.key = ptr_to_u64(key);
   264b9: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   264be: be 01 00 00 00               	movl	$1, %esi
;   return __builtin___memset_chk (__dest, __ch, __len,
   264c3: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
; 	attr.value = ptr_to_u64(value);
   264c8: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   264cd: e8 0e f5 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   264d2: 41 89 c0                     	movl	%eax, %r8d
   264d5: 85 c0                        	testl	%eax, %eax
   264d7: 79 0b                        	jns	0x264e4 <bpf_map_lookup_elem+0x64>
   264d9: e8 12 f2 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   264de: 44 8b 00                     	movl	(%rax), %r8d
   264e1: 41 f7 d8                     	negl	%r8d
; }
   264e4: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   264ec: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   264f5: 75 0b                        	jne	0x26502 <bpf_map_lookup_elem+0x82>
   264f7: 44 89 c0                     	movl	%r8d, %eax
   264fa: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26501: c3                           	retq
   26502: e8 f9 f2 fd ff               	callq	0x5800 <.plt.sec+0x190>
   26507: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000026510 <bpf_map_lookup_elem_flags>:
; {
   26510: f3 0f 1e fa                  	endbr64
   26514: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   2651b: 49 89 d0                     	movq	%rdx, %r8
   2651e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26527: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2652f: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   26531: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.map_fd = fd;
   26534: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26537: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.key = ptr_to_u64(key);
   2653c: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26541: be 01 00 00 00               	movl	$1, %esi
; 	attr.flags = flags;
   26546: 48 89 4c 24 18               	movq	%rcx, 24(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2654b: b9 20 00 00 00               	movl	$32, %ecx
; 	attr.value = ptr_to_u64(value);
   26550: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26555: c7 44 24 04 00 00 00 00      	movl	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2655d: e8 7e f4 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26562: 41 89 c0                     	movl	%eax, %r8d
   26565: 85 c0                        	testl	%eax, %eax
   26567: 79 0b                        	jns	0x26574 <bpf_map_lookup_elem_flags+0x64>
   26569: e8 82 f1 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2656e: 44 8b 00                     	movl	(%rax), %r8d
   26571: 41 f7 d8                     	negl	%r8d
; }
   26574: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   2657c: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26585: 75 0b                        	jne	0x26592 <bpf_map_lookup_elem_flags+0x82>
   26587: 44 89 c0                     	movl	%r8d, %eax
   2658a: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26591: c3                           	retq
   26592: e8 69 f2 fd ff               	callq	0x5800 <.plt.sec+0x190>
   26597: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

00000000000265a0 <bpf_map_lookup_and_delete_elem>:
; {
   265a0: f3 0f 1e fa                  	endbr64
   265a4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
;   return __builtin___memset_chk (__dest, __ch, __len,
   265ab: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   265af: 49 89 d0                     	movq	%rdx, %r8
; 	return syscall(__NR_bpf, cmd, attr, size);
   265b2: b9 20 00 00 00               	movl	$32, %ecx
; {
   265b7: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   265c0: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   265c8: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   265ca: 48 89 e2                     	movq	%rsp, %rdx
   265cd: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
; 	attr.map_fd = fd;
   265d1: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   265d4: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.key = ptr_to_u64(key);
   265d9: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   265de: be 15 00 00 00               	movl	$21, %esi
;   return __builtin___memset_chk (__dest, __ch, __len,
   265e3: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
; 	attr.value = ptr_to_u64(value);
   265e8: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   265ed: e8 ee f3 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   265f2: 41 89 c0                     	movl	%eax, %r8d
   265f5: 85 c0                        	testl	%eax, %eax
   265f7: 79 0b                        	jns	0x26604 <bpf_map_lookup_and_delete_elem+0x64>
   265f9: e8 f2 f0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   265fe: 44 8b 00                     	movl	(%rax), %r8d
   26601: 41 f7 d8                     	negl	%r8d
; }
   26604: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   2660c: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26615: 75 0b                        	jne	0x26622 <bpf_map_lookup_and_delete_elem+0x82>
   26617: 44 89 c0                     	movl	%r8d, %eax
   2661a: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26621: c3                           	retq
   26622: e8 d9 f1 fd ff               	callq	0x5800 <.plt.sec+0x190>
   26627: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

0000000000026630 <bpf_map_lookup_and_delete_elem_flags>:
; {
   26630: f3 0f 1e fa                  	endbr64
   26634: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   2663b: 49 89 d0                     	movq	%rdx, %r8
   2663e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26647: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2664f: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   26651: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.map_fd = fd;
   26654: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26657: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.key = ptr_to_u64(key);
   2665c: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26661: be 15 00 00 00               	movl	$21, %esi
; 	attr.flags = flags;
   26666: 48 89 4c 24 18               	movq	%rcx, 24(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2666b: b9 20 00 00 00               	movl	$32, %ecx
; 	attr.value = ptr_to_u64(value);
   26670: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26675: c7 44 24 04 00 00 00 00      	movl	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2667d: e8 5e f3 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26682: 41 89 c0                     	movl	%eax, %r8d
   26685: 85 c0                        	testl	%eax, %eax
   26687: 79 0b                        	jns	0x26694 <bpf_map_lookup_and_delete_elem_flags+0x64>
   26689: e8 62 f0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2668e: 44 8b 00                     	movl	(%rax), %r8d
   26691: 41 f7 d8                     	negl	%r8d
; }
   26694: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   2669c: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   266a5: 75 0b                        	jne	0x266b2 <bpf_map_lookup_and_delete_elem_flags+0x82>
   266a7: 44 89 c0                     	movl	%r8d, %eax
   266aa: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   266b1: c3                           	retq
   266b2: e8 49 f1 fd ff               	callq	0x5800 <.plt.sec+0x190>
   266b7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

00000000000266c0 <bpf_map_delete_elem>:
; {
   266c0: f3 0f 1e fa                  	endbr64
   266c4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
;   return __builtin___memset_chk (__dest, __ch, __len,
   266cb: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	return syscall(__NR_bpf, cmd, attr, size);
   266cf: b9 20 00 00 00               	movl	$32, %ecx
; {
   266d4: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   266dd: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   266e5: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   266e7: 48 89 e2                     	movq	%rsp, %rdx
   266ea: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
; 	attr.map_fd = fd;
   266ee: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   266f1: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.key = ptr_to_u64(key);
   266f6: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   266fb: be 03 00 00 00               	movl	$3, %esi
;   return __builtin___memset_chk (__dest, __ch, __len,
   26700: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26705: e8 d6 f2 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   2670a: 41 89 c0                     	movl	%eax, %r8d
   2670d: 85 c0                        	testl	%eax, %eax
   2670f: 79 0b                        	jns	0x2671c <bpf_map_delete_elem+0x5c>
   26711: e8 da ef fd ff               	callq	0x56f0 <.plt.sec+0x80>
   26716: 44 8b 00                     	movl	(%rax), %r8d
   26719: 41 f7 d8                     	negl	%r8d
; }
   2671c: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   26724: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2672d: 75 0b                        	jne	0x2673a <bpf_map_delete_elem+0x7a>
   2672f: 44 89 c0                     	movl	%r8d, %eax
   26732: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26739: c3                           	retq
   2673a: e8 c1 f0 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2673f: 90                           	nop

0000000000026740 <bpf_map_delete_elem_flags>:
; {
   26740: f3 0f 1e fa                  	endbr64
   26744: 48 81 ec a8 00 00 00         	subq	$168, %rsp
;   return __builtin___memset_chk (__dest, __ch, __len,
   2674b: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   2674f: 49 89 d0                     	movq	%rdx, %r8
; 	return syscall(__NR_bpf, cmd, attr, size);
   26752: b9 20 00 00 00               	movl	$32, %ecx
; {
   26757: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26760: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26768: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   2676a: 48 89 e2                     	movq	%rsp, %rdx
   2676d: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
; 	attr.map_fd = fd;
   26771: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26774: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.key = ptr_to_u64(key);
   26779: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2677e: be 03 00 00 00               	movl	$3, %esi
; 	attr.flags = flags;
   26783: 4c 89 44 24 18               	movq	%r8, 24(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26788: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26791: e8 4a f2 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26796: 41 89 c0                     	movl	%eax, %r8d
   26799: 85 c0                        	testl	%eax, %eax
   2679b: 79 0b                        	jns	0x267a8 <bpf_map_delete_elem_flags+0x68>
   2679d: e8 4e ef fd ff               	callq	0x56f0 <.plt.sec+0x80>
   267a2: 44 8b 00                     	movl	(%rax), %r8d
   267a5: 41 f7 d8                     	negl	%r8d
; }
   267a8: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   267b0: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   267b9: 75 0b                        	jne	0x267c6 <bpf_map_delete_elem_flags+0x86>
   267bb: 44 89 c0                     	movl	%r8d, %eax
   267be: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   267c5: c3                           	retq
   267c6: e8 35 f0 fd ff               	callq	0x5800 <.plt.sec+0x190>
   267cb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

00000000000267d0 <bpf_map_get_next_key>:
; {
   267d0: f3 0f 1e fa                  	endbr64
   267d4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   267db: 49 89 d0                     	movq	%rdx, %r8
; 	return syscall(__NR_bpf, cmd, attr, size);
   267de: b9 18 00 00 00               	movl	$24, %ecx
; {
   267e3: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   267ec: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   267f4: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   267f6: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.map_fd = fd;
   267f9: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   267fc: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.key = ptr_to_u64(key);
   26801: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26806: be 04 00 00 00               	movl	$4, %esi
; 	attr.next_key = ptr_to_u64(next_key);
   2680b: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26810: c7 44 24 04 00 00 00 00      	movl	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26818: e8 c3 f1 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   2681d: 41 89 c0                     	movl	%eax, %r8d
   26820: 85 c0                        	testl	%eax, %eax
   26822: 79 0b                        	jns	0x2682f <bpf_map_get_next_key+0x5f>
   26824: e8 c7 ee fd ff               	callq	0x56f0 <.plt.sec+0x80>
   26829: 44 8b 00                     	movl	(%rax), %r8d
   2682c: 41 f7 d8                     	negl	%r8d
; }
   2682f: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   26837: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26840: 75 0b                        	jne	0x2684d <bpf_map_get_next_key+0x7d>
   26842: 44 89 c0                     	movl	%r8d, %eax
   26845: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   2684c: c3                           	retq
   2684d: e8 ae ef fd ff               	callq	0x5800 <.plt.sec+0x190>
   26852: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2685d: 0f 1f 00                     	nopl	(%rax)

0000000000026860 <bpf_map_freeze>:
; {
   26860: f3 0f 1e fa                  	endbr64
   26864: 48 81 ec a8 00 00 00         	subq	$168, %rsp
; 	return syscall(__NR_bpf, cmd, attr, size);
   2686b: b9 04 00 00 00               	movl	$4, %ecx
   26870: be 16 00 00 00               	movl	$22, %esi
; {
   26875: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2687e: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26886: 31 c0                        	xorl	%eax, %eax
; 	return syscall(__NR_bpf, cmd, attr, size);
   26888: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.map_fd = fd;
   2688b: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2688e: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   26893: e8 48 f1 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26898: 41 89 c0                     	movl	%eax, %r8d
   2689b: 85 c0                        	testl	%eax, %eax
   2689d: 79 0b                        	jns	0x268aa <bpf_map_freeze+0x4a>
   2689f: e8 4c ee fd ff               	callq	0x56f0 <.plt.sec+0x80>
   268a4: 44 8b 00                     	movl	(%rax), %r8d
   268a7: 41 f7 d8                     	negl	%r8d
; }
   268aa: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   268b2: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   268bb: 75 0b                        	jne	0x268c8 <bpf_map_freeze+0x68>
   268bd: 44 89 c0                     	movl	%r8d, %eax
   268c0: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   268c7: c3                           	retq
   268c8: e8 33 ef fd ff               	callq	0x5800 <.plt.sec+0x190>
   268cd: 0f 1f 00                     	nopl	(%rax)

00000000000268d0 <bpf_map_delete_batch>:
; {
   268d0: f3 0f 1e fa                  	endbr64
   268d4: 48 83 ec 08                  	subq	$8, %rsp
   268d8: 49 89 f0                     	movq	%rsi, %r8
; 	return bpf_map_batch_common(BPF_MAP_DELETE_BATCH, fd, NULL,
   268db: 45 31 c9                     	xorl	%r9d, %r9d
   268de: 89 fe                        	movl	%edi, %esi
   268e0: 51                           	pushq	%rcx
   268e1: bf 1b 00 00 00               	movl	$27, %edi
   268e6: 31 c9                        	xorl	%ecx, %ecx
   268e8: 52                           	pushq	%rdx
   268e9: 31 d2                        	xorl	%edx, %edx
   268eb: e8 40 eb ff ff               	callq	0x25430 <bpf_map_batch_common>
; }
   268f0: 48 83 c4 18                  	addq	$24, %rsp
   268f4: c3                           	retq
   268f5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

0000000000026900 <bpf_map_lookup_batch>:
; {
   26900: f3 0f 1e fa                  	endbr64
   26904: 41 54                        	pushq	%r12
; 	return bpf_map_batch_common(BPF_MAP_LOOKUP_BATCH, fd, in_batch,
   26906: ff 74 24 10                  	pushq	16(%rsp)
   2690a: 41 51                        	pushq	%r9
   2690c: 4d 89 c1                     	movq	%r8, %r9
   2690f: 49 89 c8                     	movq	%rcx, %r8
   26912: 48 89 d1                     	movq	%rdx, %rcx
   26915: 48 89 f2                     	movq	%rsi, %rdx
   26918: 89 fe                        	movl	%edi, %esi
   2691a: bf 18 00 00 00               	movl	$24, %edi
   2691f: e8 0c eb ff ff               	callq	0x25430 <bpf_map_batch_common>
   26924: 5a                           	popq	%rdx
   26925: 59                           	popq	%rcx
; }
   26926: 41 5c                        	popq	%r12
   26928: c3                           	retq
   26929: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000026930 <bpf_map_lookup_and_delete_batch>:
; {
   26930: f3 0f 1e fa                  	endbr64
   26934: 41 54                        	pushq	%r12
; 	return bpf_map_batch_common(BPF_MAP_LOOKUP_AND_DELETE_BATCH,
   26936: ff 74 24 10                  	pushq	16(%rsp)
   2693a: 41 51                        	pushq	%r9
   2693c: 4d 89 c1                     	movq	%r8, %r9
   2693f: 49 89 c8                     	movq	%rcx, %r8
   26942: 48 89 d1                     	movq	%rdx, %rcx
   26945: 48 89 f2                     	movq	%rsi, %rdx
   26948: 89 fe                        	movl	%edi, %esi
   2694a: bf 19 00 00 00               	movl	$25, %edi
   2694f: e8 dc ea ff ff               	callq	0x25430 <bpf_map_batch_common>
   26954: 5a                           	popq	%rdx
   26955: 59                           	popq	%rcx
; }
   26956: 41 5c                        	popq	%r12
   26958: c3                           	retq
   26959: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000026960 <bpf_map_update_batch>:
; {
   26960: f3 0f 1e fa                  	endbr64
   26964: 48 83 ec 08                  	subq	$8, %rsp
   26968: 49 89 d1                     	movq	%rdx, %r9
; 	return bpf_map_batch_common(BPF_MAP_UPDATE_BATCH, fd, NULL, NULL,
   2696b: 31 d2                        	xorl	%edx, %edx
   2696d: 41 50                        	pushq	%r8
   2696f: 49 89 f0                     	movq	%rsi, %r8
   26972: 89 fe                        	movl	%edi, %esi
   26974: bf 1a 00 00 00               	movl	$26, %edi
   26979: 51                           	pushq	%rcx
   2697a: 31 c9                        	xorl	%ecx, %ecx
   2697c: e8 af ea ff ff               	callq	0x25430 <bpf_map_batch_common>
; }
   26981: 48 83 c4 18                  	addq	$24, %rsp
   26985: c3                           	retq
   26986: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000026990 <bpf_obj_pin>:
; {
   26990: f3 0f 1e fa                  	endbr64
   26994: 48 81 ec a8 00 00 00         	subq	$168, %rsp
; 	return syscall(__NR_bpf, cmd, attr, size);
   2699b: b9 10 00 00 00               	movl	$16, %ecx
; {
   269a0: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   269a9: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   269b1: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   269b3: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.pathname = ptr_to_u64((void *)pathname);
   269b6: 48 89 34 24                  	movq	%rsi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   269ba: be 06 00 00 00               	movl	$6, %esi
; 	attr.bpf_fd = fd;
   269bf: 89 7c 24 08                  	movl	%edi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   269c3: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   269c8: c7 44 24 0c 00 00 00 00      	movl	$0, 12(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   269d0: e8 0b f0 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   269d5: 41 89 c0                     	movl	%eax, %r8d
   269d8: 85 c0                        	testl	%eax, %eax
   269da: 79 0b                        	jns	0x269e7 <bpf_obj_pin+0x57>
   269dc: e8 0f ed fd ff               	callq	0x56f0 <.plt.sec+0x80>
   269e1: 44 8b 00                     	movl	(%rax), %r8d
   269e4: 41 f7 d8                     	negl	%r8d
; }
   269e7: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   269ef: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   269f8: 75 0b                        	jne	0x26a05 <bpf_obj_pin+0x75>
   269fa: 44 89 c0                     	movl	%r8d, %eax
   269fd: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26a04: c3                           	retq
   26a05: e8 f6 ed fd ff               	callq	0x5800 <.plt.sec+0x190>
   26a0a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

0000000000026a10 <bpf_obj_get>:
; {
   26a10: f3 0f 1e fa                  	endbr64
   26a14: 41 55                        	pushq	%r13
; 	return syscall(__NR_bpf, cmd, attr, size);
   26a16: b9 10 00 00 00               	movl	$16, %ecx
   26a1b: be 07 00 00 00               	movl	$7, %esi
; {
   26a20: 41 54                        	pushq	%r12
   26a22: 55                           	pushq	%rbp
   26a23: 53                           	pushq	%rbx
   26a24: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   26a2b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26a34: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26a3c: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   26a3e: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.pathname = ptr_to_u64((void *)pathname);
   26a41: 48 89 3c 24                  	movq	%rdi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26a45: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   26a4a: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	attr.file_flags = OPTS_GET(opts, file_flags, 0);
   26a52: c7 44 24 0c 00 00 00 00      	movl	$0, 12(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26a5a: e8 81 ef fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   26a5f: 85 c0                        	testl	%eax, %eax
   26a61: 78 6d                        	js	0x26ad0 <bpf_obj_get+0xc0>
   26a63: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 3) {
   26a66: 83 f8 02                     	cmpl	$2, %eax
   26a69: 7e 2d                        	jle	0x26a98 <bpf_obj_get+0x88>
; }
   26a6b: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   26a73: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26a7c: 0f 85 84 00 00 00            	jne	0x26b06 <bpf_obj_get+0xf6>
   26a82: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26a89: 44 89 e0                     	movl	%r12d, %eax
   26a8c: 5b                           	popq	%rbx
   26a8d: 5d                           	popq	%rbp
   26a8e: 41 5c                        	popq	%r12
   26a90: 41 5d                        	popq	%r13
   26a92: c3                           	retq
   26a93: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   26a98: 89 c7                        	movl	%eax, %edi
   26a9a: ba 03 00 00 00               	movl	$3, %edx
   26a9f: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   26aa4: 31 c0                        	xorl	%eax, %eax
   26aa6: e8 c5 f0 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   26aab: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   26aad: e8 3e ec fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   26ab2: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   26ab5: 44 8b 28                     	movl	(%rax), %r13d
   26ab8: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   26abb: e8 40 ee fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   26ac0: 85 db                        	testl	%ebx, %ebx
   26ac2: 78 1c                        	js	0x26ae0 <bpf_obj_get+0xd0>
   26ac4: 41 89 dc                     	movl	%ebx, %r12d
; 	return bpf_obj_get_opts(pathname, NULL);
   26ac7: eb a2                        	jmp	0x26a6b <bpf_obj_get+0x5b>
   26ac9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		saved_errno = errno;
   26ad0: e8 1b ec fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   26ad5: 44 8b 20                     	movl	(%rax), %r12d
   26ad8: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   26adb: eb 8e                        	jmp	0x26a6b <bpf_obj_get+0x5b>
   26add: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   26ae0: 44 89 eb                     	movl	%r13d, %ebx
   26ae3: 44 89 e2                     	movl	%r12d, %edx
   26ae6: 48 8d 35 db 44 01 00         	leaq	83163(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   26aed: 31 ff                        	xorl	%edi, %edi
   26aef: f7 db                        	negl	%ebx
   26af1: 31 c0                        	xorl	%eax, %eax
   26af3: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   26af5: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   26af8: e8 d3 15 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   26afd: 44 89 6d 00                  	movl	%r13d, (%rbp)
   26b01: e9 65 ff ff ff               	jmp	0x26a6b <bpf_obj_get+0x5b>
; }
   26b06: e8 f5 ec fd ff               	callq	0x5800 <.plt.sec+0x190>
   26b0b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000026b10 <bpf_obj_get_opts>:
; {
   26b10: f3 0f 1e fa                  	endbr64
   26b14: 41 55                        	pushq	%r13
   26b16: 41 54                        	pushq	%r12
   26b18: 55                           	pushq	%rbp
   26b19: 53                           	pushq	%rbx
   26b1a: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   26b21: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26b2a: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26b32: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_obj_get_opts))
   26b34: 48 85 f6                     	testq	%rsi, %rsi
   26b37: 0f 84 13 01 00 00            	je	0x26c50 <bpf_obj_get_opts+0x140>
   26b3d: 48 8b 0e                     	movq	(%rsi), %rcx
; 	if (user_sz < sizeof(size_t)) {
   26b40: 48 83 f9 07                  	cmpq	$7, %rcx
   26b44: 0f 86 56 01 00 00            	jbe	0x26ca0 <bpf_obj_get_opts+0x190>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   26b4a: 48 8d 51 f4                  	leaq	-12(%rcx), %rdx
   26b4e: 48 8d 46 0c                  	leaq	12(%rsi), %rax
; 	while (len > 0) {
   26b52: 48 85 d2                     	testq	%rdx, %rdx
   26b55: 7e 79                        	jle	0x26bd0 <bpf_obj_get_opts+0xc0>
   26b57: 48 8d 14 0e                  	leaq	(%rsi,%rcx), %rdx
   26b5b: eb 0c                        	jmp	0x26b69 <bpf_obj_get_opts+0x59>
   26b5d: 0f 1f 00                     	nopl	(%rax)
; 		p++;
   26b60: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   26b64: 48 39 c2                     	cmpq	%rax, %rdx
   26b67: 74 67                        	je	0x26bd0 <bpf_obj_get_opts+0xc0>
; 		if (*p)
   26b69: 80 38 00                     	cmpb	$0, (%rax)
   26b6c: 74 f2                        	je	0x26b60 <bpf_obj_get_opts+0x50>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   26b6e: 48 8d 15 b7 43 01 00         	leaq	82871(%rip), %rdx       # 0x3af2c <CSWTCH.126+0x162c>
   26b75: 48 8d 35 94 d4 00 00         	leaq	54420(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   26b7c: 31 ff                        	xorl	%edi, %edi
   26b7e: 31 c0                        	xorl	%eax, %eax
   26b80: e8 4b 15 fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   26b85: e8 66 eb fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   26b8a: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   26b90: c7 00 16 00 00 00            	movl	$22, (%rax)
   26b96: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; }
   26ba0: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   26ba8: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26bb1: 0f 85 03 01 00 00            	jne	0x26cba <bpf_obj_get_opts+0x1aa>
   26bb7: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26bbe: 44 89 e0                     	movl	%r12d, %eax
   26bc1: 5b                           	popq	%rbx
   26bc2: 5d                           	popq	%rbp
   26bc3: 41 5c                        	popq	%r12
   26bc5: 41 5d                        	popq	%r13
   26bc7: c3                           	retq
   26bc8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26bd0: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	attr.file_flags = OPTS_GET(opts, file_flags, 0);
   26bd8: 31 c0                        	xorl	%eax, %eax
; 	attr.pathname = ptr_to_u64((void *)pathname);
   26bda: 48 89 3c 24                  	movq	%rdi, (%rsp)
; 	attr.file_flags = OPTS_GET(opts, file_flags, 0);
   26bde: 48 83 f9 0b                  	cmpq	$11, %rcx
   26be2: 77 64                        	ja	0x26c48 <bpf_obj_get_opts+0x138>
   26be4: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26be8: 48 89 e2                     	movq	%rsp, %rdx
   26beb: b9 10 00 00 00               	movl	$16, %ecx
   26bf0: 31 c0                        	xorl	%eax, %eax
   26bf2: be 07 00 00 00               	movl	$7, %esi
   26bf7: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   26bfc: e8 df ed fd ff               	callq	0x59e0 <.plt.sec+0x370>
   26c01: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 0)
   26c04: 85 c0                        	testl	%eax, %eax
   26c06: 78 58                        	js	0x26c60 <bpf_obj_get_opts+0x150>
; 	if (fd < 3) {
   26c08: 83 f8 02                     	cmpl	$2, %eax
   26c0b: 7f 93                        	jg	0x26ba0 <bpf_obj_get_opts+0x90>
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   26c0d: 89 c7                        	movl	%eax, %edi
   26c0f: ba 03 00 00 00               	movl	$3, %edx
   26c14: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   26c19: 31 c0                        	xorl	%eax, %eax
   26c1b: e8 50 ef fd ff               	callq	0x5b70 <.plt.sec+0x500>
   26c20: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   26c22: e8 c9 ea fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   26c27: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   26c2a: 44 8b 28                     	movl	(%rax), %r13d
   26c2d: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   26c30: e8 cb ec fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   26c35: 85 db                        	testl	%ebx, %ebx
   26c37: 78 37                        	js	0x26c70 <bpf_obj_get_opts+0x160>
   26c39: 41 89 dc                     	movl	%ebx, %r12d
   26c3c: e9 5f ff ff ff               	jmp	0x26ba0 <bpf_obj_get_opts+0x90>
   26c41: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	attr.file_flags = OPTS_GET(opts, file_flags, 0);
   26c48: 8b 46 08                     	movl	8(%rsi), %eax
   26c4b: eb 97                        	jmp	0x26be4 <bpf_obj_get_opts+0xd4>
   26c4d: 0f 1f 00                     	nopl	(%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26c50: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	attr.file_flags = OPTS_GET(opts, file_flags, 0);
   26c58: 31 c0                        	xorl	%eax, %eax
; 	attr.pathname = ptr_to_u64((void *)pathname);
   26c5a: 48 89 3c 24                  	movq	%rdi, (%rsp)
; 	attr.file_flags = OPTS_GET(opts, file_flags, 0);
   26c5e: eb 84                        	jmp	0x26be4 <bpf_obj_get_opts+0xd4>
; 		errno = -ret;
   26c60: e8 8b ea fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   26c65: 44 8b 20                     	movl	(%rax), %r12d
   26c68: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   26c6b: e9 30 ff ff ff               	jmp	0x26ba0 <bpf_obj_get_opts+0x90>
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   26c70: 44 89 eb                     	movl	%r13d, %ebx
   26c73: 44 89 e2                     	movl	%r12d, %edx
   26c76: 48 8d 35 4b 43 01 00         	leaq	82763(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   26c7d: 31 ff                        	xorl	%edi, %edi
   26c7f: f7 db                        	negl	%ebx
   26c81: 31 c0                        	xorl	%eax, %eax
   26c83: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   26c85: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   26c88: e8 43 14 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   26c8d: 44 89 6d 00                  	movl	%r13d, (%rbp)
   26c91: e9 0a ff ff ff               	jmp	0x26ba0 <bpf_obj_get_opts+0x90>
   26c96: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   26ca0: 48 8d 15 85 42 01 00         	leaq	82565(%rip), %rdx       # 0x3af2c <CSWTCH.126+0x162c>
   26ca7: 48 8d 35 0a d3 00 00         	leaq	54026(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   26cae: 31 ff                        	xorl	%edi, %edi
   26cb0: e8 1b 14 fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   26cb5: e9 cb fe ff ff               	jmp	0x26b85 <bpf_obj_get_opts+0x75>
; }
   26cba: e8 41 eb fd ff               	callq	0x5800 <.plt.sec+0x190>
   26cbf: 90                           	nop

0000000000026cc0 <bpf_prog_attach>:
; {
   26cc0: f3 0f 1e fa                  	endbr64
   26cc4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   26ccb: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26cd4: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26cdc: 31 c0                        	xorl	%eax, %eax
; 	attr.target_fd	   = target_fd;
   26cde: 89 34 24                     	movl	%esi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26ce1: be 08 00 00 00               	movl	$8, %esi
; 	attr.attach_bpf_fd = prog_fd;
   26ce6: 89 7c 24 04                  	movl	%edi, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26cea: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.attach_type   = type;
   26cef: 89 54 24 08                  	movl	%edx, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26cf3: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.attach_flags  = OPTS_GET(opts, flags, 0);
   26cf6: 89 4c 24 0c                  	movl	%ecx, 12(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26cfa: b9 14 00 00 00               	movl	$20, %ecx
; 	attr.replace_bpf_fd = OPTS_GET(opts, replace_prog_fd, 0);
   26cff: c7 44 24 10 00 00 00 00      	movl	$0, 16(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26d07: e8 d4 ec fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26d0c: 41 89 c0                     	movl	%eax, %r8d
   26d0f: 85 c0                        	testl	%eax, %eax
   26d11: 79 0b                        	jns	0x26d1e <bpf_prog_attach+0x5e>
   26d13: e8 d8 e9 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   26d18: 44 8b 00                     	movl	(%rax), %r8d
   26d1b: 41 f7 d8                     	negl	%r8d
; }
   26d1e: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   26d26: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26d2f: 75 0b                        	jne	0x26d3c <bpf_prog_attach+0x7c>
   26d31: 44 89 c0                     	movl	%r8d, %eax
   26d34: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26d3b: c3                           	retq
   26d3c: e8 bf ea fd ff               	callq	0x5800 <.plt.sec+0x190>
   26d41: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   26d4c: 0f 1f 40 00                  	nopl	(%rax)

0000000000026d50 <bpf_prog_attach_opts>:
; {
   26d50: f3 0f 1e fa                  	endbr64
   26d54: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   26d5b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26d64: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26d6c: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_prog_attach_opts))
   26d6e: 48 85 c9                     	testq	%rcx, %rcx
   26d71: 0f 84 d9 00 00 00            	je	0x26e50 <bpf_prog_attach_opts+0x100>
   26d77: 4c 8b 09                     	movq	(%rcx), %r9
; 	if (user_sz < sizeof(size_t)) {
   26d7a: 49 83 f9 07                  	cmpq	$7, %r9
   26d7e: 0f 86 ec 00 00 00            	jbe	0x26e70 <bpf_prog_attach_opts+0x120>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   26d84: 4d 8d 41 f0                  	leaq	-16(%r9), %r8
   26d88: 48 8d 41 10                  	leaq	16(%rcx), %rax
; 	while (len > 0) {
   26d8c: 4d 85 c0                     	testq	%r8, %r8
   26d8f: 7e 4f                        	jle	0x26de0 <bpf_prog_attach_opts+0x90>
   26d91: 4e 8d 04 09                  	leaq	(%rcx,%r9), %r8
   26d95: eb 12                        	jmp	0x26da9 <bpf_prog_attach_opts+0x59>
   26d97: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		p++;
   26da0: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   26da4: 49 39 c0                     	cmpq	%rax, %r8
   26da7: 74 37                        	je	0x26de0 <bpf_prog_attach_opts+0x90>
; 		if (*p)
   26da9: 80 38 00                     	cmpb	$0, (%rax)
   26dac: 74 f2                        	je	0x26da0 <bpf_prog_attach_opts+0x50>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   26dae: 48 8d 15 88 41 01 00         	leaq	82312(%rip), %rdx       # 0x3af3d <CSWTCH.126+0x163d>
   26db5: 48 8d 35 54 d2 00 00         	leaq	53844(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   26dbc: 31 ff                        	xorl	%edi, %edi
   26dbe: 31 c0                        	xorl	%eax, %eax
   26dc0: e8 0b 13 fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   26dc5: e8 26 e9 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   26dca: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
; 		errno = -ret;
   26dd0: c7 00 16 00 00 00            	movl	$22, (%rax)
   26dd6: eb 5a                        	jmp	0x26e32 <bpf_prog_attach_opts+0xe2>
   26dd8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	attr.target_fd	   = target_fd;
   26de0: 89 34 24                     	movl	%esi, (%rsp)
; 	attr.attach_flags  = OPTS_GET(opts, flags, 0);
   26de3: 31 c0                        	xorl	%eax, %eax
; 	attr.attach_bpf_fd = prog_fd;
   26de5: 89 7c 24 04                  	movl	%edi, 4(%rsp)
; 	attr.attach_type   = type;
   26de9: 89 54 24 08                  	movl	%edx, 8(%rsp)
; 	attr.attach_flags  = OPTS_GET(opts, flags, 0);
   26ded: 49 83 f9 0b                  	cmpq	$11, %r9
   26df1: 76 03                        	jbe	0x26df6 <bpf_prog_attach_opts+0xa6>
   26df3: 8b 41 08                     	movl	8(%rcx), %eax
   26df6: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	attr.replace_bpf_fd = OPTS_GET(opts, replace_prog_fd, 0);
   26dfa: 49 83 f9 0f                  	cmpq	$15, %r9
   26dfe: 76 63                        	jbe	0x26e63 <bpf_prog_attach_opts+0x113>
   26e00: 8b 41 0c                     	movl	12(%rcx), %eax
   26e03: 89 44 24 10                  	movl	%eax, 16(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26e07: 48 89 e2                     	movq	%rsp, %rdx
   26e0a: b9 14 00 00 00               	movl	$20, %ecx
   26e0f: 31 c0                        	xorl	%eax, %eax
   26e11: be 08 00 00 00               	movl	$8, %esi
   26e16: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   26e1b: e8 c0 eb fd ff               	callq	0x59e0 <.plt.sec+0x370>
   26e20: 41 89 c0                     	movl	%eax, %r8d
; 	return ret < 0 ? -errno : ret;
   26e23: 85 c0                        	testl	%eax, %eax
   26e25: 79 0b                        	jns	0x26e32 <bpf_prog_attach_opts+0xe2>
   26e27: e8 c4 e8 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   26e2c: 44 8b 00                     	movl	(%rax), %r8d
   26e2f: 41 f7 d8                     	negl	%r8d
; }
   26e32: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   26e3a: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26e43: 75 48                        	jne	0x26e8d <bpf_prog_attach_opts+0x13d>
   26e45: 44 89 c0                     	movl	%r8d, %eax
   26e48: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26e4f: c3                           	retq
; 	attr.target_fd	   = target_fd;
   26e50: 89 34 24                     	movl	%esi, (%rsp)
; 	attr.attach_bpf_fd = prog_fd;
   26e53: 89 7c 24 04                  	movl	%edi, 4(%rsp)
; 	attr.attach_type   = type;
   26e57: 89 54 24 08                  	movl	%edx, 8(%rsp)
; 	attr.attach_flags  = OPTS_GET(opts, flags, 0);
   26e5b: c7 44 24 0c 00 00 00 00      	movl	$0, 12(%rsp)
; 	attr.replace_bpf_fd = OPTS_GET(opts, replace_prog_fd, 0);
   26e63: 31 c0                        	xorl	%eax, %eax
   26e65: eb 9c                        	jmp	0x26e03 <bpf_prog_attach_opts+0xb3>
   26e67: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   26e70: 4c 89 c9                     	movq	%r9, %rcx
   26e73: 48 8d 15 c3 40 01 00         	leaq	82115(%rip), %rdx       # 0x3af3d <CSWTCH.126+0x163d>
   26e7a: 48 8d 35 37 d1 00 00         	leaq	53559(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   26e81: 31 ff                        	xorl	%edi, %edi
   26e83: e8 48 12 fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   26e88: e9 38 ff ff ff               	jmp	0x26dc5 <bpf_prog_attach_opts+0x75>
; }
   26e8d: e8 6e e9 fd ff               	callq	0x5800 <.plt.sec+0x190>
   26e92: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   26e9d: 0f 1f 00                     	nopl	(%rax)

0000000000026ea0 <bpf_prog_detach>:
; {
   26ea0: f3 0f 1e fa                  	endbr64
   26ea4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
;   return __builtin___memset_chk (__dest, __ch, __len,
   26eab: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	return syscall(__NR_bpf, cmd, attr, size);
   26eaf: b9 14 00 00 00               	movl	$20, %ecx
; {
   26eb4: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26ebd: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26ec5: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   26ec7: 48 89 e2                     	movq	%rsp, %rdx
   26eca: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
; 	attr.target_fd	 = target_fd;
   26ece: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26ed1: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.attach_type = type;
   26ed6: 89 74 24 08                  	movl	%esi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26eda: be 09 00 00 00               	movl	$9, %esi
;   return __builtin___memset_chk (__dest, __ch, __len,
   26edf: c7 44 24 10 00 00 00 00      	movl	$0, 16(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26ee7: e8 f4 ea fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26eec: 41 89 c0                     	movl	%eax, %r8d
   26eef: 85 c0                        	testl	%eax, %eax
   26ef1: 79 0b                        	jns	0x26efe <bpf_prog_detach+0x5e>
   26ef3: e8 f8 e7 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   26ef8: 44 8b 00                     	movl	(%rax), %r8d
   26efb: 41 f7 d8                     	negl	%r8d
; }
   26efe: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   26f06: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26f0f: 75 0b                        	jne	0x26f1c <bpf_prog_detach+0x7c>
   26f11: 44 89 c0                     	movl	%r8d, %eax
   26f14: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26f1b: c3                           	retq
   26f1c: e8 df e8 fd ff               	callq	0x5800 <.plt.sec+0x190>
   26f21: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   26f2c: 0f 1f 40 00                  	nopl	(%rax)

0000000000026f30 <bpf_prog_detach2>:
; {
   26f30: f3 0f 1e fa                  	endbr64
   26f34: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   26f3b: 41 89 d0                     	movl	%edx, %r8d
; 	return syscall(__NR_bpf, cmd, attr, size);
   26f3e: b9 14 00 00 00               	movl	$20, %ecx
; {
   26f43: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26f4c: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26f54: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   26f56: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.target_fd	 = target_fd;
   26f59: 89 34 24                     	movl	%esi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26f5c: be 09 00 00 00               	movl	$9, %esi
; 	attr.attach_bpf_fd = prog_fd;
   26f61: 89 7c 24 04                  	movl	%edi, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26f65: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.attach_type = type;
   26f6a: 44 89 44 24 08               	movl	%r8d, 8(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   26f6f: 48 c7 44 24 0c 00 00 00 00   	movq	$0, 12(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26f78: e8 63 ea fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26f7d: 41 89 c0                     	movl	%eax, %r8d
   26f80: 85 c0                        	testl	%eax, %eax
   26f82: 79 0b                        	jns	0x26f8f <bpf_prog_detach2+0x5f>
   26f84: e8 67 e7 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   26f89: 44 8b 00                     	movl	(%rax), %r8d
   26f8c: 41 f7 d8                     	negl	%r8d
; }
   26f8f: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   26f97: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   26fa0: 75 0b                        	jne	0x26fad <bpf_prog_detach2+0x7d>
   26fa2: 44 89 c0                     	movl	%r8d, %eax
   26fa5: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   26fac: c3                           	retq
   26fad: e8 4e e8 fd ff               	callq	0x5800 <.plt.sec+0x190>
   26fb2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   26fbd: 0f 1f 00                     	nopl	(%rax)

0000000000026fc0 <bpf_link_detach>:
; {
   26fc0: f3 0f 1e fa                  	endbr64
   26fc4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
; 	return syscall(__NR_bpf, cmd, attr, size);
   26fcb: b9 04 00 00 00               	movl	$4, %ecx
   26fd0: be 22 00 00 00               	movl	$34, %esi
; {
   26fd5: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   26fde: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   26fe6: 31 c0                        	xorl	%eax, %eax
; 	return syscall(__NR_bpf, cmd, attr, size);
   26fe8: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.link_detach.link_fd = link_fd;
   26feb: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   26fee: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   26ff3: e8 e8 e9 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	return ret < 0 ? -errno : ret;
   26ff8: 41 89 c0                     	movl	%eax, %r8d
   26ffb: 85 c0                        	testl	%eax, %eax
   26ffd: 79 0b                        	jns	0x2700a <bpf_link_detach+0x4a>
   26fff: e8 ec e6 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   27004: 44 8b 00                     	movl	(%rax), %r8d
   27007: 41 f7 d8                     	negl	%r8d
; }
   2700a: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   27012: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2701b: 75 0b                        	jne	0x27028 <bpf_link_detach+0x68>
   2701d: 44 89 c0                     	movl	%r8d, %eax
   27020: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   27027: c3                           	retq
   27028: e8 d3 e7 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2702d: 0f 1f 00                     	nopl	(%rax)

0000000000027030 <bpf_link_update>:
; {
   27030: f3 0f 1e fa                  	endbr64
   27034: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   2703b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27044: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2704c: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_link_update_opts))
   2704e: 48 85 d2                     	testq	%rdx, %rdx
   27051: 0f 84 d9 00 00 00            	je	0x27130 <bpf_link_update+0x100>
   27057: 4c 8b 02                     	movq	(%rdx), %r8
; 	if (user_sz < sizeof(size_t)) {
   2705a: 49 83 f8 07                  	cmpq	$7, %r8
   2705e: 0f 86 e4 00 00 00            	jbe	0x27148 <bpf_link_update+0x118>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   27064: 49 8d 48 f0                  	leaq	-16(%r8), %rcx
   27068: 48 8d 42 10                  	leaq	16(%rdx), %rax
; 	while (len > 0) {
   2706c: 48 85 c9                     	testq	%rcx, %rcx
   2706f: 7e 4f                        	jle	0x270c0 <bpf_link_update+0x90>
   27071: 4a 8d 0c 02                  	leaq	(%rdx,%r8), %rcx
   27075: eb 12                        	jmp	0x27089 <bpf_link_update+0x59>
   27077: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		p++;
   27080: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   27084: 48 39 c1                     	cmpq	%rax, %rcx
   27087: 74 37                        	je	0x270c0 <bpf_link_update+0x90>
; 		if (*p)
   27089: 80 38 00                     	cmpb	$0, (%rax)
   2708c: 74 f2                        	je	0x27080 <bpf_link_update+0x50>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   2708e: 48 8d 15 bd 3e 01 00         	leaq	81597(%rip), %rdx       # 0x3af52 <CSWTCH.126+0x1652>
   27095: 48 8d 35 74 cf 00 00         	leaq	53108(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   2709c: 31 ff                        	xorl	%edi, %edi
   2709e: 31 c0                        	xorl	%eax, %eax
   270a0: e8 2b 10 fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   270a5: e8 46 e6 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   270aa: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
; 		errno = -ret;
   270b0: c7 00 16 00 00 00            	movl	$22, (%rax)
   270b6: eb 56                        	jmp	0x2710e <bpf_link_update+0xde>
   270b8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	attr.link_update.link_fd = link_fd;
   270c0: 89 3c 24                     	movl	%edi, (%rsp)
; 	attr.link_update.flags = OPTS_GET(opts, flags, 0);
   270c3: 31 c0                        	xorl	%eax, %eax
; 	attr.link_update.new_prog_fd = new_prog_fd;
   270c5: 89 74 24 04                  	movl	%esi, 4(%rsp)
; 	attr.link_update.flags = OPTS_GET(opts, flags, 0);
   270c9: 49 83 f8 0b                  	cmpq	$11, %r8
   270cd: 76 03                        	jbe	0x270d2 <bpf_link_update+0xa2>
   270cf: 8b 42 08                     	movl	8(%rdx), %eax
   270d2: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	attr.link_update.old_prog_fd = OPTS_GET(opts, old_prog_fd, 0);
   270d6: 49 83 f8 0f                  	cmpq	$15, %r8
   270da: 76 63                        	jbe	0x2713f <bpf_link_update+0x10f>
   270dc: 8b 42 0c                     	movl	12(%rdx), %eax
   270df: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   270e3: 48 89 e2                     	movq	%rsp, %rdx
   270e6: b9 10 00 00 00               	movl	$16, %ecx
   270eb: 31 c0                        	xorl	%eax, %eax
   270ed: be 1d 00 00 00               	movl	$29, %esi
   270f2: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   270f7: e8 e4 e8 fd ff               	callq	0x59e0 <.plt.sec+0x370>
   270fc: 41 89 c0                     	movl	%eax, %r8d
; 	return ret < 0 ? -errno : ret;
   270ff: 85 c0                        	testl	%eax, %eax
   27101: 79 0b                        	jns	0x2710e <bpf_link_update+0xde>
   27103: e8 e8 e5 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   27108: 44 8b 00                     	movl	(%rax), %r8d
   2710b: 41 f7 d8                     	negl	%r8d
; }
   2710e: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   27116: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2711f: 75 44                        	jne	0x27165 <bpf_link_update+0x135>
   27121: 44 89 c0                     	movl	%r8d, %eax
   27124: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   2712b: c3                           	retq
   2712c: 0f 1f 40 00                  	nopl	(%rax)
; 	attr.link_update.link_fd = link_fd;
   27130: 89 3c 24                     	movl	%edi, (%rsp)
; 	attr.link_update.new_prog_fd = new_prog_fd;
   27133: 89 74 24 04                  	movl	%esi, 4(%rsp)
; 	attr.link_update.flags = OPTS_GET(opts, flags, 0);
   27137: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	attr.link_update.old_prog_fd = OPTS_GET(opts, old_prog_fd, 0);
   2713f: 31 c0                        	xorl	%eax, %eax
   27141: eb 9c                        	jmp	0x270df <bpf_link_update+0xaf>
   27143: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   27148: 4c 89 c1                     	movq	%r8, %rcx
   2714b: 48 8d 15 00 3e 01 00         	leaq	81408(%rip), %rdx       # 0x3af52 <CSWTCH.126+0x1652>
   27152: 48 8d 35 5f ce 00 00         	leaq	52831(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   27159: 31 ff                        	xorl	%edi, %edi
   2715b: e8 70 0f fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   27160: e9 40 ff ff ff               	jmp	0x270a5 <bpf_link_update+0x75>
; }
   27165: e8 96 e6 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2716a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

0000000000027170 <bpf_iter_create>:
; {
   27170: f3 0f 1e fa                  	endbr64
   27174: 41 55                        	pushq	%r13
; 	return syscall(__NR_bpf, cmd, attr, size);
   27176: b9 08 00 00 00               	movl	$8, %ecx
   2717b: be 21 00 00 00               	movl	$33, %esi
; {
   27180: 41 54                        	pushq	%r12
   27182: 55                           	pushq	%rbp
   27183: 53                           	pushq	%rbx
   27184: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   2718b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27194: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2719c: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   2719e: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.iter_create.link_fd = link_fd;
   271a1: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   271a4: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   271a9: c7 44 24 04 00 00 00 00      	movl	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   271b1: e8 2a e8 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   271b6: 85 c0                        	testl	%eax, %eax
   271b8: 78 6e                        	js	0x27228 <bpf_iter_create+0xb8>
   271ba: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 3) {
   271bd: 83 f8 02                     	cmpl	$2, %eax
   271c0: 7e 2e                        	jle	0x271f0 <bpf_iter_create+0x80>
; }
   271c2: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   271ca: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   271d3: 0f 85 85 00 00 00            	jne	0x2725e <bpf_iter_create+0xee>
   271d9: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   271e0: 44 89 e0                     	movl	%r12d, %eax
   271e3: 5b                           	popq	%rbx
   271e4: 5d                           	popq	%rbp
   271e5: 41 5c                        	popq	%r12
   271e7: 41 5d                        	popq	%r13
   271e9: c3                           	retq
   271ea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   271f0: 89 c7                        	movl	%eax, %edi
   271f2: ba 03 00 00 00               	movl	$3, %edx
   271f7: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   271fc: 31 c0                        	xorl	%eax, %eax
   271fe: e8 6d e9 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   27203: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   27205: e8 e6 e4 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   2720a: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   2720d: 44 8b 28                     	movl	(%rax), %r13d
   27210: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   27213: e8 e8 e6 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   27218: 85 db                        	testl	%ebx, %ebx
   2721a: 78 1c                        	js	0x27238 <bpf_iter_create+0xc8>
   2721c: 41 89 dc                     	movl	%ebx, %r12d
; 	return libbpf_err_errno(fd);
   2721f: eb a1                        	jmp	0x271c2 <bpf_iter_create+0x52>
   27221: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		saved_errno = errno;
   27228: e8 c3 e4 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   2722d: 44 8b 20                     	movl	(%rax), %r12d
   27230: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   27233: eb 8d                        	jmp	0x271c2 <bpf_iter_create+0x52>
   27235: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27238: 44 89 eb                     	movl	%r13d, %ebx
   2723b: 44 89 e2                     	movl	%r12d, %edx
   2723e: 48 8d 35 83 3d 01 00         	leaq	81283(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   27245: 31 ff                        	xorl	%edi, %edi
   27247: f7 db                        	negl	%ebx
   27249: 31 c0                        	xorl	%eax, %eax
   2724b: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   2724d: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27250: e8 7b 0e fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   27255: 44 89 6d 00                  	movl	%r13d, (%rbp)
   27259: e9 64 ff ff ff               	jmp	0x271c2 <bpf_iter_create+0x52>
; }
   2725e: e8 9d e5 fd ff               	callq	0x5800 <.plt.sec+0x190>
   27263: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2726e: 66 90                        	nop

0000000000027270 <bpf_prog_query_opts>:
; {
   27270: f3 0f 1e fa                  	endbr64
   27274: 53                           	pushq	%rbx
   27275: 48 81 ec a0 00 00 00         	subq	$160, %rsp
   2727c: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27285: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2728d: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_prog_query_opts))
   2728f: 48 85 d2                     	testq	%rdx, %rdx
   27292: 0f 84 58 01 00 00            	je	0x273f0 <bpf_prog_query_opts+0x180>
   27298: 48 8b 0a                     	movq	(%rdx), %rcx
   2729b: 48 89 d3                     	movq	%rdx, %rbx
; 	if (user_sz < sizeof(size_t)) {
   2729e: 48 83 f9 07                  	cmpq	$7, %rcx
   272a2: 0f 86 88 01 00 00            	jbe	0x27430 <bpf_prog_query_opts+0x1c0>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   272a8: 48 8d 42 28                  	leaq	40(%rdx), %rax
   272ac: 48 8d 51 d8                  	leaq	-40(%rcx), %rdx
; 	while (len > 0) {
   272b0: 48 85 d2                     	testq	%rdx, %rdx
   272b3: 7e 4b                        	jle	0x27300 <bpf_prog_query_opts+0x90>
   272b5: 48 8d 14 0b                  	leaq	(%rbx,%rcx), %rdx
   272b9: eb 0e                        	jmp	0x272c9 <bpf_prog_query_opts+0x59>
   272bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		p++;
   272c0: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   272c4: 48 39 d0                     	cmpq	%rdx, %rax
   272c7: 74 37                        	je	0x27300 <bpf_prog_query_opts+0x90>
; 		if (*p)
   272c9: 80 38 00                     	cmpb	$0, (%rax)
   272cc: 74 f2                        	je	0x272c0 <bpf_prog_query_opts+0x50>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   272ce: 48 8d 15 92 3c 01 00         	leaq	81042(%rip), %rdx       # 0x3af67 <CSWTCH.126+0x1667>
   272d5: 48 8d 35 34 cd 00 00         	leaq	52532(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   272dc: 31 ff                        	xorl	%edi, %edi
   272de: 31 c0                        	xorl	%eax, %eax
   272e0: e8 eb 0d fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   272e5: e8 06 e4 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   272ea: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   272f0: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   272f5: e9 92 00 00 00               	jmp	0x2738c <bpf_prog_query_opts+0x11c>
   272fa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   27300: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	attr.query.target_fd	= target_fd;
   27304: 89 3c 24                     	movl	%edi, (%rsp)
; 	attr.query.query_flags	= OPTS_GET(opts, query_flags, 0);
   27307: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   27309: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 	attr.query.attach_type	= type;
   27312: 89 74 24 04                  	movl	%esi, 4(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   27316: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
; 	attr.query.query_flags	= OPTS_GET(opts, query_flags, 0);
   2731b: 48 83 f9 0b                  	cmpq	$11, %rcx
   2731f: 0f 87 b3 00 00 00            	ja	0x273d8 <bpf_prog_query_opts+0x168>
   27325: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	attr.query.prog_cnt	= OPTS_GET(opts, prog_cnt, 0);
   27329: 48 83 f9 1b                  	cmpq	$27, %rcx
   2732d: 0f 87 7d 00 00 00            	ja	0x273b0 <bpf_prog_query_opts+0x140>
; 	attr.query.prog_ids	= ptr_to_u64(OPTS_GET(opts, prog_ids, NULL));
   27333: 48 83 f9 17                  	cmpq	$23, %rcx
   27337: 77 7e                        	ja	0x273b7 <bpf_prog_query_opts+0x147>
   27339: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
   27342: 31 c0                        	xorl	%eax, %eax
; 	attr.query.prog_attach_flags = ptr_to_u64(OPTS_GET(opts, prog_attach_flags, NULL));
   27344: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27349: 48 89 e2                     	movq	%rsp, %rdx
   2734c: b9 28 00 00 00               	movl	$40, %ecx
   27351: 31 c0                        	xorl	%eax, %eax
   27353: be 10 00 00 00               	movl	$16, %esi
   27358: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   2735d: e8 7e e6 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	OPTS_SET(opts, attach_flags, attr.query.attach_flags);
   27362: 48 8b 13                     	movq	(%rbx), %rdx
   27365: 48 83 fa 0f                  	cmpq	$15, %rdx
   27369: 76 14                        	jbe	0x2737f <bpf_prog_query_opts+0x10f>
   2736b: 8b 4c 24 0c                  	movl	12(%rsp), %ecx
   2736f: 89 4b 0c                     	movl	%ecx, 12(%rbx)
; 	OPTS_SET(opts, prog_cnt, attr.query.prog_cnt);
   27372: 48 83 fa 1b                  	cmpq	$27, %rdx
   27376: 76 07                        	jbe	0x2737f <bpf_prog_query_opts+0x10f>
   27378: 8b 54 24 18                  	movl	24(%rsp), %edx
   2737c: 89 53 18                     	movl	%edx, 24(%rbx)
; 	return ret < 0 ? -errno : ret;
   2737f: 85 c0                        	testl	%eax, %eax
   27381: 79 09                        	jns	0x2738c <bpf_prog_query_opts+0x11c>
   27383: e8 68 e3 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   27388: 8b 00                        	movl	(%rax), %eax
   2738a: f7 d8                        	negl	%eax
; }
   2738c: 48 8b 94 24 98 00 00 00      	movq	152(%rsp), %rdx
   27394: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   2739d: 0f 85 a7 00 00 00            	jne	0x2744a <bpf_prog_query_opts+0x1da>
   273a3: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
   273aa: 5b                           	popq	%rbx
   273ab: c3                           	retq
   273ac: 0f 1f 40 00                  	nopl	(%rax)
; 	attr.query.prog_cnt	= OPTS_GET(opts, prog_cnt, 0);
   273b0: 8b 43 18                     	movl	24(%rbx), %eax
   273b3: 89 44 24 18                  	movl	%eax, 24(%rsp)
; 	attr.query.prog_ids	= ptr_to_u64(OPTS_GET(opts, prog_ids, NULL));
   273b7: 48 8b 43 10                  	movq	16(%rbx), %rax
   273bb: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	attr.query.prog_attach_flags = ptr_to_u64(OPTS_GET(opts, prog_attach_flags, NULL));
   273c0: 48 83 f9 27                  	cmpq	$39, %rcx
   273c4: 0f 86 85 00 00 00            	jbe	0x2744f <bpf_prog_query_opts+0x1df>
; 	return (__u64) (unsigned long) ptr;
   273ca: 48 8b 43 20                  	movq	32(%rbx), %rax
; 	attr.query.prog_attach_flags = ptr_to_u64(OPTS_GET(opts, prog_attach_flags, NULL));
   273ce: e9 71 ff ff ff               	jmp	0x27344 <bpf_prog_query_opts+0xd4>
   273d3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	attr.query.query_flags	= OPTS_GET(opts, query_flags, 0);
   273d8: 8b 43 08                     	movl	8(%rbx), %eax
   273db: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	attr.query.prog_cnt	= OPTS_GET(opts, prog_cnt, 0);
   273df: 48 83 f9 1b                  	cmpq	$27, %rcx
   273e3: 77 cb                        	ja	0x273b0 <bpf_prog_query_opts+0x140>
   273e5: e9 49 ff ff ff               	jmp	0x27333 <bpf_prog_query_opts+0xc3>
   273ea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	attr.query.target_fd	= target_fd;
   273f0: 89 3c 24                     	movl	%edi, (%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   273f3: 66 0f ef c0                  	pxor	%xmm0, %xmm0
   273f7: 48 89 e2                     	movq	%rsp, %rdx
; 	return syscall(__NR_bpf, cmd, attr, size);
   273fa: b9 28 00 00 00               	movl	$40, %ecx
; 	attr.query.attach_type	= type;
   273ff: 89 74 24 04                  	movl	%esi, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27403: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   27408: 31 c0                        	xorl	%eax, %eax
   2740a: be 10 00 00 00               	movl	$16, %esi
;   return __builtin___memset_chk (__dest, __ch, __len,
   2740f: 48 c7 44 24 18 00 00 00 00   	movq	$0, 24(%rsp)
; 	attr.query.prog_attach_flags = ptr_to_u64(OPTS_GET(opts, prog_attach_flags, NULL));
   27418: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   27421: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27426: e8 b5 e5 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	OPTS_SET(opts, prog_cnt, attr.query.prog_cnt);
   2742b: e9 4f ff ff ff               	jmp	0x2737f <bpf_prog_query_opts+0x10f>
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   27430: 48 8d 15 30 3b 01 00         	leaq	80688(%rip), %rdx       # 0x3af67 <CSWTCH.126+0x1667>
   27437: 48 8d 35 7a cb 00 00         	leaq	52090(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   2743e: 31 ff                        	xorl	%edi, %edi
   27440: e8 8b 0c fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   27445: e9 9b fe ff ff               	jmp	0x272e5 <bpf_prog_query_opts+0x75>
; }
   2744a: e8 b1 e3 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2744f: 31 c0                        	xorl	%eax, %eax
   27451: e9 ee fe ff ff               	jmp	0x27344 <bpf_prog_query_opts+0xd4>
   27456: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000027460 <bpf_prog_query>:
; {
   27460: f3 0f 1e fa                  	endbr64
   27464: 55                           	pushq	%rbp
   27465: 41 89 d2                     	movl	%edx, %r10d
;   return __builtin___memset_chk (__dest, __ch, __len,
   27468: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   2746c: 48 89 cd                     	movq	%rcx, %rbp
   2746f: 53                           	pushq	%rbx
   27470: 4c 89 cb                     	movq	%r9, %rbx
   27473: 48 83 ec 38                  	subq	$56, %rsp
   27477: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27480: 48 89 44 24 28               	movq	%rax, 40(%rsp)
   27485: 31 c0                        	xorl	%eax, %eax
; 	opts.prog_cnt = *prog_cnt;
   27487: 41 8b 01                     	movl	(%r9), %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   2748a: 48 89 e2                     	movq	%rsp, %rdx
   2748d: 0f 11 44 24 08               	movups	%xmm0, 8(%rsp)
   27492: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
; 	LIBBPF_OPTS(bpf_prog_query_opts, opts);
   27497: 48 c7 04 24 28 00 00 00      	movq	$40, (%rsp)
; 	opts.query_flags = query_flags;
   2749f: 44 89 54 24 08               	movl	%r10d, 8(%rsp)
; 	opts.prog_ids = prog_ids;
   274a4: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
; 	opts.prog_cnt = *prog_cnt;
   274a9: 89 44 24 18                  	movl	%eax, 24(%rsp)
; 	ret = bpf_prog_query_opts(target_fd, type, &opts);
   274ad: e8 be fd ff ff               	callq	0x27270 <bpf_prog_query_opts>
; 	if (attach_flags)
   274b2: 48 85 ed                     	testq	%rbp, %rbp
   274b5: 74 07                        	je	0x274be <bpf_prog_query+0x5e>
; 		*attach_flags = opts.attach_flags;
   274b7: 8b 54 24 0c                  	movl	12(%rsp), %edx
   274bb: 89 55 00                     	movl	%edx, (%rbp)
; 	*prog_cnt = opts.prog_cnt;
   274be: 8b 54 24 18                  	movl	24(%rsp), %edx
   274c2: 89 13                        	movl	%edx, (%rbx)
; 	return ret < 0 ? -errno : ret;
   274c4: 85 c0                        	testl	%eax, %eax
   274c6: 79 09                        	jns	0x274d1 <bpf_prog_query+0x71>
   274c8: e8 23 e2 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   274cd: 8b 00                        	movl	(%rax), %eax
   274cf: f7 d8                        	negl	%eax
; }
   274d1: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   274d6: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   274df: 75 07                        	jne	0x274e8 <bpf_prog_query+0x88>
   274e1: 48 83 c4 38                  	addq	$56, %rsp
   274e5: 5b                           	popq	%rbx
   274e6: 5d                           	popq	%rbp
   274e7: c3                           	retq
   274e8: e8 13 e3 fd ff               	callq	0x5800 <.plt.sec+0x190>
   274ed: 0f 1f 00                     	nopl	(%rax)

00000000000274f0 <bpf_prog_test_run_opts>:
; {
   274f0: f3 0f 1e fa                  	endbr64
   274f4: 53                           	pushq	%rbx
   274f5: 48 81 ec a0 00 00 00         	subq	$160, %rsp
   274fc: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27505: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2750d: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_test_run_opts))
   2750f: 48 85 f6                     	testq	%rsi, %rsi
   27512: 0f 84 08 02 00 00            	je	0x27720 <bpf_prog_test_run_opts+0x230>
   27518: 48 8b 0e                     	movq	(%rsi), %rcx
   2751b: 48 89 f3                     	movq	%rsi, %rbx
; 	if (user_sz < sizeof(size_t)) {
   2751e: 48 83 f9 07                  	cmpq	$7, %rcx
   27522: 0f 86 38 02 00 00            	jbe	0x27760 <bpf_prog_test_run_opts+0x270>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   27528: 48 8d 51 b0                  	leaq	-80(%rcx), %rdx
   2752c: 48 8d 46 50                  	leaq	80(%rsi), %rax
; 	while (len > 0) {
   27530: 48 85 d2                     	testq	%rdx, %rdx
   27533: 7e 4b                        	jle	0x27580 <bpf_prog_test_run_opts+0x90>
   27535: 48 8d 14 0e                  	leaq	(%rsi,%rcx), %rdx
   27539: eb 0e                        	jmp	0x27549 <bpf_prog_test_run_opts+0x59>
   2753b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		p++;
   27540: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   27544: 48 39 d0                     	cmpq	%rdx, %rax
   27547: 74 37                        	je	0x27580 <bpf_prog_test_run_opts+0x90>
; 		if (*p)
   27549: 80 38 00                     	cmpb	$0, (%rax)
   2754c: 74 f2                        	je	0x27540 <bpf_prog_test_run_opts+0x50>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   2754e: 48 8d 15 26 3a 01 00         	leaq	80422(%rip), %rdx       # 0x3af7b <CSWTCH.126+0x167b>
   27555: 48 8d 35 b4 ca 00 00         	leaq	51892(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   2755c: 31 ff                        	xorl	%edi, %edi
   2755e: 31 c0                        	xorl	%eax, %eax
   27560: e8 6b 0b fe ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   27565: e8 86 e1 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2756a: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   27570: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   27575: e9 10 01 00 00               	jmp	0x2768a <bpf_prog_test_run_opts+0x19a>
   2757a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   27580: 66 0f ef c0                  	pxor	%xmm0, %xmm0
   27584: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
   27588: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
; 	attr.test.prog_fd = prog_fd;
   2758d: 89 3c 24                     	movl	%edi, (%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   27590: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
   27595: 0f 29 44 24 40               	movaps	%xmm0, 64(%rsp)
; 	attr.test.batch_size = OPTS_GET(opts, batch_size, 0);
   2759a: 48 83 f9 4f                  	cmpq	$79, %rcx
   2759e: 0f 87 0c 01 00 00            	ja	0x276b0 <bpf_prog_test_run_opts+0x1c0>
; 	attr.test.cpu = OPTS_GET(opts, cpu, 0);
   275a4: 48 83 f9 4b                  	cmpq	$75, %rcx
   275a8: 0f 87 09 01 00 00            	ja	0x276b7 <bpf_prog_test_run_opts+0x1c7>
; 	attr.test.flags = OPTS_GET(opts, flags, 0);
   275ae: 48 83 f9 47                  	cmpq	$71, %rcx
   275b2: 0f 87 06 01 00 00            	ja	0x276be <bpf_prog_test_run_opts+0x1ce>
; 	attr.test.repeat = OPTS_GET(opts, repeat, 0);
   275b8: 48 83 f9 3f                  	cmpq	$63, %rcx
   275bc: 0f 87 03 01 00 00            	ja	0x276c5 <bpf_prog_test_run_opts+0x1d5>
; 	attr.test.ctx_size_in = OPTS_GET(opts, ctx_size_in, 0);
   275c2: 48 83 f9 33                  	cmpq	$51, %rcx
   275c6: 0f 87 0d 01 00 00            	ja	0x276d9 <bpf_prog_test_run_opts+0x1e9>
; 	attr.test.data_size_in = OPTS_GET(opts, data_size_in, 0);
   275cc: 48 83 f9 1b                  	cmpq	$27, %rcx
   275d0: 0f 87 17 01 00 00            	ja	0x276ed <bpf_prog_test_run_opts+0x1fd>
   275d6: 31 c0                        	xorl	%eax, %eax
   275d8: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	attr.test.data_size_out = OPTS_GET(opts, data_size_out, 0);
   275dc: 31 c0                        	xorl	%eax, %eax
   275de: 48 83 f9 1f                  	cmpq	$31, %rcx
   275e2: 76 03                        	jbe	0x275e7 <bpf_prog_test_run_opts+0xf7>
   275e4: 8b 43 1c                     	movl	28(%rbx), %eax
   275e7: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	attr.test.ctx_in = ptr_to_u64(OPTS_GET(opts, ctx_in, NULL));
   275eb: 48 83 f9 27                  	cmpq	$39, %rcx
   275ef: 0f 86 03 01 00 00            	jbe	0x276f8 <bpf_prog_test_run_opts+0x208>
   275f5: 48 8b 43 20                  	movq	32(%rbx), %rax
   275f9: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	attr.test.ctx_out = ptr_to_u64(OPTS_GET(opts, ctx_out, NULL));
   275fe: 48 83 f9 2f                  	cmpq	$47, %rcx
   27602: 76 09                        	jbe	0x2760d <bpf_prog_test_run_opts+0x11d>
   27604: 48 8b 43 28                  	movq	40(%rbx), %rax
   27608: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 	return (__u64) (unsigned long) ptr;
   2760d: 48 8b 43 08                  	movq	8(%rbx), %rax
; 	attr.test.data_in = ptr_to_u64(OPTS_GET(opts, data_in, NULL));
   27611: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	attr.test.data_out = ptr_to_u64(OPTS_GET(opts, data_out, NULL));
   27616: 31 c0                        	xorl	%eax, %eax
   27618: 48 83 f9 17                  	cmpq	$23, %rcx
   2761c: 76 04                        	jbe	0x27622 <bpf_prog_test_run_opts+0x132>
; 	return (__u64) (unsigned long) ptr;
   2761e: 48 8b 43 10                  	movq	16(%rbx), %rax
; 	attr.test.data_out = ptr_to_u64(OPTS_GET(opts, data_out, NULL));
   27622: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27627: 48 89 e2                     	movq	%rsp, %rdx
   2762a: b9 50 00 00 00               	movl	$80, %ecx
   2762f: 31 c0                        	xorl	%eax, %eax
   27631: be 0a 00 00 00               	movl	$10, %esi
   27636: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   2763b: e8 a0 e3 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	OPTS_SET(opts, data_size_out, attr.test.data_size_out);
   27640: 48 8b 13                     	movq	(%rbx), %rdx
   27643: 48 83 fa 1f                  	cmpq	$31, %rdx
   27647: 0f 86 c3 00 00 00            	jbe	0x27710 <bpf_prog_test_run_opts+0x220>
   2764d: 8b 4c 24 0c                  	movl	12(%rsp), %ecx
   27651: 89 4b 1c                     	movl	%ecx, 28(%rbx)
; 	OPTS_SET(opts, ctx_size_out, attr.test.ctx_size_out);
   27654: 48 83 fa 37                  	cmpq	$55, %rdx
   27658: 0f 86 b2 00 00 00            	jbe	0x27710 <bpf_prog_test_run_opts+0x220>
   2765e: 8b 4c 24 2c                  	movl	44(%rsp), %ecx
   27662: 89 4b 34                     	movl	%ecx, 52(%rbx)
; 	OPTS_SET(opts, duration, attr.test.duration);
   27665: 48 83 fa 43                  	cmpq	$67, %rdx
   27669: 0f 86 a1 00 00 00            	jbe	0x27710 <bpf_prog_test_run_opts+0x220>
   2766f: 8b 54 24 24                  	movl	36(%rsp), %edx
   27673: 89 53 40                     	movl	%edx, 64(%rbx)
; 	OPTS_SET(opts, retval, attr.test.retval);
   27676: 8b 54 24 04                  	movl	4(%rsp), %edx
   2767a: 89 53 38                     	movl	%edx, 56(%rbx)
; 	return ret < 0 ? -errno : ret;
   2767d: 85 c0                        	testl	%eax, %eax
   2767f: 79 09                        	jns	0x2768a <bpf_prog_test_run_opts+0x19a>
   27681: e8 6a e0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   27686: 8b 00                        	movl	(%rax), %eax
   27688: f7 d8                        	negl	%eax
; }
   2768a: 48 8b 94 24 98 00 00 00      	movq	152(%rsp), %rdx
   27692: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   2769b: 0f 85 d9 00 00 00            	jne	0x2777a <bpf_prog_test_run_opts+0x28a>
   276a1: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
   276a8: 5b                           	popq	%rbx
   276a9: c3                           	retq
   276aa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	attr.test.batch_size = OPTS_GET(opts, batch_size, 0);
   276b0: 8b 43 4c                     	movl	76(%rbx), %eax
   276b3: 89 44 24 48                  	movl	%eax, 72(%rsp)
; 	attr.test.cpu = OPTS_GET(opts, cpu, 0);
   276b7: 8b 43 48                     	movl	72(%rbx), %eax
   276ba: 89 44 24 44                  	movl	%eax, 68(%rsp)
; 	attr.test.flags = OPTS_GET(opts, flags, 0);
   276be: 8b 43 44                     	movl	68(%rbx), %eax
   276c1: 89 44 24 40                  	movl	%eax, 64(%rsp)
; 	attr.test.repeat = OPTS_GET(opts, repeat, 0);
   276c5: 8b 43 3c                     	movl	60(%rbx), %eax
   276c8: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 	attr.test.duration = OPTS_GET(opts, duration, 0);
   276cc: 48 83 f9 43                  	cmpq	$67, %rcx
   276d0: 76 07                        	jbe	0x276d9 <bpf_prog_test_run_opts+0x1e9>
   276d2: 8b 43 40                     	movl	64(%rbx), %eax
   276d5: 89 44 24 24                  	movl	%eax, 36(%rsp)
; 	attr.test.ctx_size_in = OPTS_GET(opts, ctx_size_in, 0);
   276d9: 8b 43 30                     	movl	48(%rbx), %eax
   276dc: 89 44 24 28                  	movl	%eax, 40(%rsp)
; 	attr.test.ctx_size_out = OPTS_GET(opts, ctx_size_out, 0);
   276e0: 48 83 f9 37                  	cmpq	$55, %rcx
   276e4: 76 07                        	jbe	0x276ed <bpf_prog_test_run_opts+0x1fd>
   276e6: 8b 43 34                     	movl	52(%rbx), %eax
   276e9: 89 44 24 2c                  	movl	%eax, 44(%rsp)
; 	attr.test.data_size_in = OPTS_GET(opts, data_size_in, 0);
   276ed: 8b 43 18                     	movl	24(%rbx), %eax
   276f0: e9 e3 fe ff ff               	jmp	0x275d8 <bpf_prog_test_run_opts+0xe8>
   276f5: 0f 1f 00                     	nopl	(%rax)
; 	attr.test.data_in = ptr_to_u64(OPTS_GET(opts, data_in, NULL));
   276f8: 48 83 f9 0f                  	cmpq	$15, %rcx
   276fc: 0f 87 0b ff ff ff            	ja	0x2760d <bpf_prog_test_run_opts+0x11d>
   27702: 31 c0                        	xorl	%eax, %eax
   27704: e9 08 ff ff ff               	jmp	0x27611 <bpf_prog_test_run_opts+0x121>
   27709: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	OPTS_SET(opts, retval, attr.test.retval);
   27710: 48 83 fa 3b                  	cmpq	$59, %rdx
   27714: 0f 86 63 ff ff ff            	jbe	0x2767d <bpf_prog_test_run_opts+0x18d>
   2771a: e9 57 ff ff ff               	jmp	0x27676 <bpf_prog_test_run_opts+0x186>
   2771f: 90                           	nop
;   return __builtin___memset_chk (__dest, __ch, __len,
   27720: 66 0f ef c0                  	pxor	%xmm0, %xmm0
   27724: 48 89 e2                     	movq	%rsp, %rdx
; 	return syscall(__NR_bpf, cmd, attr, size);
   27727: b9 50 00 00 00               	movl	$80, %ecx
   2772c: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   2772e: 0f 29 04 24                  	movaps	%xmm0, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27732: be 0a 00 00 00               	movl	$10, %esi
; 	attr.test.prog_fd = prog_fd;
   27737: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   2773a: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   2773f: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
   27744: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   27749: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
   2774e: 0f 29 44 24 40               	movaps	%xmm0, 64(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27753: e8 88 e2 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	OPTS_SET(opts, retval, attr.test.retval);
   27758: e9 20 ff ff ff               	jmp	0x2767d <bpf_prog_test_run_opts+0x18d>
   2775d: 0f 1f 00                     	nopl	(%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   27760: 48 8d 15 14 38 01 00         	leaq	79892(%rip), %rdx       # 0x3af7b <CSWTCH.126+0x167b>
   27767: 48 8d 35 4a c8 00 00         	leaq	51274(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   2776e: 31 ff                        	xorl	%edi, %edi
   27770: e8 5b 09 fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   27775: e9 eb fd ff ff               	jmp	0x27565 <bpf_prog_test_run_opts+0x75>
; }
   2777a: e8 81 e0 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2777f: 90                           	nop

0000000000027780 <bpf_prog_get_next_id>:
; {
   27780: f3 0f 1e fa                  	endbr64
; 	return bpf_obj_get_next_id(start_id, next_id, BPF_PROG_GET_NEXT_ID);
   27784: ba 0b 00 00 00               	movl	$11, %edx
   27789: e9 12 dc ff ff               	jmp	0x253a0 <bpf_obj_get_next_id>
   2778e: 66 90                        	nop

0000000000027790 <bpf_map_get_next_id>:
; {
   27790: f3 0f 1e fa                  	endbr64
; 	return bpf_obj_get_next_id(start_id, next_id, BPF_MAP_GET_NEXT_ID);
   27794: ba 0c 00 00 00               	movl	$12, %edx
   27799: e9 02 dc ff ff               	jmp	0x253a0 <bpf_obj_get_next_id>
   2779e: 66 90                        	nop

00000000000277a0 <bpf_btf_get_next_id>:
; {
   277a0: f3 0f 1e fa                  	endbr64
; 	return bpf_obj_get_next_id(start_id, next_id, BPF_BTF_GET_NEXT_ID);
   277a4: ba 17 00 00 00               	movl	$23, %edx
   277a9: e9 f2 db ff ff               	jmp	0x253a0 <bpf_obj_get_next_id>
   277ae: 66 90                        	nop

00000000000277b0 <bpf_link_get_next_id>:
; {
   277b0: f3 0f 1e fa                  	endbr64
; 	return bpf_obj_get_next_id(start_id, next_id, BPF_LINK_GET_NEXT_ID);
   277b4: ba 1f 00 00 00               	movl	$31, %edx
   277b9: e9 e2 db ff ff               	jmp	0x253a0 <bpf_obj_get_next_id>
   277be: 66 90                        	nop

00000000000277c0 <bpf_prog_get_fd_by_id>:
; {
   277c0: f3 0f 1e fa                  	endbr64
   277c4: 41 55                        	pushq	%r13
; 	return syscall(__NR_bpf, cmd, attr, size);
   277c6: b9 0c 00 00 00               	movl	$12, %ecx
   277cb: be 0d 00 00 00               	movl	$13, %esi
; {
   277d0: 41 54                        	pushq	%r12
   277d2: 55                           	pushq	%rbp
   277d3: 53                           	pushq	%rbx
   277d4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   277db: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   277e4: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   277ec: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   277ee: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.prog_id = id;
   277f1: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   277f4: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   277f9: 48 c7 44 24 04 00 00 00 00   	movq	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27802: e8 d9 e1 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   27807: 85 c0                        	testl	%eax, %eax
   27809: 78 6d                        	js	0x27878 <bpf_prog_get_fd_by_id+0xb8>
   2780b: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 3) {
   2780e: 83 f8 02                     	cmpl	$2, %eax
   27811: 7e 2d                        	jle	0x27840 <bpf_prog_get_fd_by_id+0x80>
; }
   27813: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   2781b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   27824: 0f 85 84 00 00 00            	jne	0x278ae <bpf_prog_get_fd_by_id+0xee>
   2782a: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   27831: 44 89 e0                     	movl	%r12d, %eax
   27834: 5b                           	popq	%rbx
   27835: 5d                           	popq	%rbp
   27836: 41 5c                        	popq	%r12
   27838: 41 5d                        	popq	%r13
   2783a: c3                           	retq
   2783b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   27840: 89 c7                        	movl	%eax, %edi
   27842: ba 03 00 00 00               	movl	$3, %edx
   27847: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   2784c: 31 c0                        	xorl	%eax, %eax
   2784e: e8 1d e3 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   27853: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   27855: e8 96 de fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   2785a: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   2785d: 44 8b 28                     	movl	(%rax), %r13d
   27860: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   27863: e8 98 e0 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   27868: 85 db                        	testl	%ebx, %ebx
   2786a: 78 1c                        	js	0x27888 <bpf_prog_get_fd_by_id+0xc8>
   2786c: 41 89 dc                     	movl	%ebx, %r12d
; 	return libbpf_err_errno(fd);
   2786f: eb a2                        	jmp	0x27813 <bpf_prog_get_fd_by_id+0x53>
   27871: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		saved_errno = errno;
   27878: e8 73 de fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   2787d: 44 8b 20                     	movl	(%rax), %r12d
   27880: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   27883: eb 8e                        	jmp	0x27813 <bpf_prog_get_fd_by_id+0x53>
   27885: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27888: 44 89 eb                     	movl	%r13d, %ebx
   2788b: 44 89 e2                     	movl	%r12d, %edx
   2788e: 48 8d 35 33 37 01 00         	leaq	79667(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   27895: 31 ff                        	xorl	%edi, %edi
   27897: f7 db                        	negl	%ebx
   27899: 31 c0                        	xorl	%eax, %eax
   2789b: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   2789d: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   278a0: e8 2b 08 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   278a5: 44 89 6d 00                  	movl	%r13d, (%rbp)
   278a9: e9 65 ff ff ff               	jmp	0x27813 <bpf_prog_get_fd_by_id+0x53>
; }
   278ae: e8 4d df fd ff               	callq	0x5800 <.plt.sec+0x190>
   278b3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   278be: 66 90                        	nop

00000000000278c0 <bpf_map_get_fd_by_id>:
; {
   278c0: f3 0f 1e fa                  	endbr64
   278c4: 41 55                        	pushq	%r13
; 	return syscall(__NR_bpf, cmd, attr, size);
   278c6: b9 0c 00 00 00               	movl	$12, %ecx
   278cb: be 0e 00 00 00               	movl	$14, %esi
; {
   278d0: 41 54                        	pushq	%r12
   278d2: 55                           	pushq	%rbp
   278d3: 53                           	pushq	%rbx
   278d4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   278db: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   278e4: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   278ec: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   278ee: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.map_id = id;
   278f1: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   278f4: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   278f9: 48 c7 44 24 04 00 00 00 00   	movq	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27902: e8 d9 e0 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   27907: 85 c0                        	testl	%eax, %eax
   27909: 78 6d                        	js	0x27978 <bpf_map_get_fd_by_id+0xb8>
   2790b: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 3) {
   2790e: 83 f8 02                     	cmpl	$2, %eax
   27911: 7e 2d                        	jle	0x27940 <bpf_map_get_fd_by_id+0x80>
; }
   27913: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   2791b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   27924: 0f 85 84 00 00 00            	jne	0x279ae <bpf_map_get_fd_by_id+0xee>
   2792a: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   27931: 44 89 e0                     	movl	%r12d, %eax
   27934: 5b                           	popq	%rbx
   27935: 5d                           	popq	%rbp
   27936: 41 5c                        	popq	%r12
   27938: 41 5d                        	popq	%r13
   2793a: c3                           	retq
   2793b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   27940: 89 c7                        	movl	%eax, %edi
   27942: ba 03 00 00 00               	movl	$3, %edx
   27947: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   2794c: 31 c0                        	xorl	%eax, %eax
   2794e: e8 1d e2 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   27953: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   27955: e8 96 dd fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   2795a: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   2795d: 44 8b 28                     	movl	(%rax), %r13d
   27960: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   27963: e8 98 df fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   27968: 85 db                        	testl	%ebx, %ebx
   2796a: 78 1c                        	js	0x27988 <bpf_map_get_fd_by_id+0xc8>
   2796c: 41 89 dc                     	movl	%ebx, %r12d
; 	return libbpf_err_errno(fd);
   2796f: eb a2                        	jmp	0x27913 <bpf_map_get_fd_by_id+0x53>
   27971: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		saved_errno = errno;
   27978: e8 73 dd fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   2797d: 44 8b 20                     	movl	(%rax), %r12d
   27980: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   27983: eb 8e                        	jmp	0x27913 <bpf_map_get_fd_by_id+0x53>
   27985: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27988: 44 89 eb                     	movl	%r13d, %ebx
   2798b: 44 89 e2                     	movl	%r12d, %edx
   2798e: 48 8d 35 33 36 01 00         	leaq	79411(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   27995: 31 ff                        	xorl	%edi, %edi
   27997: f7 db                        	negl	%ebx
   27999: 31 c0                        	xorl	%eax, %eax
   2799b: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   2799d: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   279a0: e8 2b 07 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   279a5: 44 89 6d 00                  	movl	%r13d, (%rbp)
   279a9: e9 65 ff ff ff               	jmp	0x27913 <bpf_map_get_fd_by_id+0x53>
; }
   279ae: e8 4d de fd ff               	callq	0x5800 <.plt.sec+0x190>
   279b3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   279be: 66 90                        	nop

00000000000279c0 <bpf_btf_get_fd_by_id>:
; {
   279c0: f3 0f 1e fa                  	endbr64
   279c4: 41 55                        	pushq	%r13
; 	return syscall(__NR_bpf, cmd, attr, size);
   279c6: b9 0c 00 00 00               	movl	$12, %ecx
   279cb: be 13 00 00 00               	movl	$19, %esi
; {
   279d0: 41 54                        	pushq	%r12
   279d2: 55                           	pushq	%rbp
   279d3: 53                           	pushq	%rbx
   279d4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   279db: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   279e4: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   279ec: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   279ee: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.btf_id = id;
   279f1: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   279f4: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   279f9: 48 c7 44 24 04 00 00 00 00   	movq	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27a02: e8 d9 df fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   27a07: 85 c0                        	testl	%eax, %eax
   27a09: 78 6d                        	js	0x27a78 <bpf_btf_get_fd_by_id+0xb8>
   27a0b: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 3) {
   27a0e: 83 f8 02                     	cmpl	$2, %eax
   27a11: 7e 2d                        	jle	0x27a40 <bpf_btf_get_fd_by_id+0x80>
; }
   27a13: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   27a1b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   27a24: 0f 85 84 00 00 00            	jne	0x27aae <bpf_btf_get_fd_by_id+0xee>
   27a2a: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   27a31: 44 89 e0                     	movl	%r12d, %eax
   27a34: 5b                           	popq	%rbx
   27a35: 5d                           	popq	%rbp
   27a36: 41 5c                        	popq	%r12
   27a38: 41 5d                        	popq	%r13
   27a3a: c3                           	retq
   27a3b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   27a40: 89 c7                        	movl	%eax, %edi
   27a42: ba 03 00 00 00               	movl	$3, %edx
   27a47: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   27a4c: 31 c0                        	xorl	%eax, %eax
   27a4e: e8 1d e1 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   27a53: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   27a55: e8 96 dc fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   27a5a: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   27a5d: 44 8b 28                     	movl	(%rax), %r13d
   27a60: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   27a63: e8 98 de fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   27a68: 85 db                        	testl	%ebx, %ebx
   27a6a: 78 1c                        	js	0x27a88 <bpf_btf_get_fd_by_id+0xc8>
   27a6c: 41 89 dc                     	movl	%ebx, %r12d
; 	return libbpf_err_errno(fd);
   27a6f: eb a2                        	jmp	0x27a13 <bpf_btf_get_fd_by_id+0x53>
   27a71: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		saved_errno = errno;
   27a78: e8 73 dc fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   27a7d: 44 8b 20                     	movl	(%rax), %r12d
   27a80: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   27a83: eb 8e                        	jmp	0x27a13 <bpf_btf_get_fd_by_id+0x53>
   27a85: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27a88: 44 89 eb                     	movl	%r13d, %ebx
   27a8b: 44 89 e2                     	movl	%r12d, %edx
   27a8e: 48 8d 35 33 35 01 00         	leaq	79155(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   27a95: 31 ff                        	xorl	%edi, %edi
   27a97: f7 db                        	negl	%ebx
   27a99: 31 c0                        	xorl	%eax, %eax
   27a9b: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   27a9d: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27aa0: e8 2b 06 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   27aa5: 44 89 6d 00                  	movl	%r13d, (%rbp)
   27aa9: e9 65 ff ff ff               	jmp	0x27a13 <bpf_btf_get_fd_by_id+0x53>
; }
   27aae: e8 4d dd fd ff               	callq	0x5800 <.plt.sec+0x190>
   27ab3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   27abe: 66 90                        	nop

0000000000027ac0 <bpf_link_get_fd_by_id>:
; {
   27ac0: f3 0f 1e fa                  	endbr64
   27ac4: 41 55                        	pushq	%r13
; 	return syscall(__NR_bpf, cmd, attr, size);
   27ac6: b9 0c 00 00 00               	movl	$12, %ecx
   27acb: be 1e 00 00 00               	movl	$30, %esi
; {
   27ad0: 41 54                        	pushq	%r12
   27ad2: 55                           	pushq	%rbp
   27ad3: 53                           	pushq	%rbx
   27ad4: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   27adb: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27ae4: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   27aec: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   27aee: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.link_id = id;
   27af1: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27af4: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
;   return __builtin___memset_chk (__dest, __ch, __len,
   27af9: 48 c7 44 24 04 00 00 00 00   	movq	$0, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27b02: e8 d9 de fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   27b07: 85 c0                        	testl	%eax, %eax
   27b09: 78 6d                        	js	0x27b78 <bpf_link_get_fd_by_id+0xb8>
   27b0b: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 3) {
   27b0e: 83 f8 02                     	cmpl	$2, %eax
   27b11: 7e 2d                        	jle	0x27b40 <bpf_link_get_fd_by_id+0x80>
; }
   27b13: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   27b1b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   27b24: 0f 85 84 00 00 00            	jne	0x27bae <bpf_link_get_fd_by_id+0xee>
   27b2a: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   27b31: 44 89 e0                     	movl	%r12d, %eax
   27b34: 5b                           	popq	%rbx
   27b35: 5d                           	popq	%rbp
   27b36: 41 5c                        	popq	%r12
   27b38: 41 5d                        	popq	%r13
   27b3a: c3                           	retq
   27b3b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   27b40: 89 c7                        	movl	%eax, %edi
   27b42: ba 03 00 00 00               	movl	$3, %edx
   27b47: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   27b4c: 31 c0                        	xorl	%eax, %eax
   27b4e: e8 1d e0 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   27b53: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   27b55: e8 96 db fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   27b5a: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   27b5d: 44 8b 28                     	movl	(%rax), %r13d
   27b60: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   27b63: e8 98 dd fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   27b68: 85 db                        	testl	%ebx, %ebx
   27b6a: 78 1c                        	js	0x27b88 <bpf_link_get_fd_by_id+0xc8>
   27b6c: 41 89 dc                     	movl	%ebx, %r12d
; 	return libbpf_err_errno(fd);
   27b6f: eb a2                        	jmp	0x27b13 <bpf_link_get_fd_by_id+0x53>
   27b71: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		saved_errno = errno;
   27b78: e8 73 db fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   27b7d: 44 8b 20                     	movl	(%rax), %r12d
   27b80: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   27b83: eb 8e                        	jmp	0x27b13 <bpf_link_get_fd_by_id+0x53>
   27b85: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27b88: 44 89 eb                     	movl	%r13d, %ebx
   27b8b: 44 89 e2                     	movl	%r12d, %edx
   27b8e: 48 8d 35 33 34 01 00         	leaq	78899(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   27b95: 31 ff                        	xorl	%edi, %edi
   27b97: f7 db                        	negl	%ebx
   27b99: 31 c0                        	xorl	%eax, %eax
   27b9b: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   27b9d: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27ba0: e8 2b 05 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   27ba5: 44 89 6d 00                  	movl	%r13d, (%rbp)
   27ba9: e9 65 ff ff ff               	jmp	0x27b13 <bpf_link_get_fd_by_id+0x53>
; }
   27bae: e8 4d dc fd ff               	callq	0x5800 <.plt.sec+0x190>
   27bb3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   27bbe: 66 90                        	nop

0000000000027bc0 <bpf_obj_get_info_by_fd>:
; {
   27bc0: f3 0f 1e fa                  	endbr64
   27bc4: 53                           	pushq	%rbx
; 	return syscall(__NR_bpf, cmd, attr, size);
   27bc5: b9 10 00 00 00               	movl	$16, %ecx
; {
   27bca: 48 89 d3                     	movq	%rdx, %rbx
   27bcd: 48 81 ec a0 00 00 00         	subq	$160, %rsp
   27bd4: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27bdd: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   27be5: 31 c0                        	xorl	%eax, %eax
; 	attr.info.info_len = *info_len;
   27be7: 8b 02                        	movl	(%rdx), %eax
; 	attr.info.bpf_fd = bpf_fd;
   27be9: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27bec: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.info.info = ptr_to_u64(info);
   27bef: 48 89 74 24 08               	movq	%rsi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27bf4: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   27bf9: be 0f 00 00 00               	movl	$15, %esi
; 	attr.info.info_len = *info_len;
   27bfe: 89 44 24 04                  	movl	%eax, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27c02: 31 c0                        	xorl	%eax, %eax
   27c04: e8 d7 dd fd ff               	callq	0x59e0 <.plt.sec+0x370>
   27c09: 41 89 c0                     	movl	%eax, %r8d
; 	if (!err)
   27c0c: 85 c0                        	testl	%eax, %eax
   27c0e: 75 28                        	jne	0x27c38 <bpf_obj_get_info_by_fd+0x78>
; 		*info_len = attr.info.info_len;
   27c10: 8b 44 24 04                  	movl	4(%rsp), %eax
   27c14: 89 03                        	movl	%eax, (%rbx)
; }
   27c16: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   27c1e: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   27c27: 75 1e                        	jne	0x27c47 <bpf_obj_get_info_by_fd+0x87>
   27c29: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
   27c30: 44 89 c0                     	movl	%r8d, %eax
   27c33: 5b                           	popq	%rbx
   27c34: c3                           	retq
   27c35: 0f 1f 00                     	nopl	(%rax)
; 	return ret < 0 ? -errno : ret;
   27c38: 79 dc                        	jns	0x27c16 <bpf_obj_get_info_by_fd+0x56>
   27c3a: e8 b1 da fd ff               	callq	0x56f0 <.plt.sec+0x80>
   27c3f: 44 8b 00                     	movl	(%rax), %r8d
   27c42: 41 f7 d8                     	negl	%r8d
; 	return libbpf_err_errno(err);
   27c45: eb cf                        	jmp	0x27c16 <bpf_obj_get_info_by_fd+0x56>
; }
   27c47: e8 b4 db fd ff               	callq	0x5800 <.plt.sec+0x190>
   27c4c: 0f 1f 40 00                  	nopl	(%rax)

0000000000027c50 <bpf_raw_tracepoint_open>:
; {
   27c50: f3 0f 1e fa                  	endbr64
   27c54: 41 55                        	pushq	%r13
; 	return syscall(__NR_bpf, cmd, attr, size);
   27c56: b9 10 00 00 00               	movl	$16, %ecx
; {
   27c5b: 41 54                        	pushq	%r12
   27c5d: 55                           	pushq	%rbp
   27c5e: 53                           	pushq	%rbx
   27c5f: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   27c66: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27c6f: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   27c77: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   27c79: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.raw_tracepoint.name = ptr_to_u64(name);
   27c7c: 48 89 3c 24                  	movq	%rdi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27c80: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.raw_tracepoint.prog_fd = prog_fd;
   27c85: 89 74 24 08                  	movl	%esi, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27c89: be 11 00 00 00               	movl	$17, %esi
;   return __builtin___memset_chk (__dest, __ch, __len,
   27c8e: c7 44 24 0c 00 00 00 00      	movl	$0, 12(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27c96: e8 45 dd fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   27c9b: 85 c0                        	testl	%eax, %eax
   27c9d: 78 69                        	js	0x27d08 <bpf_raw_tracepoint_open+0xb8>
   27c9f: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 3) {
   27ca2: 83 f8 02                     	cmpl	$2, %eax
   27ca5: 7e 29                        	jle	0x27cd0 <bpf_raw_tracepoint_open+0x80>
; }
   27ca7: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   27caf: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   27cb8: 0f 85 80 00 00 00            	jne	0x27d3e <bpf_raw_tracepoint_open+0xee>
   27cbe: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   27cc5: 44 89 e0                     	movl	%r12d, %eax
   27cc8: 5b                           	popq	%rbx
   27cc9: 5d                           	popq	%rbp
   27cca: 41 5c                        	popq	%r12
   27ccc: 41 5d                        	popq	%r13
   27cce: c3                           	retq
   27ccf: 90                           	nop
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   27cd0: 89 c7                        	movl	%eax, %edi
   27cd2: ba 03 00 00 00               	movl	$3, %edx
   27cd7: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   27cdc: 31 c0                        	xorl	%eax, %eax
   27cde: e8 8d de fd ff               	callq	0x5b70 <.plt.sec+0x500>
   27ce3: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   27ce5: e8 06 da fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   27cea: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   27ced: 44 8b 28                     	movl	(%rax), %r13d
   27cf0: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   27cf3: e8 08 dc fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   27cf8: 85 db                        	testl	%ebx, %ebx
   27cfa: 78 1c                        	js	0x27d18 <bpf_raw_tracepoint_open+0xc8>
   27cfc: 41 89 dc                     	movl	%ebx, %r12d
; 	return libbpf_err_errno(fd);
   27cff: eb a6                        	jmp	0x27ca7 <bpf_raw_tracepoint_open+0x57>
   27d01: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		saved_errno = errno;
   27d08: e8 e3 d9 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   27d0d: 44 8b 20                     	movl	(%rax), %r12d
   27d10: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   27d13: eb 92                        	jmp	0x27ca7 <bpf_raw_tracepoint_open+0x57>
   27d15: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27d18: 44 89 eb                     	movl	%r13d, %ebx
   27d1b: 44 89 e2                     	movl	%r12d, %edx
   27d1e: 48 8d 35 a3 32 01 00         	leaq	78499(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   27d25: 31 ff                        	xorl	%edi, %edi
   27d27: f7 db                        	negl	%ebx
   27d29: 31 c0                        	xorl	%eax, %eax
   27d2b: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   27d2d: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   27d30: e8 9b 03 fe ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   27d35: 44 89 6d 00                  	movl	%r13d, (%rbp)
   27d39: e9 69 ff ff ff               	jmp	0x27ca7 <bpf_raw_tracepoint_open+0x57>
; }
   27d3e: e8 bd da fd ff               	callq	0x5800 <.plt.sec+0x190>
   27d43: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   27d4e: 66 90                        	nop

0000000000027d50 <bpf_link_create>:
; {
   27d50: f3 0f 1e fa                  	endbr64
   27d54: 41 57                        	pushq	%r15
   27d56: 41 56                        	pushq	%r14
   27d58: 41 55                        	pushq	%r13
   27d5a: 41 54                        	pushq	%r12
   27d5c: 41 89 fc                     	movl	%edi, %r12d
   27d5f: 55                           	pushq	%rbp
   27d60: 89 d5                        	movl	%edx, %ebp
   27d62: 53                           	pushq	%rbx
   27d63: 48 89 cb                     	movq	%rcx, %rbx
   27d66: 48 81 ec b8 00 00 00         	subq	$184, %rsp
   27d6d: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   27d76: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
   27d7e: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_link_create_opts))
   27d80: 48 85 c9                     	testq	%rcx, %rcx
   27d83: 0f 84 7f 04 00 00            	je	0x28208 <bpf_link_create+0x4b8>
   27d89: 48 8b 09                     	movq	(%rcx), %rcx
; 	if (user_sz < sizeof(size_t)) {
   27d8c: 48 83 f9 07                  	cmpq	$7, %rcx
   27d90: 0f 86 7a 03 00 00            	jbe	0x28110 <bpf_link_create+0x3c0>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   27d96: 48 8d 51 c0                  	leaq	-64(%rcx), %rdx
   27d9a: 48 8d 43 40                  	leaq	64(%rbx), %rax
; 	while (len > 0) {
   27d9e: 48 85 d2                     	testq	%rdx, %rdx
   27da1: 7e 55                        	jle	0x27df8 <bpf_link_create+0xa8>
   27da3: 48 8d 14 0b                  	leaq	(%rbx,%rcx), %rdx
   27da7: eb 10                        	jmp	0x27db9 <bpf_link_create+0x69>
   27da9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		p++;
   27db0: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   27db4: 48 39 c2                     	cmpq	%rax, %rdx
   27db7: 74 3f                        	je	0x27df8 <bpf_link_create+0xa8>
; 		if (*p)
   27db9: 80 38 00                     	cmpb	$0, (%rax)
   27dbc: 74 f2                        	je	0x27db0 <bpf_link_create+0x60>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   27dbe: 48 8d 15 c8 31 01 00         	leaq	78280(%rip), %rdx       # 0x3af8d <CSWTCH.126+0x168d>
   27dc5: 48 8d 35 44 c2 00 00         	leaq	49732(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   27dcc: 31 ff                        	xorl	%edi, %edi
   27dce: 31 c0                        	xorl	%eax, %eax
   27dd0: e8 fb 02 fe ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   27dd5: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
   27dd8: e8 13 d9 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   27ddd: c7 00 16 00 00 00            	movl	$22, (%rax)
   27de3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			return libbpf_err(-EINVAL);
   27de8: 41 bf ea ff ff ff            	movl	$4294967274, %r15d      # imm = 0xFFFFFFEA
   27dee: e9 62 01 00 00               	jmp	0x27f55 <bpf_link_create+0x205>
   27df3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	iter_info_len = OPTS_GET(opts, iter_info_len, 0);
   27df8: 48 83 f9 1b                  	cmpq	$27, %rcx
   27dfc: 0f 87 9e 00 00 00            	ja	0x27ea0 <bpf_link_create+0x150>
;   return __builtin___memset_chk (__dest, __ch, __len,
   27e02: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	attr.link_create.prog_fd = prog_fd;
   27e06: 44 89 64 24 10               	movl	%r12d, 16(%rsp)
; 	attr.link_create.target_fd = target_fd;
   27e0b: 89 74 24 14                  	movl	%esi, 20(%rsp)
; 	attr.link_create.attach_type = attach_type;
   27e0f: 89 6c 24 18                  	movl	%ebp, 24(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   27e13: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   27e18: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	attr.link_create.flags = OPTS_GET(opts, flags, 0);
   27e1d: 48 83 f9 0b                  	cmpq	$11, %rcx
   27e21: 0f 87 cc 03 00 00            	ja	0x281f3 <bpf_link_create+0x4a3>
   27e27: c7 44 24 1c 00 00 00 00      	movl	$0, 28(%rsp)
   27e2f: 45 31 c0                     	xorl	%r8d, %r8d
; 	switch (attach_type) {
   27e32: 83 fd 29                     	cmpl	$41, %ebp
   27e35: 0f 84 0d 04 00 00            	je	0x28248 <bpf_link_create+0x4f8>
   27e3b: 83 fd 29                     	cmpl	$41, %ebp
   27e3e: 0f 87 44 01 00 00            	ja	0x27f88 <bpf_link_create+0x238>
   27e44: 83 fd 1b                     	cmpl	$27, %ebp
   27e47: 0f 87 b3 01 00 00            	ja	0x28000 <bpf_link_create+0x2b0>
   27e4d: 83 fd 17                     	cmpl	$23, %ebp
   27e50: 0f 87 0a 03 00 00            	ja	0x28160 <bpf_link_create+0x410>
; 		if (!OPTS_ZEROED(opts, flags))
   27e56: 48 85 db                     	testq	%rbx, %rbx
   27e59: 0f 84 c7 00 00 00            	je	0x27f26 <bpf_link_create+0x1d6>
   27e5f: 48 8b 13                     	movq	(%rbx), %rdx
   27e62: 48 8d 43 0c                  	leaq	12(%rbx), %rax
   27e66: 48 8d 4a f4                  	leaq	-12(%rdx), %rcx
; 	while (len > 0) {
   27e6a: 48 85 c9                     	testq	%rcx, %rcx
   27e6d: 0f 8e b3 00 00 00            	jle	0x27f26 <bpf_link_create+0x1d6>
   27e73: 48 01 da                     	addq	%rbx, %rdx
   27e76: eb 15                        	jmp	0x27e8d <bpf_link_create+0x13d>
   27e78: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		p++;
   27e80: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   27e84: 48 39 d0                     	cmpq	%rdx, %rax
   27e87: 0f 84 99 00 00 00            	je	0x27f26 <bpf_link_create+0x1d6>
; 		if (*p)
   27e8d: 80 38 00                     	cmpb	$0, (%rax)
   27e90: 74 ee                        	je	0x27e80 <bpf_link_create+0x130>
   27e92: e9 41 ff ff ff               	jmp	0x27dd8 <bpf_link_create+0x88>
   27e97: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	iter_info_len = OPTS_GET(opts, iter_info_len, 0);
   27ea0: 44 8b 43 18                  	movl	24(%rbx), %r8d
; 	target_btf_id = OPTS_GET(opts, target_btf_id, 0);
   27ea4: 48 83 f9 1f                  	cmpq	$31, %rcx
   27ea8: 0f 86 32 02 00 00            	jbe	0x280e0 <bpf_link_create+0x390>
   27eae: 8b 7b 1c                     	movl	28(%rbx), %edi
; 	if (iter_info_len || target_btf_id) {
   27eb1: 44 89 c0                     	movl	%r8d, %eax
   27eb4: 09 f8                        	orl	%edi, %eax
   27eb6: 0f 84 1c 03 00 00            	je	0x281d8 <bpf_link_create+0x488>
; 		if (iter_info_len && target_btf_id)
   27ebc: 45 85 c0                     	testl	%r8d, %r8d
   27ebf: 74 08                        	je	0x27ec9 <bpf_link_create+0x179>
   27ec1: 85 ff                        	testl	%edi, %edi
   27ec3: 0f 85 0f ff ff ff            	jne	0x27dd8 <bpf_link_create+0x88>
; 		if (!OPTS_ZEROED(opts, target_btf_id))
   27ec9: 48 8d 51 e0                  	leaq	-32(%rcx), %rdx
   27ecd: 48 8d 43 20                  	leaq	32(%rbx), %rax
; 	while (len > 0) {
   27ed1: 48 85 d2                     	testq	%rdx, %rdx
   27ed4: 7e 22                        	jle	0x27ef8 <bpf_link_create+0x1a8>
   27ed6: 48 8d 14 0b                  	leaq	(%rbx,%rcx), %rdx
   27eda: eb 0d                        	jmp	0x27ee9 <bpf_link_create+0x199>
   27edc: 0f 1f 40 00                  	nopl	(%rax)
; 		p++;
   27ee0: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   27ee4: 48 39 c2                     	cmpq	%rax, %rdx
   27ee7: 74 0f                        	je	0x27ef8 <bpf_link_create+0x1a8>
; 		if (*p)
   27ee9: 80 38 00                     	cmpb	$0, (%rax)
   27eec: 74 f2                        	je	0x27ee0 <bpf_link_create+0x190>
   27eee: e9 e5 fe ff ff               	jmp	0x27dd8 <bpf_link_create+0x88>
   27ef3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	attr.link_create.flags = OPTS_GET(opts, flags, 0);
   27ef8: 8b 43 08                     	movl	8(%rbx), %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   27efb: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	attr.link_create.prog_fd = prog_fd;
   27eff: 44 89 64 24 10               	movl	%r12d, 16(%rsp)
; 	attr.link_create.target_fd = target_fd;
   27f04: 89 74 24 14                  	movl	%esi, 20(%rsp)
; 	attr.link_create.attach_type = attach_type;
   27f08: 89 6c 24 18                  	movl	%ebp, 24(%rsp)
; 	attr.link_create.flags = OPTS_GET(opts, flags, 0);
   27f0c: 89 44 24 1c                  	movl	%eax, 28(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   27f10: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   27f15: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	if (target_btf_id) {
   27f1a: 85 ff                        	testl	%edi, %edi
   27f1c: 0f 84 10 ff ff ff            	je	0x27e32 <bpf_link_create+0xe2>
; 		attr.link_create.target_btf_id = target_btf_id;
   27f22: 89 7c 24 20                  	movl	%edi, 32(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   27f26: 48 8d 54 24 10               	leaq	16(%rsp), %rdx
   27f2b: b9 30 00 00 00               	movl	$48, %ecx
   27f30: be 1c 00 00 00               	movl	$28, %esi
   27f35: 31 c0                        	xorl	%eax, %eax
   27f37: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   27f3c: e8 9f da fd ff               	callq	0x59e0 <.plt.sec+0x370>
   27f41: 41 89 c7                     	movl	%eax, %r15d
; 	if (fd < 0)
   27f44: 85 c0                        	testl	%eax, %eax
   27f46: 0f 88 e4 00 00 00            	js	0x28030 <bpf_link_create+0x2e0>
; 	if (fd < 3) {
   27f4c: 83 f8 02                     	cmpl	$2, %eax
   27f4f: 0f 8e 4b 01 00 00            	jle	0x280a0 <bpf_link_create+0x350>
; }
   27f55: 48 8b 84 24 a8 00 00 00      	movq	168(%rsp), %rax
   27f5d: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   27f66: 0f 85 d2 03 00 00            	jne	0x2833e <bpf_link_create+0x5ee>
   27f6c: 48 81 c4 b8 00 00 00         	addq	$184, %rsp
   27f73: 44 89 f8                     	movl	%r15d, %eax
   27f76: 5b                           	popq	%rbx
   27f77: 5d                           	popq	%rbp
   27f78: 41 5c                        	popq	%r12
   27f7a: 41 5d                        	popq	%r13
   27f7c: 41 5e                        	popq	%r14
   27f7e: 41 5f                        	popq	%r15
   27f80: c3                           	retq
   27f81: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	switch (attach_type) {
   27f88: 83 fd 2a                     	cmpl	$42, %ebp
   27f8b: 0f 85 c5 fe ff ff            	jne	0x27e56 <bpf_link_create+0x106>
; 		attr.link_create.kprobe_multi.flags = OPTS_GET(opts, kprobe_multi.flags, 0);
   27f91: 48 85 db                     	testq	%rbx, %rbx
   27f94: 0f 84 6d 03 00 00            	je	0x28307 <bpf_link_create+0x5b7>
   27f9a: 48 8b 13                     	movq	(%rbx), %rdx
   27f9d: 48 83 fa 23                  	cmpq	$35, %rdx
   27fa1: 0f 86 09 03 00 00            	jbe	0x282b0 <bpf_link_create+0x560>
   27fa7: 8b 43 20                     	movl	32(%rbx), %eax
   27faa: 89 44 24 20                  	movl	%eax, 32(%rsp)
; 		attr.link_create.kprobe_multi.cnt = OPTS_GET(opts, kprobe_multi.cnt, 0);
   27fae: 48 83 fa 27                  	cmpq	$39, %rdx
   27fb2: 0f 86 00 03 00 00            	jbe	0x282b8 <bpf_link_create+0x568>
   27fb8: 8b 43 24                     	movl	36(%rbx), %eax
   27fbb: 89 44 24 24                  	movl	%eax, 36(%rsp)
; 		attr.link_create.kprobe_multi.syms = ptr_to_u64(OPTS_GET(opts, kprobe_multi.syms, 0));
   27fbf: 48 83 fa 2f                  	cmpq	$47, %rdx
   27fc3: 0f 86 f7 02 00 00            	jbe	0x282c0 <bpf_link_create+0x570>
   27fc9: 48 8b 43 28                  	movq	40(%rbx), %rax
   27fcd: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 		attr.link_create.kprobe_multi.addrs = ptr_to_u64(OPTS_GET(opts, kprobe_multi.addrs, 0));
   27fd2: 48 83 fa 37                  	cmpq	$55, %rdx
   27fd6: 0f 86 ed 02 00 00            	jbe	0x282c9 <bpf_link_create+0x579>
   27fdc: 48 8b 43 30                  	movq	48(%rbx), %rax
   27fe0: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 		attr.link_create.kprobe_multi.cookies = ptr_to_u64(OPTS_GET(opts, kprobe_multi.cookies, 0));
   27fe5: 48 83 fa 3f                  	cmpq	$63, %rdx
   27fe9: 0f 86 e3 02 00 00            	jbe	0x282d2 <bpf_link_create+0x582>
; 	return (__u64) (unsigned long) ptr;
   27fef: 48 8b 43 38                  	movq	56(%rbx), %rax
; 		attr.link_create.kprobe_multi.cookies = ptr_to_u64(OPTS_GET(opts, kprobe_multi.cookies, 0));
   27ff3: e9 dc 02 00 00               	jmp	0x282d4 <bpf_link_create+0x584>
   27ff8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	switch (attach_type) {
   28000: 83 fd 1c                     	cmpl	$28, %ebp
   28003: 0f 85 4d fe ff ff            	jne	0x27e56 <bpf_link_create+0x106>
; 		attr.link_create.iter_info = ptr_to_u64(OPTS_GET(opts, iter_info, (void *)0));
   28009: 31 c0                        	xorl	%eax, %eax
   2800b: 48 85 db                     	testq	%rbx, %rbx
   2800e: 74 0a                        	je	0x2801a <bpf_link_create+0x2ca>
   28010: 48 83 3b 17                  	cmpq	$23, (%rbx)
   28014: 76 04                        	jbe	0x2801a <bpf_link_create+0x2ca>
; 	return (__u64) (unsigned long) ptr;
   28016: 48 8b 43 10                  	movq	16(%rbx), %rax
; 		attr.link_create.iter_info = ptr_to_u64(OPTS_GET(opts, iter_info, (void *)0));
   2801a: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 		attr.link_create.iter_info_len = iter_info_len;
   2801f: 44 89 44 24 28               	movl	%r8d, 40(%rsp)
; 		break;
   28024: e9 fd fe ff ff               	jmp	0x27f26 <bpf_link_create+0x1d6>
   28029: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -ret;
   28030: e8 bb d6 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	err = -errno;
   28035: 44 8b 28                     	movl	(%rax), %r13d
   28038: 45 89 ef                     	movl	%r13d, %r15d
   2803b: 41 f7 df                     	negl	%r15d
; 	if (err != -EINVAL)
   2803e: 41 83 fd 16                  	cmpl	$22, %r13d
   28042: 0f 85 0d ff ff ff            	jne	0x27f55 <bpf_link_create+0x205>
; 	if (attr.link_create.target_fd || attr.link_create.target_btf_id)
   28048: 8b 44 24 14                  	movl	20(%rsp), %eax
   2804c: 0b 44 24 20                  	orl	32(%rsp), %eax
; 		return libbpf_err(err);
   28050: 41 bf ea ff ff ff            	movl	$4294967274, %r15d      # imm = 0xFFFFFFEA
; 	if (attr.link_create.target_fd || attr.link_create.target_btf_id)
   28056: 0f 85 f9 fe ff ff            	jne	0x27f55 <bpf_link_create+0x205>
; 	if (!OPTS_ZEROED(opts, sz))
   2805c: 48 85 db                     	testq	%rbx, %rbx
   2805f: 0f 84 4b 01 00 00            	je	0x281b0 <bpf_link_create+0x460>
   28065: 48 8b 13                     	movq	(%rbx), %rdx
   28068: 48 8d 43 08                  	leaq	8(%rbx), %rax
   2806c: 48 8d 4a f8                  	leaq	-8(%rdx), %rcx
; 	while (len > 0) {
   28070: 48 85 c9                     	testq	%rcx, %rcx
   28073: 0f 8e 37 01 00 00            	jle	0x281b0 <bpf_link_create+0x460>
   28079: 48 01 da                     	addq	%rbx, %rdx
   2807c: eb 0f                        	jmp	0x2808d <bpf_link_create+0x33d>
   2807e: 66 90                        	nop
; 		p++;
   28080: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   28084: 48 39 c2                     	cmpq	%rax, %rdx
   28087: 0f 84 23 01 00 00            	je	0x281b0 <bpf_link_create+0x460>
; 		if (*p)
   2808d: 80 38 00                     	cmpb	$0, (%rax)
   28090: 74 ee                        	je	0x28080 <bpf_link_create+0x330>
   28092: e9 51 fd ff ff               	jmp	0x27de8 <bpf_link_create+0x98>
   28097: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   280a0: 89 c7                        	movl	%eax, %edi
   280a2: ba 03 00 00 00               	movl	$3, %edx
   280a7: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   280ac: 31 c0                        	xorl	%eax, %eax
   280ae: e8 bd da fd ff               	callq	0x5b70 <.plt.sec+0x500>
   280b3: 41 89 c6                     	movl	%eax, %r14d
; 		saved_errno = errno;
   280b6: e8 35 d6 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   280bb: 44 89 ff                     	movl	%r15d, %edi
; 		saved_errno = errno;
   280be: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   280c3: 44 8b 28                     	movl	(%rax), %r13d
; 		close(old_fd);
   280c6: e8 35 d8 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   280cb: 45 85 f6                     	testl	%r14d, %r14d
   280ce: 78 60                        	js	0x28130 <bpf_link_create+0x3e0>
   280d0: 45 89 f7                     	movl	%r14d, %r15d
   280d3: e9 7d fe ff ff               	jmp	0x27f55 <bpf_link_create+0x205>
   280d8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (iter_info_len || target_btf_id) {
   280e0: 45 85 c0                     	testl	%r8d, %r8d
   280e3: 0f 84 ef 00 00 00            	je	0x281d8 <bpf_link_create+0x488>
; 	attr.link_create.flags = OPTS_GET(opts, flags, 0);
   280e9: 8b 43 08                     	movl	8(%rbx), %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   280ec: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	attr.link_create.prog_fd = prog_fd;
   280f0: 44 89 64 24 10               	movl	%r12d, 16(%rsp)
; 	attr.link_create.target_fd = target_fd;
   280f5: 89 74 24 14                  	movl	%esi, 20(%rsp)
; 	attr.link_create.attach_type = attach_type;
   280f9: 89 6c 24 18                  	movl	%ebp, 24(%rsp)
; 	attr.link_create.flags = OPTS_GET(opts, flags, 0);
   280fd: 89 44 24 1c                  	movl	%eax, 28(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   28101: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   28106: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	if (target_btf_id) {
   2810b: e9 22 fd ff ff               	jmp	0x27e32 <bpf_link_create+0xe2>
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   28110: 48 8d 15 76 2e 01 00         	leaq	77430(%rip), %rdx       # 0x3af8d <CSWTCH.126+0x168d>
   28117: 48 8d 35 9a be 00 00         	leaq	48794(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   2811e: 31 ff                        	xorl	%edi, %edi
   28120: e8 ab ff fd ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   28125: e9 ae fc ff ff               	jmp	0x27dd8 <bpf_link_create+0x88>
   2812a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   28130: 45 89 ee                     	movl	%r13d, %r14d
   28133: 44 89 fa                     	movl	%r15d, %edx
   28136: 31 c0                        	xorl	%eax, %eax
   28138: 31 ff                        	xorl	%edi, %edi
   2813a: 41 f7 de                     	negl	%r14d
   2813d: 48 8d 35 84 2e 01 00         	leaq	77444(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   28144: 44 89 f1                     	movl	%r14d, %ecx
; 			errno = saved_errno;
   28147: 45 89 f7                     	movl	%r14d, %r15d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   2814a: e8 81 ff fd ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   2814f: 48 8b 44 24 08               	movq	8(%rsp), %rax
   28154: 44 89 28                     	movl	%r13d, (%rax)
   28157: e9 e2 fe ff ff               	jmp	0x2803e <bpf_link_create+0x2ee>
   2815c: 0f 1f 40 00                  	nopl	(%rax)
; 		attr.link_create.tracing.cookie = OPTS_GET(opts, tracing.cookie, 0);
   28160: 48 85 db                     	testq	%rbx, %rbx
   28163: 0f 84 c7 01 00 00            	je	0x28330 <bpf_link_create+0x5e0>
   28169: 48 8b 13                     	movq	(%rbx), %rdx
   2816c: 31 c0                        	xorl	%eax, %eax
   2816e: 48 83 fa 27                  	cmpq	$39, %rdx
   28172: 0f 87 28 01 00 00            	ja	0x282a0 <bpf_link_create+0x550>
; 		if (!OPTS_ZEROED(opts, tracing))
   28178: 48 8d 4a d8                  	leaq	-40(%rdx), %rcx
; 		attr.link_create.tracing.cookie = OPTS_GET(opts, tracing.cookie, 0);
   2817c: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 		if (!OPTS_ZEROED(opts, tracing))
   28181: 48 01 da                     	addq	%rbx, %rdx
   28184: 48 8d 43 28                  	leaq	40(%rbx), %rax
; 	while (len > 0) {
   28188: 48 85 c9                     	testq	%rcx, %rcx
   2818b: 7f 18                        	jg	0x281a5 <bpf_link_create+0x455>
   2818d: e9 94 fd ff ff               	jmp	0x27f26 <bpf_link_create+0x1d6>
   28192: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		p++;
   28198: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   2819c: 48 39 d0                     	cmpq	%rdx, %rax
   2819f: 0f 84 81 fd ff ff            	je	0x27f26 <bpf_link_create+0x1d6>
; 		if (*p)
   281a5: 80 38 00                     	cmpb	$0, (%rax)
   281a8: 74 ee                        	je	0x28198 <bpf_link_create+0x448>
   281aa: e9 29 fc ff ff               	jmp	0x27dd8 <bpf_link_create+0x88>
   281af: 90                           	nop
; 	switch (attach_type) {
   281b0: 83 ed 17                     	subl	$23, %ebp
; 		return libbpf_err(err);
   281b3: 41 bf ea ff ff ff            	movl	$4294967274, %r15d      # imm = 0xFFFFFFEA
; 	switch (attach_type) {
   281b9: 83 fd 04                     	cmpl	$4, %ebp
   281bc: 0f 87 93 fd ff ff            	ja	0x27f55 <bpf_link_create+0x205>
; 		return bpf_raw_tracepoint_open(NULL, prog_fd);
   281c2: 44 89 e6                     	movl	%r12d, %esi
   281c5: 31 ff                        	xorl	%edi, %edi
   281c7: e8 84 fa ff ff               	callq	0x27c50 <bpf_raw_tracepoint_open>
   281cc: 41 89 c7                     	movl	%eax, %r15d
   281cf: e9 81 fd ff ff               	jmp	0x27f55 <bpf_link_create+0x205>
   281d4: 0f 1f 40 00                  	nopl	(%rax)
; 	attr.link_create.prog_fd = prog_fd;
   281d8: 44 89 64 24 10               	movl	%r12d, 16(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   281dd: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	attr.link_create.target_fd = target_fd;
   281e1: 89 74 24 14                  	movl	%esi, 20(%rsp)
; 	attr.link_create.attach_type = attach_type;
   281e5: 89 6c 24 18                  	movl	%ebp, 24(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   281e9: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   281ee: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	attr.link_create.flags = OPTS_GET(opts, flags, 0);
   281f3: 8b 43 08                     	movl	8(%rbx), %eax
   281f6: 45 31 c0                     	xorl	%r8d, %r8d
   281f9: 89 44 24 1c                  	movl	%eax, 28(%rsp)
; 	if (target_btf_id) {
   281fd: e9 30 fc ff ff               	jmp	0x27e32 <bpf_link_create+0xe2>
   28202: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
;   return __builtin___memset_chk (__dest, __ch, __len,
   28208: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	attr.link_create.prog_fd = prog_fd;
   2820c: 89 7c 24 10                  	movl	%edi, 16(%rsp)
; 	iter_info_len = OPTS_GET(opts, iter_info_len, 0);
   28210: 45 31 c0                     	xorl	%r8d, %r8d
; 	attr.link_create.target_fd = target_fd;
   28213: 89 74 24 14                  	movl	%esi, 20(%rsp)
; 	attr.link_create.attach_type = attach_type;
   28217: 89 54 24 18                  	movl	%edx, 24(%rsp)
; 	attr.link_create.flags = OPTS_GET(opts, flags, 0);
   2821b: c7 44 24 1c 00 00 00 00      	movl	$0, 28(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   28223: 0f 29 44 24 20               	movaps	%xmm0, 32(%rsp)
   28228: 0f 29 44 24 30               	movaps	%xmm0, 48(%rsp)
; 	switch (attach_type) {
   2822d: 83 fa 29                     	cmpl	$41, %edx
   28230: 0f 85 05 fc ff ff            	jne	0x27e3b <bpf_link_create+0xeb>
; 		attr.link_create.perf_event.bpf_cookie = OPTS_GET(opts, perf_event.bpf_cookie, 0);
   28236: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
; 		if (!OPTS_ZEROED(opts, perf_event))
   2823f: e9 e2 fc ff ff               	jmp	0x27f26 <bpf_link_create+0x1d6>
   28244: 0f 1f 40 00                  	nopl	(%rax)
; 		attr.link_create.perf_event.bpf_cookie = OPTS_GET(opts, perf_event.bpf_cookie, 0);
   28248: 31 c0                        	xorl	%eax, %eax
   2824a: 48 83 f9 27                  	cmpq	$39, %rcx
   2824e: 77 40                        	ja	0x28290 <bpf_link_create+0x540>
; 		if (!OPTS_ZEROED(opts, perf_event))
   28250: 48 8d 51 d8                  	leaq	-40(%rcx), %rdx
; 		attr.link_create.perf_event.bpf_cookie = OPTS_GET(opts, perf_event.bpf_cookie, 0);
   28254: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 		if (!OPTS_ZEROED(opts, perf_event))
   28259: 48 01 d9                     	addq	%rbx, %rcx
   2825c: 48 8d 43 28                  	leaq	40(%rbx), %rax
; 	while (len > 0) {
   28260: 48 85 d2                     	testq	%rdx, %rdx
   28263: 7f 18                        	jg	0x2827d <bpf_link_create+0x52d>
   28265: e9 bc fc ff ff               	jmp	0x27f26 <bpf_link_create+0x1d6>
   2826a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		p++;
   28270: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   28274: 48 39 c8                     	cmpq	%rcx, %rax
   28277: 0f 84 a9 fc ff ff            	je	0x27f26 <bpf_link_create+0x1d6>
; 		if (*p)
   2827d: 80 38 00                     	cmpb	$0, (%rax)
   28280: 74 ee                        	je	0x28270 <bpf_link_create+0x520>
   28282: e9 51 fb ff ff               	jmp	0x27dd8 <bpf_link_create+0x88>
   28287: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		attr.link_create.perf_event.bpf_cookie = OPTS_GET(opts, perf_event.bpf_cookie, 0);
   28290: 48 8b 43 20                  	movq	32(%rbx), %rax
   28294: eb ba                        	jmp	0x28250 <bpf_link_create+0x500>
   28296: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		attr.link_create.tracing.cookie = OPTS_GET(opts, tracing.cookie, 0);
   282a0: 48 8b 43 20                  	movq	32(%rbx), %rax
   282a4: e9 cf fe ff ff               	jmp	0x28178 <bpf_link_create+0x428>
   282a9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		attr.link_create.kprobe_multi.flags = OPTS_GET(opts, kprobe_multi.flags, 0);
   282b0: c7 44 24 20 00 00 00 00      	movl	$0, 32(%rsp)
; 		attr.link_create.kprobe_multi.cnt = OPTS_GET(opts, kprobe_multi.cnt, 0);
   282b8: c7 44 24 24 00 00 00 00      	movl	$0, 36(%rsp)
; 		attr.link_create.kprobe_multi.syms = ptr_to_u64(OPTS_GET(opts, kprobe_multi.syms, 0));
   282c0: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 		attr.link_create.kprobe_multi.addrs = ptr_to_u64(OPTS_GET(opts, kprobe_multi.addrs, 0));
   282c9: 48 c7 44 24 30 00 00 00 00   	movq	$0, 48(%rsp)
; 		attr.link_create.perf_event.bpf_cookie = OPTS_GET(opts, perf_event.bpf_cookie, 0);
   282d2: 31 c0                        	xorl	%eax, %eax
; 		if (!OPTS_ZEROED(opts, kprobe_multi))
   282d4: 48 8d 4a c0                  	leaq	-64(%rdx), %rcx
; 		attr.link_create.kprobe_multi.cookies = ptr_to_u64(OPTS_GET(opts, kprobe_multi.cookies, 0));
   282d8: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 		if (!OPTS_ZEROED(opts, kprobe_multi))
   282dd: 48 01 da                     	addq	%rbx, %rdx
   282e0: 48 8d 43 40                  	leaq	64(%rbx), %rax
; 	while (len > 0) {
   282e4: 48 85 c9                     	testq	%rcx, %rcx
   282e7: 7f 14                        	jg	0x282fd <bpf_link_create+0x5ad>
   282e9: e9 38 fc ff ff               	jmp	0x27f26 <bpf_link_create+0x1d6>
   282ee: 66 90                        	nop
; 		p++;
   282f0: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   282f4: 48 39 c2                     	cmpq	%rax, %rdx
   282f7: 0f 84 29 fc ff ff            	je	0x27f26 <bpf_link_create+0x1d6>
; 		if (*p)
   282fd: 80 38 00                     	cmpb	$0, (%rax)
   28300: 74 ee                        	je	0x282f0 <bpf_link_create+0x5a0>
   28302: e9 d1 fa ff ff               	jmp	0x27dd8 <bpf_link_create+0x88>
; 		attr.link_create.kprobe_multi.flags = OPTS_GET(opts, kprobe_multi.flags, 0);
   28307: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
; 		attr.link_create.kprobe_multi.syms = ptr_to_u64(OPTS_GET(opts, kprobe_multi.syms, 0));
   28310: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 		attr.link_create.kprobe_multi.addrs = ptr_to_u64(OPTS_GET(opts, kprobe_multi.addrs, 0));
   28319: 48 c7 44 24 30 00 00 00 00   	movq	$0, 48(%rsp)
; 		attr.link_create.kprobe_multi.cookies = ptr_to_u64(OPTS_GET(opts, kprobe_multi.cookies, 0));
   28322: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
; 		if (!OPTS_ZEROED(opts, kprobe_multi))
   2832b: e9 f6 fb ff ff               	jmp	0x27f26 <bpf_link_create+0x1d6>
; 		attr.link_create.tracing.cookie = OPTS_GET(opts, tracing.cookie, 0);
   28330: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 		if (!OPTS_ZEROED(opts, tracing))
   28339: e9 e8 fb ff ff               	jmp	0x27f26 <bpf_link_create+0x1d6>
; }
   2833e: e8 bd d4 fd ff               	callq	0x5800 <.plt.sec+0x190>
   28343: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2834e: 66 90                        	nop

0000000000028350 <bpf_btf_load>:
; {
   28350: f3 0f 1e fa                  	endbr64
   28354: 41 57                        	pushq	%r15
   28356: 41 56                        	pushq	%r14
   28358: 41 55                        	pushq	%r13
   2835a: 41 54                        	pushq	%r12
   2835c: 49 89 fc                     	movq	%rdi, %r12
   2835f: 55                           	pushq	%rbp
   28360: 48 89 f5                     	movq	%rsi, %rbp
   28363: 53                           	pushq	%rbx
   28364: 48 89 d3                     	movq	%rdx, %rbx
   28367: 48 81 ec b8 00 00 00         	subq	$184, %rsp
   2836e: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   28377: 48 89 84 24 a8 00 00 00      	movq	%rax, 168(%rsp)
   2837f: 31 c0                        	xorl	%eax, %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   28381: 4c 8d 6c 24 10               	leaq	16(%rsp), %r13
; 	bump_rlimit_memlock();
   28386: e8 85 d4 ff ff               	callq	0x25810 <bump_rlimit_memlock>
;   return __builtin___memset_chk (__dest, __ch, __len,
   2838b: 66 0f ef c0                  	pxor	%xmm0, %xmm0
   2838f: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
   28398: c7 44 24 28 00 00 00 00      	movl	$0, 40(%rsp)
   283a0: 0f 29 44 24 10               	movaps	%xmm0, 16(%rsp)
; 	if (!OPTS_VALID(opts, bpf_btf_load_opts))
   283a5: 48 85 db                     	testq	%rbx, %rbx
   283a8: 0f 84 9a 01 00 00            	je	0x28548 <bpf_btf_load+0x1f8>
   283ae: 48 8b 0b                     	movq	(%rbx), %rcx
; 	if (user_sz < sizeof(size_t)) {
   283b1: 48 83 f9 07                  	cmpq	$7, %rcx
   283b5: 0f 86 d5 01 00 00            	jbe	0x28590 <bpf_btf_load+0x240>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   283bb: 48 8d 51 e8                  	leaq	-24(%rcx), %rdx
   283bf: 48 8d 43 18                  	leaq	24(%rbx), %rax
; 	while (len > 0) {
   283c3: 48 85 d2                     	testq	%rdx, %rdx
   283c6: 7e 48                        	jle	0x28410 <bpf_btf_load+0xc0>
   283c8: 48 8d 14 0b                  	leaq	(%rbx,%rcx), %rdx
   283cc: eb 0b                        	jmp	0x283d9 <bpf_btf_load+0x89>
   283ce: 66 90                        	nop
; 		p++;
   283d0: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   283d4: 48 39 d0                     	cmpq	%rdx, %rax
   283d7: 74 37                        	je	0x28410 <bpf_btf_load+0xc0>
; 		if (*p)
   283d9: 80 38 00                     	cmpb	$0, (%rax)
   283dc: 74 f2                        	je	0x283d0 <bpf_btf_load+0x80>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   283de: 48 8d 15 bd 2b 01 00         	leaq	76733(%rip), %rdx       # 0x3afa2 <CSWTCH.126+0x16a2>
   283e5: 48 8d 35 24 bc 00 00         	leaq	48164(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   283ec: 31 ff                        	xorl	%edi, %edi
   283ee: 31 c0                        	xorl	%eax, %eax
   283f0: e8 db fc fd ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   283f5: e8 f6 d2 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   283fa: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   28400: c7 00 16 00 00 00            	movl	$22, (%rax)
   28406: eb 75                        	jmp	0x2847d <bpf_btf_load+0x12d>
   28408: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   28410: 45 31 f6                     	xorl	%r14d, %r14d
   28413: 48 83 f9 0f                  	cmpq	$15, %rcx
   28417: 76 04                        	jbe	0x2841d <bpf_btf_load+0xcd>
   28419: 4c 8b 73 08                  	movq	8(%rbx), %r14
; 	log_size = OPTS_GET(opts, log_size, 0);
   2841d: 48 83 f9 17                  	cmpq	$23, %rcx
   28421: 0f 86 89 00 00 00            	jbe	0x284b0 <bpf_btf_load+0x160>
   28427: 44 8b 7b 14                  	movl	20(%rbx), %r15d
; 	log_level = OPTS_GET(opts, log_level, 0);
   2842b: 8b 5b 10                     	movl	16(%rbx), %ebx
; 	if (log_size && !log_buf)
   2842e: 4d 85 ff                     	testq	%r15, %r15
   28431: 74 05                        	je	0x28438 <bpf_btf_load+0xe8>
   28433: 4d 85 f6                     	testq	%r14, %r14
   28436: 74 bd                        	je	0x283f5 <bpf_btf_load+0xa5>
; 	attr.btf = ptr_to_u64(btf_data);
   28438: 4c 89 64 24 10               	movq	%r12, 16(%rsp)
; 	attr.btf_size = btf_size;
   2843d: 89 6c 24 20                  	movl	%ebp, 32(%rsp)
; 	if (log_level) {
   28441: 85 db                        	testl	%ebx, %ebx
   28443: 74 0e                        	je	0x28453 <bpf_btf_load+0x103>
; 		attr.btf_log_buf = ptr_to_u64(log_buf);
   28445: 4c 89 74 24 18               	movq	%r14, 24(%rsp)
; 		attr.btf_log_size = (__u32)log_size;
   2844a: 44 89 7c 24 24               	movl	%r15d, 36(%rsp)
; 		attr.btf_log_level = log_level;
   2844f: 89 5c 24 28                  	movl	%ebx, 40(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   28453: b9 1c 00 00 00               	movl	$28, %ecx
   28458: 4c 89 ea                     	movq	%r13, %rdx
   2845b: be 12 00 00 00               	movl	$18, %esi
   28460: 31 c0                        	xorl	%eax, %eax
   28462: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   28467: e8 74 d5 fd ff               	callq	0x59e0 <.plt.sec+0x370>
   2846c: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 0)
   2846f: 85 c0                        	testl	%eax, %eax
   28471: 0f 88 b1 00 00 00            	js	0x28528 <bpf_btf_load+0x1d8>
; 	if (fd < 3) {
   28477: 41 83 fc 02                  	cmpl	$2, %r12d
   2847b: 7e 53                        	jle	0x284d0 <bpf_btf_load+0x180>
; }
   2847d: 48 8b 84 24 a8 00 00 00      	movq	168(%rsp), %rax
   28485: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2848e: 0f 85 b5 01 00 00            	jne	0x28649 <bpf_btf_load+0x2f9>
   28494: 48 81 c4 b8 00 00 00         	addq	$184, %rsp
   2849b: 44 89 e0                     	movl	%r12d, %eax
   2849e: 5b                           	popq	%rbx
   2849f: 5d                           	popq	%rbp
   284a0: 41 5c                        	popq	%r12
   284a2: 41 5d                        	popq	%r13
   284a4: 41 5e                        	popq	%r14
   284a6: 41 5f                        	popq	%r15
   284a8: c3                           	retq
   284a9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	log_level = OPTS_GET(opts, log_level, 0);
   284b0: 48 83 f9 13                  	cmpq	$19, %rcx
   284b4: 0f 87 94 01 00 00            	ja	0x2864e <bpf_btf_load+0x2fe>
; 	attr.btf = ptr_to_u64(btf_data);
   284ba: 4c 89 64 24 10               	movq	%r12, 16(%rsp)
; 	log_size = OPTS_GET(opts, log_size, 0);
   284bf: 45 31 ff                     	xorl	%r15d, %r15d
; 	log_level = OPTS_GET(opts, log_level, 0);
   284c2: 31 db                        	xorl	%ebx, %ebx
; 	attr.btf_size = btf_size;
   284c4: 89 6c 24 20                  	movl	%ebp, 32(%rsp)
; 	if (log_level) {
   284c8: eb 89                        	jmp	0x28453 <bpf_btf_load+0x103>
   284ca: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   284d0: 44 89 e7                     	movl	%r12d, %edi
   284d3: ba 03 00 00 00               	movl	$3, %edx
   284d8: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   284dd: 31 c0                        	xorl	%eax, %eax
   284df: e8 8c d6 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   284e4: 89 c5                        	movl	%eax, %ebp
; 		saved_errno = errno;
   284e6: e8 05 d2 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   284eb: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   284ee: 48 89 04 24                  	movq	%rax, (%rsp)
   284f2: 8b 00                        	movl	(%rax), %eax
   284f4: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 		close(old_fd);
   284f8: e8 03 d4 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   284fd: 85 ed                        	testl	%ebp, %ebp
   284ff: 79 7f                        	jns	0x28580 <bpf_btf_load+0x230>
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   28501: 8b 6c 24 0c                  	movl	12(%rsp), %ebp
   28505: 31 c0                        	xorl	%eax, %eax
   28507: 44 89 e2                     	movl	%r12d, %edx
   2850a: 48 8d 35 b7 2a 01 00         	leaq	76471(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   28511: 31 ff                        	xorl	%edi, %edi
   28513: 89 e9                        	movl	%ebp, %ecx
   28515: f7 d9                        	negl	%ecx
   28517: e8 b4 fb fd ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   2851c: 48 8b 04 24                  	movq	(%rsp), %rax
   28520: 89 28                        	movl	%ebp, (%rax)
   28522: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (fd < 0 && log_buf && log_level == 0) {
   28528: 4d 85 f6                     	testq	%r14, %r14
   2852b: 74 04                        	je	0x28531 <bpf_btf_load+0x1e1>
   2852d: 85 db                        	testl	%ebx, %ebx
   2852f: 74 7f                        	je	0x285b0 <bpf_btf_load+0x260>
; 		errno = -ret;
   28531: e8 ba d1 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   28536: 44 8b 20                     	movl	(%rax), %r12d
   28539: 41 f7 dc                     	negl	%r12d
   2853c: e9 3c ff ff ff               	jmp	0x2847d <bpf_btf_load+0x12d>
   28541: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return syscall(__NR_bpf, cmd, attr, size);
   28548: b9 1c 00 00 00               	movl	$28, %ecx
   2854d: 4c 89 ea                     	movq	%r13, %rdx
   28550: be 12 00 00 00               	movl	$18, %esi
   28555: 31 c0                        	xorl	%eax, %eax
   28557: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 	attr.btf = ptr_to_u64(btf_data);
   2855c: 4c 89 64 24 10               	movq	%r12, 16(%rsp)
; 	attr.btf_size = btf_size;
   28561: 89 6c 24 20                  	movl	%ebp, 32(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   28565: e8 76 d4 fd ff               	callq	0x59e0 <.plt.sec+0x370>
   2856a: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 0)
   2856d: 85 c0                        	testl	%eax, %eax
   2856f: 78 c0                        	js	0x28531 <bpf_btf_load+0x1e1>
; 	log_buf = OPTS_GET(opts, log_buf, NULL);
   28571: 45 31 f6                     	xorl	%r14d, %r14d
; 	log_size = OPTS_GET(opts, log_size, 0);
   28574: 45 31 ff                     	xorl	%r15d, %r15d
; 	log_level = OPTS_GET(opts, log_level, 0);
   28577: 31 db                        	xorl	%ebx, %ebx
   28579: e9 f9 fe ff ff               	jmp	0x28477 <bpf_btf_load+0x127>
   2857e: 66 90                        	nop
   28580: 41 89 ec                     	movl	%ebp, %r12d
; 	return ret < 0 ? -errno : ret;
   28583: e9 f5 fe ff ff               	jmp	0x2847d <bpf_btf_load+0x12d>
   28588: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   28590: 48 8d 15 0b 2a 01 00         	leaq	76299(%rip), %rdx       # 0x3afa2 <CSWTCH.126+0x16a2>
   28597: 48 8d 35 1a ba 00 00         	leaq	47642(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   2859e: 31 ff                        	xorl	%edi, %edi
   285a0: 31 c0                        	xorl	%eax, %eax
   285a2: e8 29 fb fd ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   285a7: e9 49 fe ff ff               	jmp	0x283f5 <bpf_btf_load+0xa5>
   285ac: 0f 1f 40 00                  	nopl	(%rax)
; 	return syscall(__NR_bpf, cmd, attr, size);
   285b0: b9 1c 00 00 00               	movl	$28, %ecx
   285b5: 4c 89 ea                     	movq	%r13, %rdx
   285b8: be 12 00 00 00               	movl	$18, %esi
   285bd: 31 c0                        	xorl	%eax, %eax
   285bf: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
; 		attr.btf_log_buf = ptr_to_u64(log_buf);
   285c4: 4c 89 74 24 18               	movq	%r14, 24(%rsp)
; 		attr.btf_log_size = (__u32)log_size;
   285c9: 44 89 7c 24 24               	movl	%r15d, 36(%rsp)
; 		attr.btf_log_level = 1;
   285ce: c7 44 24 28 01 00 00 00      	movl	$1, 40(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   285d6: e8 05 d4 fd ff               	callq	0x59e0 <.plt.sec+0x370>
   285db: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 0)
   285de: 85 c0                        	testl	%eax, %eax
   285e0: 0f 88 4b ff ff ff            	js	0x28531 <bpf_btf_load+0x1e1>
; 	if (fd < 3) {
   285e6: 83 f8 02                     	cmpl	$2, %eax
   285e9: 0f 8f 8e fe ff ff            	jg	0x2847d <bpf_btf_load+0x12d>
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   285ef: 89 c7                        	movl	%eax, %edi
   285f1: ba 03 00 00 00               	movl	$3, %edx
   285f6: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   285fb: 31 c0                        	xorl	%eax, %eax
   285fd: e8 6e d5 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   28602: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   28604: e8 e7 d0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   28609: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   2860c: 44 8b 28                     	movl	(%rax), %r13d
   2860f: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   28612: e8 e9 d2 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   28617: 85 db                        	testl	%ebx, %ebx
   28619: 78 08                        	js	0x28623 <bpf_btf_load+0x2d3>
   2861b: 41 89 dc                     	movl	%ebx, %r12d
   2861e: e9 5a fe ff ff               	jmp	0x2847d <bpf_btf_load+0x12d>
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   28623: 44 89 eb                     	movl	%r13d, %ebx
   28626: 44 89 e2                     	movl	%r12d, %edx
   28629: 48 8d 35 98 29 01 00         	leaq	76184(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   28630: 31 ff                        	xorl	%edi, %edi
   28632: f7 db                        	negl	%ebx
   28634: 31 c0                        	xorl	%eax, %eax
   28636: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   28638: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   2863b: e8 90 fa fd ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   28640: 44 89 6d 00                  	movl	%r13d, (%rbp)
   28644: e9 34 fe ff ff               	jmp	0x2847d <bpf_btf_load+0x12d>
; }
   28649: e8 b2 d1 fd ff               	callq	0x5800 <.plt.sec+0x190>
; 	log_level = OPTS_GET(opts, log_level, 0);
   2864e: 8b 5b 10                     	movl	16(%rbx), %ebx
; 	log_size = OPTS_GET(opts, log_size, 0);
   28651: 45 31 ff                     	xorl	%r15d, %r15d
   28654: e9 df fd ff ff               	jmp	0x28438 <bpf_btf_load+0xe8>
   28659: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000028660 <bpf_task_fd_query>:
; {
   28660: f3 0f 1e fa                  	endbr64
   28664: 41 56                        	pushq	%r14
   28666: 41 89 d2                     	movl	%edx, %r10d
;   return __builtin___memset_chk (__dest, __ch, __len,
   28669: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   2866d: 41 55                        	pushq	%r13
   2866f: 41 54                        	pushq	%r12
   28671: 55                           	pushq	%rbp
   28672: 4c 89 cd                     	movq	%r9, %rbp
   28675: 53                           	pushq	%rbx
   28676: 4c 89 c3                     	movq	%r8, %rbx
   28679: 48 81 ec a0 00 00 00         	subq	$160, %rsp
   28680: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   28689: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   28691: 31 c0                        	xorl	%eax, %eax
; 	attr.task_fd_query.buf_len = *buf_len;
   28693: 41 8b 00                     	movl	(%r8), %eax
; 	attr.task_fd_query.pid = pid;
   28696: 89 3c 24                     	movl	%edi, (%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   28699: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.task_fd_query.fd = fd;
   2869c: 89 74 24 04                  	movl	%esi, 4(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   286a0: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   286a5: be 14 00 00 00               	movl	$20, %esi
; {
   286aa: 4c 8b b4 24 d0 00 00 00      	movq	208(%rsp), %r14
; 	attr.task_fd_query.buf = ptr_to_u64(buf);
   286b2: 48 89 4c 24 10               	movq	%rcx, 16(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   286b7: b9 30 00 00 00               	movl	$48, %ecx
; {
   286bc: 4c 8b ac 24 d8 00 00 00      	movq	216(%rsp), %r13
; 	attr.task_fd_query.buf_len = *buf_len;
   286c4: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   286c8: 31 c0                        	xorl	%eax, %eax
; {
   286ca: 4c 8b a4 24 e0 00 00 00      	movq	224(%rsp), %r12
;   return __builtin___memset_chk (__dest, __ch, __len,
   286d2: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
; 	attr.task_fd_query.flags = flags;
   286db: 44 89 54 24 08               	movl	%r10d, 8(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   286e0: 0f 11 44 24 18               	movups	%xmm0, 24(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   286e5: e8 f6 d2 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	*buf_len = attr.task_fd_query.buf_len;
   286ea: 8b 54 24 0c                  	movl	12(%rsp), %edx
   286ee: 41 89 c0                     	movl	%eax, %r8d
   286f1: 89 13                        	movl	%edx, (%rbx)
; 	*prog_id = attr.task_fd_query.prog_id;
   286f3: 8b 54 24 18                  	movl	24(%rsp), %edx
   286f7: 89 55 00                     	movl	%edx, (%rbp)
; 	*fd_type = attr.task_fd_query.fd_type;
   286fa: 8b 54 24 1c                  	movl	28(%rsp), %edx
   286fe: 41 89 16                     	movl	%edx, (%r14)
; 	*probe_offset = attr.task_fd_query.probe_offset;
   28701: 48 8b 54 24 20               	movq	32(%rsp), %rdx
   28706: 49 89 55 00                  	movq	%rdx, (%r13)
; 	*probe_addr = attr.task_fd_query.probe_addr;
   2870a: 48 8b 54 24 28               	movq	40(%rsp), %rdx
   2870f: 49 89 14 24                  	movq	%rdx, (%r12)
; 	return ret < 0 ? -errno : ret;
   28713: 85 c0                        	testl	%eax, %eax
   28715: 79 0b                        	jns	0x28722 <bpf_task_fd_query+0xc2>
   28717: e8 d4 cf fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2871c: 44 8b 00                     	movl	(%rax), %r8d
   2871f: 41 f7 d8                     	negl	%r8d
; }
   28722: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   2872a: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   28733: 75 13                        	jne	0x28748 <bpf_task_fd_query+0xe8>
   28735: 48 81 c4 a0 00 00 00         	addq	$160, %rsp
   2873c: 44 89 c0                     	movl	%r8d, %eax
   2873f: 5b                           	popq	%rbx
   28740: 5d                           	popq	%rbp
   28741: 41 5c                        	popq	%r12
   28743: 41 5d                        	popq	%r13
   28745: 41 5e                        	popq	%r14
   28747: c3                           	retq
   28748: e8 b3 d0 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2874d: 0f 1f 00                     	nopl	(%rax)

0000000000028750 <bpf_enable_stats>:
; {
   28750: f3 0f 1e fa                  	endbr64
   28754: 41 55                        	pushq	%r13
; 	return syscall(__NR_bpf, cmd, attr, size);
   28756: b9 04 00 00 00               	movl	$4, %ecx
   2875b: be 20 00 00 00               	movl	$32, %esi
; {
   28760: 41 54                        	pushq	%r12
   28762: 55                           	pushq	%rbp
   28763: 53                           	pushq	%rbx
   28764: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   2876b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   28774: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2877c: 31 c0                        	xorl	%eax, %eax
; 	return syscall(__NR_bpf, cmd, attr, size);
   2877e: 48 89 e2                     	movq	%rsp, %rdx
; 	attr.enable_stats.type = type;
   28781: 89 3c 24                     	movl	%edi, (%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   28784: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   28789: e8 52 d2 fd ff               	callq	0x59e0 <.plt.sec+0x370>
; 	if (fd < 0)
   2878e: 85 c0                        	testl	%eax, %eax
   28790: 78 6e                        	js	0x28800 <bpf_enable_stats+0xb0>
   28792: 41 89 c4                     	movl	%eax, %r12d
; 	if (fd < 3) {
   28795: 83 f8 02                     	cmpl	$2, %eax
   28798: 7e 2e                        	jle	0x287c8 <bpf_enable_stats+0x78>
; }
   2879a: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   287a2: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   287ab: 0f 85 85 00 00 00            	jne	0x28836 <bpf_enable_stats+0xe6>
   287b1: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   287b8: 44 89 e0                     	movl	%r12d, %eax
   287bb: 5b                           	popq	%rbx
   287bc: 5d                           	popq	%rbp
   287bd: 41 5c                        	popq	%r12
   287bf: 41 5d                        	popq	%r13
   287c1: c3                           	retq
   287c2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
   287c8: 89 c7                        	movl	%eax, %edi
   287ca: ba 03 00 00 00               	movl	$3, %edx
   287cf: be 06 04 00 00               	movl	$1030, %esi             # imm = 0x406
   287d4: 31 c0                        	xorl	%eax, %eax
   287d6: e8 95 d3 fd ff               	callq	0x5b70 <.plt.sec+0x500>
   287db: 89 c3                        	movl	%eax, %ebx
; 		saved_errno = errno;
   287dd: e8 0e cf fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		close(old_fd);
   287e2: 44 89 e7                     	movl	%r12d, %edi
; 		saved_errno = errno;
   287e5: 44 8b 28                     	movl	(%rax), %r13d
   287e8: 48 89 c5                     	movq	%rax, %rbp
; 		close(old_fd);
   287eb: e8 10 d1 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 		if (fd < 0) {
   287f0: 85 db                        	testl	%ebx, %ebx
   287f2: 78 1c                        	js	0x28810 <bpf_enable_stats+0xc0>
   287f4: 41 89 dc                     	movl	%ebx, %r12d
; 	return libbpf_err_errno(fd);
   287f7: eb a1                        	jmp	0x2879a <bpf_enable_stats+0x4a>
   287f9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		saved_errno = errno;
   28800: e8 eb ce fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return ret < 0 ? -errno : ret;
   28805: 44 8b 20                     	movl	(%rax), %r12d
   28808: 41 f7 dc                     	negl	%r12d
; static inline int libbpf_err_errno(int ret)
   2880b: eb 8d                        	jmp	0x2879a <bpf_enable_stats+0x4a>
   2880d: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   28810: 44 89 eb                     	movl	%r13d, %ebx
   28813: 44 89 e2                     	movl	%r12d, %edx
   28816: 48 8d 35 ab 27 01 00         	leaq	75691(%rip), %rsi       # 0x3afc8 <CSWTCH.126+0x16c8>
   2881d: 31 ff                        	xorl	%edi, %edi
   2881f: f7 db                        	negl	%ebx
   28821: 31 c0                        	xorl	%eax, %eax
   28823: 89 d9                        	movl	%ebx, %ecx
; 			errno = saved_errno;
   28825: 41 89 dc                     	movl	%ebx, %r12d
; 			pr_warn("failed to dup FD %d to FD > 2: %d\n", old_fd, -saved_errno);
   28828: e8 a3 f8 fd ff               	callq	0x80d0 <libbpf_print>
; 			errno = saved_errno;
   2882d: 44 89 6d 00                  	movl	%r13d, (%rbp)
   28831: e9 64 ff ff ff               	jmp	0x2879a <bpf_enable_stats+0x4a>
; }
   28836: e8 c5 cf fd ff               	callq	0x5800 <.plt.sec+0x190>
   2883b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000028840 <bpf_prog_bind_map>:
; {
   28840: f3 0f 1e fa                  	endbr64
   28844: 48 81 ec a8 00 00 00         	subq	$168, %rsp
   2884b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   28854: 48 89 84 24 98 00 00 00      	movq	%rax, 152(%rsp)
   2885c: 31 c0                        	xorl	%eax, %eax
; 	if (!OPTS_VALID(opts, bpf_prog_bind_opts))
   2885e: 48 85 d2                     	testq	%rdx, %rdx
   28861: 0f 84 c9 00 00 00            	je	0x28930 <bpf_prog_bind_map+0xf0>
   28867: 4c 8b 02                     	movq	(%rdx), %r8
; 	if (user_sz < sizeof(size_t)) {
   2886a: 49 83 f8 07                  	cmpq	$7, %r8
   2886e: 0f 86 cc 00 00 00            	jbe	0x28940 <bpf_prog_bind_map+0x100>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   28874: 49 8d 48 f4                  	leaq	-12(%r8), %rcx
   28878: 48 8d 42 0c                  	leaq	12(%rdx), %rax
; 	while (len > 0) {
   2887c: 48 85 c9                     	testq	%rcx, %rcx
   2887f: 7e 4f                        	jle	0x288d0 <bpf_prog_bind_map+0x90>
   28881: 4a 8d 0c 02                  	leaq	(%rdx,%r8), %rcx
   28885: eb 12                        	jmp	0x28899 <bpf_prog_bind_map+0x59>
   28887: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		p++;
   28890: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   28894: 48 39 c1                     	cmpq	%rax, %rcx
   28897: 74 37                        	je	0x288d0 <bpf_prog_bind_map+0x90>
; 		if (*p)
   28899: 80 38 00                     	cmpb	$0, (%rax)
   2889c: 74 f2                        	je	0x28890 <bpf_prog_bind_map+0x50>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   2889e: 48 8d 15 0f 27 01 00         	leaq	75535(%rip), %rdx       # 0x3afb4 <CSWTCH.126+0x16b4>
   288a5: 48 8d 35 64 b7 00 00         	leaq	46948(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   288ac: 31 ff                        	xorl	%edi, %edi
   288ae: 31 c0                        	xorl	%eax, %eax
   288b0: e8 1b f8 fd ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   288b5: e8 36 ce fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   288ba: 41 b8 ea ff ff ff            	movl	$4294967274, %r8d       # imm = 0xFFFFFFEA
; 		errno = -ret;
   288c0: c7 00 16 00 00 00            	movl	$22, (%rax)
   288c6: eb 49                        	jmp	0x28911 <bpf_prog_bind_map+0xd1>
   288c8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	attr.prog_bind_map.prog_fd = prog_fd;
   288d0: 89 3c 24                     	movl	%edi, (%rsp)
; 	attr.prog_bind_map.flags = OPTS_GET(opts, flags, 0);
   288d3: 31 c0                        	xorl	%eax, %eax
; 	attr.prog_bind_map.map_fd = map_fd;
   288d5: 89 74 24 04                  	movl	%esi, 4(%rsp)
; 	attr.prog_bind_map.flags = OPTS_GET(opts, flags, 0);
   288d9: 49 83 f8 0b                  	cmpq	$11, %r8
   288dd: 76 03                        	jbe	0x288e2 <bpf_prog_bind_map+0xa2>
   288df: 8b 42 08                     	movl	8(%rdx), %eax
   288e2: 89 44 24 08                  	movl	%eax, 8(%rsp)
; 	return syscall(__NR_bpf, cmd, attr, size);
   288e6: 48 89 e2                     	movq	%rsp, %rdx
   288e9: b9 0c 00 00 00               	movl	$12, %ecx
   288ee: 31 c0                        	xorl	%eax, %eax
   288f0: be 23 00 00 00               	movl	$35, %esi
   288f5: bf 41 01 00 00               	movl	$321, %edi              # imm = 0x141
   288fa: e8 e1 d0 fd ff               	callq	0x59e0 <.plt.sec+0x370>
   288ff: 41 89 c0                     	movl	%eax, %r8d
; 	return ret < 0 ? -errno : ret;
   28902: 85 c0                        	testl	%eax, %eax
   28904: 79 0b                        	jns	0x28911 <bpf_prog_bind_map+0xd1>
   28906: e8 e5 cd fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2890b: 44 8b 00                     	movl	(%rax), %r8d
   2890e: 41 f7 d8                     	negl	%r8d
; }
   28911: 48 8b 84 24 98 00 00 00      	movq	152(%rsp), %rax
   28919: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   28922: 75 39                        	jne	0x2895d <bpf_prog_bind_map+0x11d>
   28924: 44 89 c0                     	movl	%r8d, %eax
   28927: 48 81 c4 a8 00 00 00         	addq	$168, %rsp
   2892e: c3                           	retq
   2892f: 90                           	nop
; 	attr.prog_bind_map.prog_fd = prog_fd;
   28930: 89 3c 24                     	movl	%edi, (%rsp)
; 	attr.prog_bind_map.flags = OPTS_GET(opts, flags, 0);
   28933: 31 c0                        	xorl	%eax, %eax
; 	attr.prog_bind_map.map_fd = map_fd;
   28935: 89 74 24 04                  	movl	%esi, 4(%rsp)
; 	attr.prog_bind_map.flags = OPTS_GET(opts, flags, 0);
   28939: eb a7                        	jmp	0x288e2 <bpf_prog_bind_map+0xa2>
   2893b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   28940: 4c 89 c1                     	movq	%r8, %rcx
   28943: 48 8d 15 6a 26 01 00         	leaq	75370(%rip), %rdx       # 0x3afb4 <CSWTCH.126+0x16b4>
   2894a: 48 8d 35 67 b6 00 00         	leaq	46695(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   28951: 31 ff                        	xorl	%edi, %edi
   28953: e8 78 f7 fd ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   28958: e9 58 ff ff ff               	jmp	0x288b5 <bpf_prog_bind_map+0x75>
; }
   2895d: e8 9e ce fd ff               	callq	0x5800 <.plt.sec+0x190>
   28962: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   2896c: 0f 1f 40 00                  	nopl	(%rax)

0000000000028970 <btf_rewrite_type_ids>:
; {
   28970: f3 0f 1e fa                  	endbr64
; 	if (!*type_id) /* nothing to do for VOID references */
   28974: 8b 07                        	movl	(%rdi), %eax
   28976: 85 c0                        	testl	%eax, %eax
   28978: 74 0c                        	je	0x28986 <btf_rewrite_type_ids+0x16>
; 	*type_id += btf->start_id + btf->nr_types - 1;
   2897a: 8b 56 40                     	movl	64(%rsi), %edx
   2897d: 8d 44 10 ff                  	leal	-1(%rax,%rdx), %eax
   28981: 03 46 50                     	addl	80(%rsi), %eax
   28984: 89 07                        	movl	%eax, (%rdi)
; }
   28986: 31 c0                        	xorl	%eax, %eax
   28988: c3                           	retq
   28989: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000028990 <btf_dedup_identity_hash_fn>:
; {
   28990: f3 0f 1e fa                  	endbr64
   28994: 48 89 f8                     	movq	%rdi, %rax
; }
   28997: c3                           	retq
   28998: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

00000000000289a0 <btf_dedup_collision_hash_fn>:
; {
   289a0: f3 0f 1e fa                  	endbr64
; }
   289a4: 31 c0                        	xorl	%eax, %eax
   289a6: c3                           	retq
   289a7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

00000000000289b0 <btf_dedup_equal_fn>:
; {
   289b0: f3 0f 1e fa                  	endbr64
; 	return k1 == k2;
   289b4: 48 39 fe                     	cmpq	%rdi, %rsi
   289b7: 0f 94 c0                     	sete	%al
; }
   289ba: c3                           	retq
   289bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)

00000000000289c0 <btf_hash_struct>:
; 	h = hash_combine(0, t->name_off);
   289c0: 8b 07                        	movl	(%rdi), %eax
; 	return BTF_INFO_VLEN(t->info);
   289c2: 8b 77 04                     	movl	4(%rdi), %esi
; 	return (struct btf_member *)(t + 1);
   289c5: 48 8d 57 0c                  	leaq	12(%rdi), %rdx
; 	return h * 31 + value;
   289c9: 48 89 c1                     	movq	%rax, %rcx
   289cc: 48 c1 e1 05                  	shlq	$5, %rcx
   289d0: 48 29 c1                     	subq	%rax, %rcx
; 	h = hash_combine(h, t->info);
   289d3: 89 f0                        	movl	%esi, %eax
; 	return h * 31 + value;
   289d5: 48 01 c1                     	addq	%rax, %rcx
   289d8: 48 89 c8                     	movq	%rcx, %rax
   289db: 48 c1 e0 05                  	shlq	$5, %rax
   289df: 48 29 c8                     	subq	%rcx, %rax
; 	h = hash_combine(h, t->size);
   289e2: 8b 4f 08                     	movl	8(%rdi), %ecx
; 	return h * 31 + value;
   289e5: 48 01 c8                     	addq	%rcx, %rax
; 	for (i = 0; i < vlen; i++) {
   289e8: 81 e6 ff ff 00 00            	andl	$65535, %esi            # imm = 0xFFFF
   289ee: 74 38                        	je	0x28a28 <btf_hash_struct+0x68>
   289f0: 8d 4e ff                     	leal	-1(%rsi), %ecx
   289f3: 48 8d 0c 49                  	leaq	(%rcx,%rcx,2), %rcx
   289f7: 48 8d 7c 8f 18               	leaq	24(%rdi,%rcx,4), %rdi
   289fc: 0f 1f 40 00                  	nopl	(%rax)
; 	return h * 31 + value;
   28a00: 48 89 c6                     	movq	%rax, %rsi
; 		h = hash_combine(h, member->name_off);
   28a03: 8b 0a                        	movl	(%rdx), %ecx
; 		member++;
   28a05: 48 83 c2 0c                  	addq	$12, %rdx
; 	return h * 31 + value;
   28a09: 48 c1 e6 05                  	shlq	$5, %rsi
   28a0d: 48 29 c6                     	subq	%rax, %rsi
   28a10: 48 01 f1                     	addq	%rsi, %rcx
   28a13: 48 89 c8                     	movq	%rcx, %rax
   28a16: 48 c1 e0 05                  	shlq	$5, %rax
   28a1a: 48 29 c8                     	subq	%rcx, %rax
; 		h = hash_combine(h, member->offset);
   28a1d: 8b 4a fc                     	movl	-4(%rdx), %ecx
; 	return h * 31 + value;
   28a20: 48 01 c8                     	addq	%rcx, %rax
; 	for (i = 0; i < vlen; i++) {
   28a23: 48 39 fa                     	cmpq	%rdi, %rdx
   28a26: 75 d8                        	jne	0x28a00 <btf_hash_struct+0x40>
; }
   28a28: c3                           	retq
   28a29: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000028a30 <btf_hash_fnproto>:
; 	h = hash_combine(0, t->name_off);
   28a30: 8b 07                        	movl	(%rdi), %eax
; 	return BTF_INFO_VLEN(t->info);
   28a32: 8b 77 04                     	movl	4(%rdi), %esi
; 	return (struct btf_param *)(t + 1);
   28a35: 48 8d 57 0c                  	leaq	12(%rdi), %rdx
; 	return h * 31 + value;
   28a39: 48 89 c1                     	movq	%rax, %rcx
   28a3c: 48 c1 e1 05                  	shlq	$5, %rcx
   28a40: 48 29 c1                     	subq	%rax, %rcx
; 	h = hash_combine(h, t->info);
   28a43: 89 f0                        	movl	%esi, %eax
; 	return h * 31 + value;
   28a45: 48 01 c1                     	addq	%rax, %rcx
   28a48: 48 89 c8                     	movq	%rcx, %rax
   28a4b: 48 c1 e0 05                  	shlq	$5, %rax
   28a4f: 48 29 c8                     	subq	%rcx, %rax
; 	h = hash_combine(h, t->size);
   28a52: 8b 4f 08                     	movl	8(%rdi), %ecx
; 	return h * 31 + value;
   28a55: 48 01 c8                     	addq	%rcx, %rax
; 	for (i = 0; i < vlen; i++) {
   28a58: 81 e6 ff ff 00 00            	andl	$65535, %esi            # imm = 0xFFFF
   28a5e: 74 38                        	je	0x28a98 <btf_hash_fnproto+0x68>
   28a60: 8d 4e ff                     	leal	-1(%rsi), %ecx
   28a63: 48 8d 7c cf 14               	leaq	20(%rdi,%rcx,8), %rdi
   28a68: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	return h * 31 + value;
   28a70: 48 89 c6                     	movq	%rax, %rsi
; 		h = hash_combine(h, member->name_off);
   28a73: 8b 0a                        	movl	(%rdx), %ecx
; 		member++;
   28a75: 48 83 c2 08                  	addq	$8, %rdx
; 	return h * 31 + value;
   28a79: 48 c1 e6 05                  	shlq	$5, %rsi
   28a7d: 48 29 c6                     	subq	%rax, %rsi
   28a80: 48 01 f1                     	addq	%rsi, %rcx
   28a83: 48 89 c8                     	movq	%rcx, %rax
   28a86: 48 c1 e0 05                  	shlq	$5, %rax
   28a8a: 48 29 c8                     	subq	%rcx, %rax
; 		h = hash_combine(h, member->type);
   28a8d: 8b 4a fc                     	movl	-4(%rdx), %ecx
; 	return h * 31 + value;
   28a90: 48 01 c8                     	addq	%rcx, %rax
; 	for (i = 0; i < vlen; i++) {
   28a93: 48 39 fa                     	cmpq	%rdi, %rdx
   28a96: 75 d8                        	jne	0x28a70 <btf_hash_fnproto+0x40>
; }
   28a98: c3                           	retq
   28a99: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000028aa0 <btf_dedup_remap_type_id>:
; {
   28aa0: f3 0f 1e fa                  	endbr64
; 	resolved_type_id = resolve_type_id(d, *type_id);
   28aa4: 8b 07                        	movl	(%rdi), %eax
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   28aa6: 4c 8b 4e 18                  	movq	24(%rsi), %r9
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   28aaa: eb 08                        	jmp	0x28ab4 <btf_dedup_remap_type_id+0x14>
   28aac: 0f 1f 40 00                  	nopl	(%rax)
   28ab0: 85 c0                        	testl	%eax, %eax
   28ab2: 78 14                        	js	0x28ac8 <btf_dedup_remap_type_id+0x28>
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   28ab4: 89 c2                        	movl	%eax, %edx
   28ab6: 89 c1                        	movl	%eax, %ecx
   28ab8: 41 8b 04 91                  	movl	(%r9,%rdx,4), %eax
   28abc: 4c 8d 04 95 00 00 00 00      	leaq	(,%rdx,4), %r8
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   28ac4: 39 c1                        	cmpl	%eax, %ecx
   28ac6: 75 e8                        	jne	0x28ab0 <btf_dedup_remap_type_id+0x10>
; 	new_type_id = d->hypot_map[resolved_type_id];
   28ac8: 48 8b 46 20                  	movq	32(%rsi), %rax
   28acc: 42 8b 04 00                  	movl	(%rax,%r8), %eax
; 	if (new_type_id > BTF_MAX_NR_TYPES)
   28ad0: 85 c0                        	testl	%eax, %eax
   28ad2: 78 05                        	js	0x28ad9 <btf_dedup_remap_type_id+0x39>
; 	*type_id = new_type_id;
   28ad4: 89 07                        	movl	%eax, (%rdi)
; 	return 0;
   28ad6: 31 c0                        	xorl	%eax, %eax
   28ad8: c3                           	retq
; 		return -EINVAL;
   28ad9: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   28ade: c3                           	retq
   28adf: 90                           	nop

0000000000028ae0 <btf_ext_setup_info>:
; 	if (ext_sec->len == 0)
   28ae0: 44 8b 5e 04                  	movl	4(%rsi), %r11d
; 		return 0;
   28ae4: 31 c0                        	xorl	%eax, %eax
; 	if (ext_sec->len == 0)
   28ae6: 45 85 db                     	testl	%r11d, %r11d
   28ae9: 0f 84 b1 00 00 00            	je	0x28ba0 <btf_ext_setup_info+0xc0>
; {
   28aef: 41 54                        	pushq	%r12
; 	if (ext_sec->off & 0x03) {
   28af1: 44 8b 0e                     	movl	(%rsi), %r9d
   28af4: 49 89 f2                     	movq	%rsi, %r10
   28af7: 41 f6 c1 03                  	testb	$3, %r9b
   28afb: 0f 85 0f 01 00 00            	jne	0x28c10 <btf_ext_setup_info+0x130>
; 	info = btf_ext->data + btf_ext->hdr->hdr_len + ext_sec->off;
   28b01: 48 8b 17                     	movq	(%rdi), %rdx
   28b04: 44 89 c9                     	movl	%r9d, %ecx
   28b07: 8b 42 04                     	movl	4(%rdx), %eax
   28b0a: 48 01 c8                     	addq	%rcx, %rax
; 	if (btf_ext->data + btf_ext->data_size < info + ext_sec->len) {
   28b0d: 8b 4f 68                     	movl	104(%rdi), %ecx
; 	info = btf_ext->data + btf_ext->hdr->hdr_len + ext_sec->off;
   28b10: 48 01 d0                     	addq	%rdx, %rax
; 	if (btf_ext->data + btf_ext->data_size < info + ext_sec->len) {
   28b13: 48 01 ca                     	addq	%rcx, %rdx
   28b16: 44 89 d9                     	movl	%r11d, %ecx
   28b19: 48 01 c1                     	addq	%rax, %rcx
   28b1c: 48 39 ca                     	cmpq	%rcx, %rdx
   28b1f: 0f 82 49 01 00 00            	jb	0x28c6e <btf_ext_setup_info+0x18e>
; 	if (info_left < sizeof(__u32)) {
   28b25: 41 83 fb 03                  	cmpl	$3, %r11d
   28b29: 0f 86 1e 01 00 00            	jbe	0x28c4d <btf_ext_setup_info+0x16d>
; 	record_size = *(__u32 *)info;
   28b2f: 44 8b 20                     	movl	(%rax), %r12d
; 	if (record_size < ext_sec->min_rec_size ||
   28b32: 44 39 66 08                  	cmpl	%r12d, 8(%rsi)
   28b36: 0f 87 b3 00 00 00            	ja	0x28bef <btf_ext_setup_info+0x10f>
   28b3c: 41 f6 c4 03                  	testb	$3, %r12b
   28b40: 0f 85 a9 00 00 00            	jne	0x28bef <btf_ext_setup_info+0x10f>
; 	sinfo = info + sizeof(__u32);
   28b46: 4c 8d 48 04                  	leaq	4(%rax), %r9
; 	if (!info_left) {
   28b4a: 41 83 eb 04                  	subl	$4, %r11d
   28b4e: 0f 84 d8 00 00 00            	je	0x28c2c <btf_ext_setup_info+0x14c>
   28b54: 44 89 da                     	movl	%r11d, %edx
; 	sinfo = info + sizeof(__u32);
   28b57: 4c 89 c9                     	movq	%r9, %rcx
; 	size_t sec_cnt = 0;
   28b5a: 31 f6                        	xorl	%esi, %esi
; 		total_record_size = sec_hdrlen + (__u64)num_records * record_size;
   28b5c: 45 89 e0                     	movl	%r12d, %r8d
   28b5f: 90                           	nop
; 		if (info_left < sec_hdrlen) {
   28b60: 83 fa 07                     	cmpl	$7, %edx
   28b63: 76 6b                        	jbe	0x28bd0 <btf_ext_setup_info+0xf0>
; 		num_records = sinfo->num_info;
   28b65: 8b 41 04                     	movl	4(%rcx), %eax
; 		if (num_records == 0) {
   28b68: 85 c0                        	testl	%eax, %eax
   28b6a: 74 3c                        	je	0x28ba8 <btf_ext_setup_info+0xc8>
; 		total_record_size = sec_hdrlen + (__u64)num_records * record_size;
   28b6c: 49 0f af c0                  	imulq	%r8, %rax
; 		if (info_left < total_record_size) {
   28b70: 89 d7                        	movl	%edx, %edi
; 		total_record_size = sec_hdrlen + (__u64)num_records * record_size;
   28b72: 48 83 c0 08                  	addq	$8, %rax
; 		if (info_left < total_record_size) {
   28b76: 48 39 c7                     	cmpq	%rax, %rdi
   28b79: 72 2d                        	jb	0x28ba8 <btf_ext_setup_info+0xc8>
; 		sinfo = (void *)sinfo + total_record_size;
   28b7b: 48 01 c1                     	addq	%rax, %rcx
; 		sec_cnt++;
   28b7e: 48 83 c6 01                  	addq	$1, %rsi
; 	while (info_left) {
   28b82: 29 c2                        	subl	%eax, %edx
   28b84: 75 da                        	jne	0x28b60 <btf_ext_setup_info+0x80>
; 	ext_info = ext_sec->ext_info;
   28b86: 49 8b 42 10                  	movq	16(%r10), %rax
; 	ext_info->len = ext_sec->len - sizeof(__u32);
   28b8a: 44 89 58 0c                  	movl	%r11d, 12(%rax)
; 	ext_info->rec_size = record_size;
   28b8e: 44 89 60 08                  	movl	%r12d, 8(%rax)
; 	ext_info->info = info + sizeof(__u32);
   28b92: 4c 89 08                     	movq	%r9, (%rax)
; 	ext_info->sec_cnt = sec_cnt;
   28b95: 89 70 18                     	movl	%esi, 24(%rax)
; 	return 0;
   28b98: 31 c0                        	xorl	%eax, %eax
; }
   28b9a: 41 5c                        	popq	%r12
   28b9c: c3                           	retq
   28b9d: 0f 1f 00                     	nopl	(%rax)
   28ba0: c3                           	retq
   28ba1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			pr_debug("%s section has incorrect num_records in .BTF.ext\n",
   28ba8: 49 8b 52 18                  	movq	24(%r10), %rdx
   28bac: 31 c0                        	xorl	%eax, %eax
   28bae: bf 02 00 00 00               	movl	$2, %edi
   28bb3: 48 8d 35 a6 25 01 00         	leaq	75174(%rip), %rsi       # 0x3b160 <CSWTCH.126+0x1860>
   28bba: e8 11 f5 fd ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   28bbf: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   28bc4: 41 5c                        	popq	%r12
   28bc6: c3                           	retq
   28bc7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 			pr_debug("%s section header is not found in .BTF.ext\n",
   28bd0: 49 8b 52 18                  	movq	24(%r10), %rdx
   28bd4: 31 c0                        	xorl	%eax, %eax
   28bd6: bf 02 00 00 00               	movl	$2, %edi
   28bdb: 48 8d 35 46 25 01 00         	leaq	75078(%rip), %rsi       # 0x3b128 <CSWTCH.126+0x1828>
   28be2: e8 e9 f4 fd ff               	callq	0x80d0 <libbpf_print>
; 			return -EINVAL;
   28be7: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   28bec: 41 5c                        	popq	%r12
   28bee: c3                           	retq
; 		pr_debug("%s section in .BTF.ext has invalid record size %u\n",
   28bef: 49 8b 52 18                  	movq	24(%r10), %rdx
   28bf3: 31 c0                        	xorl	%eax, %eax
   28bf5: 44 89 e1                     	movl	%r12d, %ecx
   28bf8: 48 8d 35 b9 24 01 00         	leaq	74937(%rip), %rsi       # 0x3b0b8 <CSWTCH.126+0x17b8>
   28bff: bf 02 00 00 00               	movl	$2, %edi
   28c04: e8 c7 f4 fd ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   28c09: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   28c0e: eb b4                        	jmp	0x28bc4 <btf_ext_setup_info+0xe4>
; 		pr_debug(".BTF.ext %s section is not aligned to 4 bytes\n",
   28c10: 48 8b 56 18                  	movq	24(%rsi), %rdx
   28c14: bf 02 00 00 00               	movl	$2, %edi
   28c19: 48 8d 35 d8 23 01 00         	leaq	74712(%rip), %rsi       # 0x3aff8 <CSWTCH.126+0x16f8>
   28c20: e8 ab f4 fd ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   28c25: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   28c2a: eb 98                        	jmp	0x28bc4 <btf_ext_setup_info+0xe4>
; 		pr_debug("%s section in .BTF.ext has no records", ext_sec->desc);
   28c2c: 48 8b 56 18                  	movq	24(%rsi), %rdx
   28c30: 31 c0                        	xorl	%eax, %eax
   28c32: bf 02 00 00 00               	movl	$2, %edi
   28c37: 48 8d 35 ba 24 01 00         	leaq	74938(%rip), %rsi       # 0x3b0f8 <CSWTCH.126+0x17f8>
   28c3e: e8 8d f4 fd ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   28c43: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   28c48: e9 77 ff ff ff               	jmp	0x28bc4 <btf_ext_setup_info+0xe4>
; 		pr_debug(".BTF.ext %s record size not found\n", ext_sec->desc);
   28c4d: 48 8b 56 18                  	movq	24(%rsi), %rdx
   28c51: 31 c0                        	xorl	%eax, %eax
   28c53: bf 02 00 00 00               	movl	$2, %edi
   28c58: 48 8d 35 29 24 01 00         	leaq	74793(%rip), %rsi       # 0x3b088 <CSWTCH.126+0x1788>
   28c5f: e8 6c f4 fd ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   28c64: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   28c69: e9 56 ff ff ff               	jmp	0x28bc4 <btf_ext_setup_info+0xe4>
; 		pr_debug("%s section (off:%u len:%u) is beyond the end of the ELF section .BTF.ext\n",
   28c6e: 48 8b 56 18                  	movq	24(%rsi), %rdx
   28c72: 31 c0                        	xorl	%eax, %eax
   28c74: 45 89 d8                     	movl	%r11d, %r8d
   28c77: 44 89 c9                     	movl	%r9d, %ecx
   28c7a: 48 8d 35 af 23 01 00         	leaq	74671(%rip), %rsi       # 0x3b030 <CSWTCH.126+0x1730>
   28c81: bf 02 00 00 00               	movl	$2, %edi
   28c86: e8 45 f4 fd ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   28c8b: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   28c90: e9 2f ff ff ff               	jmp	0x28bc4 <btf_ext_setup_info+0xe4>
   28c95: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

0000000000028ca0 <btf_new_empty>:
; {
   28ca0: 41 54                        	pushq	%r12
; 	btf = calloc(1, sizeof(*btf));
   28ca2: be 78 00 00 00               	movl	$120, %esi
; {
   28ca7: 53                           	pushq	%rbx
   28ca8: 48 89 fb                     	movq	%rdi, %rbx
; 	btf = calloc(1, sizeof(*btf));
   28cab: bf 01 00 00 00               	movl	$1, %edi
; {
   28cb0: 48 83 ec 08                  	subq	$8, %rsp
; 	btf = calloc(1, sizeof(*btf));
   28cb4: e8 d7 cc fd ff               	callq	0x5990 <.plt.sec+0x320>
; 	if (!btf)
   28cb9: 48 85 c0                     	testq	%rax, %rax
   28cbc: 0f 84 b2 00 00 00            	je	0x28d74 <btf_new_empty+0xd4>
; 	btf->start_id = 1;
   28cc2: 48 c7 40 50 01 00 00 00      	movq	$1, 80(%rax)
   28cca: 49 89 c4                     	movq	%rax, %r12
; 	btf->fd = -1;
   28ccd: 48 b8 ff ff ff ff 08 00 00 00	movabsq	$38654705663, %rax      # imm = 0x8FFFFFFFF
   28cd7: 49 89 44 24 6c               	movq	%rax, 108(%r12)
; 	btf->swapped_endian = false;
   28cdc: 41 c6 44 24 14 00            	movb	$0, 20(%r12)
; 	if (base_btf) {
   28ce2: 48 85 db                     	testq	%rbx, %rbx
   28ce5: 0f 84 7d 00 00 00            	je	0x28d68 <btf_new_empty+0xc8>
; 	return btf->start_id + btf->nr_types;
   28ceb: 8b 43 40                     	movl	64(%rbx), %eax
   28cee: 03 43 50                     	addl	80(%rbx), %eax
; 		btf->base_btf = base_btf;
   28cf1: 49 89 5c 24 48               	movq	%rbx, 72(%r12)
; 		btf->start_str_off = base_btf->hdr->str_len;
   28cf6: be 18 00 00 00               	movl	$24, %esi
; 		btf->start_id = btf__type_cnt(base_btf);
   28cfb: 41 89 44 24 50               	movl	%eax, 80(%r12)
; 		btf->start_str_off = base_btf->hdr->str_len;
   28d00: 48 8b 43 18                  	movq	24(%rbx), %rax
   28d04: 8b 40 14                     	movl	20(%rax), %eax
   28d07: 41 89 44 24 54               	movl	%eax, 84(%r12)
; 	btf->raw_size = sizeof(struct btf_header) + (base_btf ? 0 : 1);
   28d0c: b8 18 00 00 00               	movl	$24, %eax
   28d11: 41 89 44 24 10               	movl	%eax, 16(%r12)
; 	btf->raw_data = calloc(1, btf->raw_size);
   28d16: bf 01 00 00 00               	movl	$1, %edi
   28d1b: e8 70 cc fd ff               	callq	0x5990 <.plt.sec+0x320>
   28d20: 49 89 04 24                  	movq	%rax, (%r12)
; 	if (!btf->raw_data) {
   28d24: 48 85 c0                     	testq	%rax, %rax
   28d27: 74 54                        	je	0x28d7d <btf_new_empty+0xdd>
; 	btf->hdr->magic = BTF_MAGIC;
   28d29: ba 9f eb ff ff               	movl	$4294962079, %edx       # imm = 0xFFFFEB9F
; 	btf->hdr = btf->raw_data;
   28d2e: 49 89 44 24 18               	movq	%rax, 24(%r12)
; 	btf->hdr->magic = BTF_MAGIC;
   28d33: 66 89 10                     	movw	%dx, (%rax)
; 	btf->types_data = btf->raw_data + btf->hdr->hdr_len;
   28d36: 48 8d 50 18                  	leaq	24(%rax), %rdx
   28d3a: 49 89 54 24 20               	movq	%rdx, 32(%r12)
; 	btf->strs_data = btf->raw_data + btf->hdr->hdr_len;
   28d3f: 49 89 54 24 58               	movq	%rdx, 88(%r12)
; 	btf->hdr->str_len = base_btf ? 0 : 1; /* empty string at offset 0 */
   28d44: 31 d2                        	xorl	%edx, %edx
   28d46: 48 85 db                     	testq	%rbx, %rbx
   28d49: 0f 94 c2                     	sete	%dl
; 	btf->hdr->hdr_len = sizeof(struct btf_header);
   28d4c: c7 40 04 18 00 00 00         	movl	$24, 4(%rax)
; 	btf->hdr->version = BTF_VERSION;
   28d53: c6 40 02 01                  	movb	$1, 2(%rax)
; 	btf->hdr->str_len = base_btf ? 0 : 1; /* empty string at offset 0 */
   28d57: 89 50 14                     	movl	%edx, 20(%rax)
; }
   28d5a: 48 83 c4 08                  	addq	$8, %rsp
   28d5e: 4c 89 e0                     	movq	%r12, %rax
   28d61: 5b                           	popq	%rbx
   28d62: 41 5c                        	popq	%r12
   28d64: c3                           	retq
   28d65: 0f 1f 00                     	nopl	(%rax)
   28d68: be 19 00 00 00               	movl	$25, %esi
; 	btf->raw_size = sizeof(struct btf_header) + (base_btf ? 0 : 1);
   28d6d: b8 19 00 00 00               	movl	$25, %eax
   28d72: eb 9d                        	jmp	0x28d11 <btf_new_empty+0x71>
; 		return ERR_PTR(-ENOMEM);
   28d74: 49 c7 c4 f4 ff ff ff         	movq	$-12, %r12
   28d7b: eb dd                        	jmp	0x28d5a <btf_new_empty+0xba>
; 		free(btf);
   28d7d: 4c 89 e7                     	movq	%r12, %rdi
; 		return ERR_PTR(-ENOMEM);
   28d80: 49 c7 c4 f4 ff ff ff         	movq	$-12, %r12
; 		free(btf);
   28d87: e8 34 c9 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 		return ERR_PTR(-ENOMEM);
   28d8c: eb cc                        	jmp	0x28d5a <btf_new_empty+0xba>
   28d8e: 66 90                        	nop

0000000000028d90 <btf_bswap_type_rest>:
; 	return BTF_INFO_VLEN(t->info);
   28d90: 8b 77 04                     	movl	4(%rdi), %esi
; 	return BTF_INFO_KIND(t->info);
   28d93: 89 f2                        	movl	%esi, %edx
   28d95: c1 ea 18                     	shrl	$24, %edx
   28d98: 83 e2 1f                     	andl	$31, %edx
; 	switch (btf_kind(t)) {
   28d9b: 66 83 fa 13                  	cmpw	$19, %dx
   28d9f: 0f 87 88 01 00 00            	ja	0x28f2d <btf_bswap_type_rest+0x19d>
   28da5: 48 89 f9                     	movq	%rdi, %rcx
   28da8: 0f b7 c2                     	movzwl	%dx, %eax
   28dab: 48 8d 3d b6 2b 01 00         	leaq	76726(%rip), %rdi       # 0x3b968 <CSWTCH.126+0x2068>
   28db2: 48 63 04 87                  	movslq	(%rdi,%rax,4), %rax
   28db6: 48 01 f8                     	addq	%rdi, %rax
   28db9: 3e ff e0                     	jmpq	*%rax
   28dbc: 0f 1f 40 00                  	nopl	(%rax)
; 	return (struct btf_enum *)(t + 1);
   28dc0: 48 8d 41 0c                  	leaq	12(%rcx), %rax
; 		for (i = 0, e = btf_enum(t); i < vlen; i++, e++) {
   28dc4: 81 e6 ff ff 00 00            	andl	$65535, %esi            # imm = 0xFFFF
   28dca: 74 24                        	je	0x28df0 <btf_bswap_type_rest+0x60>
   28dcc: 8d 56 ff                     	leal	-1(%rsi), %edx
   28dcf: 48 8d 4c d1 14               	leaq	20(%rcx,%rdx,8), %rcx
   28dd4: 0f 1f 40 00                  	nopl	(%rax)
;   return __builtin_bswap32 (__bsx);
   28dd8: 8b 10                        	movl	(%rax), %edx
; 		for (i = 0, e = btf_enum(t); i < vlen; i++, e++) {
   28dda: 48 83 c0 08                  	addq	$8, %rax
;   return __builtin_bswap32 (__bsx);
   28dde: 0f ca                        	bswapl	%edx
; 			e->name_off = bswap_32(e->name_off);
   28de0: 89 50 f8                     	movl	%edx, -8(%rax)
;   return __builtin_bswap32 (__bsx);
   28de3: 8b 50 fc                     	movl	-4(%rax), %edx
   28de6: 0f ca                        	bswapl	%edx
; 			e->val = bswap_32(e->val);
   28de8: 89 50 fc                     	movl	%edx, -4(%rax)
; 		for (i = 0, e = btf_enum(t); i < vlen; i++, e++) {
   28deb: 48 39 c1                     	cmpq	%rax, %rcx
   28dee: 75 e8                        	jne	0x28dd8 <btf_bswap_type_rest+0x48>
; 	switch (btf_kind(t)) {
   28df0: 31 c0                        	xorl	%eax, %eax
; }
   28df2: c3                           	retq
   28df3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
;   return __builtin_bswap32 (__bsx);
   28df8: 8b 41 0c                     	movl	12(%rcx), %eax
   28dfb: 0f c8                        	bswapl	%eax
; 		btf_decl_tag(t)->component_idx = bswap_32(btf_decl_tag(t)->component_idx);
   28dfd: 89 41 0c                     	movl	%eax, 12(%rcx)
; 		return 0;
   28e00: 31 c0                        	xorl	%eax, %eax
   28e02: c3                           	retq
   28e03: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	return (struct btf_member *)(t + 1);
   28e08: 48 8d 41 0c                  	leaq	12(%rcx), %rax
; 		for (i = 0, m = btf_members(t); i < vlen; i++, m++) {
   28e0c: 81 e6 ff ff 00 00            	andl	$65535, %esi            # imm = 0xFFFF
   28e12: 74 dc                        	je	0x28df0 <btf_bswap_type_rest+0x60>
   28e14: 8d 56 ff                     	leal	-1(%rsi), %edx
   28e17: 48 8d 14 52                  	leaq	(%rdx,%rdx,2), %rdx
   28e1b: 48 8d 4c 91 18               	leaq	24(%rcx,%rdx,4), %rcx
;   return __builtin_bswap32 (__bsx);
   28e20: 8b 10                        	movl	(%rax), %edx
; 		for (i = 0, m = btf_members(t); i < vlen; i++, m++) {
   28e22: 48 83 c0 0c                  	addq	$12, %rax
;   return __builtin_bswap32 (__bsx);
   28e26: 0f ca                        	bswapl	%edx
; 			m->name_off = bswap_32(m->name_off);
   28e28: 89 50 f4                     	movl	%edx, -12(%rax)
;   return __builtin_bswap32 (__bsx);
   28e2b: 8b 50 f8                     	movl	-8(%rax), %edx
   28e2e: 0f ca                        	bswapl	%edx
; 			m->type = bswap_32(m->type);
   28e30: 89 50 f8                     	movl	%edx, -8(%rax)
;   return __builtin_bswap32 (__bsx);
   28e33: 8b 50 fc                     	movl	-4(%rax), %edx
   28e36: 0f ca                        	bswapl	%edx
; 			m->offset = bswap_32(m->offset);
   28e38: 89 50 fc                     	movl	%edx, -4(%rax)
; 		for (i = 0, m = btf_members(t); i < vlen; i++, m++) {
   28e3b: 48 39 c1                     	cmpq	%rax, %rcx
   28e3e: 75 e0                        	jne	0x28e20 <btf_bswap_type_rest+0x90>
   28e40: eb ae                        	jmp	0x28df0 <btf_bswap_type_rest+0x60>
   28e42: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return (struct btf_var_secinfo *)(t + 1);
   28e48: 48 8d 41 0c                  	leaq	12(%rcx), %rax
; 		for (i = 0, v = btf_var_secinfos(t); i < vlen; i++, v++) {
   28e4c: 81 e6 ff ff 00 00            	andl	$65535, %esi            # imm = 0xFFFF
   28e52: 74 9c                        	je	0x28df0 <btf_bswap_type_rest+0x60>
   28e54: 8d 56 ff                     	leal	-1(%rsi), %edx
   28e57: 48 8d 14 52                  	leaq	(%rdx,%rdx,2), %rdx
   28e5b: 48 8d 4c 91 18               	leaq	24(%rcx,%rdx,4), %rcx
;   return __builtin_bswap32 (__bsx);
   28e60: 8b 10                        	movl	(%rax), %edx
; 		for (i = 0, v = btf_var_secinfos(t); i < vlen; i++, v++) {
   28e62: 48 83 c0 0c                  	addq	$12, %rax
;   return __builtin_bswap32 (__bsx);
   28e66: 0f ca                        	bswapl	%edx
; 			v->type = bswap_32(v->type);
   28e68: 89 50 f4                     	movl	%edx, -12(%rax)
;   return __builtin_bswap32 (__bsx);
   28e6b: 8b 50 f8                     	movl	-8(%rax), %edx
   28e6e: 0f ca                        	bswapl	%edx
; 			v->offset = bswap_32(v->offset);
   28e70: 89 50 f8                     	movl	%edx, -8(%rax)
;   return __builtin_bswap32 (__bsx);
   28e73: 8b 50 fc                     	movl	-4(%rax), %edx
   28e76: 0f ca                        	bswapl	%edx
; 			v->size = bswap_32(v->size);
   28e78: 89 50 fc                     	movl	%edx, -4(%rax)
; 		for (i = 0, v = btf_var_secinfos(t); i < vlen; i++, v++) {
   28e7b: 48 39 c1                     	cmpq	%rax, %rcx
   28e7e: 75 e0                        	jne	0x28e60 <btf_bswap_type_rest+0xd0>
   28e80: e9 6b ff ff ff               	jmp	0x28df0 <btf_bswap_type_rest+0x60>
   28e85: 0f 1f 00                     	nopl	(%rax)
; 	return (struct btf_enum64 *)(t + 1);
   28e88: 48 8d 41 0c                  	leaq	12(%rcx), %rax
; 		for (i = 0, e64 = btf_enum64(t); i < vlen; i++, e64++) {
   28e8c: 81 e6 ff ff 00 00            	andl	$65535, %esi            # imm = 0xFFFF
   28e92: 0f 84 58 ff ff ff            	je	0x28df0 <btf_bswap_type_rest+0x60>
   28e98: 8d 56 ff                     	leal	-1(%rsi), %edx
   28e9b: 48 8d 14 52                  	leaq	(%rdx,%rdx,2), %rdx
   28e9f: 48 8d 4c 91 18               	leaq	24(%rcx,%rdx,4), %rcx
   28ea4: 0f 1f 40 00                  	nopl	(%rax)
;   return __builtin_bswap32 (__bsx);
   28ea8: 8b 10                        	movl	(%rax), %edx
; 		for (i = 0, e64 = btf_enum64(t); i < vlen; i++, e64++) {
   28eaa: 48 83 c0 0c                  	addq	$12, %rax
;   return __builtin_bswap32 (__bsx);
   28eae: 0f ca                        	bswapl	%edx
; 			e64->name_off = bswap_32(e64->name_off);
   28eb0: 89 50 f4                     	movl	%edx, -12(%rax)
;   return __builtin_bswap32 (__bsx);
   28eb3: 8b 50 f8                     	movl	-8(%rax), %edx
   28eb6: 0f ca                        	bswapl	%edx
; 			e64->val_lo32 = bswap_32(e64->val_lo32);
   28eb8: 89 50 f8                     	movl	%edx, -8(%rax)
;   return __builtin_bswap32 (__bsx);
   28ebb: 8b 50 fc                     	movl	-4(%rax), %edx
   28ebe: 0f ca                        	bswapl	%edx
; 			e64->val_hi32 = bswap_32(e64->val_hi32);
   28ec0: 89 50 fc                     	movl	%edx, -4(%rax)
; 		for (i = 0, e64 = btf_enum64(t); i < vlen; i++, e64++) {
   28ec3: 48 39 c1                     	cmpq	%rax, %rcx
   28ec6: 75 e0                        	jne	0x28ea8 <btf_bswap_type_rest+0x118>
   28ec8: e9 23 ff ff ff               	jmp	0x28df0 <btf_bswap_type_rest+0x60>
   28ecd: 0f 1f 00                     	nopl	(%rax)
;   return __builtin_bswap32 (__bsx);
   28ed0: 8b 41 0c                     	movl	12(%rcx), %eax
   28ed3: 0f c8                        	bswapl	%eax
; 		a->type = bswap_32(a->type);
   28ed5: 89 41 0c                     	movl	%eax, 12(%rcx)
;   return __builtin_bswap32 (__bsx);
   28ed8: 8b 41 10                     	movl	16(%rcx), %eax
   28edb: 0f c8                        	bswapl	%eax
; 		a->index_type = bswap_32(a->index_type);
   28edd: 89 41 10                     	movl	%eax, 16(%rcx)
;   return __builtin_bswap32 (__bsx);
   28ee0: 8b 41 14                     	movl	20(%rcx), %eax
   28ee3: 0f c8                        	bswapl	%eax
; 		a->nelems = bswap_32(a->nelems);
   28ee5: 89 41 14                     	movl	%eax, 20(%rcx)
; 		return 0;
   28ee8: 31 c0                        	xorl	%eax, %eax
   28eea: c3                           	retq
   28eeb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	return (struct btf_param *)(t + 1);
   28ef0: 48 8d 41 0c                  	leaq	12(%rcx), %rax
; 		for (i = 0, p = btf_params(t); i < vlen; i++, p++) {
   28ef4: 81 e6 ff ff 00 00            	andl	$65535, %esi            # imm = 0xFFFF
   28efa: 0f 84 f0 fe ff ff            	je	0x28df0 <btf_bswap_type_rest+0x60>
   28f00: 8d 56 ff                     	leal	-1(%rsi), %edx
   28f03: 48 8d 4c d1 14               	leaq	20(%rcx,%rdx,8), %rcx
   28f08: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
;   return __builtin_bswap32 (__bsx);
   28f10: 8b 10                        	movl	(%rax), %edx
; 		for (i = 0, p = btf_params(t); i < vlen; i++, p++) {
   28f12: 48 83 c0 08                  	addq	$8, %rax
;   return __builtin_bswap32 (__bsx);
   28f16: 0f ca                        	bswapl	%edx
; 			p->name_off = bswap_32(p->name_off);
   28f18: 89 50 f8                     	movl	%edx, -8(%rax)
;   return __builtin_bswap32 (__bsx);
   28f1b: 8b 50 fc                     	movl	-4(%rax), %edx
   28f1e: 0f ca                        	bswapl	%edx
; 			p->type = bswap_32(p->type);
   28f20: 89 50 fc                     	movl	%edx, -4(%rax)
; 		for (i = 0, p = btf_params(t); i < vlen; i++, p++) {
   28f23: 48 39 c1                     	cmpq	%rax, %rcx
   28f26: 75 e8                        	jne	0x28f10 <btf_bswap_type_rest+0x180>
   28f28: e9 c3 fe ff ff               	jmp	0x28df0 <btf_bswap_type_rest+0x60>
; {
   28f2d: 48 83 ec 08                  	subq	$8, %rsp
; 		pr_debug("Unsupported BTF_KIND:%u\n", btf_kind(t));
   28f31: 31 c0                        	xorl	%eax, %eax
; 	switch (btf_kind(t)) {
   28f33: 0f b7 d2                     	movzwl	%dx, %edx
; 		pr_debug("Unsupported BTF_KIND:%u\n", btf_kind(t));
   28f36: bf 02 00 00 00               	movl	$2, %edi
   28f3b: 48 8d 35 5e 22 01 00         	leaq	74334(%rip), %rsi       # 0x3b1a0 <CSWTCH.126+0x18a0>
   28f42: e8 89 f1 fd ff               	callq	0x80d0 <libbpf_print>
; 		return -EINVAL;
   28f47: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   28f4c: 48 83 c4 08                  	addq	$8, %rsp
   28f50: c3                           	retq
   28f51: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   28f5c: 0f 1f 40 00                  	nopl	(%rax)

0000000000028f60 <btf_equal_enum>:
; 	       t1->info == t2->info &&
   28f60: 8b 17                        	movl	(%rdi), %edx
; 		return false;
   28f62: 31 c0                        	xorl	%eax, %eax
; 	       t1->info == t2->info &&
   28f64: 39 16                        	cmpl	%edx, (%rsi)
   28f66: 74 08                        	je	0x28f70 <btf_equal_enum+0x10>
; }
   28f68: c3                           	retq
   28f69: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	       t1->info == t2->info &&
   28f70: 8b 57 04                     	movl	4(%rdi), %edx
; 	return t1->name_off == t2->name_off &&
   28f73: 39 56 04                     	cmpl	%edx, 4(%rsi)
   28f76: 75 f0                        	jne	0x28f68 <btf_equal_enum+0x8>
; 	       t1->info == t2->info &&
   28f78: 8b 4e 08                     	movl	8(%rsi), %ecx
   28f7b: 39 4f 08                     	cmpl	%ecx, 8(%rdi)
   28f7e: 75 e8                        	jne	0x28f68 <btf_equal_enum+0x8>
; 	return (struct btf_enum *)(t + 1);
   28f80: 48 8d 47 0c                  	leaq	12(%rdi), %rax
   28f84: 48 83 c6 0c                  	addq	$12, %rsi
; 	for (i = 0; i < vlen; i++) {
   28f88: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   28f8e: 74 30                        	je	0x28fc0 <btf_equal_enum+0x60>
   28f90: 83 ea 01                     	subl	$1, %edx
   28f93: 48 8d 54 d7 14               	leaq	20(%rdi,%rdx,8), %rdx
   28f98: eb 1b                        	jmp	0x28fb5 <btf_equal_enum+0x55>
   28f9a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		if (m1->name_off != m2->name_off || m1->val != m2->val)
   28fa0: 8b 7e 04                     	movl	4(%rsi), %edi
   28fa3: 39 78 04                     	cmpl	%edi, 4(%rax)
   28fa6: 75 13                        	jne	0x28fbb <btf_equal_enum+0x5b>
; 		m1++;
   28fa8: 48 83 c0 08                  	addq	$8, %rax
; 		m2++;
   28fac: 48 83 c6 08                  	addq	$8, %rsi
; 	for (i = 0; i < vlen; i++) {
   28fb0: 48 39 d0                     	cmpq	%rdx, %rax
   28fb3: 74 0b                        	je	0x28fc0 <btf_equal_enum+0x60>
; 		if (m1->name_off != m2->name_off || m1->val != m2->val)
   28fb5: 8b 0e                        	movl	(%rsi), %ecx
   28fb7: 39 08                        	cmpl	%ecx, (%rax)
   28fb9: 74 e5                        	je	0x28fa0 <btf_equal_enum+0x40>
; 		return false;
   28fbb: 31 c0                        	xorl	%eax, %eax
   28fbd: c3                           	retq
   28fbe: 66 90                        	nop
; 	return true;
   28fc0: b8 01 00 00 00               	movl	$1, %eax
; }
   28fc5: c3                           	retq
   28fc6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000028fd0 <btf_equal_enum64>:
; 	       t1->info == t2->info &&
   28fd0: 8b 17                        	movl	(%rdi), %edx
; 		return false;
   28fd2: 31 c0                        	xorl	%eax, %eax
; 	       t1->info == t2->info &&
   28fd4: 39 16                        	cmpl	%edx, (%rsi)
   28fd6: 74 08                        	je	0x28fe0 <btf_equal_enum64+0x10>
; }
   28fd8: c3                           	retq
   28fd9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	       t1->info == t2->info &&
   28fe0: 8b 57 04                     	movl	4(%rdi), %edx
; 	return t1->name_off == t2->name_off &&
   28fe3: 39 56 04                     	cmpl	%edx, 4(%rsi)
   28fe6: 75 f0                        	jne	0x28fd8 <btf_equal_enum64+0x8>
; 	       t1->info == t2->info &&
   28fe8: 8b 4e 08                     	movl	8(%rsi), %ecx
   28feb: 39 4f 08                     	cmpl	%ecx, 8(%rdi)
   28fee: 75 e8                        	jne	0x28fd8 <btf_equal_enum64+0x8>
; 	return (struct btf_enum64 *)(t + 1);
   28ff0: 48 8d 47 0c                  	leaq	12(%rdi), %rax
   28ff4: 48 83 c6 0c                  	addq	$12, %rsi
; 	for (i = 0; i < vlen; i++) {
   28ff8: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   28ffe: 74 40                        	je	0x29040 <btf_equal_enum64+0x70>
   29000: 83 ea 01                     	subl	$1, %edx
   29003: 48 8d 14 52                  	leaq	(%rdx,%rdx,2), %rdx
   29007: 48 8d 54 97 18               	leaq	24(%rdi,%rdx,4), %rdx
   2900c: eb 1f                        	jmp	0x2902d <btf_equal_enum64+0x5d>
   2900e: 66 90                        	nop
; 		if (m1->name_off != m2->name_off || m1->val_lo32 != m2->val_lo32 ||
   29010: 8b 7e 04                     	movl	4(%rsi), %edi
   29013: 39 78 04                     	cmpl	%edi, 4(%rax)
   29016: 75 1b                        	jne	0x29033 <btf_equal_enum64+0x63>
   29018: 8b 4e 08                     	movl	8(%rsi), %ecx
   2901b: 39 48 08                     	cmpl	%ecx, 8(%rax)
   2901e: 75 13                        	jne	0x29033 <btf_equal_enum64+0x63>
; 		m1++;
   29020: 48 83 c0 0c                  	addq	$12, %rax
; 		m2++;
   29024: 48 83 c6 0c                  	addq	$12, %rsi
; 	for (i = 0; i < vlen; i++) {
   29028: 48 39 d0                     	cmpq	%rdx, %rax
   2902b: 74 13                        	je	0x29040 <btf_equal_enum64+0x70>
; 		if (m1->name_off != m2->name_off || m1->val_lo32 != m2->val_lo32 ||
   2902d: 8b 0e                        	movl	(%rsi), %ecx
   2902f: 39 08                        	cmpl	%ecx, (%rax)
   29031: 74 dd                        	je	0x29010 <btf_equal_enum64+0x40>
; 		return false;
   29033: 31 c0                        	xorl	%eax, %eax
   29035: c3                           	retq
   29036: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	return true;
   29040: b8 01 00 00 00               	movl	$1, %eax
; }
   29045: c3                           	retq
   29046: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

0000000000029050 <btf_shallow_equal_struct>:
; 	       t1->info == t2->info &&
   29050: 8b 17                        	movl	(%rdi), %edx
; 		return false;
   29052: 31 c0                        	xorl	%eax, %eax
; 	       t1->info == t2->info &&
   29054: 39 16                        	cmpl	%edx, (%rsi)
   29056: 74 08                        	je	0x29060 <btf_shallow_equal_struct+0x10>
; }
   29058: c3                           	retq
   29059: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	       t1->info == t2->info &&
   29060: 8b 57 04                     	movl	4(%rdi), %edx
; 	return t1->name_off == t2->name_off &&
   29063: 39 56 04                     	cmpl	%edx, 4(%rsi)
   29066: 75 f0                        	jne	0x29058 <btf_shallow_equal_struct+0x8>
; 	       t1->info == t2->info &&
   29068: 8b 4e 08                     	movl	8(%rsi), %ecx
   2906b: 39 4f 08                     	cmpl	%ecx, 8(%rdi)
   2906e: 75 e8                        	jne	0x29058 <btf_shallow_equal_struct+0x8>
; 	return (struct btf_member *)(t + 1);
   29070: 48 8d 47 0c                  	leaq	12(%rdi), %rax
   29074: 48 83 c6 0c                  	addq	$12, %rsi
; 	for (i = 0; i < vlen; i++) {
   29078: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   2907e: 74 30                        	je	0x290b0 <btf_shallow_equal_struct+0x60>
   29080: 83 ea 01                     	subl	$1, %edx
   29083: 48 8d 14 52                  	leaq	(%rdx,%rdx,2), %rdx
   29087: 48 8d 54 97 18               	leaq	24(%rdi,%rdx,4), %rdx
   2908c: eb 17                        	jmp	0x290a5 <btf_shallow_equal_struct+0x55>
   2908e: 66 90                        	nop
; 		if (m1->name_off != m2->name_off || m1->offset != m2->offset)
   29090: 8b 7e 08                     	movl	8(%rsi), %edi
   29093: 39 78 08                     	cmpl	%edi, 8(%rax)
   29096: 75 13                        	jne	0x290ab <btf_shallow_equal_struct+0x5b>
; 		m1++;
   29098: 48 83 c0 0c                  	addq	$12, %rax
; 		m2++;
   2909c: 48 83 c6 0c                  	addq	$12, %rsi
; 	for (i = 0; i < vlen; i++) {
   290a0: 48 39 d0                     	cmpq	%rdx, %rax
   290a3: 74 0b                        	je	0x290b0 <btf_shallow_equal_struct+0x60>
; 		if (m1->name_off != m2->name_off || m1->offset != m2->offset)
   290a5: 8b 0e                        	movl	(%rsi), %ecx
   290a7: 39 08                        	cmpl	%ecx, (%rax)
   290a9: 74 e5                        	je	0x29090 <btf_shallow_equal_struct+0x40>
; 		return false;
   290ab: 31 c0                        	xorl	%eax, %eax
   290ad: c3                           	retq
   290ae: 66 90                        	nop
; 	return true;
   290b0: b8 01 00 00 00               	movl	$1, %eax
; }
   290b5: c3                           	retq
   290b6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

00000000000290c0 <btf_equal_array>:
; 	       t1->info == t2->info &&
   290c0: 8b 17                        	movl	(%rdi), %edx
; 		return false;
   290c2: 31 c0                        	xorl	%eax, %eax
; 	       t1->info == t2->info &&
   290c4: 39 16                        	cmpl	%edx, (%rsi)
   290c6: 74 08                        	je	0x290d0 <btf_equal_array+0x10>
; }
   290c8: c3                           	retq
   290c9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	return t1->name_off == t2->name_off &&
   290d0: 8b 4e 04                     	movl	4(%rsi), %ecx
   290d3: 39 4f 04                     	cmpl	%ecx, 4(%rdi)
   290d6: 75 f0                        	jne	0x290c8 <btf_equal_array+0x8>
; 	       t1->info == t2->info &&
   290d8: 8b 4e 08                     	movl	8(%rsi), %ecx
   290db: 39 4f 08                     	cmpl	%ecx, 8(%rdi)
   290de: 75 e8                        	jne	0x290c8 <btf_equal_array+0x8>
; 	       info1->index_type == info2->index_type &&
   290e0: 8b 4e 0c                     	movl	12(%rsi), %ecx
   290e3: 39 4f 0c                     	cmpl	%ecx, 12(%rdi)
   290e6: 75 e0                        	jne	0x290c8 <btf_equal_array+0x8>
; 	return info1->type == info2->type &&
   290e8: 8b 56 10                     	movl	16(%rsi), %edx
   290eb: 39 57 10                     	cmpl	%edx, 16(%rdi)
   290ee: 75 d8                        	jne	0x290c8 <btf_equal_array+0x8>
; 	       info1->index_type == info2->index_type &&
   290f0: 8b 46 14                     	movl	20(%rsi), %eax
   290f3: 39 47 14                     	cmpl	%eax, 20(%rdi)
   290f6: 0f 94 c0                     	sete	%al
   290f9: c3                           	retq
   290fa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

0000000000029100 <btf_get_raw_data>:
; {
   29100: 41 57                        	pushq	%r15
   29102: 49 89 ff                     	movq	%rdi, %r15
   29105: 41 56                        	pushq	%r14
   29107: 41 55                        	pushq	%r13
   29109: 41 54                        	pushq	%r12
   2910b: 55                           	pushq	%rbp
   2910c: 53                           	pushq	%rbx
   2910d: 48 83 ec 28                  	subq	$40, %rsp
; 	data = swap_endian ? btf->raw_data_swapped : btf->raw_data;
   29111: 84 d2                        	testb	%dl, %dl
   29113: 4c 8b 67 08                  	movq	8(%rdi), %r12
   29117: 4c 0f 44 27                  	cmoveq	(%rdi), %r12
; {
   2911b: 48 89 74 24 10               	movq	%rsi, 16(%rsp)
; 	struct btf_header *hdr = btf->hdr;
   29120: 4c 8b 6f 18                  	movq	24(%rdi), %r13
; 	if (data) {
   29124: 4d 85 e4                     	testq	%r12, %r12
   29127: 74 17                        	je	0x29140 <btf_get_raw_data+0x40>
; 		*size = btf->raw_size;
   29129: 8b 47 10                     	movl	16(%rdi), %eax
   2912c: 89 06                        	movl	%eax, (%rsi)
; }
   2912e: 48 83 c4 28                  	addq	$40, %rsp
   29132: 4c 89 e0                     	movq	%r12, %rax
   29135: 5b                           	popq	%rbx
   29136: 5d                           	popq	%rbp
   29137: 41 5c                        	popq	%r12
   29139: 41 5d                        	popq	%r13
   2913b: 41 5e                        	popq	%r14
   2913d: 41 5f                        	popq	%r15
   2913f: c3                           	retq
; 	data_sz = hdr->hdr_len + hdr->type_len + hdr->str_len;
   29140: 41 8b 5d 04                  	movl	4(%r13), %ebx
   29144: 41 8b 45 0c                  	movl	12(%r13), %eax
; 	data = calloc(1, data_sz);
   29148: bf 01 00 00 00               	movl	$1, %edi
   2914d: 41 89 d6                     	movl	%edx, %r14d
; 	data_sz = hdr->hdr_len + hdr->type_len + hdr->str_len;
   29150: 01 d8                        	addl	%ebx, %eax
   29152: 41 03 45 14                  	addl	20(%r13), %eax
; 	data = calloc(1, data_sz);
   29156: 89 c6                        	movl	%eax, %esi
; 	data_sz = hdr->hdr_len + hdr->type_len + hdr->str_len;
   29158: 89 44 24 1c                  	movl	%eax, 28(%rsp)
; 	data = calloc(1, data_sz);
   2915c: e8 2f c8 fd ff               	callq	0x5990 <.plt.sec+0x320>
   29161: 48 89 c5                     	movq	%rax, %rbp
; 	if (!data)
   29164: 48 85 c0                     	testq	%rax, %rax
   29167: 74 c5                        	je	0x2912e <btf_get_raw_data+0x2e>
; 	memcpy(p, hdr, hdr->hdr_len);
   29169: 89 da                        	movl	%ebx, %edx
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2916b: 4c 89 ee                     	movq	%r13, %rsi
   2916e: 48 89 c7                     	movq	%rax, %rdi
   29171: e8 ca c8 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	if (swap_endian)
   29176: 45 84 f6                     	testb	%r14b, %r14b
   29179: 75 55                        	jne	0x291d0 <btf_get_raw_data+0xd0>
; 	p += hdr->hdr_len;
   2917b: 45 8b 75 04                  	movl	4(%r13), %r14d
; 	memcpy(p, btf->types_data, hdr->type_len);
   2917f: 41 8b 55 0c                  	movl	12(%r13), %edx
;   return __builtin___memcpy_chk (__dest, __src, __len,
   29183: 49 8b 77 20                  	movq	32(%r15), %rsi
; 	p += hdr->hdr_len;
   29187: 4a 8d 44 35 00               	leaq	(%rbp,%r14), %rax
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2918c: 48 89 c7                     	movq	%rax, %rdi
; 	p += hdr->hdr_len;
   2918f: 48 89 44 24 08               	movq	%rax, 8(%rsp)
;   return __builtin___memcpy_chk (__dest, __src, __len,
   29194: e8 a7 c8 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	return btf->strs_data ? btf->strs_data : strset__data(btf->strs_set);
   29199: 49 8b 77 58                  	movq	88(%r15), %rsi
; 	p += hdr->type_len;
   2919d: 45 8b 65 0c                  	movl	12(%r13), %r12d
; 	memcpy(p, btf_strs_data(btf), hdr->str_len);
   291a1: 41 8b 55 14                  	movl	20(%r13), %edx
; 	p += hdr->type_len;
   291a5: 4c 03 64 24 08               	addq	8(%rsp), %r12
; 	return btf->strs_data ? btf->strs_data : strset__data(btf->strs_set);
   291aa: 48 85 f6                     	testq	%rsi, %rsi
   291ad: 0f 84 d5 00 00 00            	je	0x29288 <btf_get_raw_data+0x188>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   291b3: 4c 89 e7                     	movq	%r12, %rdi
; 	return data;
   291b6: 49 89 ec                     	movq	%rbp, %r12
;   return __builtin___memcpy_chk (__dest, __src, __len,
   291b9: e8 82 c8 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	*size = data_sz;
   291be: 48 8b 44 24 10               	movq	16(%rsp), %rax
   291c3: 8b 4c 24 1c                  	movl	28(%rsp), %ecx
   291c7: 89 08                        	movl	%ecx, (%rax)
; 	return data;
   291c9: e9 60 ff ff ff               	jmp	0x2912e <btf_get_raw_data+0x2e>
   291ce: 66 90                        	nop
;   return __builtin_bswap32 (__bsx);
   291d0: 8b 45 04                     	movl	4(%rbp), %eax
;   return __builtin___memcpy_chk (__dest, __src, __len,
   291d3: 49 8b 77 20                  	movq	32(%r15), %rsi
; 	h->magic = bswap_16(h->magic);
   291d7: 66 c1 45 00 08               	rolw	$8, (%rbp)
;   return __builtin_bswap32 (__bsx);
   291dc: 0f c8                        	bswapl	%eax
; 	h->hdr_len = bswap_32(h->hdr_len);
   291de: 89 45 04                     	movl	%eax, 4(%rbp)
;   return __builtin_bswap32 (__bsx);
   291e1: 8b 45 08                     	movl	8(%rbp), %eax
; 	p += hdr->hdr_len;
   291e4: 45 8b 75 04                  	movl	4(%r13), %r14d
;   return __builtin_bswap32 (__bsx);
   291e8: 0f c8                        	bswapl	%eax
; 	h->type_off = bswap_32(h->type_off);
   291ea: 89 45 08                     	movl	%eax, 8(%rbp)
;   return __builtin_bswap32 (__bsx);
   291ed: 8b 45 0c                     	movl	12(%rbp), %eax
   291f0: 0f c8                        	bswapl	%eax
; 	h->type_len = bswap_32(h->type_len);
   291f2: 89 45 0c                     	movl	%eax, 12(%rbp)
;   return __builtin_bswap32 (__bsx);
   291f5: 8b 45 10                     	movl	16(%rbp), %eax
; 	memcpy(p, btf->types_data, hdr->type_len);
   291f8: 41 8b 55 0c                  	movl	12(%r13), %edx
;   return __builtin_bswap32 (__bsx);
   291fc: 0f c8                        	bswapl	%eax
; 	h->str_off = bswap_32(h->str_off);
   291fe: 89 45 10                     	movl	%eax, 16(%rbp)
;   return __builtin_bswap32 (__bsx);
   29201: 8b 45 14                     	movl	20(%rbp), %eax
   29204: 0f c8                        	bswapl	%eax
; 	h->str_len = bswap_32(h->str_len);
   29206: 89 45 14                     	movl	%eax, 20(%rbp)
; 	p += hdr->hdr_len;
   29209: 4a 8d 44 35 00               	leaq	(%rbp,%r14), %rax
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2920e: 48 89 c7                     	movq	%rax, %rdi
; 	p += hdr->hdr_len;
   29211: 48 89 44 24 08               	movq	%rax, 8(%rsp)
;   return __builtin___memcpy_chk (__dest, __src, __len,
   29216: e8 25 c8 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 		for (i = 0; i < btf->nr_types; i++) {
   2921b: 41 8b 47 40                  	movl	64(%r15), %eax
   2921f: 85 c0                        	testl	%eax, %eax
   29221: 0f 84 72 ff ff ff            	je	0x29199 <btf_get_raw_data+0x99>
   29227: 31 db                        	xorl	%ebx, %ebx
   29229: eb 2f                        	jmp	0x2925a <btf_get_raw_data+0x15a>
   2922b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
;   return __builtin_bswap32 (__bsx);
   29230: 41 8b 06                     	movl	(%r14), %eax
; 		for (i = 0; i < btf->nr_types; i++) {
   29233: 48 83 c3 01                  	addq	$1, %rbx
;   return __builtin_bswap32 (__bsx);
   29237: 0f c8                        	bswapl	%eax
; 	t->name_off = bswap_32(t->name_off);
   29239: 41 89 06                     	movl	%eax, (%r14)
;   return __builtin_bswap32 (__bsx);
   2923c: 41 8b 46 04                  	movl	4(%r14), %eax
   29240: 0f c8                        	bswapl	%eax
; 	t->info = bswap_32(t->info);
   29242: 41 89 46 04                  	movl	%eax, 4(%r14)
;   return __builtin_bswap32 (__bsx);
   29246: 41 8b 46 08                  	movl	8(%r14), %eax
   2924a: 0f c8                        	bswapl	%eax
; 	t->type = bswap_32(t->type);
   2924c: 41 89 46 08                  	movl	%eax, 8(%r14)
; 		for (i = 0; i < btf->nr_types; i++) {
   29250: 41 39 5f 40                  	cmpl	%ebx, 64(%r15)
   29254: 0f 86 3f ff ff ff            	jbe	0x29199 <btf_get_raw_data+0x99>
; 			t = p + btf->type_offs[i];
   2925a: 49 8b 47 30                  	movq	48(%r15), %rax
   2925e: 8b 14 98                     	movl	(%rax,%rbx,4), %edx
   29261: 48 8b 44 24 08               	movq	8(%rsp), %rax
   29266: 4c 8d 34 10                  	leaq	(%rax,%rdx), %r14
; 			if (btf_bswap_type_rest(t))
   2926a: 4c 89 f7                     	movq	%r14, %rdi
   2926d: e8 1e fb ff ff               	callq	0x28d90 <btf_bswap_type_rest>
   29272: 85 c0                        	testl	%eax, %eax
   29274: 74 ba                        	je	0x29230 <btf_get_raw_data+0x130>
; 	free(data);
   29276: 48 89 ef                     	movq	%rbp, %rdi
   29279: e8 42 c4 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return NULL;
   2927e: e9 ab fe ff ff               	jmp	0x2912e <btf_get_raw_data+0x2e>
   29283: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	return btf->strs_data ? btf->strs_data : strset__data(btf->strs_set);
   29288: 49 8b 7f 60                  	movq	96(%r15), %rdi
   2928c: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
   29291: e8 7a 6b 00 00               	callq	0x2fe10 <strset__data>
   29296: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   2929b: 48 89 c6                     	movq	%rax, %rsi
   2929e: e9 10 ff ff ff               	jmp	0x291b3 <btf_get_raw_data+0xb3>
   292a3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   292ae: 66 90                        	nop

00000000000292b0 <btf_type_size.isra.0>:
; 	return BTF_INFO_KIND(t->info);
   292b0: 89 f9                        	movl	%edi, %ecx
   292b2: c1 e9 18                     	shrl	$24, %ecx
   292b5: 83 e1 1f                     	andl	$31, %ecx
; 	switch (btf_kind(t)) {
   292b8: 66 83 f9 0d                  	cmpw	$13, %cx
   292bc: 77 3a                        	ja	0x292f8 <btf_type_size.isra.0+0x48>
   292be: 66 85 c9                     	testw	%cx, %cx
   292c1: 74 7d                        	je	0x29340 <btf_type_size.isra.0+0x90>
   292c3: 66 83 f9 0d                  	cmpw	$13, %cx
   292c7: 0f 87 c3 00 00 00            	ja	0x29390 <btf_type_size.isra.0+0xe0>
   292cd: 48 8d 15 e4 26 01 00         	leaq	75492(%rip), %rdx       # 0x3b9b8 <CSWTCH.126+0x20b8>
   292d4: 0f b7 c9                     	movzwl	%cx, %ecx
   292d7: 48 63 04 8a                  	movslq	(%rdx,%rcx,4), %rax
   292db: 48 01 d0                     	addq	%rdx, %rax
   292de: 3e ff e0                     	jmpq	*%rax
   292e1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return base_size;
   292e8: 41 b8 0c 00 00 00            	movl	$12, %r8d
; }
   292ee: 44 89 c0                     	movl	%r8d, %eax
   292f1: c3                           	retq
   292f2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	switch (btf_kind(t)) {
   292f8: 8d 41 f2                     	leal	-14(%rcx), %eax
   292fb: 0f b7 c9                     	movzwl	%cx, %ecx
   292fe: 66 83 f8 05                  	cmpw	$5, %ax
   29302: 77 3e                        	ja	0x29342 <btf_type_size.isra.0+0x92>
   29304: b8 01 00 00 00               	movl	$1, %eax
; 		return base_size;
   29309: 41 b8 0c 00 00 00            	movl	$12, %r8d
   2930f: 48 d3 e0                     	shlq	%cl, %rax
; 	switch (btf_kind(t)) {
   29312: a9 00 00 05 00               	testl	$327680, %eax           # imm = 0x50000
   29317: 75 d5                        	jne	0x292ee <btf_type_size.isra.0+0x3e>
   29319: 41 b8 10 00 00 00            	movl	$16, %r8d
   2931f: a9 00 40 02 00               	testl	$147456, %eax           # imm = 0x24000
   29324: 75 c8                        	jne	0x292ee <btf_type_size.isra.0+0x3e>
   29326: a9 00 80 08 00               	testl	$557056, %eax           # imm = 0x88000
   2932b: 74 15                        	je	0x29342 <btf_type_size.isra.0+0x92>
; 		return base_size + vlen * sizeof(struct btf_var_secinfo);
   2932d: 0f b7 ff                     	movzwl	%di, %edi
   29330: 44 8d 44 7f 03               	leal	3(%rdi,%rdi,2), %r8d
   29335: 41 c1 e0 02                  	shll	$2, %r8d
   29339: eb b3                        	jmp	0x292ee <btf_type_size.isra.0+0x3e>
   2933b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   29340: 31 c9                        	xorl	%ecx, %ecx
; static int btf_type_size(const struct btf_type *t)
   29342: 48 83 ec 08                  	subq	$8, %rsp
; 		pr_debug("Unsupported BTF_KIND:%u\n", btf_kind(t));
   29346: 31 c0                        	xorl	%eax, %eax
   29348: 89 ca                        	movl	%ecx, %edx
   2934a: bf 02 00 00 00               	movl	$2, %edi
   2934f: 48 8d 35 4a 1e 01 00         	leaq	73290(%rip), %rsi       # 0x3b1a0 <CSWTCH.126+0x18a0>
   29356: e8 75 ed fd ff               	callq	0x80d0 <libbpf_print>
; }
   2935b: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   29360: 48 83 c4 08                  	addq	$8, %rsp
   29364: c3                           	retq
   29365: 0f 1f 00                     	nopl	(%rax)
; 		return base_size + vlen * sizeof(struct btf_enum);
   29368: 0f b7 ff                     	movzwl	%di, %edi
   2936b: 44 8d 04 fd 0c 00 00 00      	leal	12(,%rdi,8), %r8d
   29373: e9 76 ff ff ff               	jmp	0x292ee <btf_type_size.isra.0+0x3e>
   29378: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		return base_size + sizeof(struct btf_array);
   29380: 41 b8 18 00 00 00            	movl	$24, %r8d
   29386: e9 63 ff ff ff               	jmp	0x292ee <btf_type_size.isra.0+0x3e>
   2938b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	switch (btf_kind(t)) {
   29390: 41 b8 10 00 00 00            	movl	$16, %r8d
   29396: e9 53 ff ff ff               	jmp	0x292ee <btf_type_size.isra.0+0x3e>
   2939b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

00000000000293a0 <btf_ensure_modifiable>:
; {
   293a0: 41 56                        	pushq	%r14
   293a2: 41 55                        	pushq	%r13
   293a4: 41 54                        	pushq	%r12
   293a6: 55                           	pushq	%rbp
   293a7: 53                           	pushq	%rbx
   293a8: 48 89 fb                     	movq	%rdi, %rbx
   293ab: 48 83 ec 10                  	subq	$16, %rsp
; 	return (void *)btf->hdr != btf->raw_data;
   293af: 48 8b 6f 18                  	movq	24(%rdi), %rbp
   293b3: 48 8b 3f                     	movq	(%rdi), %rdi
; 	if (btf_is_modifiable(btf)) {
   293b6: 48 39 fd                     	cmpq	%rdi, %rbp
   293b9: 74 3d                        	je	0x293f8 <btf_ensure_modifiable+0x58>
; 	if (btf->raw_data) {
   293bb: 48 85 ff                     	testq	%rdi, %rdi
   293be: 74 0c                        	je	0x293cc <btf_ensure_modifiable+0x2c>
; 		free(btf->raw_data);
   293c0: e8 fb c2 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 		btf->raw_data = NULL;
   293c5: 48 c7 03 00 00 00 00         	movq	$0, (%rbx)
; 	if (btf->raw_data_swapped) {
   293cc: 48 8b 7b 08                  	movq	8(%rbx), %rdi
   293d0: 48 85 ff                     	testq	%rdi, %rdi
   293d3: 74 0d                        	je	0x293e2 <btf_ensure_modifiable+0x42>
; 		free(btf->raw_data_swapped);
   293d5: e8 e6 c2 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 		btf->raw_data_swapped = NULL;
   293da: 48 c7 43 08 00 00 00 00      	movq	$0, 8(%rbx)
; }
   293e2: 48 83 c4 10                  	addq	$16, %rsp
; 	return 0;
   293e6: 31 c0                        	xorl	%eax, %eax
; }
   293e8: 5b                           	popq	%rbx
   293e9: 5d                           	popq	%rbp
   293ea: 41 5c                        	popq	%r12
   293ec: 41 5d                        	popq	%r13
   293ee: 41 5e                        	popq	%r14
   293f0: c3                           	retq
   293f1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	hdr = malloc(btf->hdr->hdr_len);
   293f8: 44 8b 75 04                  	movl	4(%rbp), %r14d
   293fc: 4c 89 f7                     	movq	%r14, %rdi
   293ff: e8 8c c6 fd ff               	callq	0x5a90 <.plt.sec+0x420>
; 	types = malloc(btf->hdr->type_len);
   29404: 8b 7d 0c                     	movl	12(%rbp), %edi
; 	hdr = malloc(btf->hdr->hdr_len);
   29407: 49 89 c4                     	movq	%rax, %r12
; 	types = malloc(btf->hdr->type_len);
   2940a: e8 81 c6 fd ff               	callq	0x5a90 <.plt.sec+0x420>
   2940f: 49 89 c5                     	movq	%rax, %r13
; 	if (!hdr || !types)
   29412: 4d 85 e4                     	testq	%r12, %r12
   29415: 0f 84 83 00 00 00            	je	0x2949e <btf_ensure_modifiable+0xfe>
   2941b: 48 85 c0                     	testq	%rax, %rax
   2941e: 74 7e                        	je	0x2949e <btf_ensure_modifiable+0xfe>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   29420: 4c 89 f2                     	movq	%r14, %rdx
   29423: 48 89 ee                     	movq	%rbp, %rsi
   29426: 4c 89 e7                     	movq	%r12, %rdi
   29429: e8 12 c6 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	memcpy(types, btf->types_data, btf->hdr->type_len);
   2942e: 8b 55 0c                     	movl	12(%rbp), %edx
;   return __builtin___memcpy_chk (__dest, __src, __len,
   29431: 48 8b 73 20                  	movq	32(%rbx), %rsi
   29435: 4c 89 ef                     	movq	%r13, %rdi
   29438: e8 03 c6 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	set = strset__new(BTF_MAX_STR_OFFSET, btf->strs_data, btf->hdr->str_len);
   2943d: 8b 55 14                     	movl	20(%rbp), %edx
   29440: 48 8b 73 58                  	movq	88(%rbx), %rsi
   29444: bf ff ff ff 7f               	movl	$2147483647, %edi       # imm = 0x7FFFFFFF
   29449: e8 22 68 00 00               	callq	0x2fc70 <strset__new>
   2944e: 48 89 c7                     	movq	%rax, %rdi
; 	if (IS_ERR(set)) {
   29451: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   29457: 77 4c                        	ja	0x294a5 <btf_ensure_modifiable+0x105>
; 	btf->types_data_cap = btf->hdr->type_len;
   29459: 41 8b 44 24 0c               	movl	12(%r12), %eax
; 	btf->hdr = hdr;
   2945e: 4c 89 63 18                  	movq	%r12, 24(%rbx)
; 	btf->types_data = types;
   29462: 4c 89 6b 20                  	movq	%r13, 32(%rbx)
; 	btf->types_data_cap = btf->hdr->type_len;
   29466: 48 89 43 28                  	movq	%rax, 40(%rbx)
; 	if (btf->hdr->str_len == 0)
   2946a: 41 8b 44 24 14               	movl	20(%r12), %eax
; 	btf->strs_data = NULL;
   2946f: 48 c7 43 58 00 00 00 00      	movq	$0, 88(%rbx)
; 	btf->strs_set = set;
   29477: 48 89 7b 60                  	movq	%rdi, 96(%rbx)
; 	if (btf->hdr->str_len == 0)
   2947b: 85 c0                        	testl	%eax, %eax
   2947d: 75 11                        	jne	0x29490 <btf_ensure_modifiable+0xf0>
; 		btf->strs_deduped = true;
   2947f: c6 43 68 01                  	movb	$1, 104(%rbx)
; 	if (btf->raw_data) {
   29483: 48 8b 3b                     	movq	(%rbx), %rdi
   29486: e9 30 ff ff ff               	jmp	0x293bb <btf_ensure_modifiable+0x1b>
   2948b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	if (!btf->base_btf && btf->hdr->str_len == 1)
   29490: 48 83 7b 48 00               	cmpq	$0, 72(%rbx)
   29495: 75 ec                        	jne	0x29483 <btf_ensure_modifiable+0xe3>
   29497: 83 f8 01                     	cmpl	$1, %eax
   2949a: 75 e7                        	jne	0x29483 <btf_ensure_modifiable+0xe3>
   2949c: eb e1                        	jmp	0x2947f <btf_ensure_modifiable+0xdf>
; 	int err = -ENOMEM;
   2949e: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
; 	struct strset *set = NULL;
   294a3: 31 ff                        	xorl	%edi, %edi
   294a5: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	strset__free(set);
   294a9: e8 02 69 00 00               	callq	0x2fdb0 <strset__free>
; 	free(hdr);
   294ae: 4c 89 e7                     	movq	%r12, %rdi
   294b1: e8 0a c2 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(types);
   294b6: 4c 89 ef                     	movq	%r13, %rdi
   294b9: e8 02 c2 fd ff               	callq	0x56c0 <.plt.sec+0x50>
   294be: 8b 44 24 0c                  	movl	12(%rsp), %eax
; }
   294c2: 48 83 c4 10                  	addq	$16, %rsp
   294c6: 5b                           	popq	%rbx
   294c7: 5d                           	popq	%rbp
   294c8: 41 5c                        	popq	%r12
   294ca: 41 5d                        	popq	%r13
   294cc: 41 5e                        	popq	%r14
   294ce: c3                           	retq
   294cf: 90                           	nop

00000000000294d0 <btf_compat_enum64>:
; 	if (!btf_is_enum_fwd(t1) && !btf_is_enum_fwd(t2))
   294d0: 8b 57 04                     	movl	4(%rdi), %edx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   294d3: b9 40 00 08 00               	movl	$524352, %ecx           # imm = 0x80040
; 	return BTF_INFO_KIND(t->info);
   294d8: 89 d0                        	movl	%edx, %eax
   294da: c1 e8 18                     	shrl	$24, %eax
; 	return btf_is_enum(t) || btf_is_enum64(t);
   294dd: 83 e0 1f                     	andl	$31, %eax
   294e0: 48 0f a3 c1                  	btq	%rax, %rcx
   294e4: 73 12                        	jae	0x294f8 <btf_compat_enum64+0x28>
; 	return btf_is_any_enum(t) && btf_vlen(t) == 0;
   294e6: 66 85 d2                     	testw	%dx, %dx
   294e9: 75 0d                        	jne	0x294f8 <btf_compat_enum64+0x28>
; 	       (t1->info & ~0xffff) == (t2->info & ~0xffff) &&
   294eb: 8b 0e                        	movl	(%rsi), %ecx
   294ed: 31 c0                        	xorl	%eax, %eax
   294ef: 39 0f                        	cmpl	%ecx, (%rdi)
   294f1: 74 2d                        	je	0x29520 <btf_compat_enum64+0x50>
; }
   294f3: c3                           	retq
   294f4: 0f 1f 40 00                  	nopl	(%rax)
   294f8: 8b 4e 04                     	movl	4(%rsi), %ecx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   294fb: 41 b8 40 00 08 00            	movl	$524352, %r8d           # imm = 0x80040
; 	return BTF_INFO_KIND(t->info);
   29501: 89 c8                        	movl	%ecx, %eax
   29503: c1 e8 18                     	shrl	$24, %eax
; 	return btf_is_enum(t) || btf_is_enum64(t);
   29506: 83 e0 1f                     	andl	$31, %eax
   29509: 49 0f a3 c0                  	btq	%rax, %r8
   2950d: 73 05                        	jae	0x29514 <btf_compat_enum64+0x44>
; 	return btf_is_any_enum(t) && btf_vlen(t) == 0;
   2950f: 66 85 c9                     	testw	%cx, %cx
   29512: 74 d7                        	je	0x294eb <btf_compat_enum64+0x1b>
; 		return btf_equal_enum64(t1, t2);
   29514: e9 b7 fa ff ff               	jmp	0x28fd0 <btf_equal_enum64>
   29519: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	       (t1->info & ~0xffff) == (t2->info & ~0xffff) &&
   29520: 33 56 04                     	xorl	4(%rsi), %edx
; 	return t1->name_off == t2->name_off &&
   29523: 81 e2 00 00 ff ff            	andl	$4294901760, %edx       # imm = 0xFFFF0000
   29529: 75 c8                        	jne	0x294f3 <btf_compat_enum64+0x23>
; 	       (t1->info & ~0xffff) == (t2->info & ~0xffff) &&
   2952b: 8b 46 08                     	movl	8(%rsi), %eax
   2952e: 39 47 08                     	cmpl	%eax, 8(%rdi)
   29531: 0f 94 c0                     	sete	%al
   29534: c3                           	retq
   29535: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

0000000000029540 <btf_compat_enum>:
; 	if (!btf_is_enum_fwd(t1) && !btf_is_enum_fwd(t2))
   29540: 8b 57 04                     	movl	4(%rdi), %edx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   29543: b9 40 00 08 00               	movl	$524352, %ecx           # imm = 0x80040
; 	return BTF_INFO_KIND(t->info);
   29548: 89 d0                        	movl	%edx, %eax
   2954a: c1 e8 18                     	shrl	$24, %eax
; 	return btf_is_enum(t) || btf_is_enum64(t);
   2954d: 83 e0 1f                     	andl	$31, %eax
   29550: 48 0f a3 c1                  	btq	%rax, %rcx
   29554: 73 12                        	jae	0x29568 <btf_compat_enum+0x28>
; 	return btf_is_any_enum(t) && btf_vlen(t) == 0;
   29556: 66 85 d2                     	testw	%dx, %dx
   29559: 75 0d                        	jne	0x29568 <btf_compat_enum+0x28>
; 	       (t1->info & ~0xffff) == (t2->info & ~0xffff) &&
   2955b: 8b 0e                        	movl	(%rsi), %ecx
   2955d: 31 c0                        	xorl	%eax, %eax
   2955f: 39 0f                        	cmpl	%ecx, (%rdi)
   29561: 74 2d                        	je	0x29590 <btf_compat_enum+0x50>
; }
   29563: c3                           	retq
   29564: 0f 1f 40 00                  	nopl	(%rax)
   29568: 8b 4e 04                     	movl	4(%rsi), %ecx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   2956b: 41 b8 40 00 08 00            	movl	$524352, %r8d           # imm = 0x80040
; 	return BTF_INFO_KIND(t->info);
   29571: 89 c8                        	movl	%ecx, %eax
   29573: c1 e8 18                     	shrl	$24, %eax
; 	return btf_is_enum(t) || btf_is_enum64(t);
   29576: 83 e0 1f                     	andl	$31, %eax
   29579: 49 0f a3 c0                  	btq	%rax, %r8
   2957d: 73 05                        	jae	0x29584 <btf_compat_enum+0x44>
; 	return btf_is_any_enum(t) && btf_vlen(t) == 0;
   2957f: 66 85 c9                     	testw	%cx, %cx
   29582: 74 d7                        	je	0x2955b <btf_compat_enum+0x1b>
; 		return btf_equal_enum(t1, t2);
   29584: e9 d7 f9 ff ff               	jmp	0x28f60 <btf_equal_enum>
   29589: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	       (t1->info & ~0xffff) == (t2->info & ~0xffff) &&
   29590: 33 56 04                     	xorl	4(%rsi), %edx
; 	return t1->name_off == t2->name_off &&
   29593: 81 e2 00 00 ff ff            	andl	$4294901760, %edx       # imm = 0xFFFF0000
   29599: 75 c8                        	jne	0x29563 <btf_compat_enum+0x23>
; 	       (t1->info & ~0xffff) == (t2->info & ~0xffff) &&
   2959b: 8b 46 08                     	movl	8(%rsi), %eax
   2959e: 39 47 08                     	cmpl	%eax, 8(%rdi)
   295a1: 0f 94 c0                     	sete	%al
   295a4: c3                           	retq
   295a5: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

00000000000295b0 <btf_add_type_mem>:
; {
   295b0: 41 55                        	pushq	%r13
   295b2: 41 54                        	pushq	%r12
   295b4: 55                           	pushq	%rbp
   295b5: 48 89 fd                     	movq	%rdi, %rbp
   295b8: 53                           	pushq	%rbx
   295b9: 48 83 ec 08                  	subq	$8, %rsp
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   295bd: 48 8b 47 18                  	movq	24(%rdi), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   295c1: 44 8b 60 0c                  	movl	12(%rax), %r12d
; 	if (cur_cnt + add_cnt <= *cap_cnt)
   295c5: 48 8b 47 28                  	movq	40(%rdi), %rax
   295c9: 4c 01 e6                     	addq	%r12, %rsi
   295cc: 48 39 c6                     	cmpq	%rax, %rsi
   295cf: 76 7f                        	jbe	0x29650 <btf_add_type_mem+0xa0>
; 	if (cur_cnt + add_cnt > max_cnt)
   295d1: 48 89 f1                     	movq	%rsi, %rcx
   295d4: 48 c1 e9 20                  	shrq	$32, %rcx
   295d8: 0f 85 8a 00 00 00            	jne	0x29668 <btf_add_type_mem+0xb8>
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   295de: 48 89 c2                     	movq	%rax, %rdx
   295e1: 48 89 f3                     	movq	%rsi, %rbx
; 	return realloc(ptr, total);
   295e4: 48 8b 7f 20                  	movq	32(%rdi), %rdi
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   295e8: 48 c1 ea 02                  	shrq	$2, %rdx
   295ec: 48 01 c2                     	addq	%rax, %rdx
   295ef: b8 10 00 00 00               	movl	$16, %eax
   295f4: 48 39 c2                     	cmpq	%rax, %rdx
   295f7: 48 0f 42 d0                  	cmovbq	%rax, %rdx
   295fb: b8 ff ff ff ff               	movl	$4294967295, %eax       # imm = 0xFFFFFFFF
   29600: 48 39 c2                     	cmpq	%rax, %rdx
   29603: 48 0f 47 d0                  	cmovaq	%rax, %rdx
   29607: 48 39 f2                     	cmpq	%rsi, %rdx
   2960a: 48 0f 43 da                  	cmovaeq	%rdx, %rbx
; 	return realloc(ptr, total);
   2960e: 48 89 de                     	movq	%rbx, %rsi
   29611: e8 0a c5 fd ff               	callq	0x5b20 <.plt.sec+0x4b0>
   29616: 49 89 c5                     	movq	%rax, %r13
; 	if (!new_data)
   29619: 48 85 c0                     	testq	%rax, %rax
   2961c: 74 4a                        	je	0x29668 <btf_add_type_mem+0xb8>
; 	memset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);
   2961e: 48 8b 7d 28                  	movq	40(%rbp), %rdi
   29622: 48 89 da                     	movq	%rbx, %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
   29625: 31 f6                        	xorl	%esi, %esi
; 	memset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);
   29627: 48 2b 55 28                  	subq	40(%rbp), %rdx
   2962b: 48 01 c7                     	addq	%rax, %rdi
;   return __builtin___memset_chk (__dest, __ch, __len,
   2962e: e8 8d c2 fd ff               	callq	0x58c0 <.plt.sec+0x250>
; 	*data = new_data;
   29633: 4c 89 6d 20                  	movq	%r13, 32(%rbp)
; 	return new_data + cur_cnt * elem_sz;
   29637: 4b 8d 44 25 00               	leaq	(%r13,%r12), %rax
; 	*cap_cnt = new_cnt;
   2963c: 48 89 5d 28                  	movq	%rbx, 40(%rbp)
; }
   29640: 48 83 c4 08                  	addq	$8, %rsp
   29644: 5b                           	popq	%rbx
   29645: 5d                           	popq	%rbp
   29646: 41 5c                        	popq	%r12
   29648: 41 5d                        	popq	%r13
   2964a: c3                           	retq
   2964b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		return *data + cur_cnt * elem_sz;
   29650: 48 8b 47 20                  	movq	32(%rdi), %rax
; }
   29654: 48 83 c4 08                  	addq	$8, %rsp
   29658: 5b                           	popq	%rbx
   29659: 5d                           	popq	%rbp
; 		return *data + cur_cnt * elem_sz;
   2965a: 4c 01 e0                     	addq	%r12, %rax
; }
   2965d: 41 5c                        	popq	%r12
   2965f: 41 5d                        	popq	%r13
   29661: c3                           	retq
   29662: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   29668: 48 83 c4 08                  	addq	$8, %rsp
; 		return NULL;
   2966c: 31 c0                        	xorl	%eax, %eax
; }
   2966e: 5b                           	popq	%rbx
   2966f: 5d                           	popq	%rbp
   29670: 41 5c                        	popq	%r12
   29672: 41 5d                        	popq	%r13
   29674: c3                           	retq
   29675: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

0000000000029680 <btf_commit_type>:
; {
   29680: 41 57                        	pushq	%r15
   29682: 41 56                        	pushq	%r14
   29684: 41 55                        	pushq	%r13
   29686: 41 89 f5                     	movl	%esi, %r13d
   29689: 41 54                        	pushq	%r12
   2968b: 55                           	pushq	%rbp
   2968c: 53                           	pushq	%rbx
   2968d: 48 89 fb                     	movq	%rdi, %rbx
   29690: 48 83 ec 08                  	subq	$8, %rsp
; 	return libbpf_add_mem((void **)&btf->type_offs, &btf->type_offs_cap, sizeof(__u32),
   29694: 44 8b 7f 40                  	movl	64(%rdi), %r15d
; 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
   29698: 48 8b 47 18                  	movq	24(%rdi), %rax
; 	if (cur_cnt + add_cnt <= *cap_cnt)
   2969c: 48 8b 4f 38                  	movq	56(%rdi), %rcx
   296a0: 49 8d 57 01                  	leaq	1(%r15), %rdx
; 	err = btf_add_type_idx_entry(btf, btf->hdr->type_len);
   296a4: 44 8b 60 0c                  	movl	12(%rax), %r12d
; 	if (cur_cnt + add_cnt <= *cap_cnt)
   296a8: 48 39 ca                     	cmpq	%rcx, %rdx
   296ab: 0f 86 a7 00 00 00            	jbe	0x29758 <btf_commit_type+0xd8>
; 	if (cur_cnt + add_cnt > max_cnt)
   296b1: 48 81 fa ff ff ff 7f         	cmpq	$2147483647, %rdx       # imm = 0x7FFFFFFF
   296b8: 0f 87 a7 00 00 00            	ja	0x29765 <btf_commit_type+0xe5>
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   296be: 48 89 c8                     	movq	%rcx, %rax
; 	return realloc(ptr, total);
   296c1: 48 8b 7f 30                  	movq	48(%rdi), %rdi
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   296c5: 48 c1 e8 02                  	shrq	$2, %rax
   296c9: 48 01 c8                     	addq	%rcx, %rax
   296cc: b9 10 00 00 00               	movl	$16, %ecx
   296d1: 48 39 c8                     	cmpq	%rcx, %rax
   296d4: 48 0f 42 c1                  	cmovbq	%rcx, %rax
   296d8: b9 ff ff ff 7f               	movl	$2147483647, %ecx       # imm = 0x7FFFFFFF
   296dd: 48 39 c8                     	cmpq	%rcx, %rax
   296e0: 48 0f 47 c1                  	cmovaq	%rcx, %rax
   296e4: 48 39 d0                     	cmpq	%rdx, %rax
   296e7: 48 0f 43 d0                  	cmovaeq	%rax, %rdx
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   296eb: 48 8d 34 95 00 00 00 00      	leaq	(,%rdx,4), %rsi
   296f3: 48 89 d5                     	movq	%rdx, %rbp
; 	return realloc(ptr, total);
   296f6: e8 25 c4 fd ff               	callq	0x5b20 <.plt.sec+0x4b0>
   296fb: 49 89 c6                     	movq	%rax, %r14
; 	if (!new_data)
   296fe: 48 85 c0                     	testq	%rax, %rax
   29701: 74 62                        	je	0x29765 <btf_commit_type+0xe5>
; 	memset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);
   29703: 48 8b 43 38                  	movq	56(%rbx), %rax
   29707: 48 89 ea                     	movq	%rbp, %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
   2970a: 31 f6                        	xorl	%esi, %esi
; 	memset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);
   2970c: 48 29 c2                     	subq	%rax, %rdx
   2970f: 49 8d 3c 86                  	leaq	(%r14,%rax,4), %rdi
   29713: 48 c1 e2 02                  	shlq	$2, %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
   29717: e8 a4 c1 fd ff               	callq	0x58c0 <.plt.sec+0x250>
; 	*data = new_data;
   2971c: 4c 89 73 30                  	movq	%r14, 48(%rbx)
; 	btf->hdr->type_len += data_sz;
   29720: 48 8b 43 18                  	movq	24(%rbx), %rax
; 	return new_data + cur_cnt * elem_sz;
   29724: 4b 8d 14 be                  	leaq	(%r14,%r15,4), %rdx
; 	*cap_cnt = new_cnt;
   29728: 48 89 6b 38                  	movq	%rbp, 56(%rbx)
; 	*p = type_off;
   2972c: 44 89 22                     	movl	%r12d, (%rdx)
; 	btf->hdr->type_len += data_sz;
   2972f: 44 01 68 0c                  	addl	%r13d, 12(%rax)
; 	btf->hdr->str_off += data_sz;
   29733: 44 01 68 10                  	addl	%r13d, 16(%rax)
; 	btf->nr_types++;
   29737: 8b 43 40                     	movl	64(%rbx), %eax
   2973a: 83 c0 01                     	addl	$1, %eax
   2973d: 89 43 40                     	movl	%eax, 64(%rbx)
; 	return btf->start_id + btf->nr_types - 1;
   29740: 03 43 50                     	addl	80(%rbx), %eax
; }
   29743: 48 83 c4 08                  	addq	$8, %rsp
   29747: 5b                           	popq	%rbx
; 	return btf->start_id + btf->nr_types - 1;
   29748: 83 e8 01                     	subl	$1, %eax
; }
   2974b: 5d                           	popq	%rbp
   2974c: 41 5c                        	popq	%r12
   2974e: 41 5d                        	popq	%r13
   29750: 41 5e                        	popq	%r14
   29752: 41 5f                        	popq	%r15
   29754: c3                           	retq
   29755: 0f 1f 00                     	nopl	(%rax)
; 		return *data + cur_cnt * elem_sz;
   29758: 48 8b 57 30                  	movq	48(%rdi), %rdx
   2975c: 4a 8d 14 ba                  	leaq	(%rdx,%r15,4), %rdx
; 	if (!p)
   29760: 48 85 d2                     	testq	%rdx, %rdx
   29763: 75 c7                        	jne	0x2972c <btf_commit_type+0xac>
; 		errno = -ret;
   29765: e8 86 bf fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2976a: c7 00 0c 00 00 00            	movl	$12, (%rax)
; }
   29770: 48 83 c4 08                  	addq	$8, %rsp
; 		return -ENOMEM;
   29774: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
; }
   29779: 5b                           	popq	%rbx
   2977a: 5d                           	popq	%rbp
   2977b: 41 5c                        	popq	%r12
   2977d: 41 5d                        	popq	%r13
   2977f: 41 5e                        	popq	%r14
   29781: 41 5f                        	popq	%r15
   29783: c3                           	retq
   29784: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2978f: 90                           	nop

0000000000029790 <btf_dedup_ref_type>:
; {
   29790: 41 57                        	pushq	%r15
   29792: 41 56                        	pushq	%r14
   29794: 41 55                        	pushq	%r13
   29796: 41 89 f5                     	movl	%esi, %r13d
   29799: 41 54                        	pushq	%r12
   2979b: 55                           	pushq	%rbp
   2979c: 53                           	pushq	%rbx
   2979d: 48 83 ec 18                  	subq	$24, %rsp
; 	if (d->map[type_id] == BTF_IN_PROGRESS_ID)
   297a1: 48 8b 4f 18                  	movq	24(%rdi), %rcx
   297a5: 4a 8d 34 a9                  	leaq	(%rcx,%r13,4), %rsi
   297a9: 8b 06                        	movl	(%rsi), %eax
   297ab: 83 f8 fe                     	cmpl	$-2, %eax
   297ae: 0f 84 ca 05 00 00            	je	0x29d7e <btf_dedup_ref_type+0x5ee>
   297b4: 4c 89 eb                     	movq	%r13, %rbx
; 	if (d->map[type_id] <= BTF_MAX_NR_TYPES)
   297b7: 85 c0                        	testl	%eax, %eax
   297b9: 78 25                        	js	0x297e0 <btf_dedup_ref_type+0x50>
   297bb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   297c0: 39 c3                        	cmpl	%eax, %ebx
   297c2: 74 0b                        	je	0x297cf <btf_dedup_ref_type+0x3f>
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   297c4: 89 c2                        	movl	%eax, %edx
   297c6: 89 c3                        	movl	%eax, %ebx
   297c8: 8b 04 91                     	movl	(%rcx,%rdx,4), %eax
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   297cb: 85 c0                        	testl	%eax, %eax
   297cd: 79 f1                        	jns	0x297c0 <btf_dedup_ref_type+0x30>
; 		return resolve_type_id(d, type_id);
   297cf: 89 d8                        	movl	%ebx, %eax
; }
   297d1: 48 83 c4 18                  	addq	$24, %rsp
   297d5: 5b                           	popq	%rbx
   297d6: 5d                           	popq	%rbp
   297d7: 41 5c                        	popq	%r12
   297d9: 41 5d                        	popq	%r13
   297db: 41 5e                        	popq	%r14
   297dd: 41 5f                        	popq	%r15
   297df: c3                           	retq
; 	t = btf_type_by_id(d->btf, type_id);
   297e0: 48 8b 07                     	movq	(%rdi), %rax
   297e3: 49 89 fe                     	movq	%rdi, %r14
; 		return &btf_void;
   297e6: 48 8d 2d a3 da 01 00         	leaq	121507(%rip), %rbp      # 0x47290 <btf_void>
; 	if (type_id == 0)
   297ed: 45 85 ed                     	testl	%r13d, %r13d
   297f0: 75 0a                        	jne	0x297fc <btf_dedup_ref_type+0x6c>
   297f2: eb 1e                        	jmp	0x29812 <btf_dedup_ref_type+0x82>
   297f4: 0f 1f 40 00                  	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   297f8: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   297fc: 8b 50 50                     	movl	80(%rax), %edx
   297ff: 39 d3                        	cmpl	%edx, %ebx
   29801: 72 f5                        	jb	0x297f8 <btf_dedup_ref_type+0x68>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   29803: 89 d9                        	movl	%ebx, %ecx
   29805: 29 d1                        	subl	%edx, %ecx
   29807: 48 8b 50 30                  	movq	48(%rax), %rdx
   2980b: 8b 2c 8a                     	movl	(%rdx,%rcx,4), %ebp
   2980e: 48 03 68 20                  	addq	32(%rax), %rbp
; 	d->map[type_id] = BTF_IN_PROGRESS_ID;
   29812: c7 06 fe ff ff ff            	movl	$4294967294, (%rsi)     # imm = 0xFFFFFFFE
; 	return BTF_INFO_KIND(t->info);
   29818: 0f b6 45 07                  	movzbl	7(%rbp), %eax
   2981c: 83 e0 1f                     	andl	$31, %eax
; 	switch (btf_kind(t)) {
   2981f: 66 83 f8 12                  	cmpw	$18, %ax
   29823: 0f 87 1f 01 00 00            	ja	0x29948 <btf_dedup_ref_type+0x1b8>
   29829: 48 8d 15 c0 21 01 00         	leaq	74176(%rip), %rdx       # 0x3b9f0 <CSWTCH.126+0x20f0>
   29830: 0f b7 c0                     	movzwl	%ax, %eax
   29833: 48 63 04 82                  	movslq	(%rdx,%rax,4), %rax
   29837: 48 01 d0                     	addq	%rdx, %rax
   2983a: 3e ff e0                     	jmpq	*%rax
   2983d: 0f 1f 00                     	nopl	(%rax)
; 		ref_type_id = btf_dedup_ref_type(d, t->type);
   29840: 8b 75 08                     	movl	8(%rbp), %esi
   29843: 4c 89 f7                     	movq	%r14, %rdi
   29846: e8 45 ff ff ff               	callq	0x29790 <btf_dedup_ref_type>
; 		if (ref_type_id < 0)
   2984b: 85 c0                        	testl	%eax, %eax
   2984d: 78 82                        	js	0x297d1 <btf_dedup_ref_type+0x41>
; 	h = hash_combine(0, t->name_off);
   2984f: 8b 4d 00                     	movl	(%rbp), %ecx
; 		for_each_dedup_cand(d, hash_entry, h) {
   29852: 4d 8b 56 10                  	movq	16(%r14), %r10
; 		t->type = ref_type_id;
   29856: 89 45 08                     	movl	%eax, 8(%rbp)
; 	h = hash_combine(h, t->size);
   29859: 48 98                        	cltq
; 	return h * 31 + value;
   2985b: 48 89 ca                     	movq	%rcx, %rdx
; 		for_each_dedup_cand(d, hash_entry, h) {
   2985e: 4d 8b 42 18                  	movq	24(%r10), %r8
; 	return h * 31 + value;
   29862: 48 c1 e2 05                  	shlq	$5, %rdx
   29866: 48 29 ca                     	subq	%rcx, %rdx
; 	h = hash_combine(h, t->info);
   29869: 8b 4d 04                     	movl	4(%rbp), %ecx
; 		for_each_dedup_cand(d, hash_entry, h) {
   2986c: 4c 89 04 24                  	movq	%r8, (%rsp)
; 	return h * 31 + value;
   29870: 48 01 ca                     	addq	%rcx, %rdx
   29873: 49 89 d4                     	movq	%rdx, %r12
   29876: 49 c1 e4 05                  	shlq	$5, %r12
   2987a: 49 29 d4                     	subq	%rdx, %r12
   2987d: 49 01 c4                     	addq	%rax, %r12
; 		for_each_dedup_cand(d, hash_entry, h) {
   29880: 4d 85 c0                     	testq	%r8, %r8
   29883: 0f 84 cb 04 00 00            	je	0x29d54 <btf_dedup_ref_type+0x5c4>
   29889: 4d 8b 7a 28                  	movq	40(%r10), %r15
   2988d: 49 8b 72 10                  	movq	16(%r10), %rsi
   29891: 4c 89 e7                     	movq	%r12, %rdi
   29894: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   29897: 4c 8b 04 24                  	movq	(%rsp), %r8
   2989b: 45 85 ff                     	testl	%r15d, %r15d
   2989e: 74 1d                        	je	0x298bd <btf_dedup_ref_type+0x12d>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   298a0: 48 ba 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdx # imm = 0x9E3779B97F4A7C15
   298aa: b9 40 00 00 00               	movl	$64, %ecx
   298af: 48 0f af c2                  	imulq	%rdx, %rax
   298b3: 44 29 f9                     	subl	%r15d, %ecx
   298b6: 48 d3 e8                     	shrq	%cl, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   298b9: 4d 8d 04 c0                  	leaq	(%r8,%rax,8), %r8
   298bd: 4d 8b 38                     	movq	(%r8), %r15
   298c0: 4d 8b 56 10                  	movq	16(%r14), %r10
   298c4: 4d 85 ff                     	testq	%r15, %r15
   298c7: 75 14                        	jne	0x298dd <btf_dedup_ref_type+0x14d>
   298c9: e9 86 04 00 00               	jmp	0x29d54 <btf_dedup_ref_type+0x5c4>
   298ce: 66 90                        	nop
   298d0: 4d 8b 7f 10                  	movq	16(%r15), %r15
   298d4: 4d 85 ff                     	testq	%r15, %r15
   298d7: 0f 84 73 04 00 00            	je	0x29d50 <btf_dedup_ref_type+0x5c0>
   298dd: 49 8b 46 10                  	movq	16(%r14), %rax
   298e1: 49 8b 3f                     	movq	(%r15), %rdi
   298e4: 4c 89 e6                     	movq	%r12, %rsi
   298e7: 48 8b 50 10                  	movq	16(%rax), %rdx
   298eb: ff 50 08                     	callq	*8(%rax)
   298ee: 84 c0                        	testb	%al, %al
   298f0: 74 de                        	je	0x298d0 <btf_dedup_ref_type+0x140>
; 			cand_id = (__u32)(long)hash_entry->value;
   298f2: 49 8b 4f 08                  	movq	8(%r15), %rcx
; 			cand = btf_type_by_id(d->btf, cand_id);
   298f6: 49 8b 06                     	movq	(%r14), %rax
; 		return &btf_void;
   298f9: 48 8d 15 90 d9 01 00         	leaq	121232(%rip), %rdx      # 0x47290 <btf_void>
; 			cand_id = (__u32)(long)hash_entry->value;
   29900: 41 89 c8                     	movl	%ecx, %r8d
; 	if (type_id == 0)
   29903: 85 c9                        	testl	%ecx, %ecx
   29905: 75 0d                        	jne	0x29914 <btf_dedup_ref_type+0x184>
   29907: eb 20                        	jmp	0x29929 <btf_dedup_ref_type+0x199>
   29909: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   29910: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   29914: 8b 50 50                     	movl	80(%rax), %edx
   29917: 41 39 d0                     	cmpl	%edx, %r8d
   2991a: 72 f4                        	jb	0x29910 <btf_dedup_ref_type+0x180>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2991c: 29 d1                        	subl	%edx, %ecx
   2991e: 48 8b 50 30                  	movq	48(%rax), %rdx
   29922: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   29925: 48 03 50 20                  	addq	32(%rax), %rdx
; 	       t1->info == t2->info &&
   29929: 8b 02                        	movl	(%rdx), %eax
   2992b: 39 45 00                     	cmpl	%eax, (%rbp)
   2992e: 75 a0                        	jne	0x298d0 <btf_dedup_ref_type+0x140>
; 	return t1->name_off == t2->name_off &&
   29930: 8b 42 04                     	movl	4(%rdx), %eax
   29933: 39 45 04                     	cmpl	%eax, 4(%rbp)
   29936: 75 98                        	jne	0x298d0 <btf_dedup_ref_type+0x140>
; 	       t1->info == t2->info &&
   29938: 8b 42 08                     	movl	8(%rdx), %eax
   2993b: 39 45 08                     	cmpl	%eax, 8(%rbp)
   2993e: 75 90                        	jne	0x298d0 <btf_dedup_ref_type+0x140>
   29940: e9 eb 03 00 00               	jmp	0x29d30 <btf_dedup_ref_type+0x5a0>
   29945: 0f 1f 00                     	nopl	(%rax)
; }
   29948: 48 83 c4 18                  	addq	$24, %rsp
; 	switch (btf_kind(t)) {
   2994c: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   29951: 5b                           	popq	%rbx
   29952: 5d                           	popq	%rbp
   29953: 41 5c                        	popq	%r12
   29955: 41 5d                        	popq	%r13
   29957: 41 5e                        	popq	%r14
   29959: 41 5f                        	popq	%r15
   2995b: c3                           	retq
; 		ref_type_id = btf_dedup_ref_type(d, t->type);
   2995c: 8b 75 08                     	movl	8(%rbp), %esi
   2995f: 4c 89 f7                     	movq	%r14, %rdi
   29962: e8 29 fe ff ff               	callq	0x29790 <btf_dedup_ref_type>
; 		if (ref_type_id < 0)
   29967: 85 c0                        	testl	%eax, %eax
   29969: 0f 88 62 fe ff ff            	js	0x297d1 <btf_dedup_ref_type+0x41>
; 	h = hash_combine(0, t->name_off);
   2996f: 8b 55 00                     	movl	(%rbp), %edx
; 		for_each_dedup_cand(d, hash_entry, h) {
   29972: 4d 8b 56 10                  	movq	16(%r14), %r10
; 		t->type = ref_type_id;
   29976: 89 45 08                     	movl	%eax, 8(%rbp)
; 	h = hash_combine(h, t->size);
   29979: 48 98                        	cltq
; 	return h * 31 + value;
   2997b: 48 89 d1                     	movq	%rdx, %rcx
; 		for_each_dedup_cand(d, hash_entry, h) {
   2997e: 4d 8b 42 18                  	movq	24(%r10), %r8
; 	return h * 31 + value;
   29982: 48 c1 e1 05                  	shlq	$5, %rcx
   29986: 48 29 d1                     	subq	%rdx, %rcx
; 	h = hash_combine(h, t->info);
   29989: 8b 55 04                     	movl	4(%rbp), %edx
; 		for_each_dedup_cand(d, hash_entry, h) {
   2998c: 4c 89 04 24                  	movq	%r8, (%rsp)
; 	return h * 31 + value;
   29990: 48 01 d1                     	addq	%rdx, %rcx
   29993: 48 89 ca                     	movq	%rcx, %rdx
   29996: 48 c1 e2 05                  	shlq	$5, %rdx
   2999a: 48 29 ca                     	subq	%rcx, %rdx
   2999d: 48 01 d0                     	addq	%rdx, %rax
   299a0: 49 89 c4                     	movq	%rax, %r12
   299a3: 49 c1 e4 05                  	shlq	$5, %r12
   299a7: 49 29 c4                     	subq	%rax, %r12
; 	h = hash_combine(h, info);
   299aa: 8b 45 0c                     	movl	12(%rbp), %eax
; 	return h * 31 + value;
   299ad: 49 01 c4                     	addq	%rax, %r12
; 		for_each_dedup_cand(d, hash_entry, h) {
   299b0: 4d 85 c0                     	testq	%r8, %r8
   299b3: 0f 84 9b 03 00 00            	je	0x29d54 <btf_dedup_ref_type+0x5c4>
   299b9: 4d 8b 7a 28                  	movq	40(%r10), %r15
   299bd: 49 8b 72 10                  	movq	16(%r10), %rsi
   299c1: 4c 89 e7                     	movq	%r12, %rdi
   299c4: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   299c7: 4c 8b 04 24                  	movq	(%rsp), %r8
   299cb: 45 85 ff                     	testl	%r15d, %r15d
   299ce: 74 1d                        	je	0x299ed <btf_dedup_ref_type+0x25d>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   299d0: 48 ba 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdx # imm = 0x9E3779B97F4A7C15
   299da: b9 40 00 00 00               	movl	$64, %ecx
   299df: 48 0f af c2                  	imulq	%rdx, %rax
   299e3: 44 29 f9                     	subl	%r15d, %ecx
   299e6: 48 d3 e8                     	shrq	%cl, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   299e9: 4d 8d 04 c0                  	leaq	(%r8,%rax,8), %r8
   299ed: 4d 8b 38                     	movq	(%r8), %r15
   299f0: 4d 8b 56 10                  	movq	16(%r14), %r10
   299f4: 4d 85 ff                     	testq	%r15, %r15
   299f7: 75 14                        	jne	0x29a0d <btf_dedup_ref_type+0x27d>
   299f9: e9 56 03 00 00               	jmp	0x29d54 <btf_dedup_ref_type+0x5c4>
   299fe: 66 90                        	nop
   29a00: 4d 8b 7f 10                  	movq	16(%r15), %r15
   29a04: 4d 85 ff                     	testq	%r15, %r15
   29a07: 0f 84 43 03 00 00            	je	0x29d50 <btf_dedup_ref_type+0x5c0>
   29a0d: 49 8b 46 10                  	movq	16(%r14), %rax
   29a11: 49 8b 3f                     	movq	(%r15), %rdi
   29a14: 4c 89 e6                     	movq	%r12, %rsi
   29a17: 48 8b 50 10                  	movq	16(%rax), %rdx
   29a1b: ff 50 08                     	callq	*8(%rax)
   29a1e: 84 c0                        	testb	%al, %al
   29a20: 74 de                        	je	0x29a00 <btf_dedup_ref_type+0x270>
; 			cand_id = (__u32)(long)hash_entry->value;
   29a22: 49 8b 4f 08                  	movq	8(%r15), %rcx
; 			cand = btf_type_by_id(d->btf, cand_id);
   29a26: 49 8b 06                     	movq	(%r14), %rax
; 		return &btf_void;
   29a29: 48 8d 15 60 d8 01 00         	leaq	120928(%rip), %rdx      # 0x47290 <btf_void>
; 			cand_id = (__u32)(long)hash_entry->value;
   29a30: 41 89 c8                     	movl	%ecx, %r8d
; 	if (type_id == 0)
   29a33: 85 c9                        	testl	%ecx, %ecx
   29a35: 75 0d                        	jne	0x29a44 <btf_dedup_ref_type+0x2b4>
   29a37: eb 20                        	jmp	0x29a59 <btf_dedup_ref_type+0x2c9>
   29a39: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   29a40: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   29a44: 8b 50 50                     	movl	80(%rax), %edx
   29a47: 41 39 d0                     	cmpl	%edx, %r8d
   29a4a: 72 f4                        	jb	0x29a40 <btf_dedup_ref_type+0x2b0>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   29a4c: 29 d1                        	subl	%edx, %ecx
   29a4e: 48 8b 50 30                  	movq	48(%rax), %rdx
   29a52: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   29a55: 48 03 50 20                  	addq	32(%rax), %rdx
; 	       t1->info == t2->info &&
   29a59: 8b 02                        	movl	(%rdx), %eax
   29a5b: 39 45 00                     	cmpl	%eax, (%rbp)
   29a5e: 75 a0                        	jne	0x29a00 <btf_dedup_ref_type+0x270>
; 	return t1->name_off == t2->name_off &&
   29a60: 8b 42 04                     	movl	4(%rdx), %eax
   29a63: 39 45 04                     	cmpl	%eax, 4(%rbp)
   29a66: 75 98                        	jne	0x29a00 <btf_dedup_ref_type+0x270>
; 	       t1->info == t2->info &&
   29a68: 8b 42 08                     	movl	8(%rdx), %eax
   29a6b: 39 45 08                     	cmpl	%eax, 8(%rbp)
   29a6e: 75 90                        	jne	0x29a00 <btf_dedup_ref_type+0x270>
; 			if (btf_equal_int_tag(t, cand)) {
   29a70: 8b 42 0c                     	movl	12(%rdx), %eax
   29a73: 39 45 0c                     	cmpl	%eax, 12(%rbp)
   29a76: 75 88                        	jne	0x29a00 <btf_dedup_ref_type+0x270>
   29a78: e9 b3 02 00 00               	jmp	0x29d30 <btf_dedup_ref_type+0x5a0>
; 		ref_type_id = btf_dedup_ref_type(d, t->type);
   29a7d: 8b 75 08                     	movl	8(%rbp), %esi
   29a80: 4c 89 f7                     	movq	%r14, %rdi
   29a83: e8 08 fd ff ff               	callq	0x29790 <btf_dedup_ref_type>
; 		if (ref_type_id < 0)
   29a88: 85 c0                        	testl	%eax, %eax
   29a8a: 0f 88 41 fd ff ff            	js	0x297d1 <btf_dedup_ref_type+0x41>
; 		t->type = ref_type_id;
   29a90: 89 45 08                     	movl	%eax, 8(%rbp)
; 	return (struct btf_param *)(t + 1);
   29a93: 48 8d 45 0c                  	leaq	12(%rbp), %rax
   29a97: 48 89 04 24                  	movq	%rax, (%rsp)
; 		for (i = 0; i < vlen; i++) {
   29a9b: 0f b7 45 04                  	movzwl	4(%rbp), %eax
   29a9f: 85 c0                        	testl	%eax, %eax
   29aa1: 74 2d                        	je	0x29ad0 <btf_dedup_ref_type+0x340>
   29aa3: 83 e8 01                     	subl	$1, %eax
; 		param = btf_params(t);
   29aa6: 4c 8b 3c 24                  	movq	(%rsp), %r15
   29aaa: 4c 8d 64 c5 14               	leaq	20(%rbp,%rax,8), %r12
; 			ref_type_id = btf_dedup_ref_type(d, param->type);
   29aaf: 41 8b 77 04                  	movl	4(%r15), %esi
   29ab3: 4c 89 f7                     	movq	%r14, %rdi
   29ab6: e8 d5 fc ff ff               	callq	0x29790 <btf_dedup_ref_type>
; 			if (ref_type_id < 0)
   29abb: 85 c0                        	testl	%eax, %eax
   29abd: 0f 88 0e fd ff ff            	js	0x297d1 <btf_dedup_ref_type+0x41>
; 			param->type = ref_type_id;
   29ac3: 41 89 47 04                  	movl	%eax, 4(%r15)
; 			param++;
   29ac7: 49 83 c7 08                  	addq	$8, %r15
; 		for (i = 0; i < vlen; i++) {
   29acb: 4d 39 e7                     	cmpq	%r12, %r15
   29ace: 75 df                        	jne	0x29aaf <btf_dedup_ref_type+0x31f>
; 		h = btf_hash_fnproto(t);
   29ad0: 48 89 ef                     	movq	%rbp, %rdi
   29ad3: e8 58 ef ff ff               	callq	0x28a30 <btf_hash_fnproto>
; 		for_each_dedup_cand(d, hash_entry, h) {
   29ad8: 4d 8b 56 10                  	movq	16(%r14), %r10
; 		h = btf_hash_fnproto(t);
   29adc: 49 89 c4                     	movq	%rax, %r12
; 		for_each_dedup_cand(d, hash_entry, h) {
   29adf: 4d 8b 7a 18                  	movq	24(%r10), %r15
   29ae3: 4d 85 ff                     	testq	%r15, %r15
   29ae6: 0f 84 68 02 00 00            	je	0x29d54 <btf_dedup_ref_type+0x5c4>
   29aec: 49 8b 52 28                  	movq	40(%r10), %rdx
   29af0: 49 8b 72 10                  	movq	16(%r10), %rsi
   29af4: 48 89 c7                     	movq	%rax, %rdi
   29af7: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
   29afc: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   29aff: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   29b04: 85 d2                        	testl	%edx, %edx
   29b06: 74 1c                        	je	0x29b24 <btf_dedup_ref_type+0x394>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   29b08: 48 b9 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rcx # imm = 0x9E3779B97F4A7C15
   29b12: 48 0f af c1                  	imulq	%rcx, %rax
   29b16: b9 40 00 00 00               	movl	$64, %ecx
   29b1b: 29 d1                        	subl	%edx, %ecx
   29b1d: 48 d3 e8                     	shrq	%cl, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   29b20: 4d 8d 3c c7                  	leaq	(%r15,%rax,8), %r15
   29b24: 4d 8b 3f                     	movq	(%r15), %r15
   29b27: 4d 8b 56 10                  	movq	16(%r14), %r10
   29b2b: 4d 85 ff                     	testq	%r15, %r15
   29b2e: 75 15                        	jne	0x29b45 <btf_dedup_ref_type+0x3b5>
   29b30: e9 1f 02 00 00               	jmp	0x29d54 <btf_dedup_ref_type+0x5c4>
   29b35: 0f 1f 00                     	nopl	(%rax)
   29b38: 4d 8b 7f 10                  	movq	16(%r15), %r15
   29b3c: 4d 85 ff                     	testq	%r15, %r15
   29b3f: 0f 84 0b 02 00 00            	je	0x29d50 <btf_dedup_ref_type+0x5c0>
   29b45: 49 8b 46 10                  	movq	16(%r14), %rax
   29b49: 49 8b 3f                     	movq	(%r15), %rdi
   29b4c: 4c 89 e6                     	movq	%r12, %rsi
   29b4f: 48 8b 50 10                  	movq	16(%rax), %rdx
   29b53: ff 50 08                     	callq	*8(%rax)
   29b56: 84 c0                        	testb	%al, %al
   29b58: 74 de                        	je	0x29b38 <btf_dedup_ref_type+0x3a8>
; 			cand_id = (__u32)(long)hash_entry->value;
   29b5a: 49 8b 77 08                  	movq	8(%r15), %rsi
; 			cand = btf_type_by_id(d->btf, cand_id);
   29b5e: 49 8b 06                     	movq	(%r14), %rax
; 		return &btf_void;
   29b61: 48 8d 15 28 d7 01 00         	leaq	120616(%rip), %rdx      # 0x47290 <btf_void>
; 			cand_id = (__u32)(long)hash_entry->value;
   29b68: 41 89 f0                     	movl	%esi, %r8d
; 	if (type_id == 0)
   29b6b: 85 f6                        	testl	%esi, %esi
   29b6d: 75 0d                        	jne	0x29b7c <btf_dedup_ref_type+0x3ec>
   29b6f: eb 20                        	jmp	0x29b91 <btf_dedup_ref_type+0x401>
   29b71: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   29b78: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   29b7c: 8b 50 50                     	movl	80(%rax), %edx
   29b7f: 41 39 d0                     	cmpl	%edx, %r8d
   29b82: 72 f4                        	jb	0x29b78 <btf_dedup_ref_type+0x3e8>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   29b84: 29 d6                        	subl	%edx, %esi
   29b86: 48 8b 50 30                  	movq	48(%rax), %rdx
   29b8a: 8b 14 b2                     	movl	(%rdx,%rsi,4), %edx
   29b8d: 48 03 50 20                  	addq	32(%rax), %rdx
; 	       t1->info == t2->info &&
   29b91: 8b 02                        	movl	(%rdx), %eax
   29b93: 39 45 00                     	cmpl	%eax, (%rbp)
   29b96: 75 a0                        	jne	0x29b38 <btf_dedup_ref_type+0x3a8>
   29b98: 8b 45 04                     	movl	4(%rbp), %eax
; 	return t1->name_off == t2->name_off &&
   29b9b: 3b 42 04                     	cmpl	4(%rdx), %eax
   29b9e: 75 98                        	jne	0x29b38 <btf_dedup_ref_type+0x3a8>
; 	       t1->info == t2->info &&
   29ba0: 8b 7a 08                     	movl	8(%rdx), %edi
   29ba3: 39 7d 08                     	cmpl	%edi, 8(%rbp)
   29ba6: 75 90                        	jne	0x29b38 <btf_dedup_ref_type+0x3a8>
; 	return (struct btf_param *)(t + 1);
   29ba8: 48 83 c2 0c                  	addq	$12, %rdx
; 	for (i = 0; i < vlen; i++) {
   29bac: 25 ff ff 00 00               	andl	$65535, %eax            # imm = 0xFFFF
   29bb1: 0f 84 79 01 00 00            	je	0x29d30 <btf_dedup_ref_type+0x5a0>
   29bb7: 83 e8 01                     	subl	$1, %eax
   29bba: 48 8d 74 c5 14               	leaq	20(%rbp,%rax,8), %rsi
; 	m1 = btf_params(t1);
   29bbf: 48 8b 04 24                  	movq	(%rsp), %rax
   29bc3: eb 20                        	jmp	0x29be5 <btf_dedup_ref_type+0x455>
   29bc5: 0f 1f 00                     	nopl	(%rax)
; 		if (m1->name_off != m2->name_off || m1->type != m2->type)
   29bc8: 8b 7a 04                     	movl	4(%rdx), %edi
   29bcb: 39 78 04                     	cmpl	%edi, 4(%rax)
   29bce: 0f 85 64 ff ff ff            	jne	0x29b38 <btf_dedup_ref_type+0x3a8>
; 		m1++;
   29bd4: 48 83 c0 08                  	addq	$8, %rax
; 		m2++;
   29bd8: 48 83 c2 08                  	addq	$8, %rdx
; 	for (i = 0; i < vlen; i++) {
   29bdc: 48 39 f0                     	cmpq	%rsi, %rax
   29bdf: 0f 84 4b 01 00 00            	je	0x29d30 <btf_dedup_ref_type+0x5a0>
; 		if (m1->name_off != m2->name_off || m1->type != m2->type)
   29be5: 8b 3a                        	movl	(%rdx), %edi
   29be7: 39 38                        	cmpl	%edi, (%rax)
   29be9: 74 dd                        	je	0x29bc8 <btf_dedup_ref_type+0x438>
   29beb: e9 48 ff ff ff               	jmp	0x29b38 <btf_dedup_ref_type+0x3a8>
; 		ref_type_id = btf_dedup_ref_type(d, info->type);
   29bf0: 8b 75 0c                     	movl	12(%rbp), %esi
   29bf3: 4c 89 f7                     	movq	%r14, %rdi
   29bf6: e8 95 fb ff ff               	callq	0x29790 <btf_dedup_ref_type>
; 		if (ref_type_id < 0)
   29bfb: 85 c0                        	testl	%eax, %eax
   29bfd: 0f 88 ce fb ff ff            	js	0x297d1 <btf_dedup_ref_type+0x41>
; 		info->type = ref_type_id;
   29c03: 89 45 0c                     	movl	%eax, 12(%rbp)
; 		ref_type_id = btf_dedup_ref_type(d, info->index_type);
   29c06: 8b 75 10                     	movl	16(%rbp), %esi
   29c09: 4c 89 f7                     	movq	%r14, %rdi
   29c0c: e8 7f fb ff ff               	callq	0x29790 <btf_dedup_ref_type>
; 		if (ref_type_id < 0)
   29c11: 85 c0                        	testl	%eax, %eax
   29c13: 0f 88 b8 fb ff ff            	js	0x297d1 <btf_dedup_ref_type+0x41>
; 	h = hash_combine(0, t->name_off);
   29c19: 8b 55 00                     	movl	(%rbp), %edx
; 		for_each_dedup_cand(d, hash_entry, h) {
   29c1c: 4d 8b 56 10                  	movq	16(%r14), %r10
; 		info->index_type = ref_type_id;
   29c20: 89 45 10                     	movl	%eax, 16(%rbp)
; 	h = hash_combine(h, info->index_type);
   29c23: 48 98                        	cltq
; 	return h * 31 + value;
   29c25: 48 89 d1                     	movq	%rdx, %rcx
; 		for_each_dedup_cand(d, hash_entry, h) {
   29c28: 4d 8b 42 18                  	movq	24(%r10), %r8
; 	return h * 31 + value;
   29c2c: 48 c1 e1 05                  	shlq	$5, %rcx
   29c30: 48 29 d1                     	subq	%rdx, %rcx
; 	h = hash_combine(h, t->info);
   29c33: 8b 55 04                     	movl	4(%rbp), %edx
; 		for_each_dedup_cand(d, hash_entry, h) {
   29c36: 4c 89 04 24                  	movq	%r8, (%rsp)
; 	return h * 31 + value;
   29c3a: 48 01 d1                     	addq	%rdx, %rcx
   29c3d: 48 89 ca                     	movq	%rcx, %rdx
   29c40: 48 c1 e2 05                  	shlq	$5, %rdx
   29c44: 48 29 ca                     	subq	%rcx, %rdx
; 	h = hash_combine(h, t->size);
   29c47: 8b 4d 08                     	movl	8(%rbp), %ecx
; 	return h * 31 + value;
   29c4a: 48 01 ca                     	addq	%rcx, %rdx
   29c4d: 48 89 d1                     	movq	%rdx, %rcx
   29c50: 48 c1 e1 05                  	shlq	$5, %rcx
   29c54: 48 29 d1                     	subq	%rdx, %rcx
; 	h = hash_combine(h, info->type);
   29c57: 8b 55 0c                     	movl	12(%rbp), %edx
; 	return h * 31 + value;
   29c5a: 48 01 d1                     	addq	%rdx, %rcx
   29c5d: 48 89 ca                     	movq	%rcx, %rdx
   29c60: 48 c1 e2 05                  	shlq	$5, %rdx
   29c64: 48 29 ca                     	subq	%rcx, %rdx
   29c67: 48 01 d0                     	addq	%rdx, %rax
   29c6a: 49 89 c4                     	movq	%rax, %r12
   29c6d: 49 c1 e4 05                  	shlq	$5, %r12
   29c71: 49 29 c4                     	subq	%rax, %r12
; 	h = hash_combine(h, info->nelems);
   29c74: 8b 45 14                     	movl	20(%rbp), %eax
; 	return h * 31 + value;
   29c77: 49 01 c4                     	addq	%rax, %r12
; 		for_each_dedup_cand(d, hash_entry, h) {
   29c7a: 4d 85 c0                     	testq	%r8, %r8
   29c7d: 0f 84 d1 00 00 00            	je	0x29d54 <btf_dedup_ref_type+0x5c4>
   29c83: 4d 8b 7a 28                  	movq	40(%r10), %r15
   29c87: 49 8b 72 10                  	movq	16(%r10), %rsi
   29c8b: 4c 89 e7                     	movq	%r12, %rdi
   29c8e: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   29c91: 4c 8b 04 24                  	movq	(%rsp), %r8
   29c95: 45 85 ff                     	testl	%r15d, %r15d
   29c98: 74 1d                        	je	0x29cb7 <btf_dedup_ref_type+0x527>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   29c9a: 48 ba 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdx # imm = 0x9E3779B97F4A7C15
   29ca4: b9 40 00 00 00               	movl	$64, %ecx
   29ca9: 48 0f af c2                  	imulq	%rdx, %rax
   29cad: 44 29 f9                     	subl	%r15d, %ecx
   29cb0: 48 d3 e8                     	shrq	%cl, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   29cb3: 4d 8d 04 c0                  	leaq	(%r8,%rax,8), %r8
   29cb7: 4d 8b 38                     	movq	(%r8), %r15
   29cba: 4d 8b 56 10                  	movq	16(%r14), %r10
   29cbe: 4d 85 ff                     	testq	%r15, %r15
   29cc1: 75 16                        	jne	0x29cd9 <btf_dedup_ref_type+0x549>
   29cc3: e9 8c 00 00 00               	jmp	0x29d54 <btf_dedup_ref_type+0x5c4>
   29cc8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
   29cd0: 4d 8b 7f 10                  	movq	16(%r15), %r15
   29cd4: 4d 85 ff                     	testq	%r15, %r15
   29cd7: 74 77                        	je	0x29d50 <btf_dedup_ref_type+0x5c0>
   29cd9: 49 8b 46 10                  	movq	16(%r14), %rax
   29cdd: 49 8b 3f                     	movq	(%r15), %rdi
   29ce0: 4c 89 e6                     	movq	%r12, %rsi
   29ce3: 48 8b 50 10                  	movq	16(%rax), %rdx
   29ce7: ff 50 08                     	callq	*8(%rax)
   29cea: 84 c0                        	testb	%al, %al
   29cec: 74 e2                        	je	0x29cd0 <btf_dedup_ref_type+0x540>
; 			cand_id = (__u32)(long)hash_entry->value;
   29cee: 49 8b 4f 08                  	movq	8(%r15), %rcx
; 			cand = btf_type_by_id(d->btf, cand_id);
   29cf2: 49 8b 06                     	movq	(%r14), %rax
; 		return &btf_void;
   29cf5: 48 8d 35 94 d5 01 00         	leaq	120212(%rip), %rsi      # 0x47290 <btf_void>
; 			cand_id = (__u32)(long)hash_entry->value;
   29cfc: 41 89 c8                     	movl	%ecx, %r8d
; 	if (type_id == 0)
   29cff: 85 c9                        	testl	%ecx, %ecx
   29d01: 75 09                        	jne	0x29d0c <btf_dedup_ref_type+0x57c>
   29d03: eb 1c                        	jmp	0x29d21 <btf_dedup_ref_type+0x591>
   29d05: 0f 1f 00                     	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   29d08: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   29d0c: 8b 50 50                     	movl	80(%rax), %edx
   29d0f: 41 39 d0                     	cmpl	%edx, %r8d
   29d12: 72 f4                        	jb	0x29d08 <btf_dedup_ref_type+0x578>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   29d14: 29 d1                        	subl	%edx, %ecx
   29d16: 48 8b 50 30                  	movq	48(%rax), %rdx
   29d1a: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   29d1d: 48 03 70 20                  	addq	32(%rax), %rsi
; 			if (btf_equal_array(t, cand)) {
   29d21: 48 89 ef                     	movq	%rbp, %rdi
   29d24: e8 97 f3 ff ff               	callq	0x290c0 <btf_equal_array>
   29d29: 84 c0                        	testb	%al, %al
   29d2b: 74 a3                        	je	0x29cd0 <btf_dedup_ref_type+0x540>
   29d2d: 0f 1f 00                     	nopl	(%rax)
; 	d->map[type_id] = new_id;
   29d30: 49 8b 46 18                  	movq	24(%r14), %rax
   29d34: 46 89 04 a8                  	movl	%r8d, (%rax,%r13,4)
; 	if (type_id == new_id && btf_dedup_table_add(d, h, type_id))
   29d38: 41 39 d8                     	cmpl	%ebx, %r8d
   29d3b: 74 55                        	je	0x29d92 <btf_dedup_ref_type+0x602>
; }
   29d3d: 48 83 c4 18                  	addq	$24, %rsp
; 	return new_id;
   29d41: 44 89 c0                     	movl	%r8d, %eax
; }
   29d44: 5b                           	popq	%rbx
   29d45: 5d                           	popq	%rbp
   29d46: 41 5c                        	popq	%r12
   29d48: 41 5d                        	popq	%r13
   29d4a: 41 5e                        	popq	%r14
   29d4c: 41 5f                        	popq	%r15
   29d4e: c3                           	retq
   29d4f: 90                           	nop
   29d50: 4d 8b 56 10                  	movq	16(%r14), %r10
; 	d->map[type_id] = new_id;
   29d54: 49 8b 46 18                  	movq	24(%r14), %rax
   29d58: 42 89 1c a8                  	movl	%ebx, (%rax,%r13,4)
; 	return hashmap__insert(map, key, value, HASHMAP_APPEND, NULL, NULL);
   29d5c: 45 31 c9                     	xorl	%r9d, %r9d
   29d5f: 45 31 c0                     	xorl	%r8d, %r8d
   29d62: b9 03 00 00 00               	movl	$3, %ecx
   29d67: 4c 89 ea                     	movq	%r13, %rdx
   29d6a: 4c 89 e6                     	movq	%r12, %rsi
   29d6d: 4c 89 d7                     	movq	%r10, %rdi
   29d70: e8 9b 47 ff ff               	callq	0x1e510 <hashmap__insert>
; 	if (type_id == new_id && btf_dedup_table_add(d, h, type_id))
   29d75: 85 c0                        	testl	%eax, %eax
   29d77: 75 0f                        	jne	0x29d88 <btf_dedup_ref_type+0x5f8>
   29d79: 41 89 d8                     	movl	%ebx, %r8d
   29d7c: eb bf                        	jmp	0x29d3d <btf_dedup_ref_type+0x5ad>
; 		return -ELOOP;
   29d7e: b8 d8 ff ff ff               	movl	$4294967256, %eax       # imm = 0xFFFFFFD8
   29d83: e9 49 fa ff ff               	jmp	0x297d1 <btf_dedup_ref_type+0x41>
; 		return -ENOMEM;
   29d88: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   29d8d: e9 3f fa ff ff               	jmp	0x297d1 <btf_dedup_ref_type+0x41>
   29d92: 4d 8b 56 10                  	movq	16(%r14), %r10
   29d96: eb c4                        	jmp	0x29d5c <btf_dedup_ref_type+0x5cc>
   29d98: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

0000000000029da0 <libbpf_add_mem>:
; {
   29da0: f3 0f 1e fa                  	endbr64
   29da4: 41 57                        	pushq	%r15
; 	if (cur_cnt + add_cnt <= *cap_cnt)
   29da6: 49 01 c9                     	addq	%rcx, %r9
; {
   29da9: 49 89 cf                     	movq	%rcx, %r15
   29dac: 41 56                        	pushq	%r14
   29dae: 49 89 fe                     	movq	%rdi, %r14
   29db1: 41 55                        	pushq	%r13
   29db3: 41 54                        	pushq	%r12
   29db5: 49 89 d4                     	movq	%rdx, %r12
   29db8: 55                           	pushq	%rbp
   29db9: 53                           	pushq	%rbx
   29dba: 48 83 ec 08                  	subq	$8, %rsp
; 	if (cur_cnt + add_cnt <= *cap_cnt)
   29dbe: 48 8b 06                     	movq	(%rsi), %rax
   29dc1: 49 39 c1                     	cmpq	%rax, %r9
   29dc4: 0f 86 8e 00 00 00            	jbe	0x29e58 <libbpf_add_mem+0xb8>
; 	if (cur_cnt + add_cnt > max_cnt)
   29dca: 4d 39 c1                     	cmpq	%r8, %r9
   29dcd: 0f 87 a5 00 00 00            	ja	0x29e78 <libbpf_add_mem+0xd8>
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   29dd3: 48 89 c2                     	movq	%rax, %rdx
   29dd6: 49 89 f5                     	movq	%rsi, %r13
; 	new_data = libbpf_reallocarray(*data, new_cnt, elem_sz);
   29dd9: 48 8b 3f                     	movq	(%rdi), %rdi
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   29ddc: 48 c1 ea 02                  	shrq	$2, %rdx
   29de0: 48 01 c2                     	addq	%rax, %rdx
   29de3: b8 10 00 00 00               	movl	$16, %eax
   29de8: 48 39 c2                     	cmpq	%rax, %rdx
   29deb: 48 0f 42 d0                  	cmovbq	%rax, %rdx
   29def: 4c 39 c2                     	cmpq	%r8, %rdx
   29df2: 49 0f 47 d0                  	cmovaq	%r8, %rdx
   29df6: 4c 39 ca                     	cmpq	%r9, %rdx
   29df9: 4c 0f 43 ca                  	cmovaeq	%rdx, %r9
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   29dfd: 4c 89 c8                     	movq	%r9, %rax
   29e00: 4c 89 cd                     	movq	%r9, %rbp
   29e03: 49 f7 e4                     	mulq	%r12
   29e06: 48 89 c6                     	movq	%rax, %rsi
   29e09: 70 6d                        	jo	0x29e78 <libbpf_add_mem+0xd8>
; 	return realloc(ptr, total);
   29e0b: e8 10 bd fd ff               	callq	0x5b20 <.plt.sec+0x4b0>
   29e10: 48 89 c3                     	movq	%rax, %rbx
; 	if (!new_data)
   29e13: 48 85 c0                     	testq	%rax, %rax
   29e16: 74 60                        	je	0x29e78 <libbpf_add_mem+0xd8>
; 	memset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);
   29e18: 49 8b 7d 00                  	movq	(%r13), %rdi
   29e1c: 48 89 ea                     	movq	%rbp, %rdx
; 	return new_data + cur_cnt * elem_sz;
   29e1f: 4d 0f af fc                  	imulq	%r12, %r15
;   return __builtin___memset_chk (__dest, __ch, __len,
   29e23: 31 f6                        	xorl	%esi, %esi
; 	memset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);
   29e25: 48 29 fa                     	subq	%rdi, %rdx
   29e28: 49 0f af fc                  	imulq	%r12, %rdi
   29e2c: 49 0f af d4                  	imulq	%r12, %rdx
   29e30: 48 01 c7                     	addq	%rax, %rdi
;   return __builtin___memset_chk (__dest, __ch, __len,
   29e33: e8 88 ba fd ff               	callq	0x58c0 <.plt.sec+0x250>
; 	*data = new_data;
   29e38: 49 89 1e                     	movq	%rbx, (%r14)
; 	return new_data + cur_cnt * elem_sz;
   29e3b: 4a 8d 04 3b                  	leaq	(%rbx,%r15), %rax
; 	*cap_cnt = new_cnt;
   29e3f: 49 89 6d 00                  	movq	%rbp, (%r13)
; }
   29e43: 48 83 c4 08                  	addq	$8, %rsp
   29e47: 5b                           	popq	%rbx
   29e48: 5d                           	popq	%rbp
   29e49: 41 5c                        	popq	%r12
   29e4b: 41 5d                        	popq	%r13
   29e4d: 41 5e                        	popq	%r14
   29e4f: 41 5f                        	popq	%r15
   29e51: c3                           	retq
   29e52: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return *data + cur_cnt * elem_sz;
   29e58: 48 89 c8                     	movq	%rcx, %rax
   29e5b: 48 0f af c2                  	imulq	%rdx, %rax
   29e5f: 48 03 07                     	addq	(%rdi), %rax
; }
   29e62: 48 83 c4 08                  	addq	$8, %rsp
   29e66: 5b                           	popq	%rbx
   29e67: 5d                           	popq	%rbp
   29e68: 41 5c                        	popq	%r12
   29e6a: 41 5d                        	popq	%r13
   29e6c: 41 5e                        	popq	%r14
   29e6e: 41 5f                        	popq	%r15
   29e70: c3                           	retq
   29e71: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   29e78: 48 83 c4 08                  	addq	$8, %rsp
; 		return NULL;
   29e7c: 31 c0                        	xorl	%eax, %eax
; }
   29e7e: 5b                           	popq	%rbx
   29e7f: 5d                           	popq	%rbp
   29e80: 41 5c                        	popq	%r12
   29e82: 41 5d                        	popq	%r13
   29e84: 41 5e                        	popq	%r14
   29e86: 41 5f                        	popq	%r15
   29e88: c3                           	retq
   29e89: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000029e90 <libbpf_ensure_mem>:
; {
   29e90: f3 0f 1e fa                  	endbr64
   29e94: 41 57                        	pushq	%r15
; 		return 0;
   29e96: 45 31 ff                     	xorl	%r15d, %r15d
; {
   29e99: 41 56                        	pushq	%r14
   29e9b: 41 55                        	pushq	%r13
   29e9d: 41 54                        	pushq	%r12
   29e9f: 55                           	pushq	%rbp
   29ea0: 53                           	pushq	%rbx
   29ea1: 48 83 ec 08                  	subq	$8, %rsp
; 	if (need_cnt <= *cap_cnt)
   29ea5: 48 8b 06                     	movq	(%rsi), %rax
   29ea8: 48 39 c8                     	cmpq	%rcx, %rax
   29eab: 72 13                        	jb	0x29ec0 <libbpf_ensure_mem+0x30>
; }
   29ead: 48 83 c4 08                  	addq	$8, %rsp
   29eb1: 44 89 f8                     	movl	%r15d, %eax
   29eb4: 5b                           	popq	%rbx
   29eb5: 5d                           	popq	%rbp
   29eb6: 41 5c                        	popq	%r12
   29eb8: 41 5d                        	popq	%r13
   29eba: 41 5e                        	popq	%r14
   29ebc: 41 5f                        	popq	%r15
   29ebe: c3                           	retq
   29ebf: 90                           	nop
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   29ec0: 48 89 c5                     	movq	%rax, %rbp
   29ec3: 48 89 d3                     	movq	%rdx, %rbx
; 	p = libbpf_add_mem(data, cap_cnt, elem_sz, *cap_cnt, SIZE_MAX, need_cnt - *cap_cnt);
   29ec6: 49 89 fd                     	movq	%rdi, %r13
   29ec9: 49 89 f4                     	movq	%rsi, %r12
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   29ecc: 48 c1 ed 02                  	shrq	$2, %rbp
; 	new_data = libbpf_reallocarray(*data, new_cnt, elem_sz);
   29ed0: 48 8b 3f                     	movq	(%rdi), %rdi
; 	new_cnt += new_cnt / 4;		  /* expand by 25% */
   29ed3: 48 01 c5                     	addq	%rax, %rbp
   29ed6: b8 10 00 00 00               	movl	$16, %eax
   29edb: 48 39 c1                     	cmpq	%rax, %rcx
   29ede: 48 0f 42 c8                  	cmovbq	%rax, %rcx
   29ee2: 48 39 cd                     	cmpq	%rcx, %rbp
   29ee5: 48 0f 42 e9                  	cmovbq	%rcx, %rbp
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   29ee9: 48 89 e8                     	movq	%rbp, %rax
   29eec: 48 f7 e3                     	mulq	%rbx
   29eef: 48 89 c6                     	movq	%rax, %rsi
   29ef2: 70 34                        	jo	0x29f28 <libbpf_ensure_mem+0x98>
; 	return realloc(ptr, total);
   29ef4: e8 27 bc fd ff               	callq	0x5b20 <.plt.sec+0x4b0>
   29ef9: 49 89 c6                     	movq	%rax, %r14
; 	if (!new_data)
   29efc: 48 85 c0                     	testq	%rax, %rax
   29eff: 74 27                        	je	0x29f28 <libbpf_ensure_mem+0x98>
; 	memset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);
   29f01: 49 8b 04 24                  	movq	(%r12), %rax
   29f05: 48 89 ea                     	movq	%rbp, %rdx
;   return __builtin___memset_chk (__dest, __ch, __len,
   29f08: 31 f6                        	xorl	%esi, %esi
; 	memset(new_data + (*cap_cnt) * elem_sz, 0, (new_cnt - *cap_cnt) * elem_sz);
   29f0a: 48 29 c2                     	subq	%rax, %rdx
   29f0d: 48 0f af d3                  	imulq	%rbx, %rdx
   29f11: 48 0f af d8                  	imulq	%rax, %rbx
   29f15: 49 8d 3c 1e                  	leaq	(%r14,%rbx), %rdi
;   return __builtin___memset_chk (__dest, __ch, __len,
   29f19: e8 a2 b9 fd ff               	callq	0x58c0 <.plt.sec+0x250>
; 	*data = new_data;
   29f1e: 4d 89 75 00                  	movq	%r14, (%r13)
; 	*cap_cnt = new_cnt;
   29f22: 49 89 2c 24                  	movq	%rbp, (%r12)
; 	if (!p)
   29f26: eb 85                        	jmp	0x29ead <libbpf_ensure_mem+0x1d>
; 		return -ENOMEM;
   29f28: 41 bf f4 ff ff ff            	movl	$4294967284, %r15d      # imm = 0xFFFFFFF4
   29f2e: e9 7a ff ff ff               	jmp	0x29ead <libbpf_ensure_mem+0x1d>
   29f33: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   29f3e: 66 90                        	nop

0000000000029f40 <btf__type_cnt>:
; {
   29f40: f3 0f 1e fa                  	endbr64
; 	return btf->start_id + btf->nr_types;
   29f44: 8b 47 50                     	movl	80(%rdi), %eax
   29f47: 03 47 40                     	addl	64(%rdi), %eax
; }
   29f4a: c3                           	retq
   29f4b: 0f 1f 44 00 00               	nopl	(%rax,%rax)

0000000000029f50 <btf__base_btf>:
; {
   29f50: f3 0f 1e fa                  	endbr64
; 	return btf->base_btf;
   29f54: 48 8b 47 48                  	movq	72(%rdi), %rax
; }
   29f58: c3                           	retq
   29f59: 0f 1f 80 00 00 00 00         	nopl	(%rax)

0000000000029f60 <btf_type_by_id>:
; {
   29f60: f3 0f 1e fa                  	endbr64
; 		return &btf_void;
   29f64: 48 8d 05 25 d3 01 00         	leaq	119589(%rip), %rax      # 0x47290 <btf_void>
; 	if (type_id == 0)
   29f6b: 85 f6                        	testl	%esi, %esi
   29f6d: 75 0d                        	jne	0x29f7c <btf_type_by_id+0x1c>
   29f6f: eb 1f                        	jmp	0x29f90 <btf_type_by_id+0x30>
   29f71: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   29f78: 48 8b 7f 48                  	movq	72(%rdi), %rdi
; 	if (type_id < btf->start_id)
   29f7c: 8b 47 50                     	movl	80(%rdi), %eax
   29f7f: 39 f0                        	cmpl	%esi, %eax
   29f81: 77 f5                        	ja	0x29f78 <btf_type_by_id+0x18>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   29f83: 29 c6                        	subl	%eax, %esi
   29f85: 48 8b 47 30                  	movq	48(%rdi), %rax
   29f89: 8b 04 b0                     	movl	(%rax,%rsi,4), %eax
   29f8c: 48 03 47 20                  	addq	32(%rdi), %rax
; }
   29f90: c3                           	retq
   29f91: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   29f9c: 0f 1f 40 00                  	nopl	(%rax)

0000000000029fa0 <btf__type_by_id>:
; {
   29fa0: f3 0f 1e fa                  	endbr64
; 	if (type_id >= btf->start_id + btf->nr_types)
   29fa4: 8b 57 50                     	movl	80(%rdi), %edx
   29fa7: 8b 47 40                     	movl	64(%rdi), %eax
   29faa: 01 d0                        	addl	%edx, %eax
   29fac: 39 f0                        	cmpl	%esi, %eax
   29fae: 76 30                        	jbe	0x29fe0 <btf__type_by_id+0x40>
; 		return &btf_void;
   29fb0: 48 8d 05 d9 d2 01 00         	leaq	119513(%rip), %rax      # 0x47290 <btf_void>
; 	if (type_id == 0)
   29fb7: 85 f6                        	testl	%esi, %esi
   29fb9: 75 0c                        	jne	0x29fc7 <btf__type_by_id+0x27>
   29fbb: eb 1c                        	jmp	0x29fd9 <btf__type_by_id+0x39>
   29fbd: 0f 1f 00                     	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   29fc0: 48 8b 7f 48                  	movq	72(%rdi), %rdi
; 	if (type_id < btf->start_id)
   29fc4: 8b 57 50                     	movl	80(%rdi), %edx
   29fc7: 39 d6                        	cmpl	%edx, %esi
   29fc9: 72 f5                        	jb	0x29fc0 <btf__type_by_id+0x20>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   29fcb: 48 8b 47 30                  	movq	48(%rdi), %rax
   29fcf: 29 d6                        	subl	%edx, %esi
   29fd1: 8b 04 b0                     	movl	(%rax,%rsi,4), %eax
   29fd4: 48 03 47 20                  	addq	32(%rdi), %rax
   29fd8: c3                           	retq
; }
   29fd9: c3                           	retq
   29fda: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; {
   29fe0: 48 83 ec 08                  	subq	$8, %rsp
; 		return errno = EINVAL, NULL;
   29fe4: e8 07 b7 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   29fe9: c7 00 16 00 00 00            	movl	$22, (%rax)
   29fef: 31 c0                        	xorl	%eax, %eax
; }
   29ff1: 48 83 c4 08                  	addq	$8, %rsp
   29ff5: c3                           	retq
   29ff6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000002a000 <btf_dedup_is_equiv>:
; {
   2a000: 41 57                        	pushq	%r15
   2a002: 41 56                        	pushq	%r14
   2a004: 41 89 f6                     	movl	%esi, %r14d
   2a007: 41 55                        	pushq	%r13
; 	switch (cand_kind) {
   2a009: 4c 8d 2d 2c 1a 01 00         	leaq	72236(%rip), %r13       # 0x3ba3c <CSWTCH.126+0x213c>
; {
   2a010: 41 54                        	pushq	%r12
; 		return &btf_void;
   2a012: 4c 8d 25 77 d2 01 00         	leaq	119415(%rip), %r12      # 0x47290 <btf_void>
; {
   2a019: 55                           	pushq	%rbp
   2a01a: 48 89 fd                     	movq	%rdi, %rbp
   2a01d: 53                           	pushq	%rbx
   2a01e: 89 d3                        	movl	%edx, %ebx
   2a020: 48 83 ec 28                  	subq	$40, %rsp
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2a024: 48 8b 75 18                  	movq	24(%rbp), %rsi
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2a028: 44 89 f0                     	movl	%r14d, %eax
   2a02b: eb 07                        	jmp	0x2a034 <btf_dedup_is_equiv+0x34>
   2a02d: 0f 1f 00                     	nopl	(%rax)
   2a030: 85 c0                        	testl	%eax, %eax
   2a032: 78 0c                        	js	0x2a040 <btf_dedup_is_equiv+0x40>
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2a034: 89 c0                        	movl	%eax, %eax
   2a036: 48 89 c2                     	movq	%rax, %rdx
   2a039: 8b 04 86                     	movl	(%rsi,%rax,4), %eax
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2a03c: 39 d0                        	cmpl	%edx, %eax
   2a03e: 75 f0                        	jne	0x2a030 <btf_dedup_is_equiv+0x30>
   2a040: 89 d8                        	movl	%ebx, %eax
   2a042: eb 08                        	jmp	0x2a04c <btf_dedup_is_equiv+0x4c>
   2a044: 0f 1f 40 00                  	nopl	(%rax)
   2a048: 85 c0                        	testl	%eax, %eax
   2a04a: 78 0c                        	js	0x2a058 <btf_dedup_is_equiv+0x58>
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2a04c: 89 c0                        	movl	%eax, %eax
   2a04e: 48 89 c1                     	movq	%rax, %rcx
   2a051: 8b 04 86                     	movl	(%rsi,%rax,4), %eax
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2a054: 39 c1                        	cmpl	%eax, %ecx
   2a056: 75 f0                        	jne	0x2a048 <btf_dedup_is_equiv+0x48>
; 	if (resolve_type_id(d, cand_id) == resolve_type_id(d, canon_id))
   2a058: 39 d1                        	cmpl	%edx, %ecx
   2a05a: 0f 84 ca 02 00 00            	je	0x2a32a <btf_dedup_is_equiv+0x32a>
; 	if (!btf_is_fwd(btf__type_by_id(d->btf, type_id)))
   2a060: 4c 8b 7d 00                  	movq	(%rbp), %r15
; 	if (type_id >= btf->start_id + btf->nr_types)
   2a064: 41 8b 57 50                  	movl	80(%r15), %edx
   2a068: 41 8b 47 40                  	movl	64(%r15), %eax
   2a06c: 01 d0                        	addl	%edx, %eax
   2a06e: 39 c3                        	cmpl	%eax, %ebx
   2a070: 0f 83 48 bc fd ff            	jae	0x5cbe <btf_dedup_is_equiv.cold>
; 		return &btf_void;
   2a076: 4c 89 e0                     	movq	%r12, %rax
; 	if (type_id == 0)
   2a079: 85 db                        	testl	%ebx, %ebx
   2a07b: 74 28                        	je	0x2a0a5 <btf_dedup_is_equiv+0xa5>
   2a07d: 4c 89 f8                     	movq	%r15, %rax
   2a080: eb 0d                        	jmp	0x2a08f <btf_dedup_is_equiv+0x8f>
   2a082: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a088: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2a08c: 8b 50 50                     	movl	80(%rax), %edx
   2a08f: 39 d3                        	cmpl	%edx, %ebx
   2a091: 72 f5                        	jb	0x2a088 <btf_dedup_is_equiv+0x88>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a093: 89 d9                        	movl	%ebx, %ecx
   2a095: 29 d1                        	subl	%edx, %ecx
   2a097: 48 8b 50 30                  	movq	48(%rax), %rdx
   2a09b: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2a09e: 48 03 50 20                  	addq	32(%rax), %rdx
   2a0a2: 48 89 d0                     	movq	%rdx, %rax
; 	return BTF_INFO_KIND(t->info);
   2a0a5: 0f b6 40 07                  	movzbl	7(%rax), %eax
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2a0a9: 41 89 d9                     	movl	%ebx, %r9d
   2a0ac: 49 c1 e1 02                  	shlq	$2, %r9
; 	return BTF_INFO_KIND(t->info);
   2a0b0: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_fwd(btf__type_by_id(d->btf, type_id)))
   2a0b3: 66 83 f8 07                  	cmpw	$7, %ax
   2a0b7: 0f 84 23 01 00 00            	je	0x2a1e0 <btf_dedup_is_equiv+0x1e0>
; 	hypot_type_id = d->hypot_map[canon_id];
   2a0bd: 48 8b 55 20                  	movq	32(%rbp), %rdx
   2a0c1: 4c 01 ca                     	addq	%r9, %rdx
   2a0c4: 44 8b 02                     	movl	(%rdx), %r8d
; 	if (hypot_type_id <= BTF_MAX_NR_TYPES) {
   2a0c7: 45 85 c0                     	testl	%r8d, %r8d
   2a0ca: 0f 89 e8 03 00 00            	jns	0x2a4b8 <btf_dedup_is_equiv+0x4b8>
; 	if (d->hypot_cnt == d->hypot_cap) {
   2a0d0: 48 8b 45 30                  	movq	48(%rbp), %rax
; 		new_list = libbpf_reallocarray(d->hypot_list, d->hypot_cap, sizeof(__u32));
   2a0d4: 48 8b 7d 28                  	movq	40(%rbp), %rdi
; 	if (d->hypot_cnt == d->hypot_cap) {
   2a0d8: 48 3b 45 38                  	cmpq	56(%rbp), %rax
   2a0dc: 0f 84 5e 01 00 00            	je	0x2a240 <btf_dedup_is_equiv+0x240>
; 	d->hypot_list[d->hypot_cnt++] = from_id;
   2a0e2: 48 8d 48 01                  	leaq	1(%rax), %rcx
; 		return &btf_void;
   2a0e6: 4d 89 e0                     	movq	%r12, %r8
; 	d->hypot_list[d->hypot_cnt++] = from_id;
   2a0e9: 48 89 4d 30                  	movq	%rcx, 48(%rbp)
   2a0ed: 89 1c 87                     	movl	%ebx, (%rdi,%rax,4)
; 	d->hypot_map[from_id] = to_id;
   2a0f0: 44 89 32                     	movl	%r14d, (%rdx)
; 	if (type_id == 0)
   2a0f3: 45 85 f6                     	testl	%r14d, %r14d
   2a0f6: 74 23                        	je	0x2a11b <btf_dedup_is_equiv+0x11b>
   2a0f8: 4c 89 f8                     	movq	%r15, %rax
   2a0fb: eb 07                        	jmp	0x2a104 <btf_dedup_is_equiv+0x104>
   2a0fd: 0f 1f 00                     	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a100: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2a104: 8b 50 50                     	movl	80(%rax), %edx
   2a107: 41 39 d6                     	cmpl	%edx, %r14d
   2a10a: 72 f4                        	jb	0x2a100 <btf_dedup_is_equiv+0x100>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a10c: 41 29 d6                     	subl	%edx, %r14d
   2a10f: 48 8b 50 30                  	movq	48(%rax), %rdx
   2a113: 46 8b 04 b2                  	movl	(%rdx,%r14,4), %r8d
   2a117: 4c 03 40 20                  	addq	32(%rax), %r8
; 		return &btf_void;
   2a11b: 4d 89 e6                     	movq	%r12, %r14
; 	if (type_id == 0)
   2a11e: 85 db                        	testl	%ebx, %ebx
   2a120: 74 29                        	je	0x2a14b <btf_dedup_is_equiv+0x14b>
   2a122: 4c 89 f8                     	movq	%r15, %rax
   2a125: eb 0d                        	jmp	0x2a134 <btf_dedup_is_equiv+0x134>
   2a127: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a130: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2a134: 8b 50 50                     	movl	80(%rax), %edx
   2a137: 39 d3                        	cmpl	%edx, %ebx
   2a139: 72 f5                        	jb	0x2a130 <btf_dedup_is_equiv+0x130>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a13b: 89 d9                        	movl	%ebx, %ecx
   2a13d: 29 d1                        	subl	%edx, %ecx
   2a13f: 48 8b 50 30                  	movq	48(%rax), %rdx
   2a143: 44 8b 34 8a                  	movl	(%rdx,%rcx,4), %r14d
   2a147: 4c 03 70 20                  	addq	32(%rax), %r14
; 	return BTF_INFO_KIND(t->info);
   2a14b: 45 8b 48 04                  	movl	4(%r8), %r9d
   2a14f: 41 8b 4e 04                  	movl	4(%r14), %ecx
; 	if (cand_type->name_off != canon_type->name_off)
   2a153: 41 8b 3e                     	movl	(%r14), %edi
; 	return BTF_INFO_KIND(t->info);
   2a156: 44 89 c8                     	movl	%r9d, %eax
   2a159: 89 ca                        	movl	%ecx, %edx
   2a15b: c1 e8 18                     	shrl	$24, %eax
   2a15e: c1 ea 18                     	shrl	$24, %edx
   2a161: 83 e0 1f                     	andl	$31, %eax
   2a164: 83 e2 1f                     	andl	$31, %edx
; 	if (cand_type->name_off != canon_type->name_off)
   2a167: 41 39 38                     	cmpl	%edi, (%r8)
   2a16a: 0f 85 39 01 00 00            	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	if ((cand_kind == BTF_KIND_FWD || canon_kind == BTF_KIND_FWD)
   2a170: 66 83 f8 07                  	cmpw	$7, %ax
   2a174: 74 2a                        	je	0x2a1a0 <btf_dedup_is_equiv+0x1a0>
   2a176: 66 83 fa 07                  	cmpw	$7, %dx
   2a17a: 74 24                        	je	0x2a1a0 <btf_dedup_is_equiv+0x1a0>
; 	if (cand_kind != canon_kind)
   2a17c: 66 39 d0                     	cmpw	%dx, %ax
   2a17f: 0f 85 24 01 00 00            	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	switch (cand_kind) {
   2a185: 66 83 f8 13                  	cmpw	$19, %ax
   2a189: 0f 87 a9 01 00 00            	ja	0x2a338 <btf_dedup_is_equiv+0x338>
   2a18f: 0f b7 c0                     	movzwl	%ax, %eax
   2a192: 49 63 44 85 00               	movslq	(%r13,%rax,4), %rax
   2a197: 4c 01 e8                     	addq	%r13, %rax
   2a19a: 3e ff e0                     	jmpq	*%rax
   2a19d: 0f 1f 00                     	nopl	(%rax)
; 	    && cand_kind != canon_kind) {
   2a1a0: 66 39 d0                     	cmpw	%dx, %ax
   2a1a3: 74 e0                        	je	0x2a185 <btf_dedup_is_equiv+0x185>
; 		if (cand_kind == BTF_KIND_FWD) {
   2a1a5: 66 83 f8 07                  	cmpw	$7, %ax
   2a1a9: 0f 84 7b 04 00 00            	je	0x2a62a <btf_dedup_is_equiv+0x62a>
; 	return BTF_INFO_KFLAG(t->info);
   2a1af: c1 e9 1f                     	shrl	$31, %ecx
   2a1b2: 45 31 d2                     	xorl	%r10d, %r10d
   2a1b5: 89 ca                        	movl	%ecx, %edx
; 	return btf_kflag(t) ? BTF_KIND_UNION : BTF_KIND_STRUCT;
   2a1b7: 83 c2 04                     	addl	$4, %edx
; 			if (fwd_kind == real_kind && canon_id < d->btf->start_id)
   2a1ba: 66 39 d0                     	cmpw	%dx, %ax
   2a1bd: 0f 85 e9 00 00 00            	jne	0x2a2ac <btf_dedup_is_equiv+0x2ac>
   2a1c3: 41 ba 01 00 00 00            	movl	$1, %r10d
   2a1c9: 41 39 5f 50                  	cmpl	%ebx, 80(%r15)
   2a1cd: 0f 86 d9 00 00 00            	jbe	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 				d->hypot_adjust_canon = true;
   2a1d3: c6 45 40 01                  	movb	$1, 64(%rbp)
   2a1d7: e9 d0 00 00 00               	jmp	0x2a2ac <btf_dedup_is_equiv+0x2ac>
   2a1dc: 0f 1f 40 00                  	nopl	(%rax)
   2a1e0: 89 d8                        	movl	%ebx, %eax
   2a1e2: eb 08                        	jmp	0x2a1ec <btf_dedup_is_equiv+0x1ec>
   2a1e4: 0f 1f 40 00                  	nopl	(%rax)
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2a1e8: 39 c1                        	cmpl	%eax, %ecx
   2a1ea: 74 13                        	je	0x2a1ff <btf_dedup_is_equiv+0x1ff>
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2a1ec: 89 c2                        	movl	%eax, %edx
   2a1ee: 89 c1                        	movl	%eax, %ecx
   2a1f0: 8b 04 96                     	movl	(%rsi,%rdx,4), %eax
   2a1f3: 4c 8d 04 95 00 00 00 00      	leaq	(,%rdx,4), %r8
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2a1fb: 85 c0                        	testl	%eax, %eax
   2a1fd: 79 e9                        	jns	0x2a1e8 <btf_dedup_is_equiv+0x1e8>
; 	if (!btf_is_fwd(btf__type_by_id(d->btf, type_id)))
   2a1ff: 89 ce                        	movl	%ecx, %esi
   2a201: 4c 89 ff                     	movq	%r15, %rdi
   2a204: 4c 89 4c 24 18               	movq	%r9, 24(%rsp)
   2a209: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
   2a20e: 89 4c 24 08                  	movl	%ecx, 8(%rsp)
   2a212: e8 89 fd ff ff               	callq	0x29fa0 <btf__type_by_id>
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2a217: 4c 8b 44 24 10               	movq	16(%rsp), %r8
   2a21c: 4c 8b 4c 24 18               	movq	24(%rsp), %r9
; 	return BTF_INFO_KIND(t->info);
   2a221: 0f b6 40 07                  	movzbl	7(%rax), %eax
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2a225: 8b 4c 24 08                  	movl	8(%rsp), %ecx
; 	return BTF_INFO_KIND(t->info);
   2a229: 83 e0 1f                     	andl	$31, %eax
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2a22c: 66 83 f8 07                  	cmpw	$7, %ax
   2a230: 4d 0f 45 c8                  	cmovneq	%r8, %r9
   2a234: 0f 45 d9                     	cmovnel	%ecx, %ebx
   2a237: e9 81 fe ff ff               	jmp	0x2a0bd <btf_dedup_is_equiv+0xbd>
   2a23c: 0f 1f 40 00                  	nopl	(%rax)
; 		d->hypot_cap += max((size_t)16, d->hypot_cap / 2);
   2a240: 48 89 c2                     	movq	%rax, %rdx
   2a243: b9 10 00 00 00               	movl	$16, %ecx
   2a248: 4c 89 4c 24 08               	movq	%r9, 8(%rsp)
   2a24d: 48 d1 ea                     	shrq	%rdx
   2a250: 48 39 ca                     	cmpq	%rcx, %rdx
   2a253: 48 0f 42 d1                  	cmovbq	%rcx, %rdx
   2a257: 48 01 c2                     	addq	%rax, %rdx
   2a25a: 48 89 55 38                  	movq	%rdx, 56(%rbp)
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   2a25e: 48 8d 34 95 00 00 00 00      	leaq	(,%rdx,4), %rsi
   2a266: 48 c1 ea 3e                  	shrq	$62, %rdx
   2a26a: 0f 85 3d 02 00 00            	jne	0x2a4ad <btf_dedup_is_equiv+0x4ad>
; 	return realloc(ptr, total);
   2a270: e8 ab b8 fd ff               	callq	0x5b20 <.plt.sec+0x4b0>
; 		if (!new_list)
   2a275: 4c 8b 4c 24 08               	movq	8(%rsp), %r9
   2a27a: 48 85 c0                     	testq	%rax, %rax
; 	return realloc(ptr, total);
   2a27d: 48 89 c7                     	movq	%rax, %rdi
; 		if (!new_list)
   2a280: 0f 84 27 02 00 00            	je	0x2a4ad <btf_dedup_is_equiv+0x4ad>
; 	d->hypot_map[from_id] = to_id;
   2a286: 48 8b 55 20                  	movq	32(%rbp), %rdx
; 	cand_type = btf_type_by_id(d->btf, cand_id);
   2a28a: 4c 8b 7d 00                  	movq	(%rbp), %r15
; 		d->hypot_list = new_list;
   2a28e: 48 89 45 28                  	movq	%rax, 40(%rbp)
; 	d->hypot_list[d->hypot_cnt++] = from_id;
   2a292: 48 8b 45 30                  	movq	48(%rbp), %rax
; 	d->hypot_map[from_id] = to_id;
   2a296: 4c 01 ca                     	addq	%r9, %rdx
   2a299: e9 44 fe ff ff               	jmp	0x2a0e2 <btf_dedup_is_equiv+0xe2>
   2a29e: 66 90                        	nop
; 	return t1->name_off == t2->name_off &&
   2a2a0: 41 39 c9                     	cmpl	%ecx, %r9d
   2a2a3: 0f 84 8a 01 00 00            	je	0x2a433 <btf_dedup_is_equiv+0x433>
; 	       t1->info == t2->info &&
   2a2a9: 45 31 d2                     	xorl	%r10d, %r10d
; }
   2a2ac: 48 83 c4 28                  	addq	$40, %rsp
   2a2b0: 44 89 d0                     	movl	%r10d, %eax
   2a2b3: 5b                           	popq	%rbx
   2a2b4: 5d                           	popq	%rbp
   2a2b5: 41 5c                        	popq	%r12
   2a2b7: 41 5d                        	popq	%r13
   2a2b9: 41 5e                        	popq	%r14
   2a2bb: 41 5f                        	popq	%r15
   2a2bd: c3                           	retq
   2a2be: 66 90                        	nop
; 		if (cand_type->info != canon_type->info)
   2a2c0: 41 39 c9                     	cmpl	%ecx, %r9d
   2a2c3: 75 e4                        	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 		return btf_dedup_is_equiv(d, cand_type->type, canon_type->type);
   2a2c5: 41 8b 5e 08                  	movl	8(%r14), %ebx
   2a2c9: 45 8b 70 08                  	movl	8(%r8), %r14d
   2a2cd: e9 52 fd ff ff               	jmp	0x2a024 <btf_dedup_is_equiv+0x24>
   2a2d2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		if (!btf_shallow_equal_struct(cand_type, canon_type))
   2a2d8: 4c 89 f6                     	movq	%r14, %rsi
   2a2db: 4c 89 c7                     	movq	%r8, %rdi
   2a2de: e8 6d ed ff ff               	callq	0x29050 <btf_shallow_equal_struct>
   2a2e3: 84 c0                        	testb	%al, %al
   2a2e5: 74 c2                        	je	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	return (struct btf_member *)(t + 1);
   2a2e7: 4d 8d 60 0c                  	leaq	12(%r8), %r12
   2a2eb: 49 83 c6 0c                  	addq	$12, %r14
; 		for (i = 0; i < vlen; i++) {
   2a2ef: 41 81 e1 ff ff 00 00         	andl	$65535, %r9d            # imm = 0xFFFF
   2a2f6: 74 32                        	je	0x2a32a <btf_dedup_is_equiv+0x32a>
   2a2f8: 41 8d 41 ff                  	leal	-1(%r9), %eax
   2a2fc: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   2a300: 49 8d 5c 80 18               	leaq	24(%r8,%rax,4), %rbx
; 			eq = btf_dedup_is_equiv(d, cand_m->type, canon_m->type);
   2a305: 41 8b 56 04                  	movl	4(%r14), %edx
   2a309: 41 8b 74 24 04               	movl	4(%r12), %esi
   2a30e: 48 89 ef                     	movq	%rbp, %rdi
   2a311: e8 ea fc ff ff               	callq	0x2a000 <btf_dedup_is_equiv>
   2a316: 41 89 c2                     	movl	%eax, %r10d
; 			if (eq <= 0)
   2a319: 85 c0                        	testl	%eax, %eax
   2a31b: 7e 8f                        	jle	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 			cand_m++;
   2a31d: 49 83 c4 0c                  	addq	$12, %r12
; 			canon_m++;
   2a321: 49 83 c6 0c                  	addq	$12, %r14
; 		for (i = 0; i < vlen; i++) {
   2a325: 49 39 dc                     	cmpq	%rbx, %r12
   2a328: 75 db                        	jne	0x2a305 <btf_dedup_is_equiv+0x305>
; 		return 1;
   2a32a: 41 ba 01 00 00 00            	movl	$1, %r10d
   2a330: e9 77 ff ff ff               	jmp	0x2a2ac <btf_dedup_is_equiv+0x2ac>
   2a335: 0f 1f 00                     	nopl	(%rax)
; 	switch (cand_kind) {
   2a338: 41 ba ea ff ff ff            	movl	$4294967274, %r10d      # imm = 0xFFFFFFEA
   2a33e: e9 69 ff ff ff               	jmp	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 		return btf_compat_enum(cand_type, canon_type);
   2a343: 4c 89 f6                     	movq	%r14, %rsi
   2a346: 4c 89 c7                     	movq	%r8, %rdi
   2a349: e8 f2 f1 ff ff               	callq	0x29540 <btf_compat_enum>
   2a34e: 44 0f b6 d0                  	movzbl	%al, %r10d
   2a352: e9 55 ff ff ff               	jmp	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 		return btf_compat_enum64(cand_type, canon_type);
   2a357: 4c 89 f6                     	movq	%r14, %rsi
   2a35a: 4c 89 c7                     	movq	%r8, %rdi
   2a35d: e8 6e f1 ff ff               	callq	0x294d0 <btf_compat_enum64>
   2a362: 44 0f b6 d0                  	movzbl	%al, %r10d
   2a366: e9 41 ff ff ff               	jmp	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 	if (t1->name_off != t2->name_off || t1->info != t2->info)
   2a36b: 41 39 c9                     	cmpl	%ecx, %r9d
   2a36e: 0f 85 35 ff ff ff            	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	return (struct btf_param *)(t + 1);
   2a374: 4d 8d 60 0c                  	leaq	12(%r8), %r12
   2a378: 49 8d 5e 0c                  	leaq	12(%r14), %rbx
; 	for (i = 0; i < vlen; i++) {
   2a37c: 41 81 e1 ff ff 00 00         	andl	$65535, %r9d            # imm = 0xFFFF
   2a383: 0f 84 bd 00 00 00            	je	0x2a446 <btf_dedup_is_equiv+0x446>
   2a389: 44 89 c8                     	movl	%r9d, %eax
   2a38c: 31 d2                        	xorl	%edx, %edx
   2a38e: eb 0d                        	jmp	0x2a39d <btf_dedup_is_equiv+0x39d>
   2a390: 48 83 c2 01                  	addq	$1, %rdx
   2a394: 48 39 d0                     	cmpq	%rdx, %rax
   2a397: 0f 84 a9 00 00 00            	je	0x2a446 <btf_dedup_is_equiv+0x446>
; 		if (m1->name_off != m2->name_off)
   2a39d: 41 8b 7c d6 0c               	movl	12(%r14,%rdx,8), %edi
   2a3a2: 41 39 7c d0 0c               	cmpl	%edi, 12(%r8,%rdx,8)
   2a3a7: 74 e7                        	je	0x2a390 <btf_dedup_is_equiv+0x390>
   2a3a9: e9 fb fe ff ff               	jmp	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	return t1->name_off == t2->name_off &&
   2a3ae: 45 31 d2                     	xorl	%r10d, %r10d
   2a3b1: 41 39 c9                     	cmpl	%ecx, %r9d
   2a3b4: 0f 85 f2 fe ff ff            	jne	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 	       t1->info == t2->info &&
   2a3ba: 41 8b 46 08                  	movl	8(%r14), %eax
   2a3be: 41 39 40 08                  	cmpl	%eax, 8(%r8)
   2a3c2: 0f 85 e4 fe ff ff            	jne	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 	return info1 == info2;
   2a3c8: 45 31 d2                     	xorl	%r10d, %r10d
   2a3cb: 41 8b 46 0c                  	movl	12(%r14), %eax
   2a3cf: 41 39 40 0c                  	cmpl	%eax, 12(%r8)
   2a3d3: 41 0f 94 c2                  	sete	%r10b
   2a3d7: e9 d0 fe ff ff               	jmp	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 	return t1->name_off == t2->name_off &&
   2a3dc: 41 39 c9                     	cmpl	%ecx, %r9d
   2a3df: 0f 85 c4 fe ff ff            	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	       t1->info == t2->info &&
   2a3e5: 41 8b 46 08                  	movl	8(%r14), %eax
   2a3e9: 41 39 40 08                  	cmpl	%eax, 8(%r8)
   2a3ed: 0f 85 b6 fe ff ff            	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 		if (!btf_compat_array(cand_type, canon_type))
   2a3f3: 41 8b 46 14                  	movl	20(%r14), %eax
   2a3f7: 41 39 40 14                  	cmpl	%eax, 20(%r8)
   2a3fb: 0f 85 a8 fe ff ff            	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 		eq = btf_dedup_is_equiv(d, cand_arr->index_type, canon_arr->index_type);
   2a401: 41 8b 56 10                  	movl	16(%r14), %edx
   2a405: 41 8b 70 10                  	movl	16(%r8), %esi
   2a409: 48 89 ef                     	movq	%rbp, %rdi
   2a40c: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
   2a411: e8 ea fb ff ff               	callq	0x2a000 <btf_dedup_is_equiv>
   2a416: 41 89 c2                     	movl	%eax, %r10d
; 		if (eq <= 0)
   2a419: 85 c0                        	testl	%eax, %eax
   2a41b: 0f 8e 8b fe ff ff            	jle	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 		return btf_dedup_is_equiv(d, cand_arr->type, canon_arr->type);
   2a421: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   2a426: 41 8b 5e 0c                  	movl	12(%r14), %ebx
   2a42a: 45 8b 70 0c                  	movl	12(%r8), %r14d
   2a42e: e9 f1 fb ff ff               	jmp	0x2a024 <btf_dedup_is_equiv+0x24>
; 	       t1->info == t2->info &&
   2a433: 41 8b 46 08                  	movl	8(%r14), %eax
   2a437: 41 39 40 08                  	cmpl	%eax, 8(%r8)
   2a43b: 0f 85 68 fe ff ff            	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
   2a441: e9 e4 fe ff ff               	jmp	0x2a32a <btf_dedup_is_equiv+0x32a>
; 		eq = btf_dedup_is_equiv(d, cand_type->type, canon_type->type);
   2a446: 41 8b 70 08                  	movl	8(%r8), %esi
   2a44a: 41 8b 56 08                  	movl	8(%r14), %edx
   2a44e: 48 89 ef                     	movq	%rbp, %rdi
   2a451: 4c 89 44 24 08               	movq	%r8, 8(%rsp)
   2a456: e8 a5 fb ff ff               	callq	0x2a000 <btf_dedup_is_equiv>
; 		if (eq <= 0)
   2a45b: 4c 8b 44 24 08               	movq	8(%rsp), %r8
   2a460: 85 c0                        	testl	%eax, %eax
; 		eq = btf_dedup_is_equiv(d, cand_type->type, canon_type->type);
   2a462: 41 89 c2                     	movl	%eax, %r10d
; 		if (eq <= 0)
   2a465: 0f 8e 41 fe ff ff            	jle	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 		for (i = 0; i < vlen; i++) {
   2a46b: 41 0f b7 40 04               	movzwl	4(%r8), %eax
   2a470: 85 c0                        	testl	%eax, %eax
   2a472: 0f 84 b2 fe ff ff            	je	0x2a32a <btf_dedup_is_equiv+0x32a>
   2a478: 83 e8 01                     	subl	$1, %eax
   2a47b: 4d 8d 6c c6 14               	leaq	20(%r14,%rax,8), %r13
; 			eq = btf_dedup_is_equiv(d, cand_p->type, canon_p->type);
   2a480: 8b 53 04                     	movl	4(%rbx), %edx
   2a483: 41 8b 74 24 04               	movl	4(%r12), %esi
   2a488: 48 89 ef                     	movq	%rbp, %rdi
   2a48b: e8 70 fb ff ff               	callq	0x2a000 <btf_dedup_is_equiv>
   2a490: 41 89 c2                     	movl	%eax, %r10d
; 			if (eq <= 0)
   2a493: 85 c0                        	testl	%eax, %eax
   2a495: 0f 8e 11 fe ff ff            	jle	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 			canon_p++;
   2a49b: 48 83 c3 08                  	addq	$8, %rbx
; 			cand_p++;
   2a49f: 49 83 c4 08                  	addq	$8, %r12
; 		for (i = 0; i < vlen; i++) {
   2a4a3: 4c 39 eb                     	cmpq	%r13, %rbx
   2a4a6: 75 d8                        	jne	0x2a480 <btf_dedup_is_equiv+0x480>
   2a4a8: e9 7d fe ff ff               	jmp	0x2a32a <btf_dedup_is_equiv+0x32a>
; 		return -ENOMEM;
   2a4ad: 41 ba f4 ff ff ff            	movl	$4294967284, %r10d      # imm = 0xFFFFFFF4
   2a4b3: e9 f4 fd ff ff               	jmp	0x2a2ac <btf_dedup_is_equiv+0x2ac>
; 		if (hypot_type_id == cand_id)
   2a4b8: 45 39 c6                     	cmpl	%r8d, %r14d
   2a4bb: 0f 84 69 fe ff ff            	je	0x2a32a <btf_dedup_is_equiv+0x32a>
; 		return &btf_void;
   2a4c1: 48 8d 3d c8 cd 01 00         	leaq	118216(%rip), %rdi      # 0x47290 <btf_void>
; 	if (type_id == 0)
   2a4c8: 45 85 c0                     	testl	%r8d, %r8d
   2a4cb: 74 27                        	je	0x2a4f4 <btf_dedup_is_equiv+0x4f4>
; 	if (!btf_is_fwd(btf__type_by_id(d->btf, type_id)))
   2a4cd: 4c 89 f8                     	movq	%r15, %rax
   2a4d0: eb 0a                        	jmp	0x2a4dc <btf_dedup_is_equiv+0x4dc>
   2a4d2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a4d8: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2a4dc: 8b 50 50                     	movl	80(%rax), %edx
   2a4df: 41 39 d0                     	cmpl	%edx, %r8d
   2a4e2: 72 f4                        	jb	0x2a4d8 <btf_dedup_is_equiv+0x4d8>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a4e4: 44 89 c1                     	movl	%r8d, %ecx
   2a4e7: 29 d1                        	subl	%edx, %ecx
   2a4e9: 48 8b 50 30                  	movq	48(%rax), %rdx
   2a4ed: 8b 3c 8a                     	movl	(%rdx,%rcx,4), %edi
   2a4f0: 48 03 78 20                  	addq	32(%rax), %rdi
; 		return &btf_void;
   2a4f4: 48 8d 35 95 cd 01 00         	leaq	118165(%rip), %rsi      # 0x47290 <btf_void>
; 	if (type_id == 0)
   2a4fb: 45 85 f6                     	testl	%r14d, %r14d
   2a4fe: 74 24                        	je	0x2a524 <btf_dedup_is_equiv+0x524>
; 	if (!btf_is_fwd(btf__type_by_id(d->btf, type_id)))
   2a500: 4c 89 f8                     	movq	%r15, %rax
   2a503: eb 07                        	jmp	0x2a50c <btf_dedup_is_equiv+0x50c>
   2a505: 0f 1f 00                     	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a508: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2a50c: 8b 50 50                     	movl	80(%rax), %edx
   2a50f: 41 39 d6                     	cmpl	%edx, %r14d
   2a512: 72 f4                        	jb	0x2a508 <btf_dedup_is_equiv+0x508>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a514: 44 89 f1                     	movl	%r14d, %ecx
   2a517: 29 d1                        	subl	%edx, %ecx
   2a519: 48 8b 50 30                  	movq	48(%rax), %rdx
   2a51d: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2a520: 48 03 70 20                  	addq	32(%rax), %rsi
; 	return BTF_INFO_KIND(t->info);
   2a524: 0f b6 47 07                  	movzbl	7(%rdi), %eax
   2a528: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_array(t1) || !btf_is_array(t2))
   2a52b: 66 83 f8 03                  	cmpw	$3, %ax
   2a52f: 75 1a                        	jne	0x2a54b <btf_dedup_is_equiv+0x54b>
; 	return BTF_INFO_KIND(t->info);
   2a531: 0f b6 46 07                  	movzbl	7(%rsi), %eax
   2a535: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_array(t1) || !btf_is_array(t2))
   2a538: 66 83 f8 03                  	cmpw	$3, %ax
   2a53c: 75 0d                        	jne	0x2a54b <btf_dedup_is_equiv+0x54b>
; 	return btf_equal_array(t1, t2);
   2a53e: e8 7d eb ff ff               	callq	0x290c0 <btf_equal_array>
; 		if (btf_dedup_identical_arrays(d, hypot_type_id, cand_id))
   2a543: 84 c0                        	testb	%al, %al
   2a545: 0f 85 df fd ff ff            	jne	0x2a32a <btf_dedup_is_equiv+0x32a>
; 		return &btf_void;
   2a54b: 4c 8d 0d 3e cd 01 00         	leaq	118078(%rip), %r9       # 0x47290 <btf_void>
; 	if (type_id == 0)
   2a552: 45 85 c0                     	testl	%r8d, %r8d
   2a555: 74 22                        	je	0x2a579 <btf_dedup_is_equiv+0x579>
; 	if (!btf_is_fwd(btf__type_by_id(d->btf, type_id)))
   2a557: 4c 89 fa                     	movq	%r15, %rdx
   2a55a: eb 04                        	jmp	0x2a560 <btf_dedup_is_equiv+0x560>
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a55c: 48 8b 52 48                  	movq	72(%rdx), %rdx
; 	if (type_id < btf->start_id)
   2a560: 8b 4a 50                     	movl	80(%rdx), %ecx
   2a563: 41 39 c8                     	cmpl	%ecx, %r8d
   2a566: 72 f4                        	jb	0x2a55c <btf_dedup_is_equiv+0x55c>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a568: 44 89 c0                     	movl	%r8d, %eax
   2a56b: 29 c8                        	subl	%ecx, %eax
   2a56d: 48 8b 4a 30                  	movq	48(%rdx), %rcx
   2a571: 44 8b 0c 81                  	movl	(%rcx,%rax,4), %r9d
   2a575: 4c 03 4a 20                  	addq	32(%rdx), %r9
; 		return &btf_void;
   2a579: 4c 8d 05 10 cd 01 00         	leaq	118032(%rip), %r8       # 0x47290 <btf_void>
; 	if (type_id == 0)
   2a580: 45 85 f6                     	testl	%r14d, %r14d
   2a583: 75 0f                        	jne	0x2a594 <btf_dedup_is_equiv+0x594>
   2a585: eb 25                        	jmp	0x2a5ac <btf_dedup_is_equiv+0x5ac>
   2a587: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a590: 4d 8b 7f 48                  	movq	72(%r15), %r15
; 	if (type_id < btf->start_id)
   2a594: 41 8b 47 50                  	movl	80(%r15), %eax
   2a598: 41 39 c6                     	cmpl	%eax, %r14d
   2a59b: 72 f3                        	jb	0x2a590 <btf_dedup_is_equiv+0x590>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a59d: 41 29 c6                     	subl	%eax, %r14d
   2a5a0: 49 8b 47 30                  	movq	48(%r15), %rax
   2a5a4: 46 8b 04 b0                  	movl	(%rax,%r14,4), %r8d
   2a5a8: 4d 03 47 20                  	addq	32(%r15), %r8
; 	return BTF_INFO_KIND(t->info);
   2a5ac: 45 8b 51 04                  	movl	4(%r9), %r10d
   2a5b0: 44 89 d0                     	movl	%r10d, %eax
   2a5b3: c1 e8 18                     	shrl	$24, %eax
   2a5b6: 83 e0 1f                     	andl	$31, %eax
; 	return kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;
   2a5b9: 8d 50 fc                     	leal	-4(%rax), %edx
; 	if (!btf_is_composite(t1) || btf_kind(t1) != btf_kind(t2))
   2a5bc: 66 83 fa 01                  	cmpw	$1, %dx
   2a5c0: 0f 87 e3 fc ff ff            	ja	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	return BTF_INFO_KIND(t->info);
   2a5c6: 41 0f b6 50 07               	movzbl	7(%r8), %edx
   2a5cb: 83 e2 1f                     	andl	$31, %edx
; 	if (!btf_is_composite(t1) || btf_kind(t1) != btf_kind(t2))
   2a5ce: 66 39 d0                     	cmpw	%dx, %ax
   2a5d1: 0f 85 d2 fc ff ff            	jne	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	if (!btf_shallow_equal_struct(t1, t2))
   2a5d7: 4c 89 c6                     	movq	%r8, %rsi
   2a5da: 4c 89 cf                     	movq	%r9, %rdi
   2a5dd: e8 6e ea ff ff               	callq	0x29050 <btf_shallow_equal_struct>
   2a5e2: 84 c0                        	testb	%al, %al
   2a5e4: 0f 84 bf fc ff ff            	je	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	for (i = 0, n = btf_vlen(t1); i < n; i++, m1++, m2++) {
   2a5ea: 41 81 e2 ff ff 00 00         	andl	$65535, %r10d           # imm = 0xFFFF
   2a5f1: 0f 84 33 fd ff ff            	je	0x2a32a <btf_dedup_is_equiv+0x32a>
   2a5f7: 41 8d 42 ff                  	leal	-1(%r10), %eax
   2a5fb: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   2a5ff: 48 8d 14 85 1c 00 00 00      	leaq	28(,%rax,4), %rdx
   2a607: b8 10 00 00 00               	movl	$16, %eax
   2a60c: eb 0d                        	jmp	0x2a61b <btf_dedup_is_equiv+0x61b>
   2a60e: 48 83 c0 0c                  	addq	$12, %rax
   2a612: 48 39 c2                     	cmpq	%rax, %rdx
   2a615: 0f 84 0f fd ff ff            	je	0x2a32a <btf_dedup_is_equiv+0x32a>
; 		if (m1->type != m2->type)
   2a61b: 41 8b 3c 00                  	movl	(%r8,%rax), %edi
   2a61f: 41 39 3c 01                  	cmpl	%edi, (%r9,%rax)
   2a623: 74 e9                        	je	0x2a60e <btf_dedup_is_equiv+0x60e>
   2a625: e9 7f fc ff ff               	jmp	0x2a2a9 <btf_dedup_is_equiv+0x2a9>
; 	return BTF_INFO_KFLAG(t->info);
   2a62a: 44 89 c8                     	movl	%r9d, %eax
; 		return fwd_kind == real_kind;
   2a62d: 45 31 d2                     	xorl	%r10d, %r10d
; 	return BTF_INFO_KFLAG(t->info);
   2a630: c1 e8 1f                     	shrl	$31, %eax
; 	return btf_kflag(t) ? BTF_KIND_UNION : BTF_KIND_STRUCT;
   2a633: 83 c0 04                     	addl	$4, %eax
; 		return fwd_kind == real_kind;
   2a636: 66 39 c2                     	cmpw	%ax, %dx
   2a639: 41 0f 94 c2                  	sete	%r10b
   2a63d: e9 6a fc ff ff               	jmp	0x2a2ac <btf_dedup_is_equiv+0x2ac>
   2a642: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2a64d: 0f 1f 00                     	nopl	(%rax)

000000000002a650 <btf__set_pointer_size>:
; {
   2a650: f3 0f 1e fa                  	endbr64
; 	if (ptr_sz != 4 && ptr_sz != 8)
   2a654: 48 8d 46 fc                  	leaq	-4(%rsi), %rax
   2a658: 48 a9 fb ff ff ff            	testq	$-5, %rax
   2a65e: 75 06                        	jne	0x2a666 <btf__set_pointer_size+0x16>
; 	btf->ptr_sz = ptr_sz;
   2a660: 89 77 70                     	movl	%esi, 112(%rdi)
; 	return 0;
   2a663: 31 c0                        	xorl	%eax, %eax
; }
   2a665: c3                           	retq
; {
   2a666: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   2a66a: e8 81 b0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2a66f: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2a675: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2a67a: 48 83 c4 08                  	addq	$8, %rsp
   2a67e: c3                           	retq
   2a67f: 90                           	nop

000000000002a680 <btf__endianness>:
; {
   2a680: f3 0f 1e fa                  	endbr64
; 		return btf->swapped_endian ? BTF_BIG_ENDIAN : BTF_LITTLE_ENDIAN;
   2a684: 0f b6 47 14                  	movzbl	20(%rdi), %eax
; }
   2a688: c3                           	retq
   2a689: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002a690 <btf__set_endianness>:
; {
   2a690: f3 0f 1e fa                  	endbr64
   2a694: 41 54                        	pushq	%r12
   2a696: 53                           	pushq	%rbx
   2a697: 48 83 ec 08                  	subq	$8, %rsp
; 	if (endian != BTF_LITTLE_ENDIAN && endian != BTF_BIG_ENDIAN)
   2a69b: 83 fe 01                     	cmpl	$1, %esi
   2a69e: 77 3c                        	ja	0x2a6dc <btf__set_endianness+0x4c>
; 	btf->swapped_endian = is_host_big_endian() != (endian == BTF_BIG_ENDIAN);
   2a6a0: 40 88 77 14                  	movb	%sil, 20(%rdi)
   2a6a4: 48 89 fb                     	movq	%rdi, %rbx
; 	return 0;
   2a6a7: 45 31 e4                     	xorl	%r12d, %r12d
; 	btf->swapped_endian = is_host_big_endian() != (endian == BTF_BIG_ENDIAN);
   2a6aa: 80 67 14 01                  	andb	$1, 20(%rdi)
; 	if (!btf->swapped_endian) {
   2a6ae: 85 f6                        	testl	%esi, %esi
   2a6b0: 74 0e                        	je	0x2a6c0 <btf__set_endianness+0x30>
; }
   2a6b2: 48 83 c4 08                  	addq	$8, %rsp
   2a6b6: 44 89 e0                     	movl	%r12d, %eax
   2a6b9: 5b                           	popq	%rbx
   2a6ba: 41 5c                        	popq	%r12
   2a6bc: c3                           	retq
   2a6bd: 0f 1f 00                     	nopl	(%rax)
; 		free(btf->raw_data_swapped);
   2a6c0: 48 8b 7f 08                  	movq	8(%rdi), %rdi
   2a6c4: e8 f7 af fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 		btf->raw_data_swapped = NULL;
   2a6c9: 48 c7 43 08 00 00 00 00      	movq	$0, 8(%rbx)
; }
   2a6d1: 44 89 e0                     	movl	%r12d, %eax
   2a6d4: 48 83 c4 08                  	addq	$8, %rsp
   2a6d8: 5b                           	popq	%rbx
   2a6d9: 41 5c                        	popq	%r12
   2a6db: c3                           	retq
; 		errno = -ret;
   2a6dc: e8 0f b0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   2a6e1: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   2a6e7: c7 00 16 00 00 00            	movl	$22, (%rax)
   2a6ed: eb c3                        	jmp	0x2a6b2 <btf__set_endianness+0x22>
   2a6ef: 90                           	nop

000000000002a6f0 <btf__resolve_type>:
; {
   2a6f0: f3 0f 1e fa                  	endbr64
   2a6f4: 53                           	pushq	%rbx
; 	if (type_id >= btf->start_id + btf->nr_types)
   2a6f5: 44 8b 4f 50                  	movl	80(%rdi), %r9d
   2a6f9: 44 8b 5f 40                  	movl	64(%rdi), %r11d
   2a6fd: 43 8d 14 19                  	leal	(%r9,%r11), %edx
   2a701: 39 d6                        	cmpl	%edx, %esi
   2a703: 0f 83 d4 00 00 00            	jae	0x2a7dd <btf__resolve_type+0xed>
   2a709: 89 f0                        	movl	%esi, %eax
; 	if (type_id == 0)
   2a70b: 49 89 fa                     	movq	%rdi, %r10
; 		return &btf_void;
   2a70e: 48 8d 35 7b cb 01 00         	leaq	117627(%rip), %rsi      # 0x47290 <btf_void>
; 	if (type_id == 0)
   2a715: 85 c0                        	testl	%eax, %eax
   2a717: 74 29                        	je	0x2a742 <btf__resolve_type+0x52>
   2a719: 44 89 c9                     	movl	%r9d, %ecx
   2a71c: 48 89 fa                     	movq	%rdi, %rdx
   2a71f: eb 0e                        	jmp	0x2a72f <btf__resolve_type+0x3f>
   2a721: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a728: 48 8b 52 48                  	movq	72(%rdx), %rdx
; 	if (type_id < btf->start_id)
   2a72c: 8b 4a 50                     	movl	80(%rdx), %ecx
   2a72f: 39 c8                        	cmpl	%ecx, %eax
   2a731: 72 f5                        	jb	0x2a728 <btf__resolve_type+0x38>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a733: 89 c6                        	movl	%eax, %esi
   2a735: 29 ce                        	subl	%ecx, %esi
   2a737: 48 8b 4a 30                  	movq	48(%rdx), %rcx
   2a73b: 8b 34 b1                     	movl	(%rcx,%rsi,4), %esi
   2a73e: 48 03 72 20                  	addq	32(%rdx), %rsi
; 		return &btf_void;
   2a742: 31 ff                        	xorl	%edi, %edi
; 	return t == &btf_void || btf_is_fwd(t);
   2a744: 4c 8d 05 45 cb 01 00         	leaq	117573(%rip), %r8       # 0x47290 <btf_void>
; 	       (btf_is_mod(t) || btf_is_typedef(t) || btf_is_var(t))) {
   2a74b: bb 00 4f 04 00               	movl	$282368, %ebx           # imm = 0x44F00
; 	if (type_id >= btf->start_id + btf->nr_types)
   2a750: 45 01 cb                     	addl	%r9d, %r11d
   2a753: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	return !t || btf_type_is_void(t);
   2a758: 48 85 f6                     	testq	%rsi, %rsi
   2a75b: 74 5b                        	je	0x2a7b8 <btf__resolve_type+0xc8>
; 	return t == &btf_void || btf_is_fwd(t);
   2a75d: 4c 39 c6                     	cmpq	%r8, %rsi
   2a760: 74 56                        	je	0x2a7b8 <btf__resolve_type+0xc8>
; 	return BTF_INFO_KIND(t->info);
   2a762: 0f b6 56 07                  	movzbl	7(%rsi), %edx
   2a766: 83 e2 1f                     	andl	$31, %edx
; 	return t == &btf_void || btf_is_fwd(t);
   2a769: 66 83 fa 07                  	cmpw	$7, %dx
   2a76d: 74 49                        	je	0x2a7b8 <btf__resolve_type+0xc8>
; 	       (btf_is_mod(t) || btf_is_typedef(t) || btf_is_var(t))) {
   2a76f: 0f b7 d2                     	movzwl	%dx, %edx
   2a772: 48 0f a3 d3                  	btq	%rdx, %rbx
   2a776: 73 50                        	jae	0x2a7c8 <btf__resolve_type+0xd8>
; 		type_id = t->type;
   2a778: 8b 46 08                     	movl	8(%rsi), %eax
; 	if (type_id >= btf->start_id + btf->nr_types)
   2a77b: 44 89 c9                     	movl	%r9d, %ecx
   2a77e: 44 39 d8                     	cmpl	%r11d, %eax
   2a781: 73 4d                        	jae	0x2a7d0 <btf__resolve_type+0xe0>
; 		return &btf_void;
   2a783: 4c 89 c6                     	movq	%r8, %rsi
; 	if (type_id == 0)
   2a786: 85 c0                        	testl	%eax, %eax
   2a788: 74 20                        	je	0x2a7aa <btf__resolve_type+0xba>
   2a78a: 4c 89 d2                     	movq	%r10, %rdx
   2a78d: eb 08                        	jmp	0x2a797 <btf__resolve_type+0xa7>
   2a78f: 90                           	nop
; 		return btf_type_by_id(btf->base_btf, type_id);
   2a790: 48 8b 52 48                  	movq	72(%rdx), %rdx
; 	if (type_id < btf->start_id)
   2a794: 8b 4a 50                     	movl	80(%rdx), %ecx
   2a797: 39 c8                        	cmpl	%ecx, %eax
   2a799: 72 f5                        	jb	0x2a790 <btf__resolve_type+0xa0>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2a79b: 89 c6                        	movl	%eax, %esi
   2a79d: 29 ce                        	subl	%ecx, %esi
   2a79f: 48 8b 4a 30                  	movq	48(%rdx), %rcx
   2a7a3: 8b 34 b1                     	movl	(%rcx,%rsi,4), %esi
   2a7a6: 48 03 72 20                  	addq	32(%rdx), %rsi
; 		depth++;
   2a7aa: 83 c7 01                     	addl	$1, %edi
; 	       !btf_type_is_void_or_null(t) &&
   2a7ad: 83 ff 20                     	cmpl	$32, %edi
   2a7b0: 75 a6                        	jne	0x2a758 <btf__resolve_type+0x68>
   2a7b2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return errno = EINVAL, NULL;
   2a7b8: e8 33 af fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		errno = -ret;
   2a7bd: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2a7c3: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2a7c8: 5b                           	popq	%rbx
   2a7c9: c3                           	retq
   2a7ca: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return errno = EINVAL, NULL;
   2a7d0: e8 1b af fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2a7d5: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	       !btf_type_is_void_or_null(t) &&
   2a7db: eb e0                        	jmp	0x2a7bd <btf__resolve_type+0xcd>
; 		return errno = EINVAL, NULL;
   2a7dd: e8 0e af fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2a7e2: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	return !t || btf_type_is_void(t);
   2a7e8: eb ce                        	jmp	0x2a7b8 <btf__resolve_type+0xc8>
   2a7ea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000002a7f0 <btf__free>:
; {
   2a7f0: f3 0f 1e fa                  	endbr64
; 	if (IS_ERR_OR_NULL(btf))
   2a7f4: 48 85 ff                     	testq	%rdi, %rdi
   2a7f7: 0f 84 83 00 00 00            	je	0x2a880 <btf__free+0x90>
; {
   2a7fd: 55                           	pushq	%rbp
   2a7fe: 48 89 fd                     	movq	%rdi, %rbp
; 	if (IS_ERR_OR_NULL(btf))
   2a801: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   2a808: 77 6e                        	ja	0x2a878 <btf__free+0x88>
; 	if (btf->fd >= 0)
   2a80a: 8b 7f 6c                     	movl	108(%rdi), %edi
   2a80d: 85 ff                        	testl	%edi, %edi
   2a80f: 79 4f                        	jns	0x2a860 <btf__free+0x70>
; 	return (void *)btf->hdr != btf->raw_data;
   2a811: 4c 8b 45 18                  	movq	24(%rbp), %r8
   2a815: 48 8b 7d 00                  	movq	(%rbp), %rdi
; 	if (btf_is_modifiable(btf)) {
   2a819: 49 39 f8                     	cmpq	%rdi, %r8
   2a81c: 74 1e                        	je	0x2a83c <btf__free+0x4c>
; 		free(btf->hdr);
   2a81e: 4c 89 c7                     	movq	%r8, %rdi
   2a821: e8 9a ae fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 		free(btf->types_data);
   2a826: 48 8b 7d 20                  	movq	32(%rbp), %rdi
   2a82a: e8 91 ae fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 		strset__free(btf->strs_set);
   2a82f: 48 8b 7d 60                  	movq	96(%rbp), %rdi
   2a833: e8 78 55 00 00               	callq	0x2fdb0 <strset__free>
; 	free(btf->raw_data);
   2a838: 48 8b 7d 00                  	movq	(%rbp), %rdi
   2a83c: e8 7f ae fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(btf->raw_data_swapped);
   2a841: 48 8b 7d 08                  	movq	8(%rbp), %rdi
   2a845: e8 76 ae fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(btf->type_offs);
   2a84a: 48 8b 7d 30                  	movq	48(%rbp), %rdi
   2a84e: e8 6d ae fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(btf);
   2a853: 48 89 ef                     	movq	%rbp, %rdi
; }
   2a856: 5d                           	popq	%rbp
; 	free(btf);
   2a857: e9 64 ae fd ff               	jmp	0x56c0 <.plt.sec+0x50>
   2a85c: 0f 1f 40 00                  	nopl	(%rax)
; 		close(btf->fd);
   2a860: e8 9b b0 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	return (void *)btf->hdr != btf->raw_data;
   2a865: 4c 8b 45 18                  	movq	24(%rbp), %r8
   2a869: 48 8b 7d 00                  	movq	(%rbp), %rdi
; 	if (btf_is_modifiable(btf)) {
   2a86d: 49 39 f8                     	cmpq	%rdi, %r8
   2a870: 75 ac                        	jne	0x2a81e <btf__free+0x2e>
   2a872: eb c8                        	jmp	0x2a83c <btf__free+0x4c>
   2a874: 0f 1f 40 00                  	nopl	(%rax)
; }
   2a878: 5d                           	popq	%rbp
   2a879: c3                           	retq
   2a87a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2a880: c3                           	retq
   2a881: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2a88c: 0f 1f 40 00                  	nopl	(%rax)

000000000002a890 <btf_new>:
; {
   2a890: 41 56                        	pushq	%r14
   2a892: 41 55                        	pushq	%r13
   2a894: 41 89 f5                     	movl	%esi, %r13d
; 	btf = calloc(1, sizeof(struct btf));
   2a897: be 78 00 00 00               	movl	$120, %esi
; {
   2a89c: 41 54                        	pushq	%r12
   2a89e: 55                           	pushq	%rbp
   2a89f: 48 89 fd                     	movq	%rdi, %rbp
; 	btf = calloc(1, sizeof(struct btf));
   2a8a2: bf 01 00 00 00               	movl	$1, %edi
; {
   2a8a7: 53                           	pushq	%rbx
   2a8a8: 48 89 d3                     	movq	%rdx, %rbx
; 	btf = calloc(1, sizeof(struct btf));
   2a8ab: e8 e0 b0 fd ff               	callq	0x5990 <.plt.sec+0x320>
; 	if (!btf)
   2a8b0: 48 85 c0                     	testq	%rax, %rax
   2a8b3: 0f 84 d0 03 00 00            	je	0x2ac89 <btf_new+0x3f9>
; 	btf->start_id = 1;
   2a8b9: 48 c7 40 50 01 00 00 00      	movq	$1, 80(%rax)
   2a8c1: 49 89 c4                     	movq	%rax, %r12
; 	btf->fd = -1;
   2a8c4: c7 40 6c ff ff ff ff         	movl	$4294967295, 108(%rax)  # imm = 0xFFFFFFFF
; 	if (base_btf) {
   2a8cb: 48 85 db                     	testq	%rbx, %rbx
   2a8ce: 74 1b                        	je	0x2a8eb <btf_new+0x5b>
; 		btf->base_btf = base_btf;
   2a8d0: 48 89 58 48                  	movq	%rbx, 72(%rax)
; 	return btf->start_id + btf->nr_types;
   2a8d4: 8b 43 40                     	movl	64(%rbx), %eax
   2a8d7: 03 43 50                     	addl	80(%rbx), %eax
; 		btf->start_id = btf__type_cnt(base_btf);
   2a8da: 41 89 44 24 50               	movl	%eax, 80(%r12)
; 		btf->start_str_off = base_btf->hdr->str_len;
   2a8df: 48 8b 43 18                  	movq	24(%rbx), %rax
   2a8e3: 8b 40 14                     	movl	20(%rax), %eax
   2a8e6: 41 89 44 24 54               	movl	%eax, 84(%r12)
; 	btf->raw_data = malloc(size);
   2a8eb: 45 89 ee                     	movl	%r13d, %r14d
   2a8ee: 4c 89 f7                     	movq	%r14, %rdi
   2a8f1: e8 9a b1 fd ff               	callq	0x5a90 <.plt.sec+0x420>
   2a8f6: 49 89 04 24                  	movq	%rax, (%r12)
   2a8fa: 48 89 c3                     	movq	%rax, %rbx
; 	if (!btf->raw_data) {
   2a8fd: 48 85 c0                     	testq	%rax, %rax
   2a900: 0f 84 76 02 00 00            	je	0x2ab7c <btf_new+0x2ec>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2a906: 4c 89 f2                     	movq	%r14, %rdx
   2a909: 48 89 ee                     	movq	%rbp, %rsi
   2a90c: 48 89 c7                     	movq	%rax, %rdi
   2a90f: e8 2c b1 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	btf->raw_size = size;
   2a914: 45 89 6c 24 10               	movl	%r13d, 16(%r12)
; 	btf->hdr = btf->raw_data;
   2a919: 49 89 5c 24 18               	movq	%rbx, 24(%r12)
; 	if (btf->raw_size < sizeof(struct btf_header)) {
   2a91e: 41 83 fd 17                  	cmpl	$23, %r13d
   2a922: 0f 86 e2 02 00 00            	jbe	0x2ac0a <btf_new+0x37a>
; 	if (hdr->magic == bswap_16(BTF_MAGIC)) {
   2a928: 0f b7 03                     	movzwl	(%rbx), %eax
   2a92b: 66 3d eb 9f                  	cmpw	$40939, %ax             # imm = 0x9FEB
   2a92f: 0f 84 73 01 00 00            	je	0x2aaa8 <btf_new+0x218>
; 	} else if (hdr->magic != BTF_MAGIC) {
   2a935: 66 3d 9f eb                  	cmpw	$60319, %ax             # imm = 0xEB9F
   2a939: 0f 85 65 02 00 00            	jne	0x2aba4 <btf_new+0x314>
; 	if (btf->raw_size < hdr->hdr_len) {
   2a93f: 8b 53 04                     	movl	4(%rbx), %edx
   2a942: 41 39 d5                     	cmpl	%edx, %r13d
   2a945: 0f 82 00 03 00 00            	jb	0x2ac4b <btf_new+0x3bb>
; 	h->str_off = bswap_32(h->str_off);
   2a94b: 44 8b 43 10                  	movl	16(%rbx), %r8d
; 	h->str_len = bswap_32(h->str_len);
   2a94f: 44 8b 4b 14                  	movl	20(%rbx), %r9d
; 	if (meta_left < (long long)hdr->str_off + hdr->str_len) {
   2a953: 44 89 c0                     	movl	%r8d, %eax
   2a956: 44 89 ef                     	movl	%r13d, %edi
   2a959: 44 89 ce                     	movl	%r9d, %esi
   2a95c: 29 d7                        	subl	%edx, %edi
   2a95e: 48 8d 0c 06                  	leaq	(%rsi,%rax), %rcx
   2a962: 48 39 cf                     	cmpq	%rcx, %rdi
   2a965: 0f 8c be 02 00 00            	jl	0x2ac29 <btf_new+0x399>
; 	if ((long long)hdr->type_off + hdr->type_len > hdr->str_off) {
   2a96b: 8b 4b 08                     	movl	8(%rbx), %ecx
   2a96e: 44 8b 6b 0c                  	movl	12(%rbx), %r13d
   2a972: 4a 8d 3c 29                  	leaq	(%rcx,%r13), %rdi
   2a976: 49 89 ca                     	movq	%rcx, %r10
   2a979: 48 39 f8                     	cmpq	%rdi, %rax
   2a97c: 0f 8c 63 02 00 00            	jl	0x2abe5 <btf_new+0x355>
; 	if (hdr->type_off % 4) {
   2a982: 41 83 e2 03                  	andl	$3, %r10d
   2a986: 0f 85 3a 02 00 00            	jne	0x2abc6 <btf_new+0x336>
; 	btf->strs_data = btf->raw_data + btf->hdr->hdr_len + btf->hdr->str_off;
   2a98c: 89 d2                        	movl	%edx, %edx
   2a98e: 48 01 d0                     	addq	%rdx, %rax
; 	btf->types_data = btf->raw_data + btf->hdr->hdr_len + btf->hdr->type_off;
   2a991: 48 01 d1                     	addq	%rdx, %rcx
; 	if (btf->base_btf && hdr->str_len == 0)
   2a994: 49 8b 54 24 48               	movq	72(%r12), %rdx
; 	btf->strs_data = btf->raw_data + btf->hdr->hdr_len + btf->hdr->str_off;
   2a999: 48 01 d8                     	addq	%rbx, %rax
; 	btf->types_data = btf->raw_data + btf->hdr->hdr_len + btf->hdr->type_off;
   2a99c: 48 01 cb                     	addq	%rcx, %rbx
; 	btf->strs_data = btf->raw_data + btf->hdr->hdr_len + btf->hdr->str_off;
   2a99f: 49 89 44 24 58               	movq	%rax, 88(%r12)
; 	btf->types_data = btf->raw_data + btf->hdr->hdr_len + btf->hdr->type_off;
   2a9a4: 49 89 5c 24 20               	movq	%rbx, 32(%r12)
; 	if (btf->base_btf && hdr->str_len == 0)
   2a9a9: 48 85 d2                     	testq	%rdx, %rdx
   2a9ac: 74 05                        	je	0x2a9b3 <btf_new+0x123>
   2a9ae: 45 85 c9                     	testl	%r9d, %r9d
   2a9b1: 74 1e                        	je	0x2a9d1 <btf_new+0x141>
; 	if (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_STR_OFFSET || end[-1]) {
   2a9b3: 41 83 e9 01                  	subl	$1, %r9d
   2a9b7: 0f 88 4c 01 00 00            	js	0x2ab09 <btf_new+0x279>
   2a9bd: 80 7c 30 ff 00               	cmpb	$0, -1(%rax,%rsi)
   2a9c2: 0f 85 41 01 00 00            	jne	0x2ab09 <btf_new+0x279>
; 	if (!btf->base_btf && start[0]) {
   2a9c8: 48 85 d2                     	testq	%rdx, %rdx
   2a9cb: 0f 84 2f 01 00 00            	je	0x2ab00 <btf_new+0x270>
; 	void *end_type = next_type + hdr->type_len;
   2a9d1: 49 01 dd                     	addq	%rbx, %r13
; 	while (next_type + sizeof(struct btf_type) <= end_type) {
   2a9d4: 48 8d 43 0c                  	leaq	12(%rbx), %rax
   2a9d8: 49 39 c5                     	cmpq	%rax, %r13
   2a9db: 0f 82 47 01 00 00            	jb	0x2ab28 <btf_new+0x298>
; 	return libbpf_add_mem((void **)&btf->type_offs, &btf->type_offs_cap, sizeof(__u32),
   2a9e1: 4d 8d 74 24 38               	leaq	56(%r12), %r14
   2a9e6: eb 78                        	jmp	0x2aa60 <btf_new+0x1d0>
   2a9e8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		if (next_type + type_size > end_type) {
   2a9f0: 48 98                        	cltq
   2a9f2: 48 8d 2c 03                  	leaq	(%rbx,%rax), %rbp
   2a9f6: 49 39 ed                     	cmpq	%rbp, %r13
   2a9f9: 0f 82 49 01 00 00            	jb	0x2ab48 <btf_new+0x2b8>
; 		if (btf->swapped_endian && btf_bswap_type_rest(next_type))
   2a9ff: 41 80 7c 24 14 00            	cmpb	$0, 20(%r12)
   2aa05: 74 10                        	je	0x2aa17 <btf_new+0x187>
   2aa07: 48 89 df                     	movq	%rbx, %rdi
   2aa0a: e8 81 e3 ff ff               	callq	0x28d90 <btf_bswap_type_rest>
   2aa0f: 85 c0                        	testl	%eax, %eax
   2aa11: 0f 85 59 01 00 00            	jne	0x2ab70 <btf_new+0x2e0>
; 	return libbpf_add_mem((void **)&btf->type_offs, &btf->type_offs_cap, sizeof(__u32),
   2aa17: 41 8b 4c 24 40               	movl	64(%r12), %ecx
   2aa1c: 49 8d 7c 24 30               	leaq	48(%r12), %rdi
   2aa21: ba 04 00 00 00               	movl	$4, %edx
   2aa26: 41 b9 01 00 00 00            	movl	$1, %r9d
   2aa2c: 41 b8 ff ff ff 7f            	movl	$2147483647, %r8d       # imm = 0x7FFFFFFF
   2aa32: 4c 89 f6                     	movq	%r14, %rsi
; 		err = btf_add_type_idx_entry(btf, next_type - btf->types_data);
   2aa35: 49 2b 5c 24 20               	subq	32(%r12), %rbx
; 	return libbpf_add_mem((void **)&btf->type_offs, &btf->type_offs_cap, sizeof(__u32),
   2aa3a: e8 61 f3 ff ff               	callq	0x29da0 <libbpf_add_mem>
; 	if (!p)
   2aa3f: 48 85 c0                     	testq	%rax, %rax
   2aa42: 0f 84 34 01 00 00            	je	0x2ab7c <btf_new+0x2ec>
; 	*p = type_off;
   2aa48: 89 18                        	movl	%ebx, (%rax)
; 	while (next_type + sizeof(struct btf_type) <= end_type) {
   2aa4a: 48 8d 45 0c                  	leaq	12(%rbp), %rax
; 		btf->nr_types++;
   2aa4e: 41 83 44 24 40 01            	addl	$1, 64(%r12)
; 	while (next_type + sizeof(struct btf_type) <= end_type) {
   2aa54: 49 39 c5                     	cmpq	%rax, %r13
   2aa57: 0f 82 d3 00 00 00            	jb	0x2ab30 <btf_new+0x2a0>
   2aa5d: 48 89 eb                     	movq	%rbp, %rbx
; 		if (btf->swapped_endian)
   2aa60: 41 80 7c 24 14 00            	cmpb	$0, 20(%r12)
; 	t->info = bswap_32(t->info);
   2aa66: 8b 7b 04                     	movl	4(%rbx), %edi
; 		if (btf->swapped_endian)
   2aa69: 74 13                        	je	0x2aa7e <btf_new+0x1ee>
;   return __builtin_bswap32 (__bsx);
   2aa6b: 8b 03                        	movl	(%rbx), %eax
   2aa6d: 0f cf                        	bswapl	%edi
; 	t->info = bswap_32(t->info);
   2aa6f: 89 7b 04                     	movl	%edi, 4(%rbx)
;   return __builtin_bswap32 (__bsx);
   2aa72: 0f c8                        	bswapl	%eax
; 	t->name_off = bswap_32(t->name_off);
   2aa74: 89 03                        	movl	%eax, (%rbx)
;   return __builtin_bswap32 (__bsx);
   2aa76: 8b 43 08                     	movl	8(%rbx), %eax
   2aa79: 0f c8                        	bswapl	%eax
; 	t->type = bswap_32(t->type);
   2aa7b: 89 43 08                     	movl	%eax, 8(%rbx)
; 		type_size = btf_type_size(next_type);
   2aa7e: e8 2d e8 ff ff               	callq	0x292b0 <btf_type_size.isra.0>
; 		if (type_size < 0)
   2aa83: 85 c0                        	testl	%eax, %eax
   2aa85: 0f 89 65 ff ff ff            	jns	0x2a9f0 <btf_new+0x160>
; 		return ERR_PTR(err);
   2aa8b: 4c 63 e8                     	movslq	%eax, %r13
; 		btf__free(btf);
   2aa8e: 4c 89 e7                     	movq	%r12, %rdi
   2aa91: e8 5a fd ff ff               	callq	0x2a7f0 <btf__free>
; }
   2aa96: 5b                           	popq	%rbx
   2aa97: 4c 89 e8                     	movq	%r13, %rax
   2aa9a: 5d                           	popq	%rbp
   2aa9b: 41 5c                        	popq	%r12
   2aa9d: 41 5d                        	popq	%r13
   2aa9f: 41 5e                        	popq	%r14
   2aaa1: c3                           	retq
   2aaa2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
;   return __builtin_bswap32 (__bsx);
   2aaa8: 8b 43 04                     	movl	4(%rbx), %eax
; 		btf->swapped_endian = true;
   2aaab: 41 c6 44 24 14 01            	movb	$1, 20(%r12)
;   return __builtin_bswap32 (__bsx);
   2aab1: 89 c2                        	movl	%eax, %edx
   2aab3: 0f ca                        	bswapl	%edx
; 		if (bswap_32(hdr->hdr_len) != sizeof(struct btf_header)) {
   2aab5: 3d 00 00 00 18               	cmpl	$402653184, %eax        # imm = 0x18000000
   2aaba: 0f 85 c8 00 00 00            	jne	0x2ab88 <btf_new+0x2f8>
; 	h->magic = bswap_16(h->magic);
   2aac0: b8 9f eb ff ff               	movl	$4294962079, %eax       # imm = 0xFFFFEB9F
;   return __builtin_bswap32 (__bsx);
   2aac5: 44 8b 43 10                  	movl	16(%rbx), %r8d
   2aac9: 44 8b 4b 14                  	movl	20(%rbx), %r9d
; 	h->hdr_len = bswap_32(h->hdr_len);
   2aacd: c7 43 04 18 00 00 00         	movl	$24, 4(%rbx)
; 	h->magic = bswap_16(h->magic);
   2aad4: 66 89 03                     	movw	%ax, (%rbx)
;   return __builtin_bswap32 (__bsx);
   2aad7: 8b 43 08                     	movl	8(%rbx), %eax
   2aada: 41 0f c8                     	bswapl	%r8d
   2aadd: 41 0f c9                     	bswapl	%r9d
; 	h->str_off = bswap_32(h->str_off);
   2aae0: 44 89 43 10                  	movl	%r8d, 16(%rbx)
;   return __builtin_bswap32 (__bsx);
   2aae4: 0f c8                        	bswapl	%eax
; 	h->type_off = bswap_32(h->type_off);
   2aae6: 89 43 08                     	movl	%eax, 8(%rbx)
;   return __builtin_bswap32 (__bsx);
   2aae9: 8b 43 0c                     	movl	12(%rbx), %eax
; 	h->str_len = bswap_32(h->str_len);
   2aaec: 44 89 4b 14                  	movl	%r9d, 20(%rbx)
;   return __builtin_bswap32 (__bsx);
   2aaf0: 0f c8                        	bswapl	%eax
; 	h->type_len = bswap_32(h->type_len);
   2aaf2: 89 43 0c                     	movl	%eax, 12(%rbx)
; 	if (btf->raw_size < hdr->hdr_len) {
   2aaf5: e9 59 fe ff ff               	jmp	0x2a953 <btf_new+0xc3>
   2aafa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	if (!btf->base_btf && start[0]) {
   2ab00: 80 38 00                     	cmpb	$0, (%rax)
   2ab03: 0f 84 c8 fe ff ff            	je	0x2a9d1 <btf_new+0x141>
; 		pr_debug("Invalid BTF string section\n");
   2ab09: 48 8d 35 28 08 01 00         	leaq	67624(%rip), %rsi       # 0x3b338 <CSWTCH.126+0x1a38>
   2ab10: bf 02 00 00 00               	movl	$2, %edi
   2ab15: 31 c0                        	xorl	%eax, %eax
   2ab17: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2ab1e: e8 ad d5 fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2ab23: e9 66 ff ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 	void *next_type = btf->types_data;
   2ab28: 48 89 dd                     	movq	%rbx, %rbp
   2ab2b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	if (next_type != end_type) {
   2ab30: 49 39 ed                     	cmpq	%rbp, %r13
   2ab33: 0f 85 34 01 00 00            	jne	0x2ac6d <btf_new+0x3dd>
   2ab39: 4d 89 e5                     	movq	%r12, %r13
   2ab3c: e9 55 ff ff ff               	jmp	0x2aa96 <btf_new+0x206>
   2ab41: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			pr_warn("BTF type [%d] is malformed\n", btf->start_id + btf->nr_types);
   2ab48: 41 8b 54 24 40               	movl	64(%r12), %edx
   2ab4d: 48 8d 35 0c 08 01 00         	leaq	67596(%rip), %rsi       # 0x3b360 <CSWTCH.126+0x1a60>
   2ab54: 31 ff                        	xorl	%edi, %edi
   2ab56: 31 c0                        	xorl	%eax, %eax
   2ab58: 41 03 54 24 50               	addl	80(%r12), %edx
   2ab5d: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2ab64: e8 67 d5 fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2ab69: e9 20 ff ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
   2ab6e: 66 90                        	nop
   2ab70: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2ab77: e9 12 ff ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		pr_debug("BTF header not found\n");
   2ab7c: 49 c7 c5 f4 ff ff ff         	movq	$-12, %r13
   2ab83: e9 06 ff ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 			pr_warn("Can't load BTF with non-native endianness due to unsupported header length %u\n",
   2ab88: 48 8d 35 39 06 01 00         	leaq	67129(%rip), %rsi       # 0x3b1c8 <CSWTCH.126+0x18c8>
   2ab8f: 31 ff                        	xorl	%edi, %edi
   2ab91: 31 c0                        	xorl	%eax, %eax
   2ab93: 49 c7 c5 a1 ff ff ff         	movq	$-95, %r13
   2ab9a: e8 31 d5 fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2ab9f: e9 ea fe ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		pr_debug("Invalid BTF magic: %x\n", hdr->magic);
   2aba4: 0f b7 d0                     	movzwl	%ax, %edx
   2aba7: 48 8d 35 72 06 01 00         	leaq	67186(%rip), %rsi       # 0x3b220 <CSWTCH.126+0x1920>
   2abae: 31 c0                        	xorl	%eax, %eax
   2abb0: bf 02 00 00 00               	movl	$2, %edi
   2abb5: e8 16 d5 fd ff               	callq	0x80d0 <libbpf_print>
   2abba: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2abc1: e9 c8 fe ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		pr_debug("BTF type section is not aligned to 4 bytes\n");
   2abc6: 48 8d 35 33 07 01 00         	leaq	67379(%rip), %rsi       # 0x3b300 <CSWTCH.126+0x1a00>
   2abcd: bf 02 00 00 00               	movl	$2, %edi
   2abd2: 31 c0                        	xorl	%eax, %eax
   2abd4: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2abdb: e8 f0 d4 fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2abe0: e9 a9 fe ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		pr_debug("Invalid BTF data sections layout: type data at %u + %u, strings data at %u + %u\n",
   2abe5: 44 89 e9                     	movl	%r13d, %ecx
   2abe8: 44 89 d2                     	movl	%r10d, %edx
   2abeb: 48 8d 35 ae 06 01 00         	leaq	67246(%rip), %rsi       # 0x3b2a0 <CSWTCH.126+0x19a0>
   2abf2: 31 c0                        	xorl	%eax, %eax
   2abf4: bf 02 00 00 00               	movl	$2, %edi
   2abf9: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2ac00: e8 cb d4 fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2ac05: e9 84 fe ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		pr_debug("BTF header not found\n");
   2ac0a: 48 8d 35 6b 0f 01 00         	leaq	69483(%rip), %rsi       # 0x3bb7c <CSWTCH.126+0x227c>
   2ac11: bf 02 00 00 00               	movl	$2, %edi
   2ac16: 31 c0                        	xorl	%eax, %eax
   2ac18: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2ac1f: e8 ac d4 fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
   2ac24: e9 65 fe ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		pr_debug("Invalid BTF total size: %u\n", btf->raw_size);
   2ac29: 44 89 ea                     	movl	%r13d, %edx
   2ac2c: 48 8d 35 45 06 01 00         	leaq	67141(%rip), %rsi       # 0x3b278 <CSWTCH.126+0x1978>
   2ac33: bf 02 00 00 00               	movl	$2, %edi
   2ac38: 31 c0                        	xorl	%eax, %eax
   2ac3a: e8 91 d4 fd ff               	callq	0x80d0 <libbpf_print>
   2ac3f: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2ac46: e9 43 fe ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		pr_debug("BTF header len %u larger than data size %u\n",
   2ac4b: 44 89 e9                     	movl	%r13d, %ecx
   2ac4e: 48 8d 35 eb 05 01 00         	leaq	67051(%rip), %rsi       # 0x3b240 <CSWTCH.126+0x1940>
   2ac55: bf 02 00 00 00               	movl	$2, %edi
   2ac5a: 31 c0                        	xorl	%eax, %eax
   2ac5c: e8 6f d4 fd ff               	callq	0x80d0 <libbpf_print>
   2ac61: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2ac68: e9 21 fe ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		pr_warn("BTF types data is malformed\n");
   2ac6d: 48 8d 35 14 07 01 00         	leaq	67348(%rip), %rsi       # 0x3b388 <CSWTCH.126+0x1a88>
   2ac74: 31 ff                        	xorl	%edi, %edi
   2ac76: 31 c0                        	xorl	%eax, %eax
   2ac78: 49 c7 c5 ea ff ff ff         	movq	$-22, %r13
   2ac7f: e8 4c d4 fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2ac84: e9 05 fe ff ff               	jmp	0x2aa8e <btf_new+0x1fe>
; 		return ERR_PTR(-ENOMEM);
   2ac89: 49 c7 c5 f4 ff ff ff         	movq	$-12, %r13
   2ac90: e9 01 fe ff ff               	jmp	0x2aa96 <btf_new+0x206>
   2ac95: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)

000000000002aca0 <btf_parse_raw>:
; {
   2aca0: 41 55                        	pushq	%r13
   2aca2: 41 54                        	pushq	%r12
   2aca4: 49 89 f4                     	movq	%rsi, %r12
; 	f = fopen(path, "rb");
   2aca7: 48 8d 35 ec 0e 01 00         	leaq	69356(%rip), %rsi       # 0x3bb9a <CSWTCH.126+0x229a>
; {
   2acae: 55                           	pushq	%rbp
   2acaf: 53                           	pushq	%rbx
   2acb0: 48 83 ec 18                  	subq	$24, %rsp
   2acb4: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2acbd: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   2acc2: 31 c0                        	xorl	%eax, %eax
; 	f = fopen(path, "rb");
   2acc4: e8 47 ad fd ff               	callq	0x5a10 <.plt.sec+0x3a0>
; 	if (!f) {
   2acc9: 48 85 c0                     	testq	%rax, %rax
   2accc: 0f 84 4b 01 00 00            	je	0x2ae1d <btf_parse_raw+0x17d>
;     return __fread_alias (__ptr, __size, __n, __stream);
   2acd2: 48 8d 7c 24 06               	leaq	6(%rsp), %rdi
   2acd7: 48 89 c1                     	movq	%rax, %rcx
   2acda: ba 02 00 00 00               	movl	$2, %edx
   2acdf: 48 89 c5                     	movq	%rax, %rbp
   2ace2: be 01 00 00 00               	movl	$1, %esi
   2ace7: e8 94 aa fd ff               	callq	0x5780 <.plt.sec+0x110>
; 	if (fread(&magic, 1, sizeof(magic), f) < sizeof(magic)) {
   2acec: 48 83 f8 01                  	cmpq	$1, %rax
   2acf0: 0f 86 ba 00 00 00            	jbe	0x2adb0 <btf_parse_raw+0x110>
; 	if (magic != BTF_MAGIC && magic != bswap_16(BTF_MAGIC)) {
   2acf6: 0f b7 44 24 06               	movzwl	6(%rsp), %eax
   2acfb: 66 3d eb 9f                  	cmpw	$40939, %ax             # imm = 0x9FEB
   2acff: 74 3f                        	je	0x2ad40 <btf_parse_raw+0xa0>
   2ad01: 66 3d 9f eb                  	cmpw	$60319, %ax             # imm = 0xEB9F
   2ad05: 74 39                        	je	0x2ad40 <btf_parse_raw+0xa0>
; 		fclose(f);
   2ad07: 48 89 ef                     	movq	%rbp, %rdi
   2ad0a: 49 c7 c4 b9 ff ff ff         	movq	$-71, %r12
   2ad11: e8 aa aa fd ff               	callq	0x57c0 <.plt.sec+0x150>
; }
   2ad16: 48 8b 44 24 08               	movq	8(%rsp), %rax
   2ad1b: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2ad24: 0f 85 00 01 00 00            	jne	0x2ae2a <btf_parse_raw+0x18a>
   2ad2a: 48 83 c4 18                  	addq	$24, %rsp
   2ad2e: 4c 89 e0                     	movq	%r12, %rax
   2ad31: 5b                           	popq	%rbx
   2ad32: 5d                           	popq	%rbp
   2ad33: 41 5c                        	popq	%r12
   2ad35: 41 5d                        	popq	%r13
   2ad37: c3                           	retq
   2ad38: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (fseek(f, 0, SEEK_END)) {
   2ad40: 31 f6                        	xorl	%esi, %esi
   2ad42: ba 02 00 00 00               	movl	$2, %edx
   2ad47: 48 89 ef                     	movq	%rbp, %rdi
   2ad4a: e8 91 ad fd ff               	callq	0x5ae0 <.plt.sec+0x470>
   2ad4f: 85 c0                        	testl	%eax, %eax
   2ad51: 75 75                        	jne	0x2adc8 <btf_parse_raw+0x128>
; 	sz = ftell(f);
   2ad53: 48 89 ef                     	movq	%rbp, %rdi
   2ad56: e8 95 ac fd ff               	callq	0x59f0 <.plt.sec+0x380>
   2ad5b: 48 89 c3                     	movq	%rax, %rbx
; 	if (sz < 0) {
   2ad5e: 48 85 c0                     	testq	%rax, %rax
   2ad61: 78 65                        	js	0x2adc8 <btf_parse_raw+0x128>
; 	if (fseek(f, 0, SEEK_SET)) {
   2ad63: 31 d2                        	xorl	%edx, %edx
   2ad65: 31 f6                        	xorl	%esi, %esi
   2ad67: 48 89 ef                     	movq	%rbp, %rdi
   2ad6a: e8 71 ad fd ff               	callq	0x5ae0 <.plt.sec+0x470>
   2ad6f: 85 c0                        	testl	%eax, %eax
   2ad71: 75 55                        	jne	0x2adc8 <btf_parse_raw+0x128>
; 	data = malloc(sz);
   2ad73: 48 89 df                     	movq	%rbx, %rdi
   2ad76: e8 15 ad fd ff               	callq	0x5a90 <.plt.sec+0x420>
   2ad7b: 49 89 c5                     	movq	%rax, %r13
; 	if (!data) {
   2ad7e: 48 85 c0                     	testq	%rax, %rax
   2ad81: 0f 84 a8 00 00 00            	je	0x2ae2f <btf_parse_raw+0x18f>
;     return __fread_alias (__ptr, __size, __n, __stream);
   2ad87: 48 89 e9                     	movq	%rbp, %rcx
   2ad8a: 48 89 da                     	movq	%rbx, %rdx
   2ad8d: be 01 00 00 00               	movl	$1, %esi
   2ad92: 48 89 c7                     	movq	%rax, %rdi
   2ad95: e8 e6 a9 fd ff               	callq	0x5780 <.plt.sec+0x110>
; 	if (fread(data, 1, sz, f) < sz) {
   2ad9a: 48 39 c3                     	cmpq	%rax, %rbx
   2ad9d: 76 51                        	jbe	0x2adf0 <btf_parse_raw+0x150>
; 	free(data);
   2ad9f: 4c 89 ef                     	movq	%r13, %rdi
   2ada2: e8 19 a9 fd ff               	callq	0x56c0 <.plt.sec+0x50>
   2ada7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		fclose(f);
   2adb0: 48 89 ef                     	movq	%rbp, %rdi
   2adb3: 49 c7 c4 fb ff ff ff         	movq	$-5, %r12
   2adba: e8 01 aa fd ff               	callq	0x57c0 <.plt.sec+0x150>
; 	return err ? ERR_PTR(err) : btf;
   2adbf: e9 52 ff ff ff               	jmp	0x2ad16 <btf_parse_raw+0x76>
   2adc4: 0f 1f 40 00                  	nopl	(%rax)
; 		err = -errno;
   2adc8: e8 23 a9 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		fclose(f);
   2adcd: 48 89 ef                     	movq	%rbp, %rdi
; 		err = -errno;
   2add0: 44 8b 20                     	movl	(%rax), %r12d
   2add3: 41 f7 dc                     	negl	%r12d
; 		fclose(f);
   2add6: e8 e5 a9 fd ff               	callq	0x57c0 <.plt.sec+0x150>
; 	return err ? ERR_PTR(err) : btf;
   2addb: 45 85 e4                     	testl	%r12d, %r12d
   2adde: 75 35                        	jne	0x2ae15 <btf_parse_raw+0x175>
   2ade0: 45 31 e4                     	xorl	%r12d, %r12d
   2ade3: e9 2e ff ff ff               	jmp	0x2ad16 <btf_parse_raw+0x76>
   2ade8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	btf = btf_new(data, sz, base_btf);
   2adf0: 4c 89 e2                     	movq	%r12, %rdx
   2adf3: 89 de                        	movl	%ebx, %esi
   2adf5: 4c 89 ef                     	movq	%r13, %rdi
   2adf8: e8 93 fa ff ff               	callq	0x2a890 <btf_new>
; 	free(data);
   2adfd: 4c 89 ef                     	movq	%r13, %rdi
; 	btf = btf_new(data, sz, base_btf);
   2ae00: 49 89 c4                     	movq	%rax, %r12
; 	free(data);
   2ae03: e8 b8 a8 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 		fclose(f);
   2ae08: 48 89 ef                     	movq	%rbp, %rdi
   2ae0b: e8 b0 a9 fd ff               	callq	0x57c0 <.plt.sec+0x150>
; 	return err ? ERR_PTR(err) : btf;
   2ae10: e9 01 ff ff ff               	jmp	0x2ad16 <btf_parse_raw+0x76>
   2ae15: 4d 63 e4                     	movslq	%r12d, %r12
; 	return (void *) error_;
   2ae18: e9 f9 fe ff ff               	jmp	0x2ad16 <btf_parse_raw+0x76>
; 		err = -errno;
   2ae1d: e8 ce a8 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2ae22: 44 8b 20                     	movl	(%rax), %r12d
   2ae25: 41 f7 dc                     	negl	%r12d
; 	if (f)
   2ae28: eb b1                        	jmp	0x2addb <btf_parse_raw+0x13b>
; }
   2ae2a: e8 d1 a9 fd ff               	callq	0x5800 <.plt.sec+0x190>
; 		fclose(f);
   2ae2f: 48 89 ef                     	movq	%rbp, %rdi
   2ae32: 49 c7 c4 f4 ff ff ff         	movq	$-12, %r12
   2ae39: e8 82 a9 fd ff               	callq	0x57c0 <.plt.sec+0x150>
; 	return err ? ERR_PTR(err) : btf;
   2ae3e: e9 d3 fe ff ff               	jmp	0x2ad16 <btf_parse_raw+0x76>
   2ae43: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2ae4e: 66 90                        	nop

000000000002ae50 <btf__new_empty>:
; {
   2ae50: f3 0f 1e fa                  	endbr64
   2ae54: 41 54                        	pushq	%r12
; 	return libbpf_ptr(btf_new_empty(NULL));
   2ae56: 31 ff                        	xorl	%edi, %edi
   2ae58: e8 43 de ff ff               	callq	0x28ca0 <btf_new_empty>
   2ae5d: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   2ae60: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2ae66: 76 0e                        	jbe	0x2ae76 <btf__new_empty+0x26>
; 		errno = -PTR_ERR(ret);
   2ae68: e8 83 a8 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2ae6d: 41 f7 dc                     	negl	%r12d
   2ae70: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2ae73: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2ae76: 4c 89 e0                     	movq	%r12, %rax
   2ae79: 41 5c                        	popq	%r12
   2ae7b: c3                           	retq
   2ae7c: 0f 1f 40 00                  	nopl	(%rax)

000000000002ae80 <btf__new_empty_split>:
; {
   2ae80: f3 0f 1e fa                  	endbr64
   2ae84: 41 54                        	pushq	%r12
; 	return libbpf_ptr(btf_new_empty(base_btf));
   2ae86: e8 15 de ff ff               	callq	0x28ca0 <btf_new_empty>
   2ae8b: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   2ae8e: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2ae94: 76 0e                        	jbe	0x2aea4 <btf__new_empty_split+0x24>
; 		errno = -PTR_ERR(ret);
   2ae96: e8 55 a8 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2ae9b: 41 f7 dc                     	negl	%r12d
   2ae9e: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2aea1: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2aea4: 4c 89 e0                     	movq	%r12, %rax
   2aea7: 41 5c                        	popq	%r12
   2aea9: c3                           	retq
   2aeaa: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000002aeb0 <btf__new>:
; {
   2aeb0: f3 0f 1e fa                  	endbr64
   2aeb4: 41 54                        	pushq	%r12
; 	return libbpf_ptr(btf_new(data, size, NULL));
   2aeb6: 31 d2                        	xorl	%edx, %edx
   2aeb8: e8 d3 f9 ff ff               	callq	0x2a890 <btf_new>
   2aebd: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   2aec0: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2aec6: 76 0e                        	jbe	0x2aed6 <btf__new+0x26>
; 		errno = -PTR_ERR(ret);
   2aec8: e8 23 a8 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2aecd: 41 f7 dc                     	negl	%r12d
   2aed0: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2aed3: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2aed6: 4c 89 e0                     	movq	%r12, %rax
   2aed9: 41 5c                        	popq	%r12
   2aedb: c3                           	retq
   2aedc: 0f 1f 40 00                  	nopl	(%rax)

000000000002aee0 <btf__parse_raw>:
; {
   2aee0: f3 0f 1e fa                  	endbr64
   2aee4: 41 54                        	pushq	%r12
; 	return libbpf_ptr(btf_parse_raw(path, NULL));
   2aee6: 31 f6                        	xorl	%esi, %esi
   2aee8: e8 b3 fd ff ff               	callq	0x2aca0 <btf_parse_raw>
   2aeed: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   2aef0: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2aef6: 76 0e                        	jbe	0x2af06 <btf__parse_raw+0x26>
; 		errno = -PTR_ERR(ret);
   2aef8: e8 f3 a7 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2aefd: 41 f7 dc                     	negl	%r12d
   2af00: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2af03: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2af06: 4c 89 e0                     	movq	%r12, %rax
   2af09: 41 5c                        	popq	%r12
   2af0b: c3                           	retq
   2af0c: 0f 1f 40 00                  	nopl	(%rax)

000000000002af10 <btf__parse_raw_split>:
; {
   2af10: f3 0f 1e fa                  	endbr64
   2af14: 41 54                        	pushq	%r12
; 	return libbpf_ptr(btf_parse_raw(path, base_btf));
   2af16: e8 85 fd ff ff               	callq	0x2aca0 <btf_parse_raw>
   2af1b: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   2af1e: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2af24: 76 0e                        	jbe	0x2af34 <btf__parse_raw_split+0x24>
; 		errno = -PTR_ERR(ret);
   2af26: e8 c5 a7 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2af2b: 41 f7 dc                     	negl	%r12d
   2af2e: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2af31: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2af34: 4c 89 e0                     	movq	%r12, %rax
   2af37: 41 5c                        	popq	%r12
   2af39: c3                           	retq
   2af3a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000002af40 <btf_load_into_kernel>:
; {
   2af40: f3 0f 1e fa                  	endbr64
   2af44: 41 57                        	pushq	%r15
;   return __builtin___memset_chk (__dest, __ch, __len,
   2af46: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; {
   2af4a: 41 56                        	pushq	%r14
   2af4c: 41 55                        	pushq	%r13
   2af4e: 41 54                        	pushq	%r12
   2af50: 55                           	pushq	%rbp
   2af51: 53                           	pushq	%rbx
   2af52: 48 83 ec 58                  	subq	$88, %rsp
   2af56: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
   2af5b: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2af64: 48 89 44 24 48               	movq	%rax, 72(%rsp)
   2af69: 31 c0                        	xorl	%eax, %eax
; 	if (btf->fd >= 0)
   2af6b: 8b 47 6c                     	movl	108(%rdi), %eax
;   return __builtin___memset_chk (__dest, __ch, __len,
   2af6e: 0f 11 44 24 38               	movups	%xmm0, 56(%rsp)
; 	LIBBPF_OPTS(bpf_btf_load_opts, opts);
   2af73: 48 c7 44 24 30 18 00 00 00   	movq	$24, 48(%rsp)
; 	if (btf->fd >= 0)
   2af7c: 85 c0                        	testl	%eax, %eax
   2af7e: 0f 89 30 02 00 00            	jns	0x2b1b4 <btf_load_into_kernel+0x274>
; 	if (log_sz && !log_buf)
   2af84: 48 83 7c 24 08 00            	cmpq	$0, 8(%rsp)
   2af8a: 49 89 fc                     	movq	%rdi, %r12
   2af8d: 49 89 f6                     	movq	%rsi, %r14
   2af90: 89 cd                        	movl	%ecx, %ebp
   2af92: 74 09                        	je	0x2af9d <btf_load_into_kernel+0x5d>
   2af94: 48 85 f6                     	testq	%rsi, %rsi
   2af97: 0f 84 01 02 00 00            	je	0x2b19e <btf_load_into_kernel+0x25e>
; 	raw_data = btf_get_raw_data(btf, &raw_size, false);
   2af9d: 48 8d 74 24 2c               	leaq	44(%rsp), %rsi
   2afa2: 31 d2                        	xorl	%edx, %edx
   2afa4: 4c 89 e7                     	movq	%r12, %rdi
   2afa7: e8 54 e1 ff ff               	callq	0x29100 <btf_get_raw_data>
   2afac: 49 89 c7                     	movq	%rax, %r15
; 	if (!raw_data) {
   2afaf: 48 85 c0                     	testq	%rax, %rax
   2afb2: 0f 84 88 01 00 00            	je	0x2b140 <btf_load_into_kernel+0x200>
; 	btf->raw_size = raw_size;
   2afb8: 8b 44 24 2c                  	movl	44(%rsp), %eax
; 	btf->raw_data = raw_data;
   2afbc: 4d 89 3c 24                  	movq	%r15, (%r12)
   2afc0: bb 09 00 00 00               	movl	$9, %ebx
; 	char *buf = NULL, *tmp;
   2afc5: 48 c7 04 24 00 00 00 00      	movq	$0, (%rsp)
; 	btf->raw_size = raw_size;
   2afcd: 41 89 44 24 10               	movl	%eax, 16(%r12)
; 	btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
   2afd2: 48 8d 44 24 30               	leaq	48(%rsp), %rax
; 	__u32 buf_sz = 0, raw_size;
   2afd7: c7 44 24 14 00 00 00 00      	movl	$0, 20(%rsp)
; 	btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
   2afdf: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   2afe4: 0f 1f 40 00                  	nopl	(%rax)
; 	if (log_level) {
   2afe8: 85 ed                        	testl	%ebp, %ebp
   2afea: 75 1f                        	jne	0x2b00b <btf_load_into_kernel+0xcb>
; 	btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
   2afec: 8b 74 24 2c                  	movl	44(%rsp), %esi
   2aff0: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   2aff5: 4c 89 ff                     	movq	%r15, %rdi
   2aff8: e8 53 d3 ff ff               	callq	0x28350 <bpf_btf_load>
   2affd: 41 89 44 24 6c               	movl	%eax, 108(%r12)
; 	if (btf->fd < 0) {
   2b002: 85 c0                        	testl	%eax, %eax
   2b004: 79 39                        	jns	0x2b03f <btf_load_into_kernel+0xff>
; 			log_level = 1;
   2b006: bd 01 00 00 00               	movl	$1, %ebp
; 		if (!log_buf) {
   2b00b: 4d 85 f6                     	testq	%r14, %r14
   2b00e: 74 68                        	je	0x2b078 <btf_load_into_kernel+0x138>
; 		opts.log_size = log_buf ? log_sz : buf_sz;
   2b010: 8b 44 24 08                  	movl	8(%rsp), %eax
; 	btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
   2b014: 8b 74 24 2c                  	movl	44(%rsp), %esi
   2b018: 48 8d 54 24 30               	leaq	48(%rsp), %rdx
   2b01d: 4c 89 ff                     	movq	%r15, %rdi
; 		opts.log_buf = log_buf ? log_buf : buf;
   2b020: 4c 89 74 24 38               	movq	%r14, 56(%rsp)
; 		opts.log_size = log_buf ? log_sz : buf_sz;
   2b025: 89 44 24 44                  	movl	%eax, 68(%rsp)
; 		opts.log_level = log_level;
   2b029: 89 6c 24 40                  	movl	%ebp, 64(%rsp)
; 	btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
   2b02d: e8 1e d3 ff ff               	callq	0x28350 <bpf_btf_load>
   2b032: 41 89 44 24 6c               	movl	%eax, 108(%r12)
; 	if (btf->fd < 0) {
   2b037: 85 c0                        	testl	%eax, %eax
   2b039: 0f 88 b9 00 00 00            	js	0x2b0f8 <btf_load_into_kernel+0x1b8>
; 	free(buf);
   2b03f: 48 8b 3c 24                  	movq	(%rsp), %rdi
   2b043: 45 31 e4                     	xorl	%r12d, %r12d
   2b046: e8 75 a6 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; }
   2b04b: 48 8b 44 24 48               	movq	72(%rsp), %rax
   2b050: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2b059: 0f 85 8b 01 00 00            	jne	0x2b1ea <btf_load_into_kernel+0x2aa>
   2b05f: 48 83 c4 58                  	addq	$88, %rsp
   2b063: 44 89 e0                     	movl	%r12d, %eax
   2b066: 5b                           	popq	%rbx
   2b067: 5d                           	popq	%rbp
   2b068: 41 5c                        	popq	%r12
   2b06a: 41 5d                        	popq	%r13
   2b06c: 41 5e                        	popq	%r14
   2b06e: 41 5f                        	popq	%r15
   2b070: c3                           	retq
   2b071: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 			buf_sz = max((__u32)BPF_LOG_BUF_SIZE, buf_sz * 2);
   2b078: d1 64 24 14                  	shll	20(%rsp)
   2b07c: 8b 4c 24 14                  	movl	20(%rsp), %ecx
   2b080: b8 ff ff ff 00               	movl	$16777215, %eax         # imm = 0xFFFFFF
; 			tmp = realloc(buf, buf_sz);
   2b085: 48 8b 3c 24                  	movq	(%rsp), %rdi
; 			buf_sz = max((__u32)BPF_LOG_BUF_SIZE, buf_sz * 2);
   2b089: 39 c1                        	cmpl	%eax, %ecx
   2b08b: 0f 43 c1                     	cmovael	%ecx, %eax
; 			tmp = realloc(buf, buf_sz);
   2b08e: 89 c6                        	movl	%eax, %esi
; 			buf_sz = max((__u32)BPF_LOG_BUF_SIZE, buf_sz * 2);
   2b090: 89 44 24 14                  	movl	%eax, 20(%rsp)
; 			tmp = realloc(buf, buf_sz);
   2b094: e8 87 aa fd ff               	callq	0x5b20 <.plt.sec+0x4b0>
   2b099: 49 89 c5                     	movq	%rax, %r13
; 			if (!tmp) {
   2b09c: 48 85 c0                     	testq	%rax, %rax
   2b09f: 0f 84 53 01 00 00            	je	0x2b1f8 <btf_load_into_kernel+0x2b8>
; 	btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
   2b0a5: 8b 74 24 2c                  	movl	44(%rsp), %esi
   2b0a9: 48 8b 54 24 18               	movq	24(%rsp), %rdx
; 			buf[0] = '\0';
   2b0ae: c6 00 00                     	movb	$0, (%rax)
; 	btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
   2b0b1: 4c 89 ff                     	movq	%r15, %rdi
; 		opts.log_buf = log_buf ? log_buf : buf;
   2b0b4: 48 89 44 24 38               	movq	%rax, 56(%rsp)
; 		opts.log_size = log_buf ? log_sz : buf_sz;
   2b0b9: 8b 44 24 14                  	movl	20(%rsp), %eax
; 		opts.log_level = log_level;
   2b0bd: 89 6c 24 40                  	movl	%ebp, 64(%rsp)
; 		opts.log_size = log_buf ? log_sz : buf_sz;
   2b0c1: 89 44 24 44                  	movl	%eax, 68(%rsp)
; 	btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
   2b0c5: e8 86 d2 ff ff               	callq	0x28350 <bpf_btf_load>
   2b0ca: 41 89 44 24 6c               	movl	%eax, 108(%r12)
; 	if (btf->fd < 0) {
   2b0cf: 85 c0                        	testl	%eax, %eax
   2b0d1: 0f 89 18 01 00 00            	jns	0x2b1ef <btf_load_into_kernel+0x2af>
; 		if (!log_buf && errno == ENOSPC && buf_sz <= UINT_MAX / 2)
   2b0d7: e8 14 a6 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b0dc: 8b 00                        	movl	(%rax), %eax
   2b0de: 83 f8 1c                     	cmpl	$28, %eax
   2b0e1: 0f 85 e3 00 00 00            	jne	0x2b1ca <btf_load_into_kernel+0x28a>
   2b0e7: 83 eb 01                     	subl	$1, %ebx
   2b0ea: 74 64                        	je	0x2b150 <btf_load_into_kernel+0x210>
   2b0ec: 4c 89 2c 24                  	movq	%r13, (%rsp)
   2b0f0: e9 f3 fe ff ff               	jmp	0x2afe8 <btf_load_into_kernel+0xa8>
   2b0f5: 0f 1f 00                     	nopl	(%rax)
; 		err = -errno;
   2b0f8: e8 f3 a5 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		pr_warn("BTF loading error: %d\n", err);
   2b0fd: 48 8d 35 ec 02 01 00         	leaq	66284(%rip), %rsi       # 0x3b3f0 <CSWTCH.126+0x1af0>
   2b104: 31 ff                        	xorl	%edi, %edi
; 		err = -errno;
   2b106: 8b 00                        	movl	(%rax), %eax
   2b108: f7 d8                        	negl	%eax
   2b10a: 41 89 c4                     	movl	%eax, %r12d
; 		pr_warn("BTF loading error: %d\n", err);
   2b10d: 89 c2                        	movl	%eax, %edx
   2b10f: 31 c0                        	xorl	%eax, %eax
   2b111: e8 ba cf fd ff               	callq	0x80d0 <libbpf_print>
; 	free(buf);
   2b116: 48 8b 3c 24                  	movq	(%rsp), %rdi
   2b11a: e8 a1 a5 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (ret < 0)
   2b11f: 45 85 e4                     	testl	%r12d, %r12d
   2b122: 0f 89 23 ff ff ff            	jns	0x2b04b <btf_load_into_kernel+0x10b>
; 		errno = -ret;
   2b128: 44 89 e3                     	movl	%r12d, %ebx
   2b12b: f7 db                        	negl	%ebx
   2b12d: e8 be a5 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b132: 89 18                        	movl	%ebx, (%rax)
   2b134: e9 12 ff ff ff               	jmp	0x2b04b <btf_load_into_kernel+0x10b>
   2b139: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   2b140: bb 0c 00 00 00               	movl	$12, %ebx
; 		err = -ENOMEM;
   2b145: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
   2b14b: eb e0                        	jmp	0x2b12d <btf_load_into_kernel+0x1ed>
   2b14d: 0f 1f 00                     	nopl	(%rax)
; 		pr_warn("BTF loading error: %d\n", err);
   2b150: 31 ff                        	xorl	%edi, %edi
   2b152: 31 c0                        	xorl	%eax, %eax
   2b154: 48 8d 35 95 02 01 00         	leaq	66197(%rip), %rsi       # 0x3b3f0 <CSWTCH.126+0x1af0>
   2b15b: ba e4 ff ff ff               	movl	$4294967268, %edx       # imm = 0xFFFFFFE4
   2b160: e8 6b cf fd ff               	callq	0x80d0 <libbpf_print>
; 		if (!log_buf && buf[0])
   2b165: 41 80 7d 00 00               	cmpb	$0, (%r13)
   2b16a: 75 10                        	jne	0x2b17c <btf_load_into_kernel+0x23c>
; 	free(buf);
   2b16c: 4c 89 ef                     	movq	%r13, %rdi
; 		err = -errno;
   2b16f: 41 bc e4 ff ff ff            	movl	$4294967268, %r12d      # imm = 0xFFFFFFE4
; 	free(buf);
   2b175: e8 46 a5 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (ret < 0)
   2b17a: eb ac                        	jmp	0x2b128 <btf_load_into_kernel+0x1e8>
; 		err = -errno;
   2b17c: 41 bc e4 ff ff ff            	movl	$4294967268, %r12d      # imm = 0xFFFFFFE4
; 			pr_warn("-- BEGIN BTF LOAD LOG ---\n%s\n-- END BTF LOAD LOG --\n", buf);
   2b182: 4c 89 ea                     	movq	%r13, %rdx
   2b185: 48 8d 35 24 02 01 00         	leaq	66084(%rip), %rsi       # 0x3b3b0 <CSWTCH.126+0x1ab0>
   2b18c: 31 ff                        	xorl	%edi, %edi
   2b18e: 31 c0                        	xorl	%eax, %eax
   2b190: e8 3b cf fd ff               	callq	0x80d0 <libbpf_print>
   2b195: 4c 89 2c 24                  	movq	%r13, (%rsp)
   2b199: e9 78 ff ff ff               	jmp	0x2b116 <btf_load_into_kernel+0x1d6>
; 		errno = -ret;
   2b19e: e8 4d a5 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   2b1a3: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   2b1a9: c7 00 16 00 00 00            	movl	$22, (%rax)
   2b1af: e9 97 fe ff ff               	jmp	0x2b04b <btf_load_into_kernel+0x10b>
   2b1b4: e8 37 a5 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EEXIST);
   2b1b9: 41 bc ef ff ff ff            	movl	$4294967279, %r12d      # imm = 0xFFFFFFEF
; 		errno = -ret;
   2b1bf: c7 00 11 00 00 00            	movl	$17, (%rax)
   2b1c5: e9 81 fe ff ff               	jmp	0x2b04b <btf_load_into_kernel+0x10b>
; 		err = -errno;
   2b1ca: f7 d8                        	negl	%eax
; 		pr_warn("BTF loading error: %d\n", err);
   2b1cc: 31 ff                        	xorl	%edi, %edi
   2b1ce: 48 8d 35 1b 02 01 00         	leaq	66075(%rip), %rsi       # 0x3b3f0 <CSWTCH.126+0x1af0>
   2b1d5: 89 c2                        	movl	%eax, %edx
; 		err = -errno;
   2b1d7: 41 89 c4                     	movl	%eax, %r12d
; 		pr_warn("BTF loading error: %d\n", err);
   2b1da: 31 c0                        	xorl	%eax, %eax
   2b1dc: e8 ef ce fd ff               	callq	0x80d0 <libbpf_print>
; 		if (!log_buf && buf[0])
   2b1e1: 41 80 7d 00 00               	cmpb	$0, (%r13)
   2b1e6: 74 ad                        	je	0x2b195 <btf_load_into_kernel+0x255>
   2b1e8: eb 98                        	jmp	0x2b182 <btf_load_into_kernel+0x242>
; }
   2b1ea: e8 11 a6 fd ff               	callq	0x5800 <.plt.sec+0x190>
; 	if (btf->fd < 0) {
   2b1ef: 4c 89 2c 24                  	movq	%r13, (%rsp)
   2b1f3: e9 47 fe ff ff               	jmp	0x2b03f <btf_load_into_kernel+0xff>
; 	free(buf);
   2b1f8: 48 8b 3c 24                  	movq	(%rsp), %rdi
   2b1fc: bb 0c 00 00 00               	movl	$12, %ebx
; 				err = -ENOMEM;
   2b201: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
; 	free(buf);
   2b207: e8 b4 a4 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (ret < 0)
   2b20c: e9 1c ff ff ff               	jmp	0x2b12d <btf_load_into_kernel+0x1ed>
   2b211: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2b21c: 0f 1f 40 00                  	nopl	(%rax)

000000000002b220 <btf__load_into_kernel>:
; {
   2b220: f3 0f 1e fa                  	endbr64
; 	return btf_load_into_kernel(btf, NULL, 0, 0);
   2b224: 31 c9                        	xorl	%ecx, %ecx
   2b226: 31 d2                        	xorl	%edx, %edx
   2b228: 31 f6                        	xorl	%esi, %esi
   2b22a: e9 11 fd ff ff               	jmp	0x2af40 <btf_load_into_kernel>
   2b22f: 90                           	nop

000000000002b230 <btf__fd>:
; {
   2b230: f3 0f 1e fa                  	endbr64
; 	return btf->fd;
   2b234: 8b 47 6c                     	movl	108(%rdi), %eax
; }
   2b237: c3                           	retq
   2b238: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000002b240 <btf__set_fd>:
; {
   2b240: f3 0f 1e fa                  	endbr64
; 	btf->fd = fd;
   2b244: 89 77 6c                     	movl	%esi, 108(%rdi)
; }
   2b247: c3                           	retq
   2b248: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000002b250 <btf__raw_data>:
; {
   2b250: f3 0f 1e fa                  	endbr64
   2b254: 41 54                        	pushq	%r12
   2b256: 55                           	pushq	%rbp
   2b257: 48 89 f5                     	movq	%rsi, %rbp
   2b25a: 53                           	pushq	%rbx
   2b25b: 48 89 fb                     	movq	%rdi, %rbx
   2b25e: 48 83 ec 10                  	subq	$16, %rsp
; 	data = btf_get_raw_data(btf, &data_sz, btf->swapped_endian);
   2b262: 0f b6 57 14                  	movzbl	20(%rdi), %edx
; {
   2b266: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2b26f: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   2b274: 31 c0                        	xorl	%eax, %eax
; 	data = btf_get_raw_data(btf, &data_sz, btf->swapped_endian);
   2b276: 48 8d 74 24 04               	leaq	4(%rsp), %rsi
   2b27b: e8 80 de ff ff               	callq	0x29100 <btf_get_raw_data>
   2b280: 49 89 c4                     	movq	%rax, %r12
; 	if (!data)
   2b283: 48 85 c0                     	testq	%rax, %rax
   2b286: 74 48                        	je	0x2b2d0 <btf__raw_data+0x80>
; 	btf->raw_size = data_sz;
   2b288: 8b 44 24 04                  	movl	4(%rsp), %eax
; 	if (btf->swapped_endian)
   2b28c: 80 7b 14 00                  	cmpb	$0, 20(%rbx)
; 	btf->raw_size = data_sz;
   2b290: 89 43 10                     	movl	%eax, 16(%rbx)
; 	if (btf->swapped_endian)
   2b293: 75 2b                        	jne	0x2b2c0 <btf__raw_data+0x70>
; 		btf->raw_data = data;
   2b295: 4c 89 23                     	movq	%r12, (%rbx)
; 	*size = data_sz;
   2b298: 89 45 00                     	movl	%eax, (%rbp)
; }
   2b29b: 48 8b 44 24 08               	movq	8(%rsp), %rax
   2b2a0: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2b2a9: 75 32                        	jne	0x2b2dd <btf__raw_data+0x8d>
   2b2ab: 48 83 c4 10                  	addq	$16, %rsp
   2b2af: 4c 89 e0                     	movq	%r12, %rax
   2b2b2: 5b                           	popq	%rbx
   2b2b3: 5d                           	popq	%rbp
   2b2b4: 41 5c                        	popq	%r12
   2b2b6: c3                           	retq
   2b2b7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		btf->raw_data_swapped = data;
   2b2c0: 4c 89 63 08                  	movq	%r12, 8(%rbx)
   2b2c4: eb d2                        	jmp	0x2b298 <btf__raw_data+0x48>
   2b2c6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		return errno = ENOMEM, NULL;
   2b2d0: e8 1b a4 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b2d5: c7 00 0c 00 00 00            	movl	$12, (%rax)
   2b2db: eb be                        	jmp	0x2b29b <btf__raw_data+0x4b>
; }
   2b2dd: e8 1e a5 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2b2e2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2b2ed: 0f 1f 00                     	nopl	(%rax)

000000000002b2f0 <btf__str_by_offset>:
; {
   2b2f0: f3 0f 1e fa                  	endbr64
   2b2f4: 55                           	pushq	%rbp
   2b2f5: 89 f5                        	movl	%esi, %ebp
   2b2f7: 53                           	pushq	%rbx
   2b2f8: 48 89 fb                     	movq	%rdi, %rbx
   2b2fb: 48 83 ec 08                  	subq	$8, %rsp
; 	if (offset < btf->start_str_off)
   2b2ff: 8b 47 54                     	movl	84(%rdi), %eax
   2b302: 39 c6                        	cmpl	%eax, %esi
   2b304: 73 15                        	jae	0x2b31b <btf__str_by_offset+0x2b>
   2b306: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		return btf__str_by_offset(btf->base_btf, offset);
   2b310: 48 8b 5b 48                  	movq	72(%rbx), %rbx
; 	if (offset < btf->start_str_off)
   2b314: 8b 43 54                     	movl	84(%rbx), %eax
   2b317: 39 e8                        	cmpl	%ebp, %eax
   2b319: 77 f5                        	ja	0x2b310 <btf__str_by_offset+0x20>
; 	else if (offset - btf->start_str_off < btf->hdr->str_len)
   2b31b: 89 ea                        	movl	%ebp, %edx
   2b31d: 29 c2                        	subl	%eax, %edx
   2b31f: 48 8b 43 18                  	movq	24(%rbx), %rax
   2b323: 3b 50 14                     	cmpl	20(%rax), %edx
   2b326: 73 18                        	jae	0x2b340 <btf__str_by_offset+0x50>
; 	return btf->strs_data ? btf->strs_data : strset__data(btf->strs_set);
   2b328: 48 8b 43 58                  	movq	88(%rbx), %rax
   2b32c: 48 85 c0                     	testq	%rax, %rax
   2b32f: 74 27                        	je	0x2b358 <btf__str_by_offset+0x68>
; 		return btf_strs_data(btf) + (offset - btf->start_str_off);
   2b331: 2b 6b 54                     	subl	84(%rbx), %ebp
; }
   2b334: 48 83 c4 08                  	addq	$8, %rsp
; 		return btf_strs_data(btf) + (offset - btf->start_str_off);
   2b338: 48 01 e8                     	addq	%rbp, %rax
; }
   2b33b: 5b                           	popq	%rbx
   2b33c: 5d                           	popq	%rbp
   2b33d: c3                           	retq
   2b33e: 66 90                        	nop
; 		return errno = EINVAL, NULL;
   2b340: e8 ab a3 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b345: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   2b34b: 48 83 c4 08                  	addq	$8, %rsp
; 		return errno = EINVAL, NULL;
   2b34f: 31 c0                        	xorl	%eax, %eax
; }
   2b351: 5b                           	popq	%rbx
   2b352: 5d                           	popq	%rbp
   2b353: c3                           	retq
   2b354: 0f 1f 40 00                  	nopl	(%rax)
; 	return btf->strs_data ? btf->strs_data : strset__data(btf->strs_set);
   2b358: 48 8b 7b 60                  	movq	96(%rbx), %rdi
   2b35c: e8 af 4a 00 00               	callq	0x2fe10 <strset__data>
   2b361: eb ce                        	jmp	0x2b331 <btf__str_by_offset+0x41>
   2b363: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2b36e: 66 90                        	nop

000000000002b370 <determine_ptr_size>:
; {
   2b370: 41 57                        	pushq	%r15
   2b372: 49 89 ff                     	movq	%rdi, %r15
   2b375: 41 56                        	pushq	%r14
   2b377: 41 55                        	pushq	%r13
   2b379: 41 54                        	pushq	%r12
   2b37b: 55                           	pushq	%rbp
   2b37c: 53                           	pushq	%rbx
   2b37d: 48 83 ec 18                  	subq	$24, %rsp
; 	if (btf->base_btf && btf->base_btf->ptr_sz > 0)
   2b381: 48 8b 47 48                  	movq	72(%rdi), %rax
   2b385: 48 85 c0                     	testq	%rax, %rax
   2b388: 74 0b                        	je	0x2b395 <determine_ptr_size+0x25>
   2b38a: 8b 40 70                     	movl	112(%rax), %eax
   2b38d: 85 c0                        	testl	%eax, %eax
   2b38f: 0f 8f d7 00 00 00            	jg	0x2b46c <determine_ptr_size+0xfc>
; 	return btf->start_id + btf->nr_types;
   2b395: 41 8b 47 50                  	movl	80(%r15), %eax
   2b399: 41 8b 4f 40                  	movl	64(%r15), %ecx
; 	for (i = 1; i < n; i++) {
   2b39d: bb 01 00 00 00               	movl	$1, %ebx
   2b3a2: 48 8d 2d ef b6 01 00         	leaq	112367(%rip), %rbp      # 0x46a98 <_DYNAMIC>
; 	return btf->start_id + btf->nr_types;
   2b3a9: 01 c1                        	addl	%eax, %ecx
   2b3ab: 89 4c 24 0c                  	movl	%ecx, 12(%rsp)
; 	for (i = 1; i < n; i++) {
   2b3af: 83 f9 01                     	cmpl	$1, %ecx
   2b3b2: 0f 8e c3 00 00 00            	jle	0x2b47b <determine_ptr_size+0x10b>
   2b3b8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b3c0: 89 c2                        	movl	%eax, %edx
   2b3c2: 39 d9                        	cmpl	%ebx, %ecx
   2b3c4: 0f 86 08 a9 fd ff            	jbe	0x5cd2 <determine_ptr_size.cold>
; 	if (type_id < btf->start_id)
   2b3ca: 39 d8                        	cmpl	%ebx, %eax
   2b3cc: 4c 89 f8                     	movq	%r15, %rax
   2b3cf: 76 12                        	jbe	0x2b3e3 <determine_ptr_size+0x73>
   2b3d1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2b3d8: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2b3dc: 8b 50 50                     	movl	80(%rax), %edx
   2b3df: 39 da                        	cmpl	%ebx, %edx
   2b3e1: 77 f5                        	ja	0x2b3d8 <determine_ptr_size+0x68>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b3e3: 89 d9                        	movl	%ebx, %ecx
   2b3e5: 29 d1                        	subl	%edx, %ecx
   2b3e7: 48 8b 50 30                  	movq	48(%rax), %rdx
   2b3eb: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2b3ee: 48 03 50 20                  	addq	32(%rax), %rdx
; 	return BTF_INFO_KIND(t->info);
   2b3f2: 0f b6 42 07                  	movzbl	7(%rdx), %eax
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b3f6: 49 89 d5                     	movq	%rdx, %r13
; 	return BTF_INFO_KIND(t->info);
   2b3f9: 83 e0 1f                     	andl	$31, %eax
; 		if (!btf_is_int(t))
   2b3fc: 66 83 f8 01                  	cmpw	$1, %ax
   2b400: 75 4e                        	jne	0x2b450 <determine_ptr_size+0xe0>
; 		if (t->size != 4 && t->size != 8)
   2b402: 8b 42 08                     	movl	8(%rdx), %eax
   2b405: 83 e8 04                     	subl	$4, %eax
   2b408: 83 e0 fb                     	andl	$-5, %eax
   2b40b: 75 43                        	jne	0x2b450 <determine_ptr_size+0xe0>
; 	return btf__str_by_offset(btf, offset);
   2b40d: 8b 32                        	movl	(%rdx), %esi
   2b40f: 4c 89 ff                     	movq	%r15, %rdi
   2b412: e8 d9 fe ff ff               	callq	0x2b2f0 <btf__str_by_offset>
   2b417: 49 89 c4                     	movq	%rax, %r12
; 		if (!name)
   2b41a: 48 85 c0                     	testq	%rax, %rax
   2b41d: 74 31                        	je	0x2b450 <determine_ptr_size+0xe0>
   2b41f: 4c 8d 35 22 b6 01 00         	leaq	112162(%rip), %r14      # 0x46a48 <long_aliases.0+0x8>
   2b426: 48 8d 35 4d 08 01 00         	leaq	67661(%rip), %rsi       # 0x3bc7a <CSWTCH.126+0x237a>
   2b42d: eb 08                        	jmp	0x2b437 <determine_ptr_size+0xc7>
   2b42f: 90                           	nop
; 			if (strcmp(name, long_aliases[j]) == 0)
   2b430: 49 8b 36                     	movq	(%r14), %rsi
   2b433: 49 83 c6 08                  	addq	$8, %r14
   2b437: 4c 89 e7                     	movq	%r12, %rdi
   2b43a: e8 71 a5 fd ff               	callq	0x59b0 <.plt.sec+0x340>
   2b43f: 85 c0                        	testl	%eax, %eax
   2b441: 74 25                        	je	0x2b468 <determine_ptr_size+0xf8>
; 		for (j = 0; j < ARRAY_SIZE(long_aliases); j++) {
   2b443: 4c 39 f5                     	cmpq	%r14, %rbp
   2b446: 75 e8                        	jne	0x2b430 <determine_ptr_size+0xc0>
   2b448: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	for (i = 1; i < n; i++) {
   2b450: 83 c3 01                     	addl	$1, %ebx
   2b453: 39 5c 24 0c                  	cmpl	%ebx, 12(%rsp)
   2b457: 74 22                        	je	0x2b47b <determine_ptr_size+0x10b>
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b459: 41 8b 47 50                  	movl	80(%r15), %eax
   2b45d: 41 8b 4f 40                  	movl	64(%r15), %ecx
   2b461: 01 c1                        	addl	%eax, %ecx
   2b463: e9 58 ff ff ff               	jmp	0x2b3c0 <determine_ptr_size+0x50>
; 				return t->size;
   2b468: 41 8b 45 08                  	movl	8(%r13), %eax
; }
   2b46c: 48 83 c4 18                  	addq	$24, %rsp
   2b470: 5b                           	popq	%rbx
   2b471: 5d                           	popq	%rbp
   2b472: 41 5c                        	popq	%r12
   2b474: 41 5d                        	popq	%r13
   2b476: 41 5e                        	popq	%r14
   2b478: 41 5f                        	popq	%r15
   2b47a: c3                           	retq
   2b47b: 48 83 c4 18                  	addq	$24, %rsp
; 	return -1;
   2b47f: b8 ff ff ff ff               	movl	$4294967295, %eax       # imm = 0xFFFFFFFF
; }
   2b484: 5b                           	popq	%rbx
   2b485: 5d                           	popq	%rbp
   2b486: 41 5c                        	popq	%r12
   2b488: 41 5d                        	popq	%r13
   2b48a: 41 5e                        	popq	%r14
   2b48c: 41 5f                        	popq	%r15
   2b48e: c3                           	retq
   2b48f: 90                           	nop

000000000002b490 <btf__pointer_size>:
; {
   2b490: f3 0f 1e fa                  	endbr64
; 	if (!btf->ptr_sz)
   2b494: 8b 47 70                     	movl	112(%rdi), %eax
   2b497: 85 c0                        	testl	%eax, %eax
   2b499: 74 0d                        	je	0x2b4a8 <btf__pointer_size+0x18>
; }
   2b49b: 31 d2                        	xorl	%edx, %edx
   2b49d: 85 c0                        	testl	%eax, %eax
   2b49f: 0f 48 c2                     	cmovsl	%edx, %eax
   2b4a2: 48 98                        	cltq
   2b4a4: c3                           	retq
   2b4a5: 0f 1f 00                     	nopl	(%rax)
; {
   2b4a8: 53                           	pushq	%rbx
   2b4a9: 48 89 fb                     	movq	%rdi, %rbx
; 		((struct btf *)btf)->ptr_sz = determine_ptr_size(btf);
   2b4ac: e8 bf fe ff ff               	callq	0x2b370 <determine_ptr_size>
; }
   2b4b1: 31 d2                        	xorl	%edx, %edx
   2b4b3: 85 c0                        	testl	%eax, %eax
; 		((struct btf *)btf)->ptr_sz = determine_ptr_size(btf);
   2b4b5: 89 43 70                     	movl	%eax, 112(%rbx)
; }
   2b4b8: 5b                           	popq	%rbx
   2b4b9: 0f 48 c2                     	cmovsl	%edx, %eax
   2b4bc: 48 98                        	cltq
   2b4be: c3                           	retq
   2b4bf: 90                           	nop

000000000002b4c0 <btf__resolve_size>:
; {
   2b4c0: f3 0f 1e fa                  	endbr64
   2b4c4: 55                           	pushq	%rbp
   2b4c5: 48 89 fd                     	movq	%rdi, %rbp
   2b4c8: 53                           	pushq	%rbx
   2b4c9: 48 83 ec 08                  	subq	$8, %rsp
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b4cd: 8b 7f 50                     	movl	80(%rdi), %edi
   2b4d0: 44 8b 45 40                  	movl	64(%rbp), %r8d
   2b4d4: 42 8d 04 07                  	leal	(%rdi,%r8), %eax
   2b4d8: 39 c6                        	cmpl	%eax, %esi
   2b4da: 0f 83 e0 00 00 00            	jae	0x2b5c0 <btf__resolve_size+0x100>
; 	if (type_id == 0)
   2b4e0: 85 f6                        	testl	%esi, %esi
   2b4e2: 0f 84 e3 00 00 00            	je	0x2b5cb <btf__resolve_size+0x10b>
   2b4e8: 89 fa                        	movl	%edi, %edx
   2b4ea: 48 89 e8                     	movq	%rbp, %rax
   2b4ed: eb 08                        	jmp	0x2b4f7 <btf__resolve_size+0x37>
   2b4ef: 90                           	nop
; 		return btf_type_by_id(btf->base_btf, type_id);
   2b4f0: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2b4f4: 8b 50 50                     	movl	80(%rax), %edx
   2b4f7: 39 d6                        	cmpl	%edx, %esi
   2b4f9: 72 f5                        	jb	0x2b4f0 <btf__resolve_size+0x30>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b4fb: 29 d6                        	subl	%edx, %esi
   2b4fd: 48 8b 50 30                  	movq	48(%rax), %rdx
   2b501: 41 bb 20 00 00 00            	movl	$32, %r11d
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b507: 41 01 f8                     	addl	%edi, %r8d
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b50a: bb 01 00 00 00               	movl	$1, %ebx
; 	return t == &btf_void || btf_is_fwd(t);
   2b50f: 4c 8d 15 7a bd 01 00         	leaq	114042(%rip), %r10      # 0x47290 <btf_void>
   2b516: 41 b9 01 00 00 00            	movl	$1, %r9d
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b51c: 8b 34 b2                     	movl	(%rdx,%rsi,4), %esi
   2b51f: 48 03 70 20                  	addq	32(%rax), %rsi
; 	return !t || btf_type_is_void(t);
   2b523: 48 85 f6                     	testq	%rsi, %rsi
   2b526: 0f 84 9f 00 00 00            	je	0x2b5cb <btf__resolve_size+0x10b>
; 	return t == &btf_void || btf_is_fwd(t);
   2b52c: 4c 39 d6                     	cmpq	%r10, %rsi
   2b52f: 0f 84 96 00 00 00            	je	0x2b5cb <btf__resolve_size+0x10b>
; 	return BTF_INFO_KIND(t->info);
   2b535: 0f b6 46 07                  	movzbl	7(%rsi), %eax
   2b539: 83 e0 1f                     	andl	$31, %eax
; 	for (i = 0; i < MAX_RESOLVE_DEPTH && !btf_type_is_void_or_null(t); i++) {
   2b53c: 66 83 f8 07                  	cmpw	$7, %ax
   2b540: 0f 84 85 00 00 00            	je	0x2b5cb <btf__resolve_size+0x10b>
; 		switch (btf_kind(t)) {
   2b546: 66 83 f8 13                  	cmpw	$19, %ax
   2b54a: 0f 87 be 00 00 00            	ja	0x2b60e <btf__resolve_size+0x14e>
   2b550: 66 83 f8 02                  	cmpw	$2, %ax
   2b554: 76 3a                        	jbe	0x2b590 <btf__resolve_size+0xd0>
   2b556: 0f b7 c8                     	movzwl	%ax, %ecx
   2b559: 4c 89 ca                     	movq	%r9, %rdx
   2b55c: 48 d3 e2                     	shlq	%cl, %rdx
   2b55f: f7 c2 00 4f 06 00            	testl	$413440, %edx           # imm = 0x64F00
   2b565: 0f 85 15 01 00 00            	jne	0x2b680 <btf__resolve_size+0x1c0>
   2b56b: f7 c2 70 80 09 00            	testl	$622704, %edx           # imm = 0x98070
   2b571: 0f 84 91 00 00 00            	je	0x2b608 <btf__resolve_size+0x148>
; 			size = t->size;
   2b577: 8b 4e 08                     	movl	8(%rsi), %ecx
; 	if (nelems && size > UINT32_MAX / nelems)
   2b57a: 85 db                        	testl	%ebx, %ebx
   2b57c: 75 62                        	jne	0x2b5e0 <btf__resolve_size+0x120>
; 	return nelems * size;
   2b57e: 89 d8                        	movl	%ebx, %eax
   2b580: 48 0f af c1                  	imulq	%rcx, %rax
; }
   2b584: 48 83 c4 08                  	addq	$8, %rsp
   2b588: 5b                           	popq	%rbx
   2b589: 5d                           	popq	%rbp
   2b58a: c3                           	retq
   2b58b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		switch (btf_kind(t)) {
   2b590: 66 83 f8 01                  	cmpw	$1, %ax
   2b594: 74 e1                        	je	0x2b577 <btf__resolve_size+0xb7>
   2b596: 66 83 f8 02                  	cmpw	$2, %ax
   2b59a: 75 72                        	jne	0x2b60e <btf__resolve_size+0x14e>
; 	if (!btf->ptr_sz)
   2b59c: 8b 45 70                     	movl	112(%rbp), %eax
   2b59f: 85 c0                        	testl	%eax, %eax
   2b5a1: 0f 84 09 01 00 00            	je	0x2b6b0 <btf__resolve_size+0x1f0>
; 	return btf->ptr_sz < 0 ? sizeof(void *) : btf->ptr_sz;
   2b5a7: 85 c0                        	testl	%eax, %eax
   2b5a9: ba 08 00 00 00               	movl	$8, %edx
   2b5ae: 0f 48 c2                     	cmovsl	%edx, %eax
   2b5b1: 48 63 c8                     	movslq	%eax, %rcx
; 	if (nelems && size > UINT32_MAX / nelems)
   2b5b4: 85 db                        	testl	%ebx, %ebx
   2b5b6: 75 28                        	jne	0x2b5e0 <btf__resolve_size+0x120>
   2b5b8: eb c4                        	jmp	0x2b57e <btf__resolve_size+0xbe>
   2b5ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return errno = EINVAL, NULL;
   2b5c0: e8 2b a1 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b5c5: c7 00 16 00 00 00            	movl	$22, (%rax)
   2b5cb: e8 20 a1 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		errno = -ret;
   2b5d0: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2b5d6: 48 c7 c0 ea ff ff ff         	movq	$-22, %rax
   2b5dd: eb a5                        	jmp	0x2b584 <btf__resolve_size+0xc4>
   2b5df: 90                           	nop
; 	if (nelems && size > UINT32_MAX / nelems)
   2b5e0: b8 ff ff ff ff               	movl	$4294967295, %eax       # imm = 0xFFFFFFFF
   2b5e5: 31 d2                        	xorl	%edx, %edx
   2b5e7: f7 f3                        	divl	%ebx
   2b5e9: 48 39 c8                     	cmpq	%rcx, %rax
   2b5ec: 7d 90                        	jge	0x2b57e <btf__resolve_size+0xbe>
; 		errno = -ret;
   2b5ee: e8 fd a0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b5f3: c7 00 07 00 00 00            	movl	$7, (%rax)
; 		return libbpf_err(-E2BIG);
   2b5f9: 48 c7 c0 f9 ff ff ff         	movq	$-7, %rax
   2b600: e9 7f ff ff ff               	jmp	0x2b584 <btf__resolve_size+0xc4>
   2b605: 0f 1f 00                     	nopl	(%rax)
; 		switch (btf_kind(t)) {
   2b608: 66 83 f8 03                  	cmpw	$3, %ax
   2b60c: 74 22                        	je	0x2b630 <btf__resolve_size+0x170>
; 		errno = -ret;
   2b60e: e8 dd a0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b613: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   2b619: 48 83 c4 08                  	addq	$8, %rsp
; 			return libbpf_err(-EINVAL);
   2b61d: 48 c7 c0 ea ff ff ff         	movq	$-22, %rax
; }
   2b624: 5b                           	popq	%rbx
   2b625: 5d                           	popq	%rbp
   2b626: c3                           	retq
   2b627: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 			if (nelems && array->nelems > UINT32_MAX / nelems)
   2b630: 8b 4e 14                     	movl	20(%rsi), %ecx
   2b633: 85 db                        	testl	%ebx, %ebx
   2b635: 75 69                        	jne	0x2b6a0 <btf__resolve_size+0x1e0>
; 			nelems *= array->nelems;
   2b637: 0f af d9                     	imull	%ecx, %ebx
; 			type_id = array->type;
   2b63a: 8b 4e 0c                     	movl	12(%rsi), %ecx
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b63d: 89 fa                        	movl	%edi, %edx
   2b63f: 44 39 c1                     	cmpl	%r8d, %ecx
   2b642: 73 46                        	jae	0x2b68a <btf__resolve_size+0x1ca>
; 		return &btf_void;
   2b644: 4c 89 d6                     	movq	%r10, %rsi
; 	if (type_id == 0)
   2b647: 85 c9                        	testl	%ecx, %ecx
   2b649: 74 1d                        	je	0x2b668 <btf__resolve_size+0x1a8>
   2b64b: 48 89 e8                     	movq	%rbp, %rax
   2b64e: eb 07                        	jmp	0x2b657 <btf__resolve_size+0x197>
; 		return btf_type_by_id(btf->base_btf, type_id);
   2b650: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2b654: 8b 50 50                     	movl	80(%rax), %edx
   2b657: 39 d1                        	cmpl	%edx, %ecx
   2b659: 72 f5                        	jb	0x2b650 <btf__resolve_size+0x190>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b65b: 29 d1                        	subl	%edx, %ecx
   2b65d: 48 8b 50 30                  	movq	48(%rax), %rdx
   2b661: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2b664: 48 03 70 20                  	addq	32(%rax), %rsi
; 	for (i = 0; i < MAX_RESOLVE_DEPTH && !btf_type_is_void_or_null(t); i++) {
   2b668: 41 83 eb 01                  	subl	$1, %r11d
   2b66c: 0f 85 b1 fe ff ff            	jne	0x2b523 <btf__resolve_size+0x63>
; done:
   2b672: e9 54 ff ff ff               	jmp	0x2b5cb <btf__resolve_size+0x10b>
   2b677: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 			type_id = t->type;
   2b680: 8b 4e 08                     	movl	8(%rsi), %ecx
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b683: 89 fa                        	movl	%edi, %edx
   2b685: 44 39 c1                     	cmpl	%r8d, %ecx
   2b688: 72 ba                        	jb	0x2b644 <btf__resolve_size+0x184>
; 		return errno = EINVAL, NULL;
   2b68a: e8 61 a0 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b68f: c7 00 16 00 00 00            	movl	$22, (%rax)
; 	for (i = 0; i < MAX_RESOLVE_DEPTH && !btf_type_is_void_or_null(t); i++) {
   2b695: e9 36 ff ff ff               	jmp	0x2b5d0 <btf__resolve_size+0x110>
   2b69a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2b6a0: 89 c8                        	movl	%ecx, %eax
   2b6a2: f7 e3                        	mull	%ebx
   2b6a4: 71 91                        	jno	0x2b637 <btf__resolve_size+0x177>
   2b6a6: e9 43 ff ff ff               	jmp	0x2b5ee <btf__resolve_size+0x12e>
   2b6ab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		((struct btf *)btf)->ptr_sz = determine_ptr_size(btf);
   2b6b0: 48 89 ef                     	movq	%rbp, %rdi
   2b6b3: e8 b8 fc ff ff               	callq	0x2b370 <determine_ptr_size>
; 	return btf->ptr_sz < 0 ? sizeof(void *) : btf->ptr_sz;
   2b6b8: ba 08 00 00 00               	movl	$8, %edx
   2b6bd: 85 c0                        	testl	%eax, %eax
; 		((struct btf *)btf)->ptr_sz = determine_ptr_size(btf);
   2b6bf: 89 45 70                     	movl	%eax, 112(%rbp)
; 	return btf->ptr_sz < 0 ? sizeof(void *) : btf->ptr_sz;
   2b6c2: 0f 48 c2                     	cmovsl	%edx, %eax
   2b6c5: 48 63 c8                     	movslq	%eax, %rcx
; 			goto done;
   2b6c8: e9 e7 fe ff ff               	jmp	0x2b5b4 <btf__resolve_size+0xf4>
   2b6cd: 0f 1f 00                     	nopl	(%rax)

000000000002b6d0 <btf__align_of>:
; {
   2b6d0: f3 0f 1e fa                  	endbr64
   2b6d4: 41 56                        	pushq	%r14
; 		return &btf_void;
   2b6d6: 4c 8d 15 b3 bb 01 00         	leaq	113587(%rip), %r10      # 0x47290 <btf_void>
   2b6dd: 41 b9 01 00 00 00            	movl	$1, %r9d
; {
   2b6e3: 41 55                        	pushq	%r13
   2b6e5: 41 54                        	pushq	%r12
   2b6e7: 55                           	pushq	%rbp
   2b6e8: 53                           	pushq	%rbx
   2b6e9: 48 89 fb                     	movq	%rdi, %rbx
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b6ec: 8b 7f 50                     	movl	80(%rdi), %edi
   2b6ef: 44 8b 43 40                  	movl	64(%rbx), %r8d
   2b6f3: 41 01 f8                     	addl	%edi, %r8d
   2b6f6: 44 39 c6                     	cmpl	%r8d, %esi
   2b6f9: 0f 83 e7 a5 fd ff            	jae	0x5ce6 <btf__align_of.cold>
; 		return &btf_void;
   2b6ff: 4c 89 d5                     	movq	%r10, %rbp
; 	if (type_id == 0)
   2b702: 85 f6                        	testl	%esi, %esi
   2b704: 74 22                        	je	0x2b728 <btf__align_of+0x58>
   2b706: 89 fa                        	movl	%edi, %edx
   2b708: 48 89 d8                     	movq	%rbx, %rax
   2b70b: eb 0a                        	jmp	0x2b717 <btf__align_of+0x47>
   2b70d: 0f 1f 00                     	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2b710: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2b714: 8b 50 50                     	movl	80(%rax), %edx
   2b717: 39 d6                        	cmpl	%edx, %esi
   2b719: 72 f5                        	jb	0x2b710 <btf__align_of+0x40>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b71b: 29 d6                        	subl	%edx, %esi
   2b71d: 48 8b 50 30                  	movq	48(%rax), %rdx
   2b721: 8b 2c b2                     	movl	(%rdx,%rsi,4), %ebp
   2b724: 48 03 68 20                  	addq	32(%rax), %rbp
; 	return BTF_INFO_KIND(t->info);
   2b728: 8b 55 04                     	movl	4(%rbp), %edx
   2b72b: 89 d0                        	movl	%edx, %eax
   2b72d: c1 e8 18                     	shrl	$24, %eax
   2b730: 89 c1                        	movl	%eax, %ecx
   2b732: 83 e1 1f                     	andl	$31, %ecx
; 	switch (kind) {
   2b735: 66 83 f9 13                  	cmpw	$19, %cx
   2b739: 0f 87 9e 00 00 00            	ja	0x2b7dd <btf__align_of+0x10d>
   2b73f: a8 1c                        	testb	$28, %al
   2b741: 75 1d                        	jne	0x2b760 <btf__align_of+0x90>
   2b743: 66 83 f9 02                  	cmpw	$2, %cx
   2b747: 0f 84 03 01 00 00            	je	0x2b850 <btf__align_of+0x180>
   2b74d: 66 83 f9 03                  	cmpw	$3, %cx
   2b751: 0f 85 80 00 00 00            	jne	0x2b7d7 <btf__align_of+0x107>
; 		return btf__align_of(btf, btf_array(t)->type);
   2b757: 8b 75 0c                     	movl	12(%rbp), %esi
   2b75a: eb 9a                        	jmp	0x2b6f6 <btf__align_of+0x26>
   2b75c: 0f 1f 40 00                  	nopl	(%rax)
; 	switch (kind) {
   2b760: 0f b7 c9                     	movzwl	%cx, %ecx
   2b763: 4c 89 c8                     	movq	%r9, %rax
   2b766: 48 d3 e0                     	shlq	%cl, %rax
   2b769: a9 00 0f 04 00               	testl	$265984, %eax           # imm = 0x40F00
   2b76e: 0f 85 cc 00 00 00            	jne	0x2b840 <btf__align_of+0x170>
   2b774: a9 40 00 09 00               	testl	$589888, %eax           # imm = 0x90040
   2b779: 0f 85 91 00 00 00            	jne	0x2b810 <btf__align_of+0x140>
   2b77f: a8 30                        	testb	$48, %al
   2b781: 74 5d                        	je	0x2b7e0 <btf__align_of+0x110>
; 	return (struct btf_member *)(t + 1);
   2b783: 4c 8d 6d 0c                  	leaq	12(%rbp), %r13
; 		for (i = 0; i < vlen; i++, m++) {
   2b787: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   2b78d: 0f 84 1c 01 00 00            	je	0x2b8af <btf__align_of+0x1df>
   2b793: 8d 42 ff                     	leal	-1(%rdx), %eax
; 		int i, max_align = 1, align;
   2b796: 41 bc 01 00 00 00            	movl	$1, %r12d
   2b79c: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   2b7a0: 4c 8d 74 85 18               	leaq	24(%rbp,%rax,4), %r14
; 			align = btf__align_of(btf, m->type);
   2b7a5: 41 8b 75 04                  	movl	4(%r13), %esi
   2b7a9: 48 89 df                     	movq	%rbx, %rdi
   2b7ac: e8 1f ff ff ff               	callq	0x2b6d0 <btf__align_of>
   2b7b1: 89 c5                        	movl	%eax, %ebp
; 			if (align <= 0)
   2b7b3: 85 c0                        	testl	%eax, %eax
   2b7b5: 0f 8e d5 00 00 00            	jle	0x2b890 <btf__align_of+0x1c0>
; 			max_align = max(max_align, align);
   2b7bb: 41 39 c4                     	cmpl	%eax, %r12d
   2b7be: 44 0f 4c e0                  	cmovll	%eax, %r12d
; 		for (i = 0; i < vlen; i++, m++) {
   2b7c2: 49 83 c5 0c                  	addq	$12, %r13
   2b7c6: 4d 39 f5                     	cmpq	%r14, %r13
   2b7c9: 75 da                        	jne	0x2b7a5 <btf__align_of+0xd5>
; }
   2b7cb: 5b                           	popq	%rbx
   2b7cc: 44 89 e0                     	movl	%r12d, %eax
   2b7cf: 5d                           	popq	%rbp
   2b7d0: 41 5c                        	popq	%r12
   2b7d2: 41 5d                        	popq	%r13
   2b7d4: 41 5e                        	popq	%r14
   2b7d6: c3                           	retq
; 	switch (kind) {
   2b7d7: 66 83 f9 01                  	cmpw	$1, %cx
   2b7db: 74 33                        	je	0x2b810 <btf__align_of+0x140>
   2b7dd: 0f b7 c9                     	movzwl	%cx, %ecx
; 		pr_warn("unsupported BTF_KIND:%u\n", btf_kind(t));
   2b7e0: 89 ca                        	movl	%ecx, %edx
   2b7e2: 48 8d 35 27 fc 00 00         	leaq	64551(%rip), %rsi       # 0x3b410 <CSWTCH.126+0x1b10>
   2b7e9: 31 ff                        	xorl	%edi, %edi
   2b7eb: 31 c0                        	xorl	%eax, %eax
   2b7ed: e8 de c8 fd ff               	callq	0x80d0 <libbpf_print>
; 		return errno = EINVAL, 0;
   2b7f2: 45 31 e4                     	xorl	%r12d, %r12d
   2b7f5: e8 f6 9e fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b7fa: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   2b800: 44 89 e0                     	movl	%r12d, %eax
   2b803: 5b                           	popq	%rbx
   2b804: 5d                           	popq	%rbp
   2b805: 41 5c                        	popq	%r12
   2b807: 41 5d                        	popq	%r13
   2b809: 41 5e                        	popq	%r14
   2b80b: c3                           	retq
   2b80c: 0f 1f 40 00                  	nopl	(%rax)
; 	if (!btf->ptr_sz)
   2b810: 8b 43 70                     	movl	112(%rbx), %eax
   2b813: 85 c0                        	testl	%eax, %eax
   2b815: 74 6a                        	je	0x2b881 <btf__align_of+0x1b1>
; 	return btf->ptr_sz < 0 ? sizeof(void *) : btf->ptr_sz;
   2b817: 85 c0                        	testl	%eax, %eax
   2b819: ba 08 00 00 00               	movl	$8, %edx
; 		return min(btf_ptr_sz(btf), (size_t)t->size);
   2b81e: 44 8b 65 08                  	movl	8(%rbp), %r12d
; }
   2b822: 5b                           	popq	%rbx
; 	return btf->ptr_sz < 0 ? sizeof(void *) : btf->ptr_sz;
   2b823: 0f 48 c2                     	cmovsl	%edx, %eax
; }
   2b826: 5d                           	popq	%rbp
; 		return min(btf_ptr_sz(btf), (size_t)t->size);
   2b827: 48 98                        	cltq
   2b829: 49 39 c4                     	cmpq	%rax, %r12
   2b82c: 4c 0f 47 e0                  	cmovaq	%rax, %r12
; }
   2b830: 44 89 e0                     	movl	%r12d, %eax
   2b833: 41 5c                        	popq	%r12
   2b835: 41 5d                        	popq	%r13
   2b837: 41 5e                        	popq	%r14
   2b839: c3                           	retq
   2b83a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf__align_of(btf, t->type);
   2b840: 8b 75 08                     	movl	8(%rbp), %esi
   2b843: e9 ae fe ff ff               	jmp	0x2b6f6 <btf__align_of+0x26>
   2b848: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	if (!btf->ptr_sz)
   2b850: 44 8b 63 70                  	movl	112(%rbx), %r12d
   2b854: 45 85 e4                     	testl	%r12d, %r12d
   2b857: 74 18                        	je	0x2b871 <btf__align_of+0x1a1>
; 	return btf->ptr_sz < 0 ? sizeof(void *) : btf->ptr_sz;
   2b859: b8 08 00 00 00               	movl	$8, %eax
   2b85e: 45 85 e4                     	testl	%r12d, %r12d
; }
   2b861: 5b                           	popq	%rbx
   2b862: 5d                           	popq	%rbp
   2b863: 44 0f 48 e0                  	cmovsl	%eax, %r12d
   2b867: 44 89 e0                     	movl	%r12d, %eax
   2b86a: 41 5c                        	popq	%r12
   2b86c: 41 5d                        	popq	%r13
   2b86e: 41 5e                        	popq	%r14
   2b870: c3                           	retq
; 		((struct btf *)btf)->ptr_sz = determine_ptr_size(btf);
   2b871: 48 89 df                     	movq	%rbx, %rdi
   2b874: e8 f7 fa ff ff               	callq	0x2b370 <determine_ptr_size>
   2b879: 89 43 70                     	movl	%eax, 112(%rbx)
   2b87c: 41 89 c4                     	movl	%eax, %r12d
   2b87f: eb d8                        	jmp	0x2b859 <btf__align_of+0x189>
   2b881: 48 89 df                     	movq	%rbx, %rdi
   2b884: e8 e7 fa ff ff               	callq	0x2b370 <determine_ptr_size>
   2b889: 89 43 70                     	movl	%eax, 112(%rbx)
   2b88c: eb 89                        	jmp	0x2b817 <btf__align_of+0x147>
   2b88e: 66 90                        	nop
; 			align = btf__align_of(btf, m->type);
   2b890: 41 bc 00 00 00 00            	movl	$0, %r12d
; 	if (ret < 0)
   2b896: 0f 84 2f ff ff ff            	je	0x2b7cb <btf__align_of+0xfb>
; 		errno = -ret;
   2b89c: e8 4f 9e fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b8a1: 89 ea                        	movl	%ebp, %edx
   2b8a3: 41 89 ec                     	movl	%ebp, %r12d
   2b8a6: f7 da                        	negl	%edx
   2b8a8: 89 10                        	movl	%edx, (%rax)
   2b8aa: e9 1c ff ff ff               	jmp	0x2b7cb <btf__align_of+0xfb>
; 		int i, max_align = 1, align;
   2b8af: 41 bc 01 00 00 00            	movl	$1, %r12d
   2b8b5: e9 11 ff ff ff               	jmp	0x2b7cb <btf__align_of+0xfb>
   2b8ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000002b8c0 <btf__find_by_name>:
; {
   2b8c0: f3 0f 1e fa                  	endbr64
   2b8c4: 41 56                        	pushq	%r14
   2b8c6: 41 55                        	pushq	%r13
   2b8c8: 41 54                        	pushq	%r12
   2b8ca: 49 89 fc                     	movq	%rdi, %r12
   2b8cd: 55                           	pushq	%rbp
   2b8ce: 48 89 f5                     	movq	%rsi, %rbp
; 	if (!strcmp(type_name, "void"))
   2b8d1: 48 8d 35 e0 62 00 00         	leaq	25312(%rip), %rsi       # 0x31bb8 <_IO_stdin_used+0x1bb8>
; {
   2b8d8: 53                           	pushq	%rbx
; 	return btf->start_id + btf->nr_types;
   2b8d9: 44 8b 77 50                  	movl	80(%rdi), %r14d
   2b8dd: 8b 5f 40                     	movl	64(%rdi), %ebx
; 	if (!strcmp(type_name, "void"))
   2b8e0: 48 89 ef                     	movq	%rbp, %rdi
   2b8e3: e8 c8 a0 fd ff               	callq	0x59b0 <.plt.sec+0x340>
   2b8e8: 85 c0                        	testl	%eax, %eax
   2b8ea: 0f 84 90 00 00 00            	je	0x2b980 <btf__find_by_name+0xc0>
; 	return btf->start_id + btf->nr_types;
   2b8f0: 41 8d 04 1e                  	leal	(%r14,%rbx), %eax
   2b8f4: 41 89 c5                     	movl	%eax, %r13d
; 	for (i = 1; i < nr_types; i++) {
   2b8f7: 83 f8 01                     	cmpl	$1, %eax
   2b8fa: 76 74                        	jbe	0x2b970 <btf__find_by_name+0xb0>
   2b8fc: bb 01 00 00 00               	movl	$1, %ebx
   2b901: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b908: 44 89 f2                     	movl	%r14d, %edx
   2b90b: 39 c3                        	cmpl	%eax, %ebx
   2b90d: 0f 83 e7 a3 fd ff            	jae	0x5cfa <btf__find_by_name.cold>
; 	if (type_id < btf->start_id)
   2b913: 4c 89 e0                     	movq	%r12, %rax
   2b916: 44 39 f3                     	cmpl	%r14d, %ebx
   2b919: 73 10                        	jae	0x2b92b <btf__find_by_name+0x6b>
   2b91b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2b920: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2b924: 8b 50 50                     	movl	80(%rax), %edx
   2b927: 39 d3                        	cmpl	%edx, %ebx
   2b929: 72 f5                        	jb	0x2b920 <btf__find_by_name+0x60>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b92b: 89 d9                        	movl	%ebx, %ecx
; 	return btf__str_by_offset(btf, offset);
   2b92d: 4c 89 e7                     	movq	%r12, %rdi
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b930: 29 d1                        	subl	%edx, %ecx
   2b932: 48 8b 50 30                  	movq	48(%rax), %rdx
; 		const char *name = btf__name_by_offset(btf, t->name_off);
   2b936: 48 8b 40 20                  	movq	32(%rax), %rax
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2b93a: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
; 	return btf__str_by_offset(btf, offset);
   2b93d: 8b 34 10                     	movl	(%rax,%rdx), %esi
   2b940: e8 ab f9 ff ff               	callq	0x2b2f0 <btf__str_by_offset>
   2b945: 48 89 c6                     	movq	%rax, %rsi
; 		if (name && !strcmp(type_name, name))
   2b948: 48 85 c0                     	testq	%rax, %rax
   2b94b: 74 0c                        	je	0x2b959 <btf__find_by_name+0x99>
   2b94d: 48 89 ef                     	movq	%rbp, %rdi
   2b950: e8 5b a0 fd ff               	callq	0x59b0 <.plt.sec+0x340>
   2b955: 85 c0                        	testl	%eax, %eax
   2b957: 74 30                        	je	0x2b989 <btf__find_by_name+0xc9>
; 	for (i = 1; i < nr_types; i++) {
   2b959: 83 c3 01                     	addl	$1, %ebx
   2b95c: 44 39 eb                     	cmpl	%r13d, %ebx
   2b95f: 74 0f                        	je	0x2b970 <btf__find_by_name+0xb0>
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b961: 45 8b 74 24 50               	movl	80(%r12), %r14d
   2b966: 41 8b 44 24 40               	movl	64(%r12), %eax
   2b96b: 44 01 f0                     	addl	%r14d, %eax
   2b96e: eb 98                        	jmp	0x2b908 <btf__find_by_name+0x48>
; 		errno = -ret;
   2b970: e8 7b 9d fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2b975: c7 00 02 00 00 00            	movl	$2, (%rax)
; 	return libbpf_err(-ENOENT);
   2b97b: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
; }
   2b980: 5b                           	popq	%rbx
   2b981: 5d                           	popq	%rbp
   2b982: 41 5c                        	popq	%r12
   2b984: 41 5d                        	popq	%r13
   2b986: 41 5e                        	popq	%r14
   2b988: c3                           	retq
; 			return i;
   2b989: 89 d8                        	movl	%ebx, %eax
; }
   2b98b: 5b                           	popq	%rbx
   2b98c: 5d                           	popq	%rbp
   2b98d: 41 5c                        	popq	%r12
   2b98f: 41 5d                        	popq	%r13
   2b991: 41 5e                        	popq	%r14
   2b993: c3                           	retq
   2b994: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2b99f: 90                           	nop

000000000002b9a0 <btf_find_by_name_kind>:
; {
   2b9a0: 41 57                        	pushq	%r15
   2b9a2: 41 56                        	pushq	%r14
   2b9a4: 41 55                        	pushq	%r13
   2b9a6: 41 54                        	pushq	%r12
   2b9a8: 55                           	pushq	%rbp
   2b9a9: 53                           	pushq	%rbx
   2b9aa: 48 83 ec 18                  	subq	$24, %rsp
; 	return btf->start_id + btf->nr_types;
   2b9ae: 8b 5f 50                     	movl	80(%rdi), %ebx
   2b9b1: 44 8b 67 40                  	movl	64(%rdi), %r12d
; {
   2b9b5: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
; 	if (kind == BTF_KIND_UNKN || !strcmp(type_name, "void"))
   2b9ba: 85 c9                        	testl	%ecx, %ecx
   2b9bc: 0f 84 d3 00 00 00            	je	0x2ba95 <btf_find_by_name_kind+0xf5>
   2b9c2: 49 89 fd                     	movq	%rdi, %r13
   2b9c5: 41 89 f7                     	movl	%esi, %r15d
   2b9c8: 48 89 d7                     	movq	%rdx, %rdi
   2b9cb: 89 cd                        	movl	%ecx, %ebp
   2b9cd: 48 8d 35 e4 61 00 00         	leaq	25060(%rip), %rsi       # 0x31bb8 <_IO_stdin_used+0x1bb8>
   2b9d4: e8 d7 9f fd ff               	callq	0x59b0 <.plt.sec+0x340>
   2b9d9: 85 c0                        	testl	%eax, %eax
   2b9db: 74 7f                        	je	0x2ba5c <btf_find_by_name_kind+0xbc>
; 	return btf->start_id + btf->nr_types;
   2b9dd: 42 8d 04 23                  	leal	(%rbx,%r12), %eax
   2b9e1: 41 89 c4                     	movl	%eax, %r12d
; 	for (i = start_id; i < nr_types; i++) {
   2b9e4: 41 39 c7                     	cmpl	%eax, %r15d
   2b9e7: 73 63                        	jae	0x2ba4c <btf_find_by_name_kind+0xac>
; 		return &btf_void;
   2b9e9: 4c 8d 35 a0 b8 01 00         	leaq	112800(%rip), %r14      # 0x47290 <btf_void>
; 	if (type_id >= btf->start_id + btf->nr_types)
   2b9f0: 44 39 f8                     	cmpl	%r15d, %eax
   2b9f3: 0f 86 15 a3 fd ff            	jbe	0x5d0e <btf_find_by_name_kind.cold>
; 		return &btf_void;
   2b9f9: 4c 89 f2                     	movq	%r14, %rdx
; 	if (type_id == 0)
   2b9fc: 45 85 ff                     	testl	%r15d, %r15d
   2b9ff: 74 2b                        	je	0x2ba2c <btf_find_by_name_kind+0x8c>
   2ba01: 4c 89 e8                     	movq	%r13, %rax
   2ba04: eb 11                        	jmp	0x2ba17 <btf_find_by_name_kind+0x77>
   2ba06: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2ba10: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2ba14: 8b 58 50                     	movl	80(%rax), %ebx
   2ba17: 44 39 fb                     	cmpl	%r15d, %ebx
   2ba1a: 77 f4                        	ja	0x2ba10 <btf_find_by_name_kind+0x70>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2ba1c: 48 8b 50 30                  	movq	48(%rax), %rdx
   2ba20: 44 89 f9                     	movl	%r15d, %ecx
   2ba23: 29 d9                        	subl	%ebx, %ecx
   2ba25: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2ba28: 48 03 50 20                  	addq	32(%rax), %rdx
; 	return BTF_INFO_KIND(t->info);
   2ba2c: 0f b6 42 07                  	movzbl	7(%rdx), %eax
; 		if (btf_kind(t) != kind)
   2ba30: 83 e0 1f                     	andl	$31, %eax
   2ba33: 39 e8                        	cmpl	%ebp, %eax
   2ba35: 74 39                        	je	0x2ba70 <btf_find_by_name_kind+0xd0>
; 	for (i = start_id; i < nr_types; i++) {
   2ba37: 41 83 c7 01                  	addl	$1, %r15d
   2ba3b: 45 39 e7                     	cmpl	%r12d, %r15d
   2ba3e: 73 0c                        	jae	0x2ba4c <btf_find_by_name_kind+0xac>
; 	if (type_id >= btf->start_id + btf->nr_types)
   2ba40: 41 8b 5d 50                  	movl	80(%r13), %ebx
   2ba44: 41 8b 45 40                  	movl	64(%r13), %eax
   2ba48: 01 d8                        	addl	%ebx, %eax
   2ba4a: eb a4                        	jmp	0x2b9f0 <btf_find_by_name_kind+0x50>
; 		errno = -ret;
   2ba4c: e8 9f 9c fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2ba51: c7 00 02 00 00 00            	movl	$2, (%rax)
; 	return libbpf_err(-ENOENT);
   2ba57: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
; }
   2ba5c: 48 83 c4 18                  	addq	$24, %rsp
   2ba60: 5b                           	popq	%rbx
   2ba61: 5d                           	popq	%rbp
   2ba62: 41 5c                        	popq	%r12
   2ba64: 41 5d                        	popq	%r13
   2ba66: 41 5e                        	popq	%r14
   2ba68: 41 5f                        	popq	%r15
   2ba6a: c3                           	retq
   2ba6b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	return btf__str_by_offset(btf, offset);
   2ba70: 8b 32                        	movl	(%rdx), %esi
   2ba72: 4c 89 ef                     	movq	%r13, %rdi
   2ba75: e8 76 f8 ff ff               	callq	0x2b2f0 <btf__str_by_offset>
   2ba7a: 48 89 c6                     	movq	%rax, %rsi
; 		if (name && !strcmp(type_name, name))
   2ba7d: 48 85 c0                     	testq	%rax, %rax
   2ba80: 74 b5                        	je	0x2ba37 <btf_find_by_name_kind+0x97>
   2ba82: 48 8b 7c 24 08               	movq	8(%rsp), %rdi
   2ba87: e8 24 9f fd ff               	callq	0x59b0 <.plt.sec+0x340>
   2ba8c: 85 c0                        	testl	%eax, %eax
   2ba8e: 75 a7                        	jne	0x2ba37 <btf_find_by_name_kind+0x97>
; 			return i;
   2ba90: 44 89 f8                     	movl	%r15d, %eax
   2ba93: eb c7                        	jmp	0x2ba5c <btf_find_by_name_kind+0xbc>
; }
   2ba95: 48 83 c4 18                  	addq	$24, %rsp
; 		return 0;
   2ba99: 31 c0                        	xorl	%eax, %eax
; }
   2ba9b: 5b                           	popq	%rbx
   2ba9c: 5d                           	popq	%rbp
   2ba9d: 41 5c                        	popq	%r12
   2ba9f: 41 5d                        	popq	%r13
   2baa1: 41 5e                        	popq	%r14
   2baa3: 41 5f                        	popq	%r15
   2baa5: c3                           	retq
   2baa6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000002bab0 <btf__find_by_name_kind_own>:
; {
   2bab0: f3 0f 1e fa                  	endbr64
   2bab4: 49 89 f0                     	movq	%rsi, %r8
; 	return btf_find_by_name_kind(btf, btf->start_id, type_name, kind);
   2bab7: 8b 77 50                     	movl	80(%rdi), %esi
; {
   2baba: 89 d1                        	movl	%edx, %ecx
; 	return btf_find_by_name_kind(btf, btf->start_id, type_name, kind);
   2babc: 4c 89 c2                     	movq	%r8, %rdx
   2babf: e9 dc fe ff ff               	jmp	0x2b9a0 <btf_find_by_name_kind>
   2bac4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2bacf: 90                           	nop

000000000002bad0 <btf__find_by_name_kind>:
; {
   2bad0: f3 0f 1e fa                  	endbr64
   2bad4: 89 d1                        	movl	%edx, %ecx
; 	return btf_find_by_name_kind(btf, 1, type_name, kind);
   2bad6: 48 89 f2                     	movq	%rsi, %rdx
   2bad9: be 01 00 00 00               	movl	$1, %esi
   2bade: e9 bd fe ff ff               	jmp	0x2b9a0 <btf_find_by_name_kind>
   2bae3: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2baee: 66 90                        	nop

000000000002baf0 <btf__name_by_offset>:
; {
   2baf0: f3 0f 1e fa                  	endbr64
; 	return btf__str_by_offset(btf, offset);
   2baf4: e9 f7 f7 ff ff               	jmp	0x2b2f0 <btf__str_by_offset>
   2baf9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002bb00 <btf_get_from_fd>:
; {
   2bb00: f3 0f 1e fa                  	endbr64
   2bb04: 41 57                        	pushq	%r15
   2bb06: 41 56                        	pushq	%r14
   2bb08: 41 55                        	pushq	%r13
   2bb0a: 49 89 f5                     	movq	%rsi, %r13
   2bb0d: 41 54                        	pushq	%r12
   2bb0f: 41 89 fc                     	movl	%edi, %r12d
; 	ptr = malloc(last_size);
   2bb12: bf 00 10 00 00               	movl	$4096, %edi             # imm = 0x1000
; {
   2bb17: 55                           	pushq	%rbp
   2bb18: 53                           	pushq	%rbx
   2bb19: 48 83 ec 58                  	subq	$88, %rsp
   2bb1d: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2bb26: 48 89 44 24 48               	movq	%rax, 72(%rsp)
   2bb2b: 31 c0                        	xorl	%eax, %eax
; 	__u32 len = sizeof(btf_info);
   2bb2d: c7 44 24 1c 20 00 00 00      	movl	$32, 28(%rsp)
; 	ptr = malloc(last_size);
   2bb35: e8 56 9f fd ff               	callq	0x5a90 <.plt.sec+0x420>
; 	if (!ptr)
   2bb3a: 48 85 c0                     	testq	%rax, %rax
   2bb3d: 0f 84 1a 01 00 00            	je	0x2bc5d <btf_get_from_fd+0x15d>
;   return __builtin___memset_chk (__dest, __ch, __len,
   2bb43: 4c 8d 74 24 20               	leaq	32(%rsp), %r14
; 	err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
   2bb48: 4c 8d 7c 24 1c               	leaq	28(%rsp), %r15
   2bb4d: 44 89 e7                     	movl	%r12d, %edi
   2bb50: 48 89 c3                     	movq	%rax, %rbx
;   return __builtin___memset_chk (__dest, __ch, __len,
   2bb53: 66 0f ef c0                  	pxor	%xmm0, %xmm0
; 	err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
   2bb57: 4c 89 fa                     	movq	%r15, %rdx
   2bb5a: 4c 89 f6                     	movq	%r14, %rsi
; 	btf_info.btf = ptr_to_u64(ptr);
   2bb5d: 48 89 44 24 20               	movq	%rax, 32(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   2bb62: 0f 11 44 24 28               	movups	%xmm0, 40(%rsp)
   2bb67: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
; 	btf_info.btf_size = last_size;
   2bb70: c7 44 24 28 00 10 00 00      	movl	$4096, 40(%rsp)         # imm = 0x1000
; 	err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
   2bb78: e8 43 c0 ff ff               	callq	0x27bc0 <bpf_obj_get_info_by_fd>
; 	if (!err && btf_info.btf_size > last_size) {
   2bb7d: 85 c0                        	testl	%eax, %eax
   2bb7f: 75 57                        	jne	0x2bbd8 <btf_get_from_fd+0xd8>
   2bb81: 44 8b 44 24 28               	movl	40(%rsp), %r8d
   2bb86: 41 81 f8 00 10 00 00         	cmpl	$4096, %r8d             # imm = 0x1000
   2bb8d: 77 61                        	ja	0x2bbf0 <btf_get_from_fd+0xf0>
; 	btf = btf_new(ptr, btf_info.btf_size, base_btf);
   2bb8f: 4c 89 ea                     	movq	%r13, %rdx
   2bb92: 44 89 c6                     	movl	%r8d, %esi
   2bb95: 48 89 df                     	movq	%rbx, %rdi
   2bb98: 48 89 dd                     	movq	%rbx, %rbp
   2bb9b: e8 f0 ec ff ff               	callq	0x2a890 <btf_new>
   2bba0: 49 89 c4                     	movq	%rax, %r12
; 	free(ptr);
   2bba3: 48 89 ef                     	movq	%rbp, %rdi
   2bba6: e8 15 9b fd ff               	callq	0x56c0 <.plt.sec+0x50>
; }
   2bbab: 48 8b 44 24 48               	movq	72(%rsp), %rax
   2bbb0: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2bbb9: 0f 85 aa 00 00 00            	jne	0x2bc69 <btf_get_from_fd+0x169>
   2bbbf: 48 83 c4 58                  	addq	$88, %rsp
   2bbc3: 4c 89 e0                     	movq	%r12, %rax
   2bbc6: 5b                           	popq	%rbx
   2bbc7: 5d                           	popq	%rbp
   2bbc8: 41 5c                        	popq	%r12
   2bbca: 41 5d                        	popq	%r13
   2bbcc: 41 5e                        	popq	%r14
   2bbce: 41 5f                        	popq	%r15
   2bbd0: c3                           	retq
   2bbd1: 48 89 eb                     	movq	%rbp, %rbx
   2bbd4: 0f 1f 40 00                  	nopl	(%rax)
; 		btf = err ? ERR_PTR(-errno) : ERR_PTR(-E2BIG);
   2bbd8: e8 13 9b fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 	return (void *) error_;
   2bbdd: 48 89 dd                     	movq	%rbx, %rbp
; 		btf = err ? ERR_PTR(-errno) : ERR_PTR(-E2BIG);
   2bbe0: 44 8b 20                     	movl	(%rax), %r12d
   2bbe3: 41 f7 dc                     	negl	%r12d
   2bbe6: 4d 63 e4                     	movslq	%r12d, %r12
   2bbe9: eb b8                        	jmp	0x2bba3 <btf_get_from_fd+0xa3>
   2bbeb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		temp_ptr = realloc(ptr, last_size);
   2bbf0: 44 89 c6                     	movl	%r8d, %esi
   2bbf3: 48 89 df                     	movq	%rbx, %rdi
   2bbf6: 44 89 44 24 0c               	movl	%r8d, 12(%rsp)
   2bbfb: e8 20 9f fd ff               	callq	0x5b20 <.plt.sec+0x4b0>
   2bc00: 48 89 c5                     	movq	%rax, %rbp
; 		if (!temp_ptr) {
   2bc03: 48 85 c0                     	testq	%rax, %rax
   2bc06: 74 66                        	je	0x2bc6e <btf_get_from_fd+0x16e>
; 		btf_info.btf_size = last_size;
   2bc08: 44 8b 44 24 0c               	movl	12(%rsp), %r8d
;   return __builtin___memset_chk (__dest, __ch, __len,
   2bc0d: 66 0f ef c9                  	pxor	%xmm1, %xmm1
; 		err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
   2bc11: 4c 89 fa                     	movq	%r15, %rdx
   2bc14: 4c 89 f6                     	movq	%r14, %rsi
   2bc17: 44 89 e7                     	movl	%r12d, %edi
;   return __builtin___memset_chk (__dest, __ch, __len,
   2bc1a: 0f 11 4c 24 28               	movups	%xmm1, 40(%rsp)
; 		len = sizeof(btf_info);
   2bc1f: c7 44 24 1c 20 00 00 00      	movl	$32, 28(%rsp)
; 		btf_info.btf_size = last_size;
   2bc27: 44 89 44 24 28               	movl	%r8d, 40(%rsp)
;   return __builtin___memset_chk (__dest, __ch, __len,
   2bc2c: 48 c7 44 24 38 00 00 00 00   	movq	$0, 56(%rsp)
; 		btf_info.btf = ptr_to_u64(ptr);
   2bc35: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 		err = bpf_obj_get_info_by_fd(btf_fd, &btf_info, &len);
   2bc3a: e8 81 bf ff ff               	callq	0x27bc0 <bpf_obj_get_info_by_fd>
; 	if (err || btf_info.btf_size > last_size) {
   2bc3f: 44 8b 44 24 0c               	movl	12(%rsp), %r8d
   2bc44: 85 c0                        	testl	%eax, %eax
   2bc46: 75 89                        	jne	0x2bbd1 <btf_get_from_fd+0xd1>
   2bc48: 8b 44 24 28                  	movl	40(%rsp), %eax
   2bc4c: 41 39 c0                     	cmpl	%eax, %r8d
   2bc4f: 73 2c                        	jae	0x2bc7d <btf_get_from_fd+0x17d>
; 		btf = err ? ERR_PTR(-errno) : ERR_PTR(-E2BIG);
   2bc51: 49 c7 c4 f9 ff ff ff         	movq	$-7, %r12
   2bc58: e9 46 ff ff ff               	jmp	0x2bba3 <btf_get_from_fd+0xa3>
; 		return ERR_PTR(-ENOMEM);
   2bc5d: 49 c7 c4 f4 ff ff ff         	movq	$-12, %r12
   2bc64: e9 42 ff ff ff               	jmp	0x2bbab <btf_get_from_fd+0xab>
; }
   2bc69: e8 92 9b fd ff               	callq	0x5800 <.plt.sec+0x190>
   2bc6e: 48 89 dd                     	movq	%rbx, %rbp
; 			btf = ERR_PTR(-ENOMEM);
   2bc71: 49 c7 c4 f4 ff ff ff         	movq	$-12, %r12
   2bc78: e9 26 ff ff ff               	jmp	0x2bba3 <btf_get_from_fd+0xa3>
   2bc7d: 48 89 eb                     	movq	%rbp, %rbx
   2bc80: 41 89 c0                     	movl	%eax, %r8d
   2bc83: e9 07 ff ff ff               	jmp	0x2bb8f <btf_get_from_fd+0x8f>
   2bc88: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000002bc90 <btf__load_from_kernel_by_id_split>:
; {
   2bc90: f3 0f 1e fa                  	endbr64
   2bc94: 41 55                        	pushq	%r13
   2bc96: 49 89 f5                     	movq	%rsi, %r13
   2bc99: 41 54                        	pushq	%r12
; 		return libbpf_err_ptr(-errno);
   2bc9b: 45 31 e4                     	xorl	%r12d, %r12d
; {
   2bc9e: 55                           	pushq	%rbp
; 	btf_fd = bpf_btf_get_fd_by_id(id);
   2bc9f: e8 1c bd ff ff               	callq	0x279c0 <bpf_btf_get_fd_by_id>
; 	if (btf_fd < 0)
   2bca4: 85 c0                        	testl	%eax, %eax
   2bca6: 78 2d                        	js	0x2bcd5 <btf__load_from_kernel_by_id_split+0x45>
; 	btf = btf_get_from_fd(btf_fd, base_btf);
   2bca8: 89 c7                        	movl	%eax, %edi
   2bcaa: 4c 89 ee                     	movq	%r13, %rsi
   2bcad: 89 c5                        	movl	%eax, %ebp
   2bcaf: e8 4c fe ff ff               	callq	0x2bb00 <btf_get_from_fd>
; 	close(btf_fd);
   2bcb4: 89 ef                        	movl	%ebp, %edi
; 	btf = btf_get_from_fd(btf_fd, base_btf);
   2bcb6: 49 89 c4                     	movq	%rax, %r12
; 	close(btf_fd);
   2bcb9: e8 42 9c fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (IS_ERR(ret))
   2bcbe: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2bcc5: 76 0e                        	jbe	0x2bcd5 <btf__load_from_kernel_by_id_split+0x45>
; 		errno = -PTR_ERR(ret);
   2bcc7: e8 24 9a fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2bccc: 41 f7 dc                     	negl	%r12d
   2bccf: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2bcd2: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2bcd5: 4c 89 e0                     	movq	%r12, %rax
   2bcd8: 5d                           	popq	%rbp
   2bcd9: 41 5c                        	popq	%r12
   2bcdb: 41 5d                        	popq	%r13
   2bcdd: c3                           	retq
   2bcde: 66 90                        	nop

000000000002bce0 <btf__load_from_kernel_by_id>:
; {
   2bce0: f3 0f 1e fa                  	endbr64
   2bce4: 41 54                        	pushq	%r12
; 		return libbpf_err_ptr(-errno);
   2bce6: 45 31 e4                     	xorl	%r12d, %r12d
; {
   2bce9: 55                           	pushq	%rbp
   2bcea: 48 83 ec 08                  	subq	$8, %rsp
; 	btf_fd = bpf_btf_get_fd_by_id(id);
   2bcee: e8 cd bc ff ff               	callq	0x279c0 <bpf_btf_get_fd_by_id>
; 	if (btf_fd < 0)
   2bcf3: 85 c0                        	testl	%eax, %eax
   2bcf5: 78 2c                        	js	0x2bd23 <btf__load_from_kernel_by_id+0x43>
; 	btf = btf_get_from_fd(btf_fd, base_btf);
   2bcf7: 31 f6                        	xorl	%esi, %esi
   2bcf9: 89 c7                        	movl	%eax, %edi
   2bcfb: 89 c5                        	movl	%eax, %ebp
   2bcfd: e8 fe fd ff ff               	callq	0x2bb00 <btf_get_from_fd>
; 	close(btf_fd);
   2bd02: 89 ef                        	movl	%ebp, %edi
; 	btf = btf_get_from_fd(btf_fd, base_btf);
   2bd04: 49 89 c4                     	movq	%rax, %r12
; 	close(btf_fd);
   2bd07: e8 f4 9b fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (IS_ERR(ret))
   2bd0c: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2bd13: 76 0e                        	jbe	0x2bd23 <btf__load_from_kernel_by_id+0x43>
; 		errno = -PTR_ERR(ret);
   2bd15: e8 d6 99 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2bd1a: 41 f7 dc                     	negl	%r12d
   2bd1d: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2bd20: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2bd23: 48 83 c4 08                  	addq	$8, %rsp
   2bd27: 4c 89 e0                     	movq	%r12, %rax
   2bd2a: 5d                           	popq	%rbp
   2bd2b: 41 5c                        	popq	%r12
   2bd2d: c3                           	retq
   2bd2e: 66 90                        	nop

000000000002bd30 <btf__find_str>:
; {
   2bd30: f3 0f 1e fa                  	endbr64
   2bd34: 41 54                        	pushq	%r12
   2bd36: 55                           	pushq	%rbp
   2bd37: 48 89 f5                     	movq	%rsi, %rbp
   2bd3a: 53                           	pushq	%rbx
   2bd3b: 48 89 fb                     	movq	%rdi, %rbx
; 	if (btf->base_btf) {
   2bd3e: 48 8b 7f 48                  	movq	72(%rdi), %rdi
   2bd42: 48 85 ff                     	testq	%rdi, %rdi
   2bd45: 74 0d                        	je	0x2bd54 <btf__find_str+0x24>
; 		off = btf__find_str(btf->base_btf, s);
   2bd47: e8 e4 ff ff ff               	callq	0x2bd30 <btf__find_str>
   2bd4c: 41 89 c4                     	movl	%eax, %r12d
; 		if (off != -ENOENT)
   2bd4f: 83 f8 fe                     	cmpl	$-2, %eax
   2bd52: 75 23                        	jne	0x2bd77 <btf__find_str+0x47>
; 	if (btf_ensure_modifiable(btf))
   2bd54: 48 89 df                     	movq	%rbx, %rdi
   2bd57: e8 44 d6 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2bd5c: 85 c0                        	testl	%eax, %eax
   2bd5e: 75 2e                        	jne	0x2bd8e <btf__find_str+0x5e>
; 	off = strset__find_str(btf->strs_set, s);
   2bd60: 48 8b 7b 60                  	movq	96(%rbx), %rdi
   2bd64: 48 89 ee                     	movq	%rbp, %rsi
   2bd67: e8 b4 40 00 00               	callq	0x2fe20 <strset__find_str>
   2bd6c: 41 89 c4                     	movl	%eax, %r12d
; 	if (off < 0)
   2bd6f: 85 c0                        	testl	%eax, %eax
   2bd71: 78 0d                        	js	0x2bd80 <btf__find_str+0x50>
; 	return btf->start_str_off + off;
   2bd73: 44 03 63 54                  	addl	84(%rbx), %r12d
; }
   2bd77: 44 89 e0                     	movl	%r12d, %eax
   2bd7a: 5b                           	popq	%rbx
   2bd7b: 5d                           	popq	%rbp
   2bd7c: 41 5c                        	popq	%r12
   2bd7e: c3                           	retq
   2bd7f: 90                           	nop
; 		errno = -ret;
   2bd80: e8 6b 99 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2bd85: 44 89 e2                     	movl	%r12d, %edx
   2bd88: f7 da                        	negl	%edx
   2bd8a: 89 10                        	movl	%edx, (%rax)
; 		return libbpf_err(off);
   2bd8c: eb e9                        	jmp	0x2bd77 <btf__find_str+0x47>
; 		errno = -ret;
   2bd8e: e8 5d 99 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOMEM);
   2bd93: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
; 		errno = -ret;
   2bd99: c7 00 0c 00 00 00            	movl	$12, (%rax)
   2bd9f: eb d6                        	jmp	0x2bd77 <btf__find_str+0x47>
   2bda1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2bdac: 0f 1f 40 00                  	nopl	(%rax)

000000000002bdb0 <strs_dedup_remap_str_off>:
; {
   2bdb0: f3 0f 1e fa                  	endbr64
   2bdb4: 41 54                        	pushq	%r12
; 		return 0;
   2bdb6: 31 c0                        	xorl	%eax, %eax
; {
   2bdb8: 55                           	pushq	%rbp
   2bdb9: 53                           	pushq	%rbx
   2bdba: 48 89 f3                     	movq	%rsi, %rbx
; 	__u32 str_off = *str_off_ptr;
   2bdbd: 8b 37                        	movl	(%rdi), %esi
; 	if (str_off == 0 || str_off < d->btf->start_str_off)
   2bdbf: 85 f6                        	testl	%esi, %esi
   2bdc1: 74 0b                        	je	0x2bdce <strs_dedup_remap_str_off+0x1e>
   2bdc3: 48 89 fd                     	movq	%rdi, %rbp
   2bdc6: 48 8b 3b                     	movq	(%rbx), %rdi
   2bdc9: 39 77 54                     	cmpl	%esi, 84(%rdi)
   2bdcc: 76 0a                        	jbe	0x2bdd8 <strs_dedup_remap_str_off+0x28>
; }
   2bdce: 5b                           	popq	%rbx
   2bdcf: 5d                           	popq	%rbp
   2bdd0: 41 5c                        	popq	%r12
   2bdd2: c3                           	retq
   2bdd3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	s = btf__str_by_offset(d->btf, str_off);
   2bdd8: e8 13 f5 ff ff               	callq	0x2b2f0 <btf__str_by_offset>
   2bddd: 49 89 c4                     	movq	%rax, %r12
; 	if (d->btf->base_btf) {
   2bde0: 48 8b 03                     	movq	(%rbx), %rax
   2bde3: 48 8b 78 48                  	movq	72(%rax), %rdi
   2bde7: 48 85 ff                     	testq	%rdi, %rdi
   2bdea: 74 11                        	je	0x2bdfd <strs_dedup_remap_str_off+0x4d>
; 		err = btf__find_str(d->btf->base_btf, s);
   2bdec: 4c 89 e6                     	movq	%r12, %rsi
   2bdef: e8 3c ff ff ff               	callq	0x2bd30 <btf__find_str>
; 		if (err >= 0) {
   2bdf4: 85 c0                        	testl	%eax, %eax
   2bdf6: 79 1b                        	jns	0x2be13 <strs_dedup_remap_str_off+0x63>
; 		if (err != -ENOENT)
   2bdf8: 83 f8 fe                     	cmpl	$-2, %eax
   2bdfb: 75 d1                        	jne	0x2bdce <strs_dedup_remap_str_off+0x1e>
; 	off = strset__add_str(d->strs_set, s);
   2bdfd: 48 8b 7b 60                  	movq	96(%rbx), %rdi
   2be01: 4c 89 e6                     	movq	%r12, %rsi
   2be04: e8 c7 40 00 00               	callq	0x2fed0 <strset__add_str>
; 	if (off < 0)
   2be09: 85 c0                        	testl	%eax, %eax
   2be0b: 78 c1                        	js	0x2bdce <strs_dedup_remap_str_off+0x1e>
; 	*str_off_ptr = d->btf->start_str_off + off;
   2be0d: 48 8b 13                     	movq	(%rbx), %rdx
   2be10: 03 42 54                     	addl	84(%rdx), %eax
   2be13: 89 45 00                     	movl	%eax, (%rbp)
; 	return 0;
   2be16: 31 c0                        	xorl	%eax, %eax
; }
   2be18: 5b                           	popq	%rbx
   2be19: 5d                           	popq	%rbp
   2be1a: 41 5c                        	popq	%r12
   2be1c: c3                           	retq
   2be1d: 0f 1f 00                     	nopl	(%rax)

000000000002be20 <btf__add_str>:
; {
   2be20: f3 0f 1e fa                  	endbr64
   2be24: 41 54                        	pushq	%r12
   2be26: 55                           	pushq	%rbp
   2be27: 48 89 f5                     	movq	%rsi, %rbp
   2be2a: 53                           	pushq	%rbx
   2be2b: 48 89 fb                     	movq	%rdi, %rbx
; 	if (btf->base_btf) {
   2be2e: 48 8b 7f 48                  	movq	72(%rdi), %rdi
   2be32: 48 85 ff                     	testq	%rdi, %rdi
   2be35: 74 0d                        	je	0x2be44 <btf__add_str+0x24>
; 		off = btf__find_str(btf->base_btf, s);
   2be37: e8 f4 fe ff ff               	callq	0x2bd30 <btf__find_str>
   2be3c: 41 89 c4                     	movl	%eax, %r12d
; 		if (off != -ENOENT)
   2be3f: 83 f8 fe                     	cmpl	$-2, %eax
   2be42: 75 33                        	jne	0x2be77 <btf__add_str+0x57>
; 	if (btf_ensure_modifiable(btf))
   2be44: 48 89 df                     	movq	%rbx, %rdi
   2be47: e8 54 d5 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2be4c: 85 c0                        	testl	%eax, %eax
   2be4e: 75 44                        	jne	0x2be94 <btf__add_str+0x74>
; 	off = strset__add_str(btf->strs_set, s);
   2be50: 48 8b 7b 60                  	movq	96(%rbx), %rdi
   2be54: 48 89 ee                     	movq	%rbp, %rsi
   2be57: e8 74 40 00 00               	callq	0x2fed0 <strset__add_str>
   2be5c: 41 89 c4                     	movl	%eax, %r12d
; 	if (off < 0)
   2be5f: 85 c0                        	testl	%eax, %eax
   2be61: 78 1d                        	js	0x2be80 <btf__add_str+0x60>
; 	btf->hdr->str_len = strset__data_size(btf->strs_set);
   2be63: 48 8b 7b 60                  	movq	96(%rbx), %rdi
   2be67: e8 94 3f 00 00               	callq	0x2fe00 <strset__data_size>
   2be6c: 48 8b 53 18                  	movq	24(%rbx), %rdx
; 	return btf->start_str_off + off;
   2be70: 44 03 63 54                  	addl	84(%rbx), %r12d
; 	btf->hdr->str_len = strset__data_size(btf->strs_set);
   2be74: 89 42 14                     	movl	%eax, 20(%rdx)
; }
   2be77: 44 89 e0                     	movl	%r12d, %eax
   2be7a: 5b                           	popq	%rbx
   2be7b: 5d                           	popq	%rbp
   2be7c: 41 5c                        	popq	%r12
   2be7e: c3                           	retq
   2be7f: 90                           	nop
; 		errno = -ret;
   2be80: e8 6b 98 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2be85: 44 89 e2                     	movl	%r12d, %edx
   2be88: f7 da                        	negl	%edx
   2be8a: 89 10                        	movl	%edx, (%rax)
; }
   2be8c: 44 89 e0                     	movl	%r12d, %eax
   2be8f: 5b                           	popq	%rbx
   2be90: 5d                           	popq	%rbp
   2be91: 41 5c                        	popq	%r12
   2be93: c3                           	retq
; 		errno = -ret;
   2be94: e8 57 98 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOMEM);
   2be99: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
; 		errno = -ret;
   2be9f: c7 00 0c 00 00 00            	movl	$12, (%rax)
   2bea5: eb d0                        	jmp	0x2be77 <btf__add_str+0x57>
   2bea7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000002beb0 <btf_rewrite_str>:
; {
   2beb0: f3 0f 1e fa                  	endbr64
   2beb4: 41 54                        	pushq	%r12
; 		return 0;
   2beb6: 45 31 e4                     	xorl	%r12d, %r12d
; {
   2beb9: 55                           	pushq	%rbp
   2beba: 53                           	pushq	%rbx
   2bebb: 48 89 f3                     	movq	%rsi, %rbx
   2bebe: 48 83 ec 10                  	subq	$16, %rsp
; 	if (!*str_off) /* nothing to do for empty strings */
   2bec2: 8b 37                        	movl	(%rdi), %esi
; {
   2bec4: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2becd: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   2bed2: 31 c0                        	xorl	%eax, %eax
; 	if (!*str_off) /* nothing to do for empty strings */
   2bed4: 85 f6                        	testl	%esi, %esi
   2bed6: 74 60                        	je	0x2bf38 <btf_rewrite_str+0x88>
   2bed8: 48 89 fd                     	movq	%rdi, %rbp
; 	if (p->str_off_map &&
   2bedb: 48 8b 7b 10                  	movq	16(%rbx), %rdi
   2bedf: 48 85 ff                     	testq	%rdi, %rdi
   2bee2: 74 0f                        	je	0x2bef3 <btf_rewrite_str+0x43>
; 	    hashmap__find(p->str_off_map, (void *)(long)*str_off, &mapped_off)) {
   2bee4: 48 89 e2                     	movq	%rsp, %rdx
   2bee7: e8 54 29 ff ff               	callq	0x1e840 <hashmap__find>
; 	if (p->str_off_map &&
   2beec: 84 c0                        	testb	%al, %al
   2beee: 75 78                        	jne	0x2bf68 <btf_rewrite_str+0xb8>
; 	off = btf__add_str(p->dst, btf__str_by_offset(p->src, *str_off));
   2bef0: 8b 75 00                     	movl	(%rbp), %esi
   2bef3: 48 8b 3b                     	movq	(%rbx), %rdi
   2bef6: e8 f5 f3 ff ff               	callq	0x2b2f0 <btf__str_by_offset>
   2befb: 48 8b 7b 08                  	movq	8(%rbx), %rdi
   2beff: 48 89 c6                     	movq	%rax, %rsi
   2bf02: e8 19 ff ff ff               	callq	0x2be20 <btf__add_str>
   2bf07: 41 89 c4                     	movl	%eax, %r12d
; 	if (off < 0)
   2bf0a: 85 c0                        	testl	%eax, %eax
   2bf0c: 78 2a                        	js	0x2bf38 <btf_rewrite_str+0x88>
; 	if (p->str_off_map) {
   2bf0e: 48 8b 7b 10                  	movq	16(%rbx), %rdi
   2bf12: 48 85 ff                     	testq	%rdi, %rdi
   2bf15: 74 41                        	je	0x2bf58 <btf_rewrite_str+0xa8>
; 		err = hashmap__append(p->str_off_map, (void *)(long)*str_off, (void *)(long)off);
   2bf17: 8b 75 00                     	movl	(%rbp), %esi
; 	return hashmap__insert(map, key, value, HASHMAP_APPEND, NULL, NULL);
   2bf1a: 45 31 c9                     	xorl	%r9d, %r9d
   2bf1d: 45 31 c0                     	xorl	%r8d, %r8d
; 		err = hashmap__append(p->str_off_map, (void *)(long)*str_off, (void *)(long)off);
   2bf20: 48 63 d0                     	movslq	%eax, %rdx
; 	return hashmap__insert(map, key, value, HASHMAP_APPEND, NULL, NULL);
   2bf23: b9 03 00 00 00               	movl	$3, %ecx
   2bf28: e8 e3 25 ff ff               	callq	0x1e510 <hashmap__insert>
; 		if (err)
   2bf2d: 85 c0                        	testl	%eax, %eax
   2bf2f: 74 27                        	je	0x2bf58 <btf_rewrite_str+0xa8>
   2bf31: 41 89 c4                     	movl	%eax, %r12d
   2bf34: 0f 1f 40 00                  	nopl	(%rax)
; }
   2bf38: 48 8b 44 24 08               	movq	8(%rsp), %rax
   2bf3d: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2bf46: 75 29                        	jne	0x2bf71 <btf_rewrite_str+0xc1>
   2bf48: 48 83 c4 10                  	addq	$16, %rsp
   2bf4c: 44 89 e0                     	movl	%r12d, %eax
   2bf4f: 5b                           	popq	%rbx
   2bf50: 5d                           	popq	%rbp
   2bf51: 41 5c                        	popq	%r12
   2bf53: c3                           	retq
   2bf54: 0f 1f 40 00                  	nopl	(%rax)
; 	*str_off = off;
   2bf58: 44 89 65 00                  	movl	%r12d, (%rbp)
; 	return 0;
   2bf5c: 45 31 e4                     	xorl	%r12d, %r12d
   2bf5f: eb d7                        	jmp	0x2bf38 <btf_rewrite_str+0x88>
   2bf61: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		*str_off = (__u32)(long)mapped_off;
   2bf68: 48 8b 04 24                  	movq	(%rsp), %rax
   2bf6c: 89 45 00                     	movl	%eax, (%rbp)
; 		return 0;
   2bf6f: eb c7                        	jmp	0x2bf38 <btf_rewrite_str+0x88>
; }
   2bf71: e8 8a 98 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2bf76: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000002bf80 <btf_add_ref_kind>:
; {
   2bf80: 41 56                        	pushq	%r14
   2bf82: 41 55                        	pushq	%r13
   2bf84: 41 54                        	pushq	%r12
   2bf86: 55                           	pushq	%rbp
   2bf87: 53                           	pushq	%rbx
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2bf88: 85 c9                        	testl	%ecx, %ecx
   2bf8a: 0f 88 a2 00 00 00            	js	0x2c032 <btf_add_ref_kind+0xb2>
   2bf90: 48 89 fd                     	movq	%rdi, %rbp
   2bf93: 41 89 f4                     	movl	%esi, %r12d
   2bf96: 49 89 d6                     	movq	%rdx, %r14
   2bf99: 41 89 cd                     	movl	%ecx, %r13d
; 	if (btf_ensure_modifiable(btf))
   2bf9c: e8 ff d3 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2bfa1: 85 c0                        	testl	%eax, %eax
   2bfa3: 75 7b                        	jne	0x2c020 <btf_add_ref_kind+0xa0>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2bfa5: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2bfa9: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2bfad: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2bfb1: 41 b9 0c 00 00 00            	movl	$12, %r9d
   2bfb7: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2bfbd: ba 01 00 00 00               	movl	$1, %edx
   2bfc2: 8b 48 0c                     	movl	12(%rax), %ecx
   2bfc5: e8 d6 dd ff ff               	callq	0x29da0 <libbpf_add_mem>
   2bfca: 48 89 c3                     	movq	%rax, %rbx
; 	if (!t)
   2bfcd: 48 85 c0                     	testq	%rax, %rax
   2bfd0: 74 4e                        	je	0x2c020 <btf_add_ref_kind+0xa0>
; 	if (name && name[0]) {
   2bfd2: 31 c0                        	xorl	%eax, %eax
   2bfd4: 4d 85 f6                     	testq	%r14, %r14
   2bfd7: 74 06                        	je	0x2bfdf <btf_add_ref_kind+0x5f>
   2bfd9: 41 80 3e 00                  	cmpb	$0, (%r14)
   2bfdd: 75 29                        	jne	0x2c008 <btf_add_ref_kind+0x88>
; 	return (kflag << 31) | (kind << 24) | vlen;
   2bfdf: 41 c1 e4 18                  	shll	$24, %r12d
; 	t->name_off = name_off;
   2bfe3: 89 03                        	movl	%eax, (%rbx)
; 	return btf_commit_type(btf, sz);
   2bfe5: 48 89 ef                     	movq	%rbp, %rdi
   2bfe8: be 0c 00 00 00               	movl	$12, %esi
; 	return (kflag << 31) | (kind << 24) | vlen;
   2bfed: 44 89 63 04                  	movl	%r12d, 4(%rbx)
; 	t->type = ref_type_id;
   2bff1: 44 89 6b 08                  	movl	%r13d, 8(%rbx)
; }
   2bff5: 5b                           	popq	%rbx
   2bff6: 5d                           	popq	%rbp
   2bff7: 41 5c                        	popq	%r12
   2bff9: 41 5d                        	popq	%r13
   2bffb: 41 5e                        	popq	%r14
; 	return btf_commit_type(btf, sz);
   2bffd: e9 7e d6 ff ff               	jmp	0x29680 <btf_commit_type>
   2c002: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		name_off = btf__add_str(btf, name);
   2c008: 4c 89 f6                     	movq	%r14, %rsi
   2c00b: 48 89 ef                     	movq	%rbp, %rdi
   2c00e: e8 0d fe ff ff               	callq	0x2be20 <btf__add_str>
; 		if (name_off < 0)
   2c013: 85 c0                        	testl	%eax, %eax
   2c015: 79 c8                        	jns	0x2bfdf <btf_add_ref_kind+0x5f>
; }
   2c017: 5b                           	popq	%rbx
   2c018: 5d                           	popq	%rbp
   2c019: 41 5c                        	popq	%r12
   2c01b: 41 5d                        	popq	%r13
   2c01d: 41 5e                        	popq	%r14
   2c01f: c3                           	retq
; 		errno = -ret;
   2c020: e8 cb 96 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c025: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2c02b: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2c030: eb e5                        	jmp	0x2c017 <btf_add_ref_kind+0x97>
; 		errno = -ret;
   2c032: e8 b9 96 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c037: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2c03d: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   2c042: eb d3                        	jmp	0x2c017 <btf_add_ref_kind+0x97>
   2c044: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c04f: 90                           	nop

000000000002c050 <btf_add_composite>:
; {
   2c050: 41 56                        	pushq	%r14
   2c052: 49 89 d6                     	movq	%rdx, %r14
   2c055: 41 55                        	pushq	%r13
   2c057: 41 89 cd                     	movl	%ecx, %r13d
   2c05a: 41 54                        	pushq	%r12
   2c05c: 41 89 f4                     	movl	%esi, %r12d
   2c05f: 55                           	pushq	%rbp
   2c060: 48 89 fd                     	movq	%rdi, %rbp
   2c063: 53                           	pushq	%rbx
; 	if (btf_ensure_modifiable(btf))
   2c064: e8 37 d3 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2c069: 85 c0                        	testl	%eax, %eax
   2c06b: 0f 85 7f 00 00 00            	jne	0x2c0f0 <btf_add_composite+0xa0>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2c071: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2c075: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2c079: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2c07d: 41 b9 0c 00 00 00            	movl	$12, %r9d
   2c083: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2c089: ba 01 00 00 00               	movl	$1, %edx
   2c08e: 8b 48 0c                     	movl	12(%rax), %ecx
   2c091: e8 0a dd ff ff               	callq	0x29da0 <libbpf_add_mem>
   2c096: 48 89 c3                     	movq	%rax, %rbx
; 	if (!t)
   2c099: 48 85 c0                     	testq	%rax, %rax
   2c09c: 74 52                        	je	0x2c0f0 <btf_add_composite+0xa0>
; 	if (name && name[0]) {
   2c09e: 31 c0                        	xorl	%eax, %eax
   2c0a0: 4d 85 f6                     	testq	%r14, %r14
   2c0a3: 74 06                        	je	0x2c0ab <btf_add_composite+0x5b>
   2c0a5: 41 80 3e 00                  	cmpb	$0, (%r14)
   2c0a9: 75 25                        	jne	0x2c0d0 <btf_add_composite+0x80>
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c0ab: 41 c1 e4 18                  	shll	$24, %r12d
; 	t->name_off = name_off;
   2c0af: 89 03                        	movl	%eax, (%rbx)
; 	return btf_commit_type(btf, sz);
   2c0b1: 48 89 ef                     	movq	%rbp, %rdi
   2c0b4: be 0c 00 00 00               	movl	$12, %esi
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c0b9: 44 89 63 04                  	movl	%r12d, 4(%rbx)
; 	t->size = bytes_sz;
   2c0bd: 44 89 6b 08                  	movl	%r13d, 8(%rbx)
; }
   2c0c1: 5b                           	popq	%rbx
   2c0c2: 5d                           	popq	%rbp
   2c0c3: 41 5c                        	popq	%r12
   2c0c5: 41 5d                        	popq	%r13
   2c0c7: 41 5e                        	popq	%r14
; 	return btf_commit_type(btf, sz);
   2c0c9: e9 b2 d5 ff ff               	jmp	0x29680 <btf_commit_type>
   2c0ce: 66 90                        	nop
; 		name_off = btf__add_str(btf, name);
   2c0d0: 4c 89 f6                     	movq	%r14, %rsi
   2c0d3: 48 89 ef                     	movq	%rbp, %rdi
   2c0d6: e8 45 fd ff ff               	callq	0x2be20 <btf__add_str>
; 		if (name_off < 0)
   2c0db: 85 c0                        	testl	%eax, %eax
   2c0dd: 79 cc                        	jns	0x2c0ab <btf_add_composite+0x5b>
; }
   2c0df: 5b                           	popq	%rbx
   2c0e0: 5d                           	popq	%rbp
   2c0e1: 41 5c                        	popq	%r12
   2c0e3: 41 5d                        	popq	%r13
   2c0e5: 41 5e                        	popq	%r14
   2c0e7: c3                           	retq
   2c0e8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		errno = -ret;
   2c0f0: e8 fb 95 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c0f5: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2c0fb: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2c100: eb dd                        	jmp	0x2c0df <btf_add_composite+0x8f>
   2c102: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c10d: 0f 1f 00                     	nopl	(%rax)

000000000002c110 <btf_add_enum_common>:
; {
   2c110: 41 57                        	pushq	%r15
   2c112: 41 56                        	pushq	%r14
   2c114: 41 55                        	pushq	%r13
   2c116: 41 54                        	pushq	%r12
   2c118: 55                           	pushq	%rbp
   2c119: 53                           	pushq	%rbx
; 	if (!byte_sz || (byte_sz & (byte_sz - 1)) || byte_sz > 8)
   2c11a: 8d 5a ff                     	leal	-1(%rdx), %ebx
; {
   2c11d: 48 83 ec 18                  	subq	$24, %rsp
; 	if (!byte_sz || (byte_sz & (byte_sz - 1)) || byte_sz > 8)
   2c121: 83 fb 07                     	cmpl	$7, %ebx
   2c124: 0f 87 b6 00 00 00            	ja	0x2c1e0 <btf_add_enum_common+0xd0>
   2c12a: 41 89 d5                     	movl	%edx, %r13d
   2c12d: 21 d3                        	andl	%edx, %ebx
   2c12f: 0f 85 ab 00 00 00            	jne	0x2c1e0 <btf_add_enum_common+0xd0>
   2c135: 48 89 fd                     	movq	%rdi, %rbp
   2c138: 49 89 f7                     	movq	%rsi, %r15
   2c13b: 41 89 cc                     	movl	%ecx, %r12d
   2c13e: 45 89 c6                     	movl	%r8d, %r14d
; 	if (btf_ensure_modifiable(btf))
   2c141: e8 5a d2 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2c146: 85 c0                        	testl	%eax, %eax
   2c148: 0f 85 b2 00 00 00            	jne	0x2c200 <btf_add_enum_common+0xf0>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2c14e: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2c152: ba 01 00 00 00               	movl	$1, %edx
   2c157: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2c15b: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2c15f: 41 b9 0c 00 00 00            	movl	$12, %r9d
   2c165: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2c16b: 8b 48 0c                     	movl	12(%rax), %ecx
   2c16e: e8 2d dc ff ff               	callq	0x29da0 <libbpf_add_mem>
   2c173: 48 89 c2                     	movq	%rax, %rdx
; 	if (!t)
   2c176: 48 85 c0                     	testq	%rax, %rax
   2c179: 0f 84 81 00 00 00            	je	0x2c200 <btf_add_enum_common+0xf0>
; 	if (name && name[0]) {
   2c17f: 4d 85 ff                     	testq	%r15, %r15
   2c182: 74 06                        	je	0x2c18a <btf_add_enum_common+0x7a>
   2c184: 41 80 3f 00                  	cmpb	$0, (%r15)
   2c188: 75 36                        	jne	0x2c1c0 <btf_add_enum_common+0xb0>
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c18a: 41 c1 e6 18                  	shll	$24, %r14d
   2c18e: 41 c1 e4 1f                  	shll	$31, %r12d
; 	t->name_off = name_off;
   2c192: 89 1a                        	movl	%ebx, (%rdx)
; 	return btf_commit_type(btf, sz);
   2c194: 48 89 ef                     	movq	%rbp, %rdi
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c197: 45 09 f4                     	orl	%r14d, %r12d
; 	t->size = byte_sz;
   2c19a: 44 89 6a 08                  	movl	%r13d, 8(%rdx)
; 	return btf_commit_type(btf, sz);
   2c19e: be 0c 00 00 00               	movl	$12, %esi
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c1a3: 44 89 62 04                  	movl	%r12d, 4(%rdx)
; }
   2c1a7: 48 83 c4 18                  	addq	$24, %rsp
   2c1ab: 5b                           	popq	%rbx
   2c1ac: 5d                           	popq	%rbp
   2c1ad: 41 5c                        	popq	%r12
   2c1af: 41 5d                        	popq	%r13
   2c1b1: 41 5e                        	popq	%r14
   2c1b3: 41 5f                        	popq	%r15
; 	return btf_commit_type(btf, sz);
   2c1b5: e9 c6 d4 ff ff               	jmp	0x29680 <btf_commit_type>
   2c1ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		name_off = btf__add_str(btf, name);
   2c1c0: 4c 89 fe                     	movq	%r15, %rsi
   2c1c3: 48 89 ef                     	movq	%rbp, %rdi
   2c1c6: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   2c1cb: e8 50 fc ff ff               	callq	0x2be20 <btf__add_str>
; 		if (name_off < 0)
   2c1d0: 85 c0                        	testl	%eax, %eax
   2c1d2: 78 1c                        	js	0x2c1f0 <btf_add_enum_common+0xe0>
; 	t->name_off = name_off;
   2c1d4: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   2c1d9: 89 c3                        	movl	%eax, %ebx
   2c1db: eb ad                        	jmp	0x2c18a <btf_add_enum_common+0x7a>
   2c1dd: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
   2c1e0: e8 0b 95 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c1e5: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2c1eb: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2c1f0: 48 83 c4 18                  	addq	$24, %rsp
   2c1f4: 5b                           	popq	%rbx
   2c1f5: 5d                           	popq	%rbp
   2c1f6: 41 5c                        	popq	%r12
   2c1f8: 41 5d                        	popq	%r13
   2c1fa: 41 5e                        	popq	%r14
   2c1fc: 41 5f                        	popq	%r15
   2c1fe: c3                           	retq
   2c1ff: 90                           	nop
; 		errno = -ret;
   2c200: e8 eb 94 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c205: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2c20b: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2c210: eb de                        	jmp	0x2c1f0 <btf_add_enum_common+0xe0>
   2c212: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c21d: 0f 1f 00                     	nopl	(%rax)

000000000002c220 <btf__add_int>:
; {
   2c220: f3 0f 1e fa                  	endbr64
   2c224: 41 56                        	pushq	%r14
   2c226: 41 55                        	pushq	%r13
   2c228: 41 54                        	pushq	%r12
   2c22a: 55                           	pushq	%rbp
   2c22b: 53                           	pushq	%rbx
; 	if (!name || !name[0])
   2c22c: 48 85 f6                     	testq	%rsi, %rsi
   2c22f: 0f 84 bb 00 00 00            	je	0x2c2f0 <btf__add_int+0xd0>
   2c235: 80 3e 00                     	cmpb	$0, (%rsi)
   2c238: 49 89 f5                     	movq	%rsi, %r13
   2c23b: 0f 84 af 00 00 00            	je	0x2c2f0 <btf__add_int+0xd0>
; 	if (!byte_sz || (byte_sz & (byte_sz - 1)) || byte_sz > 16)
   2c241: 48 8d 42 ff                  	leaq	-1(%rdx), %rax
   2c245: 48 89 d3                     	movq	%rdx, %rbx
   2c248: 48 83 f8 0f                  	cmpq	$15, %rax
   2c24c: 0f 87 9e 00 00 00            	ja	0x2c2f0 <btf__add_int+0xd0>
   2c252: 48 85 c2                     	testq	%rax, %rdx
   2c255: 0f 85 95 00 00 00            	jne	0x2c2f0 <btf__add_int+0xd0>
   2c25b: 41 89 ce                     	movl	%ecx, %r14d
; 	if (encoding & ~(BTF_INT_SIGNED | BTF_INT_CHAR | BTF_INT_BOOL))
   2c25e: f7 c1 f8 ff ff ff            	testl	$4294967288, %ecx       # imm = 0xFFFFFFF8
   2c264: 0f 85 86 00 00 00            	jne	0x2c2f0 <btf__add_int+0xd0>
   2c26a: 48 89 fd                     	movq	%rdi, %rbp
; 	if (btf_ensure_modifiable(btf))
   2c26d: e8 2e d1 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2c272: 85 c0                        	testl	%eax, %eax
   2c274: 0f 85 96 00 00 00            	jne	0x2c310 <btf__add_int+0xf0>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2c27a: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2c27e: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2c282: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2c286: 41 b9 10 00 00 00            	movl	$16, %r9d
   2c28c: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2c292: ba 01 00 00 00               	movl	$1, %edx
   2c297: 8b 48 0c                     	movl	12(%rax), %ecx
   2c29a: e8 01 db ff ff               	callq	0x29da0 <libbpf_add_mem>
   2c29f: 49 89 c4                     	movq	%rax, %r12
; 	if (!t)
   2c2a2: 48 85 c0                     	testq	%rax, %rax
   2c2a5: 74 69                        	je	0x2c310 <btf__add_int+0xf0>
; 	name_off = btf__add_str(btf, name);
   2c2a7: 4c 89 ee                     	movq	%r13, %rsi
   2c2aa: 48 89 ef                     	movq	%rbp, %rdi
   2c2ad: e8 6e fb ff ff               	callq	0x2be20 <btf__add_str>
; 	if (name_off < 0)
   2c2b2: 85 c0                        	testl	%eax, %eax
   2c2b4: 78 4a                        	js	0x2c300 <btf__add_int+0xe0>
; 	*(__u32 *)(t + 1) = (encoding << 24) | (byte_sz * 8);
   2c2b6: 41 c1 e6 18                  	shll	$24, %r14d
; 	t->name_off = name_off;
   2c2ba: 41 89 04 24                  	movl	%eax, (%r12)
; 	return btf_commit_type(btf, sz);
   2c2be: 48 89 ef                     	movq	%rbp, %rdi
   2c2c1: be 10 00 00 00               	movl	$16, %esi
; 	t->size = byte_sz;
   2c2c6: 41 89 5c 24 08               	movl	%ebx, 8(%r12)
; 	*(__u32 *)(t + 1) = (encoding << 24) | (byte_sz * 8);
   2c2cb: c1 e3 03                     	shll	$3, %ebx
; 	t->info = btf_type_info(BTF_KIND_INT, 0, 0);
   2c2ce: 41 c7 44 24 04 00 00 00 01   	movl	$16777216, 4(%r12)      # imm = 0x1000000
; 	*(__u32 *)(t + 1) = (encoding << 24) | (byte_sz * 8);
   2c2d7: 41 09 de                     	orl	%ebx, %r14d
   2c2da: 45 89 74 24 0c               	movl	%r14d, 12(%r12)
; }
   2c2df: 5b                           	popq	%rbx
   2c2e0: 5d                           	popq	%rbp
   2c2e1: 41 5c                        	popq	%r12
   2c2e3: 41 5d                        	popq	%r13
   2c2e5: 41 5e                        	popq	%r14
; 	return btf_commit_type(btf, sz);
   2c2e7: e9 94 d3 ff ff               	jmp	0x29680 <btf_commit_type>
   2c2ec: 0f 1f 40 00                  	nopl	(%rax)
; 		errno = -ret;
   2c2f0: e8 fb 93 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c2f5: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2c2fb: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2c300: 5b                           	popq	%rbx
   2c301: 5d                           	popq	%rbp
   2c302: 41 5c                        	popq	%r12
   2c304: 41 5d                        	popq	%r13
   2c306: 41 5e                        	popq	%r14
   2c308: c3                           	retq
   2c309: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -ret;
   2c310: e8 db 93 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c315: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2c31b: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2c320: eb de                        	jmp	0x2c300 <btf__add_int+0xe0>
   2c322: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c32d: 0f 1f 00                     	nopl	(%rax)

000000000002c330 <btf__add_float>:
; {
   2c330: f3 0f 1e fa                  	endbr64
   2c334: 41 55                        	pushq	%r13
   2c336: 41 54                        	pushq	%r12
   2c338: 55                           	pushq	%rbp
   2c339: 53                           	pushq	%rbx
   2c33a: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!name || !name[0])
   2c33e: 48 85 f6                     	testq	%rsi, %rsi
   2c341: 0f 84 99 00 00 00            	je	0x2c3e0 <btf__add_float+0xb0>
   2c347: 80 3e 00                     	cmpb	$0, (%rsi)
   2c34a: 49 89 f4                     	movq	%rsi, %r12
   2c34d: 0f 84 8d 00 00 00            	je	0x2c3e0 <btf__add_float+0xb0>
   2c353: 49 89 d5                     	movq	%rdx, %r13
; 	if (byte_sz != 2 && byte_sz != 4 && byte_sz != 8 && byte_sz != 12 &&
   2c356: 48 83 fa 10                  	cmpq	$16, %rdx
   2c35a: 0f 87 80 00 00 00            	ja	0x2c3e0 <btf__add_float+0xb0>
   2c360: 48 c7 c0 eb ee fe ff         	movq	$-69909, %rax           # imm = 0xFFFEEEEB
   2c367: 48 0f a3 d0                  	btq	%rdx, %rax
   2c36b: 72 73                        	jb	0x2c3e0 <btf__add_float+0xb0>
   2c36d: 48 89 fd                     	movq	%rdi, %rbp
; 	if (btf_ensure_modifiable(btf))
   2c370: e8 2b d0 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2c375: 85 c0                        	testl	%eax, %eax
   2c377: 0f 85 83 00 00 00            	jne	0x2c400 <btf__add_float+0xd0>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2c37d: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2c381: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2c385: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2c389: 41 b9 0c 00 00 00            	movl	$12, %r9d
   2c38f: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2c395: ba 01 00 00 00               	movl	$1, %edx
   2c39a: 8b 48 0c                     	movl	12(%rax), %ecx
   2c39d: e8 fe d9 ff ff               	callq	0x29da0 <libbpf_add_mem>
   2c3a2: 48 89 c3                     	movq	%rax, %rbx
; 	if (!t)
   2c3a5: 48 85 c0                     	testq	%rax, %rax
   2c3a8: 74 56                        	je	0x2c400 <btf__add_float+0xd0>
; 	name_off = btf__add_str(btf, name);
   2c3aa: 4c 89 e6                     	movq	%r12, %rsi
   2c3ad: 48 89 ef                     	movq	%rbp, %rdi
   2c3b0: e8 6b fa ff ff               	callq	0x2be20 <btf__add_str>
; 	if (name_off < 0)
   2c3b5: 85 c0                        	testl	%eax, %eax
   2c3b7: 78 37                        	js	0x2c3f0 <btf__add_float+0xc0>
; 	t->name_off = name_off;
   2c3b9: 89 03                        	movl	%eax, (%rbx)
; 	return btf_commit_type(btf, sz);
   2c3bb: 48 89 ef                     	movq	%rbp, %rdi
   2c3be: be 0c 00 00 00               	movl	$12, %esi
; 	t->info = btf_type_info(BTF_KIND_FLOAT, 0, 0);
   2c3c3: c7 43 04 00 00 00 10         	movl	$268435456, 4(%rbx)     # imm = 0x10000000
; 	t->size = byte_sz;
   2c3ca: 44 89 6b 08                  	movl	%r13d, 8(%rbx)
; }
   2c3ce: 48 83 c4 08                  	addq	$8, %rsp
   2c3d2: 5b                           	popq	%rbx
   2c3d3: 5d                           	popq	%rbp
   2c3d4: 41 5c                        	popq	%r12
   2c3d6: 41 5d                        	popq	%r13
; 	return btf_commit_type(btf, sz);
   2c3d8: e9 a3 d2 ff ff               	jmp	0x29680 <btf_commit_type>
   2c3dd: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
   2c3e0: e8 0b 93 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c3e5: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2c3eb: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2c3f0: 48 83 c4 08                  	addq	$8, %rsp
   2c3f4: 5b                           	popq	%rbx
   2c3f5: 5d                           	popq	%rbp
   2c3f6: 41 5c                        	popq	%r12
   2c3f8: 41 5d                        	popq	%r13
   2c3fa: c3                           	retq
   2c3fb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		errno = -ret;
   2c400: e8 eb 92 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c405: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2c40b: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2c410: eb de                        	jmp	0x2c3f0 <btf__add_float+0xc0>
   2c412: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c41d: 0f 1f 00                     	nopl	(%rax)

000000000002c420 <btf__add_ptr>:
; {
   2c420: f3 0f 1e fa                  	endbr64
   2c424: 89 f1                        	movl	%esi, %ecx
; 	return btf_add_ref_kind(btf, BTF_KIND_PTR, NULL, ref_type_id);
   2c426: 31 d2                        	xorl	%edx, %edx
   2c428: be 02 00 00 00               	movl	$2, %esi
   2c42d: e9 4e fb ff ff               	jmp	0x2bf80 <btf_add_ref_kind>
   2c432: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c43d: 0f 1f 00                     	nopl	(%rax)

000000000002c440 <btf__add_array>:
; {
   2c440: f3 0f 1e fa                  	endbr64
   2c444: 41 55                        	pushq	%r13
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2c446: 89 f0                        	movl	%esi, %eax
; {
   2c448: 41 54                        	pushq	%r12
   2c44a: 55                           	pushq	%rbp
   2c44b: 53                           	pushq	%rbx
   2c44c: 48 83 ec 08                  	subq	$8, %rsp
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2c450: 09 d0                        	orl	%edx, %eax
   2c452: 0f 88 98 00 00 00            	js	0x2c4f0 <btf__add_array+0xb0>
   2c458: 48 89 fd                     	movq	%rdi, %rbp
   2c45b: 89 f3                        	movl	%esi, %ebx
   2c45d: 41 89 d4                     	movl	%edx, %r12d
   2c460: 41 89 cd                     	movl	%ecx, %r13d
; 	if (btf_ensure_modifiable(btf))
   2c463: e8 38 cf ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2c468: 85 c0                        	testl	%eax, %eax
   2c46a: 75 64                        	jne	0x2c4d0 <btf__add_array+0x90>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2c46c: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2c470: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2c474: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2c478: 41 b9 18 00 00 00            	movl	$24, %r9d
   2c47e: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2c484: ba 01 00 00 00               	movl	$1, %edx
   2c489: 8b 48 0c                     	movl	12(%rax), %ecx
   2c48c: e8 0f d9 ff ff               	callq	0x29da0 <libbpf_add_mem>
; 	if (!t)
   2c491: 48 85 c0                     	testq	%rax, %rax
   2c494: 74 3a                        	je	0x2c4d0 <btf__add_array+0x90>
; 	t->name_off = 0;
   2c496: 48 ba 00 00 00 00 00 00 00 03	movabsq	$216172782113783808, %rdx # imm = 0x300000000000000
; 	a->type = elem_type_id;
   2c4a0: 44 89 60 0c                  	movl	%r12d, 12(%rax)
; 	return btf_commit_type(btf, sz);
   2c4a4: 48 89 ef                     	movq	%rbp, %rdi
   2c4a7: be 18 00 00 00               	movl	$24, %esi
; 	t->name_off = 0;
   2c4ac: 48 89 10                     	movq	%rdx, (%rax)
; 	t->size = 0;
   2c4af: c7 40 08 00 00 00 00         	movl	$0, 8(%rax)
; 	a->index_type = index_type_id;
   2c4b6: 89 58 10                     	movl	%ebx, 16(%rax)
; 	a->nelems = nr_elems;
   2c4b9: 44 89 68 14                  	movl	%r13d, 20(%rax)
; }
   2c4bd: 48 83 c4 08                  	addq	$8, %rsp
   2c4c1: 5b                           	popq	%rbx
   2c4c2: 5d                           	popq	%rbp
   2c4c3: 41 5c                        	popq	%r12
   2c4c5: 41 5d                        	popq	%r13
; 	return btf_commit_type(btf, sz);
   2c4c7: e9 b4 d1 ff ff               	jmp	0x29680 <btf_commit_type>
   2c4cc: 0f 1f 40 00                  	nopl	(%rax)
; 		errno = -ret;
   2c4d0: e8 1b 92 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c4d5: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2c4db: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
; }
   2c4e0: 48 83 c4 08                  	addq	$8, %rsp
   2c4e4: 5b                           	popq	%rbx
   2c4e5: 5d                           	popq	%rbp
   2c4e6: 41 5c                        	popq	%r12
   2c4e8: 41 5d                        	popq	%r13
   2c4ea: c3                           	retq
   2c4eb: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		errno = -ret;
   2c4f0: e8 fb 91 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c4f5: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2c4fb: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   2c500: eb de                        	jmp	0x2c4e0 <btf__add_array+0xa0>
   2c502: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c50d: 0f 1f 00                     	nopl	(%rax)

000000000002c510 <btf__add_struct>:
; {
   2c510: f3 0f 1e fa                  	endbr64
   2c514: 89 d1                        	movl	%edx, %ecx
; 	return btf_add_composite(btf, BTF_KIND_STRUCT, name, byte_sz);
   2c516: 48 89 f2                     	movq	%rsi, %rdx
   2c519: be 04 00 00 00               	movl	$4, %esi
   2c51e: e9 2d fb ff ff               	jmp	0x2c050 <btf_add_composite>
   2c523: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c52e: 66 90                        	nop

000000000002c530 <btf__add_union>:
; {
   2c530: f3 0f 1e fa                  	endbr64
   2c534: 89 d1                        	movl	%edx, %ecx
; 	return btf_add_composite(btf, BTF_KIND_UNION, name, byte_sz);
   2c536: 48 89 f2                     	movq	%rsi, %rdx
   2c539: be 05 00 00 00               	movl	$5, %esi
   2c53e: e9 0d fb ff ff               	jmp	0x2c050 <btf_add_composite>
   2c543: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c54e: 66 90                        	nop

000000000002c550 <btf__add_field>:
; {
   2c550: f3 0f 1e fa                  	endbr64
   2c554: 41 57                        	pushq	%r15
   2c556: 41 56                        	pushq	%r14
   2c558: 41 55                        	pushq	%r13
   2c55a: 41 54                        	pushq	%r12
   2c55c: 55                           	pushq	%rbp
   2c55d: 53                           	pushq	%rbx
   2c55e: 48 83 ec 18                  	subq	$24, %rsp
; 	if (btf->nr_types == 0)
   2c562: 8b 47 40                     	movl	64(%rdi), %eax
   2c565: 85 c0                        	testl	%eax, %eax
   2c567: 0f 84 79 01 00 00            	je	0x2c6e6 <btf__add_field+0x196>
   2c56d: 41 89 d5                     	movl	%edx, %r13d
; 	return btf->start_id + btf->nr_types;
   2c570: 8b 57 50                     	movl	80(%rdi), %edx
   2c573: 89 cd                        	movl	%ecx, %ebp
   2c575: 49 89 ff                     	movq	%rdi, %r15
   2c578: 49 89 f4                     	movq	%rsi, %r12
   2c57b: 44 89 c3                     	movl	%r8d, %ebx
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2c57e: 8d 4c 10 ff                  	leal	-1(%rax,%rdx), %ecx
; 		return &btf_void;
   2c582: 48 8d 05 07 ad 01 00         	leaq	109831(%rip), %rax      # 0x47290 <btf_void>
; 	if (type_id == 0)
   2c589: 85 c9                        	testl	%ecx, %ecx
   2c58b: 74 26                        	je	0x2c5b3 <btf__add_field+0x63>
   2c58d: 48 89 f8                     	movq	%rdi, %rax
   2c590: eb 0d                        	jmp	0x2c59f <btf__add_field+0x4f>
   2c592: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2c598: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2c59c: 8b 50 50                     	movl	80(%rax), %edx
   2c59f: 39 d1                        	cmpl	%edx, %ecx
   2c5a1: 72 f5                        	jb	0x2c598 <btf__add_field+0x48>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2c5a3: 29 d1                        	subl	%edx, %ecx
   2c5a5: 48 8b 50 30                  	movq	48(%rax), %rdx
   2c5a9: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2c5ac: 48 03 50 20                  	addq	32(%rax), %rdx
   2c5b0: 48 89 d0                     	movq	%rdx, %rax
; 	return BTF_INFO_KIND(t->info);
   2c5b3: 0f b6 40 07                  	movzbl	7(%rax), %eax
   2c5b7: 83 e0 1f                     	andl	$31, %eax
; 	return kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;
   2c5ba: 8d 50 fc                     	leal	-4(%rax), %edx
; 	if (!btf_is_composite(t))
   2c5bd: 66 83 fa 01                  	cmpw	$1, %dx
   2c5c1: 0f 87 1f 01 00 00            	ja	0x2c6e6 <btf__add_field+0x196>
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2c5c7: 45 85 ed                     	testl	%r13d, %r13d
   2c5ca: 0f 88 16 01 00 00            	js	0x2c6e6 <btf__add_field+0x196>
; 	is_bitfield = bit_size || (bit_offset % 8 != 0);
   2c5d0: 85 db                        	testl	%ebx, %ebx
   2c5d2: 0f 84 08 01 00 00            	je	0x2c6e0 <btf__add_field+0x190>
; 	if (is_bitfield && (bit_size == 0 || bit_size > 255 || bit_offset > 0xffffff))
   2c5d8: 8d 53 ff                     	leal	-1(%rbx), %edx
   2c5db: 81 fa fe 00 00 00            	cmpl	$254, %edx
   2c5e1: 0f 87 ff 00 00 00            	ja	0x2c6e6 <btf__add_field+0x196>
   2c5e7: 81 fd ff ff ff 00            	cmpl	$16777215, %ebp         # imm = 0xFFFFFF
   2c5ed: 0f 87 f3 00 00 00            	ja	0x2c6e6 <btf__add_field+0x196>
   2c5f3: c7 44 24 04 01 00 00 00      	movl	$1, 4(%rsp)
; 	if (btf_is_union(t) && bit_offset)
   2c5fb: 66 83 f8 05                  	cmpw	$5, %ax
   2c5ff: 75 08                        	jne	0x2c609 <btf__add_field+0xb9>
   2c601: 85 ed                        	testl	%ebp, %ebp
   2c603: 0f 85 dd 00 00 00            	jne	0x2c6e6 <btf__add_field+0x196>
; 	if (btf_ensure_modifiable(btf))
   2c609: 4c 89 ff                     	movq	%r15, %rdi
   2c60c: e8 8f cd ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2c611: 41 89 c6                     	movl	%eax, %r14d
   2c614: 85 c0                        	testl	%eax, %eax
   2c616: 0f 85 16 01 00 00            	jne	0x2c732 <btf__add_field+0x1e2>
; 	m = btf_add_type_mem(btf, sz);
   2c61c: be 0c 00 00 00               	movl	$12, %esi
   2c621: 4c 89 ff                     	movq	%r15, %rdi
   2c624: e8 87 cf ff ff               	callq	0x295b0 <btf_add_type_mem>
   2c629: 48 89 c2                     	movq	%rax, %rdx
; 	if (!m)
   2c62c: 48 85 c0                     	testq	%rax, %rax
   2c62f: 0f 84 fd 00 00 00            	je	0x2c732 <btf__add_field+0x1e2>
; 	if (name && name[0]) {
   2c635: 31 c0                        	xorl	%eax, %eax
   2c637: 4d 85 e4                     	testq	%r12, %r12
   2c63a: 74 0b                        	je	0x2c647 <btf__add_field+0xf7>
   2c63c: 41 80 3c 24 00               	cmpb	$0, (%r12)
   2c641: 0f 85 b9 00 00 00            	jne	0x2c700 <btf__add_field+0x1b0>
; 	m->offset = bit_offset | (bit_size << 24);
   2c647: c1 e3 18                     	shll	$24, %ebx
; 	m->name_off = name_off;
   2c64a: 89 02                        	movl	%eax, (%rdx)
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2c64c: 41 8b 47 40                  	movl	64(%r15), %eax
; 		return &btf_void;
   2c650: 48 8d 35 39 ac 01 00         	leaq	109625(%rip), %rsi      # 0x47290 <btf_void>
; 	m->offset = bit_offset | (bit_size << 24);
   2c657: 09 eb                        	orl	%ebp, %ebx
; 	m->type = type_id;
   2c659: 44 89 6a 04                  	movl	%r13d, 4(%rdx)
; 	m->offset = bit_offset | (bit_size << 24);
   2c65d: 89 5a 08                     	movl	%ebx, 8(%rdx)
; 	return btf->start_id + btf->nr_types;
   2c660: 41 8b 57 50                  	movl	80(%r15), %edx
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2c664: 8d 4c 02 ff                  	leal	-1(%rdx,%rax), %ecx
; 	if (type_id == 0)
   2c668: 85 c9                        	testl	%ecx, %ecx
   2c66a: 74 24                        	je	0x2c690 <btf__add_field+0x140>
   2c66c: 4c 89 f8                     	movq	%r15, %rax
   2c66f: eb 0e                        	jmp	0x2c67f <btf__add_field+0x12f>
   2c671: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2c678: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2c67c: 8b 50 50                     	movl	80(%rax), %edx
   2c67f: 39 d1                        	cmpl	%edx, %ecx
   2c681: 72 f5                        	jb	0x2c678 <btf__add_field+0x128>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2c683: 29 d1                        	subl	%edx, %ecx
   2c685: 48 8b 50 30                  	movq	48(%rax), %rdx
   2c689: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2c68c: 48 03 70 20                  	addq	32(%rax), %rsi
; 	return BTF_INFO_KFLAG(t->info);
   2c690: 8b 46 04                     	movl	4(%rsi), %eax
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c693: 8b 54 24 04                  	movl	4(%rsp), %edx
   2c697: 89 c1                        	movl	%eax, %ecx
   2c699: 81 e1 00 00 00 80            	andl	$2147483648, %ecx       # imm = 0x80000000
   2c69f: 85 d2                        	testl	%edx, %edx
   2c6a1: ba 00 00 00 80               	movl	$2147483648, %edx       # imm = 0x80000000
   2c6a6: 0f 45 ca                     	cmovnel	%edx, %ecx
   2c6a9: 89 c2                        	movl	%eax, %edx
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, is_bitfield || btf_kflag(t));
   2c6ab: 0f b7 c0                     	movzwl	%ax, %eax
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c6ae: 81 e2 00 00 00 1f            	andl	$520093696, %edx        # imm = 0x1F000000
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, is_bitfield || btf_kflag(t));
   2c6b4: 83 c0 01                     	addl	$1, %eax
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c6b7: 09 d0                        	orl	%edx, %eax
   2c6b9: 09 c8                        	orl	%ecx, %eax
   2c6bb: 89 46 04                     	movl	%eax, 4(%rsi)
; 	btf->hdr->type_len += sz;
   2c6be: 49 8b 47 18                  	movq	24(%r15), %rax
   2c6c2: 83 40 0c 0c                  	addl	$12, 12(%rax)
; 	btf->hdr->str_off += sz;
   2c6c6: 83 40 10 0c                  	addl	$12, 16(%rax)
; }
   2c6ca: 48 83 c4 18                  	addq	$24, %rsp
   2c6ce: 44 89 f0                     	movl	%r14d, %eax
   2c6d1: 5b                           	popq	%rbx
   2c6d2: 5d                           	popq	%rbp
   2c6d3: 41 5c                        	popq	%r12
   2c6d5: 41 5d                        	popq	%r13
   2c6d7: 41 5e                        	popq	%r14
   2c6d9: 41 5f                        	popq	%r15
   2c6db: c3                           	retq
   2c6dc: 0f 1f 40 00                  	nopl	(%rax)
; 	is_bitfield = bit_size || (bit_offset % 8 != 0);
   2c6e0: 40 f6 c5 07                  	testb	$7, %bpl
   2c6e4: 74 3a                        	je	0x2c720 <btf__add_field+0x1d0>
; 		errno = -ret;
   2c6e6: e8 05 90 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   2c6eb: 41 be ea ff ff ff            	movl	$4294967274, %r14d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   2c6f1: c7 00 16 00 00 00            	movl	$22, (%rax)
   2c6f7: eb d1                        	jmp	0x2c6ca <btf__add_field+0x17a>
   2c6f9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		name_off = btf__add_str(btf, name);
   2c700: 4c 89 e6                     	movq	%r12, %rsi
   2c703: 4c 89 ff                     	movq	%r15, %rdi
   2c706: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
   2c70b: e8 10 f7 ff ff               	callq	0x2be20 <btf__add_str>
; 		if (name_off < 0)
   2c710: 85 c0                        	testl	%eax, %eax
   2c712: 78 19                        	js	0x2c72d <btf__add_field+0x1dd>
   2c714: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   2c719: e9 29 ff ff ff               	jmp	0x2c647 <btf__add_field+0xf7>
   2c71e: 66 90                        	nop
; 	is_bitfield = bit_size || (bit_offset % 8 != 0);
   2c720: c7 44 24 04 00 00 00 00      	movl	$0, 4(%rsp)
   2c728: e9 ce fe ff ff               	jmp	0x2c5fb <btf__add_field+0xab>
   2c72d: 41 89 c6                     	movl	%eax, %r14d
   2c730: eb 98                        	jmp	0x2c6ca <btf__add_field+0x17a>
; 		errno = -ret;
   2c732: e8 b9 8f fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOMEM);
   2c737: 41 be f4 ff ff ff            	movl	$4294967284, %r14d      # imm = 0xFFFFFFF4
; 		errno = -ret;
   2c73d: c7 00 0c 00 00 00            	movl	$12, (%rax)
   2c743: e9 82 ff ff ff               	jmp	0x2c6ca <btf__add_field+0x17a>
   2c748: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000002c750 <btf__add_enum>:
; {
   2c750: f3 0f 1e fa                  	endbr64
; 	return btf_add_enum_common(btf, name, byte_sz, false, BTF_KIND_ENUM);
   2c754: 41 b8 06 00 00 00            	movl	$6, %r8d
   2c75a: 31 c9                        	xorl	%ecx, %ecx
   2c75c: e9 af f9 ff ff               	jmp	0x2c110 <btf_add_enum_common>
   2c761: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c76c: 0f 1f 40 00                  	nopl	(%rax)

000000000002c770 <btf__add_enum_value>:
; {
   2c770: f3 0f 1e fa                  	endbr64
   2c774: 41 55                        	pushq	%r13
   2c776: 41 54                        	pushq	%r12
   2c778: 55                           	pushq	%rbp
   2c779: 53                           	pushq	%rbx
   2c77a: 48 83 ec 08                  	subq	$8, %rsp
; 	if (btf->nr_types == 0)
   2c77e: 8b 47 40                     	movl	64(%rdi), %eax
   2c781: 85 c0                        	testl	%eax, %eax
   2c783: 0f 84 37 01 00 00            	je	0x2c8c0 <btf__add_enum_value+0x150>
   2c789: 48 89 d3                     	movq	%rdx, %rbx
; 	return btf->start_id + btf->nr_types;
   2c78c: 8b 57 50                     	movl	80(%rdi), %edx
   2c78f: 48 89 fd                     	movq	%rdi, %rbp
   2c792: 49 89 f4                     	movq	%rsi, %r12
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2c795: 8d 4c 10 ff                  	leal	-1(%rax,%rdx), %ecx
; 		return &btf_void;
   2c799: 48 8d 05 f0 aa 01 00         	leaq	109296(%rip), %rax      # 0x47290 <btf_void>
; 	if (type_id == 0)
   2c7a0: 85 c9                        	testl	%ecx, %ecx
   2c7a2: 74 27                        	je	0x2c7cb <btf__add_enum_value+0x5b>
   2c7a4: 48 89 f8                     	movq	%rdi, %rax
   2c7a7: eb 0e                        	jmp	0x2c7b7 <btf__add_enum_value+0x47>
   2c7a9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2c7b0: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2c7b4: 8b 50 50                     	movl	80(%rax), %edx
   2c7b7: 39 d1                        	cmpl	%edx, %ecx
   2c7b9: 72 f5                        	jb	0x2c7b0 <btf__add_enum_value+0x40>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2c7bb: 29 d1                        	subl	%edx, %ecx
   2c7bd: 48 8b 50 30                  	movq	48(%rax), %rdx
   2c7c1: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2c7c4: 48 03 50 20                  	addq	32(%rax), %rdx
   2c7c8: 48 89 d0                     	movq	%rdx, %rax
; 	return BTF_INFO_KIND(t->info);
   2c7cb: 0f b6 40 07                  	movzbl	7(%rax), %eax
   2c7cf: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_enum(t))
   2c7d2: 66 83 f8 06                  	cmpw	$6, %ax
   2c7d6: 0f 85 e4 00 00 00            	jne	0x2c8c0 <btf__add_enum_value+0x150>
; 	if (!name || !name[0])
   2c7dc: 4d 85 e4                     	testq	%r12, %r12
   2c7df: 0f 84 db 00 00 00            	je	0x2c8c0 <btf__add_enum_value+0x150>
   2c7e5: 41 80 3c 24 00               	cmpb	$0, (%r12)
   2c7ea: 0f 84 d0 00 00 00            	je	0x2c8c0 <btf__add_enum_value+0x150>
; 	if (value < INT_MIN || value > UINT_MAX)
   2c7f0: 48 ba ff ff ff 7f 01 00 00 00	movabsq	$6442450943, %rdx       # imm = 0x17FFFFFFF
   2c7fa: b8 00 00 00 80               	movl	$2147483648, %eax       # imm = 0x80000000
   2c7ff: 48 01 d8                     	addq	%rbx, %rax
   2c802: 48 39 d0                     	cmpq	%rdx, %rax
   2c805: 0f 87 d9 00 00 00            	ja	0x2c8e4 <btf__add_enum_value+0x174>
; 	if (btf_ensure_modifiable(btf))
   2c80b: 48 89 ef                     	movq	%rbp, %rdi
   2c80e: e8 8d cb ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2c813: 85 c0                        	testl	%eax, %eax
   2c815: 0f 85 b7 00 00 00            	jne	0x2c8d2 <btf__add_enum_value+0x162>
; 	v = btf_add_type_mem(btf, sz);
   2c81b: be 08 00 00 00               	movl	$8, %esi
   2c820: 48 89 ef                     	movq	%rbp, %rdi
   2c823: e8 88 cd ff ff               	callq	0x295b0 <btf_add_type_mem>
   2c828: 49 89 c5                     	movq	%rax, %r13
; 	if (!v)
   2c82b: 48 85 c0                     	testq	%rax, %rax
   2c82e: 0f 84 9e 00 00 00            	je	0x2c8d2 <btf__add_enum_value+0x162>
; 	name_off = btf__add_str(btf, name);
   2c834: 4c 89 e6                     	movq	%r12, %rsi
   2c837: 48 89 ef                     	movq	%rbp, %rdi
   2c83a: e8 e1 f5 ff ff               	callq	0x2be20 <btf__add_str>
; 	if (name_off < 0)
   2c83f: 85 c0                        	testl	%eax, %eax
   2c841: 78 72                        	js	0x2c8b5 <btf__add_enum_value+0x145>
; 	v->name_off = name_off;
   2c843: 41 89 45 00                  	movl	%eax, (%r13)
; 	return btf->start_id + btf->nr_types;
   2c847: 8b 55 50                     	movl	80(%rbp), %edx
; 		return &btf_void;
   2c84a: 48 8d 35 3f aa 01 00         	leaq	109119(%rip), %rsi      # 0x47290 <btf_void>
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2c851: 8b 45 40                     	movl	64(%rbp), %eax
; 	v->val = value;
   2c854: 41 89 5d 04                  	movl	%ebx, 4(%r13)
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2c858: 8d 4c 02 ff                  	leal	-1(%rdx,%rax), %ecx
; 	if (type_id == 0)
   2c85c: 85 c9                        	testl	%ecx, %ecx
   2c85e: 74 20                        	je	0x2c880 <btf__add_enum_value+0x110>
   2c860: 48 89 e8                     	movq	%rbp, %rax
   2c863: eb 0a                        	jmp	0x2c86f <btf__add_enum_value+0xff>
   2c865: 0f 1f 00                     	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2c868: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2c86c: 8b 50 50                     	movl	80(%rax), %edx
   2c86f: 39 d1                        	cmpl	%edx, %ecx
   2c871: 72 f5                        	jb	0x2c868 <btf__add_enum_value+0xf8>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2c873: 29 d1                        	subl	%edx, %ecx
   2c875: 48 8b 50 30                  	movq	48(%rax), %rdx
   2c879: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2c87c: 48 03 70 20                  	addq	32(%rax), %rsi
; 	return BTF_INFO_KFLAG(t->info);
   2c880: 8b 46 04                     	movl	4(%rsi), %eax
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2c883: 0f b7 d0                     	movzwl	%ax, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c886: 25 00 00 00 9f               	andl	$2667577344, %eax       # imm = 0x9F000000
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2c88b: 83 c2 01                     	addl	$1, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2c88e: 09 d0                        	orl	%edx, %eax
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2c890: 89 c2                        	movl	%eax, %edx
   2c892: 81 e2 ff ff 00 1f            	andl	$520159231, %edx        # imm = 0x1F00FFFF
   2c898: 81 ca 00 00 00 80            	orl	$2147483648, %edx       # imm = 0x80000000
   2c89e: 48 85 db                     	testq	%rbx, %rbx
   2c8a1: 0f 48 c2                     	cmovsl	%edx, %eax
   2c8a4: 89 46 04                     	movl	%eax, 4(%rsi)
; 	btf->hdr->type_len += sz;
   2c8a7: 48 8b 45 18                  	movq	24(%rbp), %rax
   2c8ab: 83 40 0c 08                  	addl	$8, 12(%rax)
; 	btf->hdr->str_off += sz;
   2c8af: 83 40 10 08                  	addl	$8, 16(%rax)
; 	return 0;
   2c8b3: 31 c0                        	xorl	%eax, %eax
; }
   2c8b5: 48 83 c4 08                  	addq	$8, %rsp
   2c8b9: 5b                           	popq	%rbx
   2c8ba: 5d                           	popq	%rbp
   2c8bb: 41 5c                        	popq	%r12
   2c8bd: 41 5d                        	popq	%r13
   2c8bf: c3                           	retq
; 		errno = -ret;
   2c8c0: e8 2b 8e fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c8c5: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2c8cb: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   2c8d0: eb e3                        	jmp	0x2c8b5 <btf__add_enum_value+0x145>
; 		errno = -ret;
   2c8d2: e8 19 8e fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c8d7: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2c8dd: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2c8e2: eb d1                        	jmp	0x2c8b5 <btf__add_enum_value+0x145>
; 		errno = -ret;
   2c8e4: e8 07 8e fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2c8e9: c7 00 07 00 00 00            	movl	$7, (%rax)
; 		return libbpf_err(-E2BIG);
   2c8ef: b8 f9 ff ff ff               	movl	$4294967289, %eax       # imm = 0xFFFFFFF9
   2c8f4: eb bf                        	jmp	0x2c8b5 <btf__add_enum_value+0x145>
   2c8f6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000002c900 <btf__add_enum64>:
; {
   2c900: f3 0f 1e fa                  	endbr64
; 	return btf_add_enum_common(btf, name, byte_sz, is_signed,
   2c904: 0f b6 c9                     	movzbl	%cl, %ecx
   2c907: 41 b8 13 00 00 00            	movl	$19, %r8d
   2c90d: e9 fe f7 ff ff               	jmp	0x2c110 <btf_add_enum_common>
   2c912: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2c91d: 0f 1f 00                     	nopl	(%rax)

000000000002c920 <btf__add_enum64_value>:
; {
   2c920: f3 0f 1e fa                  	endbr64
   2c924: 41 55                        	pushq	%r13
   2c926: 41 54                        	pushq	%r12
   2c928: 55                           	pushq	%rbp
   2c929: 53                           	pushq	%rbx
   2c92a: 48 83 ec 08                  	subq	$8, %rsp
; 	if (btf->nr_types == 0)
   2c92e: 8b 47 40                     	movl	64(%rdi), %eax
   2c931: 85 c0                        	testl	%eax, %eax
   2c933: 0f 84 23 01 00 00            	je	0x2ca5c <btf__add_enum64_value+0x13c>
   2c939: 48 89 d5                     	movq	%rdx, %rbp
; 	return btf->start_id + btf->nr_types;
   2c93c: 8b 57 50                     	movl	80(%rdi), %edx
   2c93f: 48 89 fb                     	movq	%rdi, %rbx
   2c942: 49 89 f4                     	movq	%rsi, %r12
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2c945: 8d 4c 10 ff                  	leal	-1(%rax,%rdx), %ecx
; 		return &btf_void;
   2c949: 48 8d 05 40 a9 01 00         	leaq	108864(%rip), %rax      # 0x47290 <btf_void>
; 	if (type_id == 0)
   2c950: 85 c9                        	testl	%ecx, %ecx
   2c952: 74 27                        	je	0x2c97b <btf__add_enum64_value+0x5b>
   2c954: 48 89 f8                     	movq	%rdi, %rax
   2c957: eb 0e                        	jmp	0x2c967 <btf__add_enum64_value+0x47>
   2c959: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2c960: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2c964: 8b 50 50                     	movl	80(%rax), %edx
   2c967: 39 d1                        	cmpl	%edx, %ecx
   2c969: 72 f5                        	jb	0x2c960 <btf__add_enum64_value+0x40>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2c96b: 29 d1                        	subl	%edx, %ecx
   2c96d: 48 8b 50 30                  	movq	48(%rax), %rdx
   2c971: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2c974: 48 03 50 20                  	addq	32(%rax), %rdx
   2c978: 48 89 d0                     	movq	%rdx, %rax
; 	return BTF_INFO_KIND(t->info);
   2c97b: 0f b6 40 07                  	movzbl	7(%rax), %eax
   2c97f: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_enum64(t))
   2c982: 66 83 f8 13                  	cmpw	$19, %ax
   2c986: 0f 85 d0 00 00 00            	jne	0x2ca5c <btf__add_enum64_value+0x13c>
; 	if (!name || !name[0])
   2c98c: 4d 85 e4                     	testq	%r12, %r12
   2c98f: 0f 84 c7 00 00 00            	je	0x2ca5c <btf__add_enum64_value+0x13c>
   2c995: 41 80 3c 24 00               	cmpb	$0, (%r12)
   2c99a: 0f 84 bc 00 00 00            	je	0x2ca5c <btf__add_enum64_value+0x13c>
; 	if (btf_ensure_modifiable(btf))
   2c9a0: 48 89 df                     	movq	%rbx, %rdi
   2c9a3: e8 f8 c9 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2c9a8: 85 c0                        	testl	%eax, %eax
   2c9aa: 0f 85 be 00 00 00            	jne	0x2ca6e <btf__add_enum64_value+0x14e>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2c9b0: 48 8b 43 18                  	movq	24(%rbx), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2c9b4: 48 8d 73 28                  	leaq	40(%rbx), %rsi
   2c9b8: 48 8d 7b 20                  	leaq	32(%rbx), %rdi
   2c9bc: 41 b9 0c 00 00 00            	movl	$12, %r9d
   2c9c2: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2c9c8: ba 01 00 00 00               	movl	$1, %edx
   2c9cd: 8b 48 0c                     	movl	12(%rax), %ecx
   2c9d0: e8 cb d3 ff ff               	callq	0x29da0 <libbpf_add_mem>
   2c9d5: 49 89 c5                     	movq	%rax, %r13
; 	if (!v)
   2c9d8: 48 85 c0                     	testq	%rax, %rax
   2c9db: 0f 84 8d 00 00 00            	je	0x2ca6e <btf__add_enum64_value+0x14e>
; 	name_off = btf__add_str(btf, name);
   2c9e1: 4c 89 e6                     	movq	%r12, %rsi
   2c9e4: 48 89 df                     	movq	%rbx, %rdi
   2c9e7: e8 34 f4 ff ff               	callq	0x2be20 <btf__add_str>
; 	if (name_off < 0)
   2c9ec: 85 c0                        	testl	%eax, %eax
   2c9ee: 78 61                        	js	0x2ca51 <btf__add_enum64_value+0x131>
; 	v->val_lo32 = (__u32)value;
   2c9f0: 49 89 6d 04                  	movq	%rbp, 4(%r13)
; 	return btf->start_id + btf->nr_types;
   2c9f4: 8b 53 50                     	movl	80(%rbx), %edx
; 		return &btf_void;
   2c9f7: 48 8d 35 92 a8 01 00         	leaq	108690(%rip), %rsi      # 0x47290 <btf_void>
; 	v->name_off = name_off;
   2c9fe: 41 89 45 00                  	movl	%eax, (%r13)
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2ca02: 8b 43 40                     	movl	64(%rbx), %eax
   2ca05: 8d 4c 02 ff                  	leal	-1(%rdx,%rax), %ecx
; 	if (type_id == 0)
   2ca09: 85 c9                        	testl	%ecx, %ecx
   2ca0b: 74 23                        	je	0x2ca30 <btf__add_enum64_value+0x110>
   2ca0d: 48 89 d8                     	movq	%rbx, %rax
   2ca10: eb 0d                        	jmp	0x2ca1f <btf__add_enum64_value+0xff>
   2ca12: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2ca18: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2ca1c: 8b 50 50                     	movl	80(%rax), %edx
   2ca1f: 39 d1                        	cmpl	%edx, %ecx
   2ca21: 72 f5                        	jb	0x2ca18 <btf__add_enum64_value+0xf8>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2ca23: 29 d1                        	subl	%edx, %ecx
   2ca25: 48 8b 50 30                  	movq	48(%rax), %rdx
   2ca29: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2ca2c: 48 03 70 20                  	addq	32(%rax), %rsi
; 	return BTF_INFO_KFLAG(t->info);
   2ca30: 8b 46 04                     	movl	4(%rsi), %eax
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2ca33: 0f b7 d0                     	movzwl	%ax, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2ca36: 25 00 00 00 9f               	andl	$2667577344, %eax       # imm = 0x9F000000
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2ca3b: 83 c2 01                     	addl	$1, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2ca3e: 09 d0                        	orl	%edx, %eax
   2ca40: 89 46 04                     	movl	%eax, 4(%rsi)
; 	btf->hdr->type_len += sz;
   2ca43: 48 8b 43 18                  	movq	24(%rbx), %rax
   2ca47: 83 40 0c 0c                  	addl	$12, 12(%rax)
; 	btf->hdr->str_off += sz;
   2ca4b: 83 40 10 0c                  	addl	$12, 16(%rax)
; 	return 0;
   2ca4f: 31 c0                        	xorl	%eax, %eax
; }
   2ca51: 48 83 c4 08                  	addq	$8, %rsp
   2ca55: 5b                           	popq	%rbx
   2ca56: 5d                           	popq	%rbp
   2ca57: 41 5c                        	popq	%r12
   2ca59: 41 5d                        	popq	%r13
   2ca5b: c3                           	retq
; 		errno = -ret;
   2ca5c: e8 8f 8c fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2ca61: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2ca67: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   2ca6c: eb e3                        	jmp	0x2ca51 <btf__add_enum64_value+0x131>
; 		errno = -ret;
   2ca6e: e8 7d 8c fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2ca73: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2ca79: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2ca7e: eb d1                        	jmp	0x2ca51 <btf__add_enum64_value+0x131>

000000000002ca80 <btf__add_fwd>:
; {
   2ca80: f3 0f 1e fa                  	endbr64
   2ca84: 55                           	pushq	%rbp
   2ca85: 53                           	pushq	%rbx
   2ca86: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!name || !name[0])
   2ca8a: 48 85 f6                     	testq	%rsi, %rsi
   2ca8d: 0f 84 7d 00 00 00            	je	0x2cb10 <btf__add_fwd+0x90>
   2ca93: 80 3e 00                     	cmpb	$0, (%rsi)
   2ca96: 74 78                        	je	0x2cb10 <btf__add_fwd+0x90>
   2ca98: 48 89 fd                     	movq	%rdi, %rbp
   2ca9b: 89 d3                        	movl	%edx, %ebx
; 	switch (fwd_kind) {
   2ca9d: 83 fa 01                     	cmpl	$1, %edx
   2caa0: 76 1e                        	jbe	0x2cac0 <btf__add_fwd+0x40>
   2caa2: 83 fa 02                     	cmpl	$2, %edx
   2caa5: 75 69                        	jne	0x2cb10 <btf__add_fwd+0x90>
; }
   2caa7: 48 83 c4 08                  	addq	$8, %rsp
; 	return btf_add_enum_common(btf, name, byte_sz, false, BTF_KIND_ENUM);
   2caab: 41 b8 06 00 00 00            	movl	$6, %r8d
   2cab1: 31 c9                        	xorl	%ecx, %ecx
   2cab3: ba 04 00 00 00               	movl	$4, %edx
; }
   2cab8: 5b                           	popq	%rbx
   2cab9: 5d                           	popq	%rbp
; 	return btf_add_enum_common(btf, name, byte_sz, false, BTF_KIND_ENUM);
   2caba: e9 51 f6 ff ff               	jmp	0x2c110 <btf_add_enum_common>
   2cabf: 90                           	nop
; 		id = btf_add_ref_kind(btf, BTF_KIND_FWD, name, 0);
   2cac0: 31 c9                        	xorl	%ecx, %ecx
   2cac2: 48 89 f2                     	movq	%rsi, %rdx
   2cac5: be 07 00 00 00               	movl	$7, %esi
   2caca: e8 b1 f4 ff ff               	callq	0x2bf80 <btf_add_ref_kind>
; 		if (id <= 0)
   2cacf: 85 c0                        	testl	%eax, %eax
   2cad1: 7f 11                        	jg	0x2cae4 <btf__add_fwd+0x64>
; }
   2cad3: 48 83 c4 08                  	addq	$8, %rsp
   2cad7: 5b                           	popq	%rbx
   2cad8: 5d                           	popq	%rbp
   2cad9: c3                           	retq
   2cada: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2cae0: 48 8b 6d 48                  	movq	72(%rbp), %rbp
; 	if (type_id < btf->start_id)
   2cae4: 8b 55 50                     	movl	80(%rbp), %edx
   2cae7: 39 d0                        	cmpl	%edx, %eax
   2cae9: 72 f5                        	jb	0x2cae0 <btf__add_fwd+0x60>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2caeb: 89 c1                        	movl	%eax, %ecx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2caed: c1 e3 1f                     	shll	$31, %ebx
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2caf0: 29 d1                        	subl	%edx, %ecx
   2caf2: 48 8b 55 30                  	movq	48(%rbp), %rdx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2caf6: 81 cb 00 00 00 07            	orl	$117440512, %ebx        # imm = 0x7000000
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2cafc: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
; 		t->info = btf_type_info(BTF_KIND_FWD, 0, fwd_kind == BTF_FWD_UNION);
   2caff: 48 8b 4d 20                  	movq	32(%rbp), %rcx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2cb03: 89 5c 11 04                  	movl	%ebx, 4(%rcx,%rdx)
; }
   2cb07: 48 83 c4 08                  	addq	$8, %rsp
   2cb0b: 5b                           	popq	%rbx
   2cb0c: 5d                           	popq	%rbp
   2cb0d: c3                           	retq
   2cb0e: 66 90                        	nop
; 		errno = -ret;
   2cb10: e8 db 8b fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2cb15: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   2cb1b: 48 83 c4 08                  	addq	$8, %rsp
; 		return libbpf_err(-EINVAL);
   2cb1f: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2cb24: 5b                           	popq	%rbx
   2cb25: 5d                           	popq	%rbp
   2cb26: c3                           	retq
   2cb27: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000002cb30 <btf__add_typedef>:
; {
   2cb30: f3 0f 1e fa                  	endbr64
; 	if (!name || !name[0])
   2cb34: 48 85 f6                     	testq	%rsi, %rsi
   2cb37: 74 17                        	je	0x2cb50 <btf__add_typedef+0x20>
   2cb39: 80 3e 00                     	cmpb	$0, (%rsi)
   2cb3c: 74 12                        	je	0x2cb50 <btf__add_typedef+0x20>
   2cb3e: 89 d1                        	movl	%edx, %ecx
; 	return btf_add_ref_kind(btf, BTF_KIND_TYPEDEF, name, ref_type_id);
   2cb40: 48 89 f2                     	movq	%rsi, %rdx
   2cb43: be 08 00 00 00               	movl	$8, %esi
   2cb48: e9 33 f4 ff ff               	jmp	0x2bf80 <btf_add_ref_kind>
   2cb4d: 0f 1f 00                     	nopl	(%rax)
; {
   2cb50: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   2cb54: e8 97 8b fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2cb59: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   2cb5f: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   2cb64: 48 83 c4 08                  	addq	$8, %rsp
   2cb68: c3                           	retq
   2cb69: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002cb70 <btf__add_volatile>:
; {
   2cb70: f3 0f 1e fa                  	endbr64
   2cb74: 89 f1                        	movl	%esi, %ecx
; 	return btf_add_ref_kind(btf, BTF_KIND_VOLATILE, NULL, ref_type_id);
   2cb76: 31 d2                        	xorl	%edx, %edx
   2cb78: be 09 00 00 00               	movl	$9, %esi
   2cb7d: e9 fe f3 ff ff               	jmp	0x2bf80 <btf_add_ref_kind>
   2cb82: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2cb8d: 0f 1f 00                     	nopl	(%rax)

000000000002cb90 <btf__add_const>:
; {
   2cb90: f3 0f 1e fa                  	endbr64
   2cb94: 89 f1                        	movl	%esi, %ecx
; 	return btf_add_ref_kind(btf, BTF_KIND_CONST, NULL, ref_type_id);
   2cb96: 31 d2                        	xorl	%edx, %edx
   2cb98: be 0a 00 00 00               	movl	$10, %esi
   2cb9d: e9 de f3 ff ff               	jmp	0x2bf80 <btf_add_ref_kind>
   2cba2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2cbad: 0f 1f 00                     	nopl	(%rax)

000000000002cbb0 <btf__add_restrict>:
; {
   2cbb0: f3 0f 1e fa                  	endbr64
   2cbb4: 89 f1                        	movl	%esi, %ecx
; 	return btf_add_ref_kind(btf, BTF_KIND_RESTRICT, NULL, ref_type_id);
   2cbb6: 31 d2                        	xorl	%edx, %edx
   2cbb8: be 0b 00 00 00               	movl	$11, %esi
   2cbbd: e9 be f3 ff ff               	jmp	0x2bf80 <btf_add_ref_kind>
   2cbc2: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2cbcd: 0f 1f 00                     	nopl	(%rax)

000000000002cbd0 <btf__add_type_tag>:
; {
   2cbd0: f3 0f 1e fa                  	endbr64
; 	if (!value|| !value[0])
   2cbd4: 48 85 f6                     	testq	%rsi, %rsi
   2cbd7: 74 17                        	je	0x2cbf0 <btf__add_type_tag+0x20>
   2cbd9: 80 3e 00                     	cmpb	$0, (%rsi)
   2cbdc: 74 12                        	je	0x2cbf0 <btf__add_type_tag+0x20>
   2cbde: 89 d1                        	movl	%edx, %ecx
; 	return btf_add_ref_kind(btf, BTF_KIND_TYPE_TAG, value, ref_type_id);
   2cbe0: 48 89 f2                     	movq	%rsi, %rdx
   2cbe3: be 12 00 00 00               	movl	$18, %esi
   2cbe8: e9 93 f3 ff ff               	jmp	0x2bf80 <btf_add_ref_kind>
   2cbed: 0f 1f 00                     	nopl	(%rax)
; {
   2cbf0: 48 83 ec 08                  	subq	$8, %rsp
; 		errno = -ret;
   2cbf4: e8 f7 8a fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2cbf9: c7 00 16 00 00 00            	movl	$22, (%rax)
; }
   2cbff: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   2cc04: 48 83 c4 08                  	addq	$8, %rsp
   2cc08: c3                           	retq
   2cc09: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002cc10 <btf__add_func>:
; {
   2cc10: f3 0f 1e fa                  	endbr64
   2cc14: 41 54                        	pushq	%r12
   2cc16: 55                           	pushq	%rbp
   2cc17: 53                           	pushq	%rbx
; 	if (!name || !name[0])
   2cc18: 48 85 f6                     	testq	%rsi, %rsi
   2cc1b: 74 71                        	je	0x2cc8e <btf__add_func+0x7e>
   2cc1d: 80 3e 00                     	cmpb	$0, (%rsi)
   2cc20: 74 6c                        	je	0x2cc8e <btf__add_func+0x7e>
   2cc22: 89 d5                        	movl	%edx, %ebp
; 	if (linkage != BTF_FUNC_STATIC && linkage != BTF_FUNC_GLOBAL &&
   2cc24: 83 fa 02                     	cmpl	$2, %edx
   2cc27: 77 65                        	ja	0x2cc8e <btf__add_func+0x7e>
; 	id = btf_add_ref_kind(btf, BTF_KIND_FUNC, name, proto_type_id);
   2cc29: 48 89 f2                     	movq	%rsi, %rdx
   2cc2c: be 0c 00 00 00               	movl	$12, %esi
   2cc31: 48 89 fb                     	movq	%rdi, %rbx
   2cc34: e8 47 f3 ff ff               	callq	0x2bf80 <btf_add_ref_kind>
   2cc39: 41 89 c4                     	movl	%eax, %r12d
; 	if (id > 0) {
   2cc3c: 85 c0                        	testl	%eax, %eax
   2cc3e: 7f 24                        	jg	0x2cc64 <btf__add_func+0x54>
; 	if (ret < 0)
   2cc40: 74 0c                        	je	0x2cc4e <btf__add_func+0x3e>
; 		errno = -ret;
   2cc42: e8 a9 8a fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2cc47: 44 89 e2                     	movl	%r12d, %edx
   2cc4a: f7 da                        	negl	%edx
   2cc4c: 89 10                        	movl	%edx, (%rax)
; }
   2cc4e: 44 89 e0                     	movl	%r12d, %eax
   2cc51: 5b                           	popq	%rbx
   2cc52: 5d                           	popq	%rbp
   2cc53: 41 5c                        	popq	%r12
   2cc55: c3                           	retq
   2cc56: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2cc60: 48 8b 5b 48                  	movq	72(%rbx), %rbx
; 	if (type_id < btf->start_id)
   2cc64: 8b 43 50                     	movl	80(%rbx), %eax
   2cc67: 41 39 c4                     	cmpl	%eax, %r12d
   2cc6a: 72 f4                        	jb	0x2cc60 <btf__add_func+0x50>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2cc6c: 44 89 e2                     	movl	%r12d, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2cc6f: 81 cd 00 00 00 0c            	orl	$201326592, %ebp        # imm = 0xC000000
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2cc75: 29 c2                        	subl	%eax, %edx
   2cc77: 48 8b 43 30                  	movq	48(%rbx), %rax
   2cc7b: 8b 04 90                     	movl	(%rax,%rdx,4), %eax
; 		t->info = btf_type_info(BTF_KIND_FUNC, linkage, 0);
   2cc7e: 48 8b 53 20                  	movq	32(%rbx), %rdx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2cc82: 89 6c 02 04                  	movl	%ebp, 4(%rdx,%rax)
; }
   2cc86: 44 89 e0                     	movl	%r12d, %eax
   2cc89: 5b                           	popq	%rbx
   2cc8a: 5d                           	popq	%rbp
   2cc8b: 41 5c                        	popq	%r12
   2cc8d: c3                           	retq
; 		errno = -ret;
   2cc8e: e8 5d 8a fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   2cc93: 41 bc ea ff ff ff            	movl	$4294967274, %r12d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   2cc99: c7 00 16 00 00 00            	movl	$22, (%rax)
   2cc9f: eb ad                        	jmp	0x2cc4e <btf__add_func+0x3e>
   2cca1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2ccac: 0f 1f 40 00                  	nopl	(%rax)

000000000002ccb0 <btf__add_func_proto>:
; {
   2ccb0: f3 0f 1e fa                  	endbr64
   2ccb4: 55                           	pushq	%rbp
   2ccb5: 53                           	pushq	%rbx
   2ccb6: 48 83 ec 08                  	subq	$8, %rsp
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2ccba: 85 f6                        	testl	%esi, %esi
   2ccbc: 78 79                        	js	0x2cd37 <btf__add_func_proto+0x87>
   2ccbe: 48 89 fd                     	movq	%rdi, %rbp
   2ccc1: 89 f3                        	movl	%esi, %ebx
; 	if (btf_ensure_modifiable(btf))
   2ccc3: e8 d8 c6 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2ccc8: 85 c0                        	testl	%eax, %eax
   2ccca: 75 54                        	jne	0x2cd20 <btf__add_func_proto+0x70>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2cccc: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2ccd0: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2ccd4: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2ccd8: 41 b9 0c 00 00 00            	movl	$12, %r9d
   2ccde: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2cce4: ba 01 00 00 00               	movl	$1, %edx
   2cce9: 8b 48 0c                     	movl	12(%rax), %ecx
   2ccec: e8 af d0 ff ff               	callq	0x29da0 <libbpf_add_mem>
; 	if (!t)
   2ccf1: 48 85 c0                     	testq	%rax, %rax
   2ccf4: 74 2a                        	je	0x2cd20 <btf__add_func_proto+0x70>
; 	t->name_off = 0;
   2ccf6: 48 ba 00 00 00 00 00 00 00 0d	movabsq	$936748722493063168, %rdx # imm = 0xD00000000000000
; 	t->type = ret_type_id;
   2cd00: 89 58 08                     	movl	%ebx, 8(%rax)
; 	return btf_commit_type(btf, sz);
   2cd03: 48 89 ef                     	movq	%rbp, %rdi
   2cd06: be 0c 00 00 00               	movl	$12, %esi
; 	t->name_off = 0;
   2cd0b: 48 89 10                     	movq	%rdx, (%rax)
; }
   2cd0e: 48 83 c4 08                  	addq	$8, %rsp
   2cd12: 5b                           	popq	%rbx
   2cd13: 5d                           	popq	%rbp
; 	return btf_commit_type(btf, sz);
   2cd14: e9 67 c9 ff ff               	jmp	0x29680 <btf_commit_type>
   2cd19: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -ret;
   2cd20: e8 cb 89 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2cd25: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2cd2b: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
; }
   2cd30: 48 83 c4 08                  	addq	$8, %rsp
   2cd34: 5b                           	popq	%rbx
   2cd35: 5d                           	popq	%rbp
   2cd36: c3                           	retq
; 		errno = -ret;
   2cd37: e8 b4 89 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2cd3c: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2cd42: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   2cd47: eb e7                        	jmp	0x2cd30 <btf__add_func_proto+0x80>
   2cd49: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002cd50 <btf__add_func_param>:
; {
   2cd50: f3 0f 1e fa                  	endbr64
   2cd54: 41 56                        	pushq	%r14
   2cd56: 41 55                        	pushq	%r13
   2cd58: 41 54                        	pushq	%r12
   2cd5a: 55                           	pushq	%rbp
   2cd5b: 53                           	pushq	%rbx
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2cd5c: 85 d2                        	testl	%edx, %edx
   2cd5e: 0f 88 2c 01 00 00            	js	0x2ce90 <btf__add_func_param+0x140>
; 	if (btf->nr_types == 0)
   2cd64: 8b 47 40                     	movl	64(%rdi), %eax
   2cd67: 48 89 fb                     	movq	%rdi, %rbx
   2cd6a: 85 c0                        	testl	%eax, %eax
   2cd6c: 0f 84 1e 01 00 00            	je	0x2ce90 <btf__add_func_param+0x140>
   2cd72: 41 89 d4                     	movl	%edx, %r12d
; 	return btf->start_id + btf->nr_types;
   2cd75: 8b 57 50                     	movl	80(%rdi), %edx
   2cd78: 48 89 f5                     	movq	%rsi, %rbp
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2cd7b: 8d 4c 10 ff                  	leal	-1(%rax,%rdx), %ecx
; 		return &btf_void;
   2cd7f: 48 8d 05 0a a5 01 00         	leaq	107786(%rip), %rax      # 0x47290 <btf_void>
; 	if (type_id == 0)
   2cd86: 85 c9                        	testl	%ecx, %ecx
   2cd88: 74 21                        	je	0x2cdab <btf__add_func_param+0x5b>
   2cd8a: 48 89 f8                     	movq	%rdi, %rax
   2cd8d: eb 08                        	jmp	0x2cd97 <btf__add_func_param+0x47>
   2cd8f: 90                           	nop
; 		return btf_type_by_id(btf->base_btf, type_id);
   2cd90: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2cd94: 8b 50 50                     	movl	80(%rax), %edx
   2cd97: 39 d1                        	cmpl	%edx, %ecx
   2cd99: 72 f5                        	jb	0x2cd90 <btf__add_func_param+0x40>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2cd9b: 29 d1                        	subl	%edx, %ecx
   2cd9d: 48 8b 50 30                  	movq	48(%rax), %rdx
   2cda1: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2cda4: 48 03 50 20                  	addq	32(%rax), %rdx
   2cda8: 48 89 d0                     	movq	%rdx, %rax
; 	return BTF_INFO_KIND(t->info);
   2cdab: 0f b6 40 07                  	movzbl	7(%rax), %eax
   2cdaf: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_func_proto(t))
   2cdb2: 66 83 f8 0d                  	cmpw	$13, %ax
   2cdb6: 0f 85 d4 00 00 00            	jne	0x2ce90 <btf__add_func_param+0x140>
; 	if (btf_ensure_modifiable(btf))
   2cdbc: 48 89 df                     	movq	%rbx, %rdi
   2cdbf: e8 dc c5 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2cdc4: 41 89 c5                     	movl	%eax, %r13d
   2cdc7: 85 c0                        	testl	%eax, %eax
   2cdc9: 0f 85 d4 00 00 00            	jne	0x2cea3 <btf__add_func_param+0x153>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2cdcf: 48 8b 43 18                  	movq	24(%rbx), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2cdd3: 48 8d 73 28                  	leaq	40(%rbx), %rsi
   2cdd7: 48 8d 7b 20                  	leaq	32(%rbx), %rdi
   2cddb: 41 b9 08 00 00 00            	movl	$8, %r9d
   2cde1: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2cde7: ba 01 00 00 00               	movl	$1, %edx
   2cdec: 8b 48 0c                     	movl	12(%rax), %ecx
   2cdef: e8 ac cf ff ff               	callq	0x29da0 <libbpf_add_mem>
   2cdf4: 49 89 c6                     	movq	%rax, %r14
; 	if (!p)
   2cdf7: 48 85 c0                     	testq	%rax, %rax
   2cdfa: 0f 84 a3 00 00 00            	je	0x2cea3 <btf__add_func_param+0x153>
; 	if (name && name[0]) {
   2ce00: 31 c0                        	xorl	%eax, %eax
   2ce02: 48 85 ed                     	testq	%rbp, %rbp
   2ce05: 74 06                        	je	0x2ce0d <btf__add_func_param+0xbd>
   2ce07: 80 7d 00 00                  	cmpb	$0, (%rbp)
   2ce0b: 75 6b                        	jne	0x2ce78 <btf__add_func_param+0x128>
; 	p->name_off = name_off;
   2ce0d: 41 89 06                     	movl	%eax, (%r14)
; 	return btf->start_id + btf->nr_types;
   2ce10: 8b 53 50                     	movl	80(%rbx), %edx
; 		return &btf_void;
   2ce13: 48 8d 35 76 a4 01 00         	leaq	107638(%rip), %rsi      # 0x47290 <btf_void>
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2ce1a: 8b 43 40                     	movl	64(%rbx), %eax
; 	p->type = type_id;
   2ce1d: 45 89 66 04                  	movl	%r12d, 4(%r14)
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2ce21: 8d 4c 02 ff                  	leal	-1(%rdx,%rax), %ecx
; 	if (type_id == 0)
   2ce25: 85 c9                        	testl	%ecx, %ecx
   2ce27: 74 1f                        	je	0x2ce48 <btf__add_func_param+0xf8>
   2ce29: 48 89 d8                     	movq	%rbx, %rax
   2ce2c: eb 09                        	jmp	0x2ce37 <btf__add_func_param+0xe7>
   2ce2e: 66 90                        	nop
; 		return btf_type_by_id(btf->base_btf, type_id);
   2ce30: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2ce34: 8b 50 50                     	movl	80(%rax), %edx
   2ce37: 39 d1                        	cmpl	%edx, %ecx
   2ce39: 72 f5                        	jb	0x2ce30 <btf__add_func_param+0xe0>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2ce3b: 29 d1                        	subl	%edx, %ecx
   2ce3d: 48 8b 50 30                  	movq	48(%rax), %rdx
   2ce41: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2ce44: 48 03 70 20                  	addq	32(%rax), %rsi
; 	return BTF_INFO_KFLAG(t->info);
   2ce48: 8b 46 04                     	movl	4(%rsi), %eax
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2ce4b: 0f b7 d0                     	movzwl	%ax, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2ce4e: 25 00 00 00 9f               	andl	$2667577344, %eax       # imm = 0x9F000000
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2ce53: 83 c2 01                     	addl	$1, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2ce56: 09 d0                        	orl	%edx, %eax
   2ce58: 89 46 04                     	movl	%eax, 4(%rsi)
; 	btf->hdr->type_len += sz;
   2ce5b: 48 8b 43 18                  	movq	24(%rbx), %rax
   2ce5f: 83 40 0c 08                  	addl	$8, 12(%rax)
; 	btf->hdr->str_off += sz;
   2ce63: 83 40 10 08                  	addl	$8, 16(%rax)
; }
   2ce67: 5b                           	popq	%rbx
   2ce68: 44 89 e8                     	movl	%r13d, %eax
   2ce6b: 5d                           	popq	%rbp
   2ce6c: 41 5c                        	popq	%r12
   2ce6e: 41 5d                        	popq	%r13
   2ce70: 41 5e                        	popq	%r14
   2ce72: c3                           	retq
   2ce73: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		name_off = btf__add_str(btf, name);
   2ce78: 48 89 ee                     	movq	%rbp, %rsi
   2ce7b: 48 89 df                     	movq	%rbx, %rdi
   2ce7e: e8 9d ef ff ff               	callq	0x2be20 <btf__add_str>
; 		if (name_off < 0)
   2ce83: 85 c0                        	testl	%eax, %eax
   2ce85: 0f 89 82 ff ff ff            	jns	0x2ce0d <btf__add_func_param+0xbd>
   2ce8b: 41 89 c5                     	movl	%eax, %r13d
   2ce8e: eb d7                        	jmp	0x2ce67 <btf__add_func_param+0x117>
; 		errno = -ret;
   2ce90: e8 5b 88 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   2ce95: 41 bd ea ff ff ff            	movl	$4294967274, %r13d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   2ce9b: c7 00 16 00 00 00            	movl	$22, (%rax)
   2cea1: eb c4                        	jmp	0x2ce67 <btf__add_func_param+0x117>
   2cea3: e8 48 88 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOMEM);
   2cea8: 41 bd f4 ff ff ff            	movl	$4294967284, %r13d      # imm = 0xFFFFFFF4
; 		errno = -ret;
   2ceae: c7 00 0c 00 00 00            	movl	$12, (%rax)
   2ceb4: eb b1                        	jmp	0x2ce67 <btf__add_func_param+0x117>
   2ceb6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000002cec0 <btf__add_var>:
; {
   2cec0: f3 0f 1e fa                  	endbr64
   2cec4: 41 56                        	pushq	%r14
   2cec6: 41 55                        	pushq	%r13
   2cec8: 41 54                        	pushq	%r12
   2ceca: 55                           	pushq	%rbp
   2cecb: 53                           	pushq	%rbx
; 	if (!name || !name[0])
   2cecc: 48 85 f6                     	testq	%rsi, %rsi
   2cecf: 0f 84 93 00 00 00            	je	0x2cf68 <btf__add_var+0xa8>
   2ced5: 80 3e 00                     	cmpb	$0, (%rsi)
   2ced8: 49 89 f4                     	movq	%rsi, %r12
   2cedb: 0f 84 87 00 00 00            	je	0x2cf68 <btf__add_var+0xa8>
   2cee1: 41 89 d5                     	movl	%edx, %r13d
; 	if (linkage != BTF_VAR_STATIC && linkage != BTF_VAR_GLOBAL_ALLOCATED &&
   2cee4: 83 fa 02                     	cmpl	$2, %edx
   2cee7: 77 7f                        	ja	0x2cf68 <btf__add_var+0xa8>
   2cee9: 41 89 ce                     	movl	%ecx, %r14d
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2ceec: 85 c9                        	testl	%ecx, %ecx
   2ceee: 78 78                        	js	0x2cf68 <btf__add_var+0xa8>
   2cef0: 48 89 fd                     	movq	%rdi, %rbp
; 	if (btf_ensure_modifiable(btf))
   2cef3: e8 a8 c4 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2cef8: 85 c0                        	testl	%eax, %eax
   2cefa: 0f 85 88 00 00 00            	jne	0x2cf88 <btf__add_var+0xc8>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2cf00: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2cf04: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2cf08: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2cf0c: 41 b9 10 00 00 00            	movl	$16, %r9d
   2cf12: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2cf18: ba 01 00 00 00               	movl	$1, %edx
   2cf1d: 8b 48 0c                     	movl	12(%rax), %ecx
   2cf20: e8 7b ce ff ff               	callq	0x29da0 <libbpf_add_mem>
   2cf25: 48 89 c3                     	movq	%rax, %rbx
; 	if (!t)
   2cf28: 48 85 c0                     	testq	%rax, %rax
   2cf2b: 74 5b                        	je	0x2cf88 <btf__add_var+0xc8>
; 	name_off = btf__add_str(btf, name);
   2cf2d: 4c 89 e6                     	movq	%r12, %rsi
   2cf30: 48 89 ef                     	movq	%rbp, %rdi
   2cf33: e8 e8 ee ff ff               	callq	0x2be20 <btf__add_str>
; 	if (name_off < 0)
   2cf38: 85 c0                        	testl	%eax, %eax
   2cf3a: 78 3c                        	js	0x2cf78 <btf__add_var+0xb8>
; 	t->name_off = name_off;
   2cf3c: 89 03                        	movl	%eax, (%rbx)
; 	return btf_commit_type(btf, sz);
   2cf3e: 48 89 ef                     	movq	%rbp, %rdi
   2cf41: be 10 00 00 00               	movl	$16, %esi
; 	t->info = btf_type_info(BTF_KIND_VAR, 0, 0);
   2cf46: c7 43 04 00 00 00 0e         	movl	$234881024, 4(%rbx)     # imm = 0xE000000
; 	t->type = type_id;
   2cf4d: 44 89 73 08                  	movl	%r14d, 8(%rbx)
; 	v->linkage = linkage;
   2cf51: 44 89 6b 0c                  	movl	%r13d, 12(%rbx)
; }
   2cf55: 5b                           	popq	%rbx
   2cf56: 5d                           	popq	%rbp
   2cf57: 41 5c                        	popq	%r12
   2cf59: 41 5d                        	popq	%r13
   2cf5b: 41 5e                        	popq	%r14
; 	return btf_commit_type(btf, sz);
   2cf5d: e9 1e c7 ff ff               	jmp	0x29680 <btf_commit_type>
   2cf62: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -ret;
   2cf68: e8 83 87 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2cf6d: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2cf73: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2cf78: 5b                           	popq	%rbx
   2cf79: 5d                           	popq	%rbp
   2cf7a: 41 5c                        	popq	%r12
   2cf7c: 41 5d                        	popq	%r13
   2cf7e: 41 5e                        	popq	%r14
   2cf80: c3                           	retq
   2cf81: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -ret;
   2cf88: e8 63 87 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2cf8d: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2cf93: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2cf98: eb de                        	jmp	0x2cf78 <btf__add_var+0xb8>
   2cf9a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000002cfa0 <btf__add_datasec>:
; {
   2cfa0: f3 0f 1e fa                  	endbr64
   2cfa4: 41 55                        	pushq	%r13
   2cfa6: 41 54                        	pushq	%r12
   2cfa8: 55                           	pushq	%rbp
   2cfa9: 53                           	pushq	%rbx
   2cfaa: 48 83 ec 08                  	subq	$8, %rsp
; 	if (!name || !name[0])
   2cfae: 48 85 f6                     	testq	%rsi, %rsi
   2cfb1: 74 7d                        	je	0x2d030 <btf__add_datasec+0x90>
   2cfb3: 80 3e 00                     	cmpb	$0, (%rsi)
   2cfb6: 49 89 f4                     	movq	%rsi, %r12
   2cfb9: 74 75                        	je	0x2d030 <btf__add_datasec+0x90>
   2cfbb: 48 89 fd                     	movq	%rdi, %rbp
   2cfbe: 41 89 d5                     	movl	%edx, %r13d
; 	if (btf_ensure_modifiable(btf))
   2cfc1: e8 da c3 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2cfc6: 85 c0                        	testl	%eax, %eax
   2cfc8: 0f 85 82 00 00 00            	jne	0x2d050 <btf__add_datasec+0xb0>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2cfce: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2cfd2: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2cfd6: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2cfda: 41 b9 0c 00 00 00            	movl	$12, %r9d
   2cfe0: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2cfe6: ba 01 00 00 00               	movl	$1, %edx
   2cfeb: 8b 48 0c                     	movl	12(%rax), %ecx
   2cfee: e8 ad cd ff ff               	callq	0x29da0 <libbpf_add_mem>
   2cff3: 48 89 c3                     	movq	%rax, %rbx
; 	if (!t)
   2cff6: 48 85 c0                     	testq	%rax, %rax
   2cff9: 74 55                        	je	0x2d050 <btf__add_datasec+0xb0>
; 	name_off = btf__add_str(btf, name);
   2cffb: 4c 89 e6                     	movq	%r12, %rsi
   2cffe: 48 89 ef                     	movq	%rbp, %rdi
   2d001: e8 1a ee ff ff               	callq	0x2be20 <btf__add_str>
; 	if (name_off < 0)
   2d006: 85 c0                        	testl	%eax, %eax
   2d008: 78 36                        	js	0x2d040 <btf__add_datasec+0xa0>
; 	t->name_off = name_off;
   2d00a: 89 03                        	movl	%eax, (%rbx)
; 	return btf_commit_type(btf, sz);
   2d00c: 48 89 ef                     	movq	%rbp, %rdi
   2d00f: be 0c 00 00 00               	movl	$12, %esi
; 	t->info = btf_type_info(BTF_KIND_DATASEC, 0, 0);
   2d014: c7 43 04 00 00 00 0f         	movl	$251658240, 4(%rbx)     # imm = 0xF000000
; 	t->size = byte_sz;
   2d01b: 44 89 6b 08                  	movl	%r13d, 8(%rbx)
; }
   2d01f: 48 83 c4 08                  	addq	$8, %rsp
   2d023: 5b                           	popq	%rbx
   2d024: 5d                           	popq	%rbp
   2d025: 41 5c                        	popq	%r12
   2d027: 41 5d                        	popq	%r13
; 	return btf_commit_type(btf, sz);
   2d029: e9 52 c6 ff ff               	jmp	0x29680 <btf_commit_type>
   2d02e: 66 90                        	nop
; 		errno = -ret;
   2d030: e8 bb 86 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2d035: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2d03b: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2d040: 48 83 c4 08                  	addq	$8, %rsp
   2d044: 5b                           	popq	%rbx
   2d045: 5d                           	popq	%rbp
   2d046: 41 5c                        	popq	%r12
   2d048: 41 5d                        	popq	%r13
   2d04a: c3                           	retq
   2d04b: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		errno = -ret;
   2d050: e8 9b 86 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2d055: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2d05b: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2d060: eb de                        	jmp	0x2d040 <btf__add_datasec+0xa0>
   2d062: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2d06d: 0f 1f 00                     	nopl	(%rax)

000000000002d070 <btf__add_datasec_var_info>:
; {
   2d070: f3 0f 1e fa                  	endbr64
   2d074: 41 56                        	pushq	%r14
   2d076: 41 55                        	pushq	%r13
   2d078: 41 54                        	pushq	%r12
   2d07a: 55                           	pushq	%rbp
   2d07b: 53                           	pushq	%rbx
; 	if (btf->nr_types == 0)
   2d07c: 8b 47 40                     	movl	64(%rdi), %eax
   2d07f: 85 c0                        	testl	%eax, %eax
   2d081: 0f 84 04 01 00 00            	je	0x2d18b <btf__add_datasec_var_info+0x11b>
   2d087: 41 89 d5                     	movl	%edx, %r13d
; 	return btf->start_id + btf->nr_types;
   2d08a: 8b 57 50                     	movl	80(%rdi), %edx
   2d08d: 41 89 cc                     	movl	%ecx, %r12d
   2d090: 48 89 fb                     	movq	%rdi, %rbx
   2d093: 89 f5                        	movl	%esi, %ebp
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2d095: 8d 4c 10 ff                  	leal	-1(%rax,%rdx), %ecx
; 		return &btf_void;
   2d099: 48 8d 05 f0 a1 01 00         	leaq	106992(%rip), %rax      # 0x47290 <btf_void>
; 	if (type_id == 0)
   2d0a0: 85 c9                        	testl	%ecx, %ecx
   2d0a2: 74 27                        	je	0x2d0cb <btf__add_datasec_var_info+0x5b>
   2d0a4: 48 89 f8                     	movq	%rdi, %rax
   2d0a7: eb 0e                        	jmp	0x2d0b7 <btf__add_datasec_var_info+0x47>
   2d0a9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2d0b0: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2d0b4: 8b 50 50                     	movl	80(%rax), %edx
   2d0b7: 39 d1                        	cmpl	%edx, %ecx
   2d0b9: 72 f5                        	jb	0x2d0b0 <btf__add_datasec_var_info+0x40>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2d0bb: 29 d1                        	subl	%edx, %ecx
   2d0bd: 48 8b 50 30                  	movq	48(%rax), %rdx
   2d0c1: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2d0c4: 48 03 50 20                  	addq	32(%rax), %rdx
   2d0c8: 48 89 d0                     	movq	%rdx, %rax
; 	return BTF_INFO_KIND(t->info);
   2d0cb: 0f b6 40 07                  	movzbl	7(%rax), %eax
   2d0cf: 83 e0 1f                     	andl	$31, %eax
; 	if (!btf_is_datasec(t))
   2d0d2: 66 83 f8 0f                  	cmpw	$15, %ax
   2d0d6: 0f 85 af 00 00 00            	jne	0x2d18b <btf__add_datasec_var_info+0x11b>
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2d0dc: 85 ed                        	testl	%ebp, %ebp
   2d0de: 0f 88 a7 00 00 00            	js	0x2d18b <btf__add_datasec_var_info+0x11b>
; 	if (btf_ensure_modifiable(btf))
   2d0e4: 48 89 df                     	movq	%rbx, %rdi
   2d0e7: e8 b4 c2 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2d0ec: 41 89 c6                     	movl	%eax, %r14d
   2d0ef: 85 c0                        	testl	%eax, %eax
   2d0f1: 0f 85 a7 00 00 00            	jne	0x2d19e <btf__add_datasec_var_info+0x12e>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2d0f7: 48 8b 43 18                  	movq	24(%rbx), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2d0fb: 48 8d 73 28                  	leaq	40(%rbx), %rsi
   2d0ff: 48 8d 7b 20                  	leaq	32(%rbx), %rdi
   2d103: 41 b9 0c 00 00 00            	movl	$12, %r9d
   2d109: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2d10f: ba 01 00 00 00               	movl	$1, %edx
   2d114: 8b 48 0c                     	movl	12(%rax), %ecx
   2d117: e8 84 cc ff ff               	callq	0x29da0 <libbpf_add_mem>
; 	if (!v)
   2d11c: 48 85 c0                     	testq	%rax, %rax
   2d11f: 74 7d                        	je	0x2d19e <btf__add_datasec_var_info+0x12e>
; 	v->type = var_type_id;
   2d121: 89 28                        	movl	%ebp, (%rax)
; 	return btf->start_id + btf->nr_types;
   2d123: 8b 53 50                     	movl	80(%rbx), %edx
; 		return &btf_void;
   2d126: 48 8d 35 63 a1 01 00         	leaq	106851(%rip), %rsi      # 0x47290 <btf_void>
; 	v->offset = offset;
   2d12d: 44 89 68 04                  	movl	%r13d, 4(%rax)
; 	v->size = byte_sz;
   2d131: 44 89 60 08                  	movl	%r12d, 8(%rax)
; 	return btf_type_by_id(btf, btf__type_cnt(btf) - 1);
   2d135: 8b 43 40                     	movl	64(%rbx), %eax
   2d138: 8d 4c 02 ff                  	leal	-1(%rdx,%rax), %ecx
; 	if (type_id == 0)
   2d13c: 85 c9                        	testl	%ecx, %ecx
   2d13e: 74 20                        	je	0x2d160 <btf__add_datasec_var_info+0xf0>
   2d140: 48 89 d8                     	movq	%rbx, %rax
   2d143: eb 0a                        	jmp	0x2d14f <btf__add_datasec_var_info+0xdf>
   2d145: 0f 1f 00                     	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2d148: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2d14c: 8b 50 50                     	movl	80(%rax), %edx
   2d14f: 39 d1                        	cmpl	%edx, %ecx
   2d151: 72 f5                        	jb	0x2d148 <btf__add_datasec_var_info+0xd8>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2d153: 29 d1                        	subl	%edx, %ecx
   2d155: 48 8b 50 30                  	movq	48(%rax), %rdx
   2d159: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2d15c: 48 03 70 20                  	addq	32(%rax), %rsi
; 	return BTF_INFO_KFLAG(t->info);
   2d160: 8b 46 04                     	movl	4(%rsi), %eax
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2d163: 0f b7 d0                     	movzwl	%ax, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2d166: 25 00 00 00 9f               	andl	$2667577344, %eax       # imm = 0x9F000000
; 	t->info = btf_type_info(btf_kind(t), btf_vlen(t) + 1, btf_kflag(t));
   2d16b: 83 c2 01                     	addl	$1, %edx
; 	return (kflag << 31) | (kind << 24) | vlen;
   2d16e: 09 d0                        	orl	%edx, %eax
   2d170: 89 46 04                     	movl	%eax, 4(%rsi)
; 	btf->hdr->type_len += sz;
   2d173: 48 8b 43 18                  	movq	24(%rbx), %rax
   2d177: 83 40 0c 0c                  	addl	$12, 12(%rax)
; 	btf->hdr->str_off += sz;
   2d17b: 83 40 10 0c                  	addl	$12, 16(%rax)
; }
   2d17f: 5b                           	popq	%rbx
   2d180: 44 89 f0                     	movl	%r14d, %eax
   2d183: 5d                           	popq	%rbp
   2d184: 41 5c                        	popq	%r12
   2d186: 41 5d                        	popq	%r13
   2d188: 41 5e                        	popq	%r14
   2d18a: c3                           	retq
; 		errno = -ret;
   2d18b: e8 60 85 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   2d190: 41 be ea ff ff ff            	movl	$4294967274, %r14d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   2d196: c7 00 16 00 00 00            	movl	$22, (%rax)
   2d19c: eb e1                        	jmp	0x2d17f <btf__add_datasec_var_info+0x10f>
   2d19e: e8 4d 85 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOMEM);
   2d1a3: 41 be f4 ff ff ff            	movl	$4294967284, %r14d      # imm = 0xFFFFFFF4
; 		errno = -ret;
   2d1a9: c7 00 0c 00 00 00            	movl	$12, (%rax)
   2d1af: eb ce                        	jmp	0x2d17f <btf__add_datasec_var_info+0x10f>
   2d1b1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2d1bc: 0f 1f 40 00                  	nopl	(%rax)

000000000002d1c0 <btf__add_decl_tag>:
; {
   2d1c0: f3 0f 1e fa                  	endbr64
   2d1c4: 41 56                        	pushq	%r14
   2d1c6: 41 55                        	pushq	%r13
   2d1c8: 41 54                        	pushq	%r12
   2d1ca: 55                           	pushq	%rbp
   2d1cb: 53                           	pushq	%rbx
; 	if (!value || !value[0] || component_idx < -1)
   2d1cc: 48 85 f6                     	testq	%rsi, %rsi
   2d1cf: 0f 84 93 00 00 00            	je	0x2d268 <btf__add_decl_tag+0xa8>
   2d1d5: 80 3e 00                     	cmpb	$0, (%rsi)
   2d1d8: 49 89 f4                     	movq	%rsi, %r12
   2d1db: 0f 84 87 00 00 00            	je	0x2d268 <btf__add_decl_tag+0xa8>
   2d1e1: 41 89 cd                     	movl	%ecx, %r13d
   2d1e4: 83 f9 ff                     	cmpl	$-1, %ecx
   2d1e7: 7c 7f                        	jl	0x2d268 <btf__add_decl_tag+0xa8>
   2d1e9: 41 89 d6                     	movl	%edx, %r14d
; 	if (id < 0 || id > BTF_MAX_NR_TYPES)
   2d1ec: 85 d2                        	testl	%edx, %edx
   2d1ee: 78 78                        	js	0x2d268 <btf__add_decl_tag+0xa8>
   2d1f0: 48 89 fd                     	movq	%rdi, %rbp
; 	if (btf_ensure_modifiable(btf))
   2d1f3: e8 a8 c1 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2d1f8: 85 c0                        	testl	%eax, %eax
   2d1fa: 0f 85 88 00 00 00            	jne	0x2d288 <btf__add_decl_tag+0xc8>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2d200: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2d204: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2d208: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2d20c: 41 b9 10 00 00 00            	movl	$16, %r9d
   2d212: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2d218: ba 01 00 00 00               	movl	$1, %edx
   2d21d: 8b 48 0c                     	movl	12(%rax), %ecx
   2d220: e8 7b cb ff ff               	callq	0x29da0 <libbpf_add_mem>
   2d225: 48 89 c3                     	movq	%rax, %rbx
; 	if (!t)
   2d228: 48 85 c0                     	testq	%rax, %rax
   2d22b: 74 5b                        	je	0x2d288 <btf__add_decl_tag+0xc8>
; 	value_off = btf__add_str(btf, value);
   2d22d: 4c 89 e6                     	movq	%r12, %rsi
   2d230: 48 89 ef                     	movq	%rbp, %rdi
   2d233: e8 e8 eb ff ff               	callq	0x2be20 <btf__add_str>
; 	if (value_off < 0)
   2d238: 85 c0                        	testl	%eax, %eax
   2d23a: 78 3c                        	js	0x2d278 <btf__add_decl_tag+0xb8>
; 	t->name_off = value_off;
   2d23c: 89 03                        	movl	%eax, (%rbx)
; 	return btf_commit_type(btf, sz);
   2d23e: 48 89 ef                     	movq	%rbp, %rdi
   2d241: be 10 00 00 00               	movl	$16, %esi
; 	t->info = btf_type_info(BTF_KIND_DECL_TAG, 0, false);
   2d246: c7 43 04 00 00 00 11         	movl	$285212672, 4(%rbx)     # imm = 0x11000000
; 	t->type = ref_type_id;
   2d24d: 44 89 73 08                  	movl	%r14d, 8(%rbx)
; 	btf_decl_tag(t)->component_idx = component_idx;
   2d251: 44 89 6b 0c                  	movl	%r13d, 12(%rbx)
; }
   2d255: 5b                           	popq	%rbx
   2d256: 5d                           	popq	%rbp
   2d257: 41 5c                        	popq	%r12
   2d259: 41 5d                        	popq	%r13
   2d25b: 41 5e                        	popq	%r14
; 	return btf_commit_type(btf, sz);
   2d25d: e9 1e c4 ff ff               	jmp	0x29680 <btf_commit_type>
   2d262: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -ret;
   2d268: e8 83 84 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2d26d: c7 00 16 00 00 00            	movl	$22, (%rax)
; 		return libbpf_err(-EINVAL);
   2d273: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
; }
   2d278: 5b                           	popq	%rbx
   2d279: 5d                           	popq	%rbp
   2d27a: 41 5c                        	popq	%r12
   2d27c: 41 5d                        	popq	%r13
   2d27e: 41 5e                        	popq	%r14
   2d280: c3                           	retq
   2d281: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		errno = -ret;
   2d288: e8 63 84 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2d28d: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err(-ENOMEM);
   2d293: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2d298: eb de                        	jmp	0x2d278 <btf__add_decl_tag+0xb8>
   2d29a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000002d2a0 <btf_ext__free>:
; {
   2d2a0: f3 0f 1e fa                  	endbr64
; 	if (IS_ERR_OR_NULL(btf_ext))
   2d2a4: 48 85 ff                     	testq	%rdi, %rdi
   2d2a7: 74 47                        	je	0x2d2f0 <btf_ext__free+0x50>
; {
   2d2a9: 55                           	pushq	%rbp
   2d2aa: 48 89 fd                     	movq	%rdi, %rbp
; 	if (IS_ERR_OR_NULL(btf_ext))
   2d2ad: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   2d2b4: 77 32                        	ja	0x2d2e8 <btf_ext__free+0x48>
; 	free(btf_ext->func_info.sec_idxs);
   2d2b6: 48 8b 7f 18                  	movq	24(%rdi), %rdi
   2d2ba: e8 01 84 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(btf_ext->line_info.sec_idxs);
   2d2bf: 48 8b 7d 38                  	movq	56(%rbp), %rdi
   2d2c3: e8 f8 83 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(btf_ext->core_relo_info.sec_idxs);
   2d2c8: 48 8b 7d 58                  	movq	88(%rbp), %rdi
   2d2cc: e8 ef 83 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(btf_ext->data);
   2d2d1: 48 8b 7d 00                  	movq	(%rbp), %rdi
   2d2d5: e8 e6 83 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(btf_ext);
   2d2da: 48 89 ef                     	movq	%rbp, %rdi
; }
   2d2dd: 5d                           	popq	%rbp
; 	free(btf_ext);
   2d2de: e9 dd 83 fd ff               	jmp	0x56c0 <.plt.sec+0x50>
   2d2e3: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; }
   2d2e8: 5d                           	popq	%rbp
   2d2e9: c3                           	retq
   2d2ea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2d2f0: c3                           	retq
   2d2f1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2d2fc: 0f 1f 40 00                  	nopl	(%rax)

000000000002d300 <btf_ext__new>:
; {
   2d300: f3 0f 1e fa                  	endbr64
   2d304: 41 55                        	pushq	%r13
   2d306: 41 54                        	pushq	%r12
   2d308: 55                           	pushq	%rbp
   2d309: 48 89 fd                     	movq	%rdi, %rbp
; 	btf_ext = calloc(1, sizeof(struct btf_ext));
   2d30c: bf 01 00 00 00               	movl	$1, %edi
; {
   2d311: 53                           	pushq	%rbx
   2d312: 89 f3                        	movl	%esi, %ebx
; 	btf_ext = calloc(1, sizeof(struct btf_ext));
   2d314: be 70 00 00 00               	movl	$112, %esi
; {
   2d319: 48 83 ec 38                  	subq	$56, %rsp
   2d31d: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2d326: 48 89 44 24 28               	movq	%rax, 40(%rsp)
   2d32b: 31 c0                        	xorl	%eax, %eax
; 	btf_ext = calloc(1, sizeof(struct btf_ext));
   2d32d: e8 5e 86 fd ff               	callq	0x5990 <.plt.sec+0x320>
   2d332: 49 89 c4                     	movq	%rax, %r12
; 	if (!btf_ext)
   2d335: 48 85 c0                     	testq	%rax, %rax
   2d338: 0f 84 47 02 00 00            	je	0x2d585 <btf_ext__new+0x285>
; 	btf_ext->data_size = size;
   2d33e: 89 58 68                     	movl	%ebx, 104(%rax)
; 	btf_ext->data = malloc(size);
   2d341: 41 89 dd                     	movl	%ebx, %r13d
   2d344: 4c 89 ef                     	movq	%r13, %rdi
   2d347: e8 44 87 fd ff               	callq	0x5a90 <.plt.sec+0x420>
   2d34c: 49 89 04 24                  	movq	%rax, (%r12)
; 	if (!btf_ext->data) {
   2d350: 48 85 c0                     	testq	%rax, %rax
   2d353: 0f 84 22 02 00 00            	je	0x2d57b <btf_ext__new+0x27b>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2d359: 4c 89 ea                     	movq	%r13, %rdx
   2d35c: 48 89 ee                     	movq	%rbp, %rsi
   2d35f: 48 89 c7                     	movq	%rax, %rdi
   2d362: e8 d9 86 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
   2d367: 48 89 c1                     	movq	%rax, %rcx
; 	if (data_size < offsetofend(struct btf_ext_header, hdr_len) ||
   2d36a: 83 fb 07                     	cmpl	$7, %ebx
   2d36d: 0f 86 5d 01 00 00            	jbe	0x2d4d0 <btf_ext__new+0x1d0>
; 	    data_size < hdr->hdr_len) {
   2d373: 8b 40 04                     	movl	4(%rax), %eax
; 	if (data_size < offsetofend(struct btf_ext_header, hdr_len) ||
   2d376: 39 c3                        	cmpl	%eax, %ebx
   2d378: 0f 82 52 01 00 00            	jb	0x2d4d0 <btf_ext__new+0x1d0>
; 	if (hdr->magic == bswap_16(BTF_MAGIC)) {
   2d37e: 0f b7 11                     	movzwl	(%rcx), %edx
   2d381: 66 81 fa eb 9f               	cmpw	$40939, %dx             # imm = 0x9FEB
   2d386: 0f 84 b8 01 00 00            	je	0x2d544 <btf_ext__new+0x244>
; 	} else if (hdr->magic != BTF_MAGIC) {
   2d38c: 66 81 fa 9f eb               	cmpw	$60319, %dx             # imm = 0xEB9F
   2d391: 0f 85 56 01 00 00            	jne	0x2d4ed <btf_ext__new+0x1ed>
; 	if (hdr->version != BTF_VERSION) {
   2d397: 0f b6 51 02                  	movzbl	2(%rcx), %edx
   2d39b: 80 fa 01                     	cmpb	$1, %dl
   2d39e: 0f 85 66 01 00 00            	jne	0x2d50a <btf_ext__new+0x20a>
; 	if (hdr->flags) {
   2d3a4: 0f b6 51 03                  	movzbl	3(%rcx), %edx
   2d3a8: 84 d2                        	testb	%dl, %dl
   2d3aa: 0f 85 77 01 00 00            	jne	0x2d527 <btf_ext__new+0x227>
; 	if (data_size == hdr->hdr_len) {
   2d3b0: 39 c3                        	cmpl	%eax, %ebx
   2d3b2: 0f 84 a6 01 00 00            	je	0x2d55e <btf_ext__new+0x25e>
; 	if (btf_ext->hdr->hdr_len < offsetofend(struct btf_ext_header, line_info_len)) {
   2d3b8: 83 f8 17                     	cmpl	$23, %eax
   2d3bb: 0f 86 ff 00 00 00            	jbe	0x2d4c0 <btf_ext__new+0x1c0>
; 	struct btf_ext_sec_setup_param param = {
   2d3c1: 48 8b 41 08                  	movq	8(%rcx), %rax
; 	return btf_ext_setup_info(btf_ext, &param);
   2d3c5: 48 89 e5                     	movq	%rsp, %rbp
   2d3c8: 4c 89 e7                     	movq	%r12, %rdi
; 	struct btf_ext_sec_setup_param param = {
   2d3cb: c7 44 24 08 08 00 00 00      	movl	$8, 8(%rsp)
; 	return btf_ext_setup_info(btf_ext, &param);
   2d3d3: 48 89 ee                     	movq	%rbp, %rsi
; 	struct btf_ext_sec_setup_param param = {
   2d3d6: 48 89 04 24                  	movq	%rax, (%rsp)
; 		.ext_info = &btf_ext->func_info,
   2d3da: 49 8d 44 24 08               	leaq	8(%r12), %rax
   2d3df: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	struct btf_ext_sec_setup_param param = {
   2d3e4: 48 8d 05 cf e7 00 00         	leaq	59343(%rip), %rax       # 0x3bbba <CSWTCH.126+0x22ba>
   2d3eb: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	return btf_ext_setup_info(btf_ext, &param);
   2d3f0: e8 eb b6 ff ff               	callq	0x28ae0 <btf_ext_setup_info>
; 	if (err)
   2d3f5: 85 c0                        	testl	%eax, %eax
   2d3f7: 74 3f                        	je	0x2d438 <btf_ext__new+0x138>
; 	errno = -err;
   2d3f9: f7 d8                        	negl	%eax
   2d3fb: 89 c3                        	movl	%eax, %ebx
; 		btf_ext__free(btf_ext);
   2d3fd: 4c 89 e7                     	movq	%r12, %rdi
; 		return libbpf_err_ptr(err);
   2d400: 45 31 e4                     	xorl	%r12d, %r12d
; 		btf_ext__free(btf_ext);
   2d403: e8 98 fe ff ff               	callq	0x2d2a0 <btf_ext__free>
; 	errno = -err;
   2d408: e8 e3 82 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2d40d: 89 18                        	movl	%ebx, (%rax)
; }
   2d40f: 48 8b 44 24 28               	movq	40(%rsp), %rax
   2d414: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2d41d: 0f 85 72 01 00 00            	jne	0x2d595 <btf_ext__new+0x295>
   2d423: 48 83 c4 38                  	addq	$56, %rsp
   2d427: 4c 89 e0                     	movq	%r12, %rax
   2d42a: 5b                           	popq	%rbx
   2d42b: 5d                           	popq	%rbp
   2d42c: 41 5c                        	popq	%r12
   2d42e: 41 5d                        	popq	%r13
   2d430: c3                           	retq
   2d431: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		.off = btf_ext->hdr->line_info_off,
   2d438: 49 8b 04 24                  	movq	(%r12), %rax
; 	return btf_ext_setup_info(btf_ext, &param);
   2d43c: 48 89 ee                     	movq	%rbp, %rsi
   2d43f: 4c 89 e7                     	movq	%r12, %rdi
; 	struct btf_ext_sec_setup_param param = {
   2d442: 48 8b 40 10                  	movq	16(%rax), %rax
   2d446: c7 44 24 08 10 00 00 00      	movl	$16, 8(%rsp)
   2d44e: 48 89 04 24                  	movq	%rax, (%rsp)
; 		.ext_info = &btf_ext->line_info,
   2d452: 49 8d 44 24 28               	leaq	40(%r12), %rax
   2d457: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	struct btf_ext_sec_setup_param param = {
   2d45c: 48 8d 05 61 e7 00 00         	leaq	59233(%rip), %rax       # 0x3bbc4 <CSWTCH.126+0x22c4>
   2d463: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	return btf_ext_setup_info(btf_ext, &param);
   2d468: e8 73 b6 ff ff               	callq	0x28ae0 <btf_ext_setup_info>
; 	if (err)
   2d46d: 85 c0                        	testl	%eax, %eax
   2d46f: 75 88                        	jne	0x2d3f9 <btf_ext__new+0xf9>
; 	if (btf_ext->hdr->hdr_len < offsetofend(struct btf_ext_header, core_relo_len))
   2d471: 49 8b 04 24                  	movq	(%r12), %rax
   2d475: 83 78 04 1f                  	cmpl	$31, 4(%rax)
   2d479: 76 94                        	jbe	0x2d40f <btf_ext__new+0x10f>
; 	struct btf_ext_sec_setup_param param = {
   2d47b: 48 8b 40 18                  	movq	24(%rax), %rax
; 	return btf_ext_setup_info(btf_ext, &param);
   2d47f: 48 89 ee                     	movq	%rbp, %rsi
   2d482: 4c 89 e7                     	movq	%r12, %rdi
; 	struct btf_ext_sec_setup_param param = {
   2d485: c7 44 24 08 10 00 00 00      	movl	$16, 8(%rsp)
   2d48d: 48 89 04 24                  	movq	%rax, (%rsp)
; 		.ext_info = &btf_ext->core_relo_info,
   2d491: 49 8d 44 24 48               	leaq	72(%r12), %rax
   2d496: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	struct btf_ext_sec_setup_param param = {
   2d49b: 48 8d 05 2c e7 00 00         	leaq	59180(%rip), %rax       # 0x3bbce <CSWTCH.126+0x22ce>
   2d4a2: 48 89 44 24 18               	movq	%rax, 24(%rsp)
; 	return btf_ext_setup_info(btf_ext, &param);
   2d4a7: e8 34 b6 ff ff               	callq	0x28ae0 <btf_ext_setup_info>
; 	if (err)
   2d4ac: 85 c0                        	testl	%eax, %eax
   2d4ae: 0f 84 5b ff ff ff            	je	0x2d40f <btf_ext__new+0x10f>
   2d4b4: e9 40 ff ff ff               	jmp	0x2d3f9 <btf_ext__new+0xf9>
   2d4b9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   2d4c0: bb 16 00 00 00               	movl	$22, %ebx
   2d4c5: e9 33 ff ff ff               	jmp	0x2d3fd <btf_ext__new+0xfd>
   2d4ca: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_debug("BTF.ext header not found");
   2d4d0: 48 8d 35 61 df 00 00         	leaq	57185(%rip), %rsi       # 0x3b438 <CSWTCH.126+0x1b38>
   2d4d7: bf 02 00 00 00               	movl	$2, %edi
   2d4dc: 31 c0                        	xorl	%eax, %eax
   2d4de: bb 16 00 00 00               	movl	$22, %ebx
   2d4e3: e8 e8 ab fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
   2d4e8: e9 10 ff ff ff               	jmp	0x2d3fd <btf_ext__new+0xfd>
; 		pr_debug("Invalid BTF.ext magic:%x\n", hdr->magic);
   2d4ed: 48 8d 35 ac df 00 00         	leaq	57260(%rip), %rsi       # 0x3b4a0 <CSWTCH.126+0x1ba0>
   2d4f4: bf 02 00 00 00               	movl	$2, %edi
   2d4f9: 31 c0                        	xorl	%eax, %eax
   2d4fb: bb 16 00 00 00               	movl	$22, %ebx
   2d500: e8 cb ab fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2d505: e9 f3 fe ff ff               	jmp	0x2d3fd <btf_ext__new+0xfd>
; 		pr_debug("Unsupported BTF.ext version:%u\n", hdr->version);
   2d50a: 48 8d 35 b7 df 00 00         	leaq	57271(%rip), %rsi       # 0x3b4c8 <CSWTCH.126+0x1bc8>
   2d511: bf 02 00 00 00               	movl	$2, %edi
   2d516: 31 c0                        	xorl	%eax, %eax
   2d518: bb 5f 00 00 00               	movl	$95, %ebx
   2d51d: e8 ae ab fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
   2d522: e9 d6 fe ff ff               	jmp	0x2d3fd <btf_ext__new+0xfd>
; 		pr_debug("Unsupported BTF.ext flags:%x\n", hdr->flags);
   2d527: 48 8d 35 c2 df 00 00         	leaq	57282(%rip), %rsi       # 0x3b4f0 <CSWTCH.126+0x1bf0>
   2d52e: bf 02 00 00 00               	movl	$2, %edi
   2d533: 31 c0                        	xorl	%eax, %eax
   2d535: bb 5f 00 00 00               	movl	$95, %ebx
   2d53a: e8 91 ab fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2d53f: e9 b9 fe ff ff               	jmp	0x2d3fd <btf_ext__new+0xfd>
; 		pr_warn("BTF.ext in non-native endianness is not supported\n");
   2d544: 48 8d 35 15 df 00 00         	leaq	57109(%rip), %rsi       # 0x3b460 <CSWTCH.126+0x1b60>
   2d54b: 31 ff                        	xorl	%edi, %edi
   2d54d: 31 c0                        	xorl	%eax, %eax
   2d54f: bb 5f 00 00 00               	movl	$95, %ebx
   2d554: e8 77 ab fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err)
   2d559: e9 9f fe ff ff               	jmp	0x2d3fd <btf_ext__new+0xfd>
; 		pr_debug("BTF.ext has no data\n");
   2d55e: 48 8d 35 38 e6 00 00         	leaq	58936(%rip), %rsi       # 0x3bb9d <CSWTCH.126+0x229d>
   2d565: bf 02 00 00 00               	movl	$2, %edi
   2d56a: 31 c0                        	xorl	%eax, %eax
   2d56c: bb 16 00 00 00               	movl	$22, %ebx
   2d571: e8 5a ab fd ff               	callq	0x80d0 <libbpf_print>
; 	if (err) {
   2d576: e9 82 fe ff ff               	jmp	0x2d3fd <btf_ext__new+0xfd>
   2d57b: bb 0c 00 00 00               	movl	$12, %ebx
   2d580: e9 78 fe ff ff               	jmp	0x2d3fd <btf_ext__new+0xfd>
; 	errno = -err;
   2d585: e8 66 81 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2d58a: c7 00 0c 00 00 00            	movl	$12, (%rax)
; 		return libbpf_err_ptr(-ENOMEM);
   2d590: e9 7a fe ff ff               	jmp	0x2d40f <btf_ext__new+0x10f>
; }
   2d595: e8 66 82 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2d59a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)

000000000002d5a0 <btf_parse_elf.part.0>:
; static struct btf *btf_parse_elf(const char *path, struct btf *base_btf,
   2d5a0: 41 57                        	pushq	%r15
   2d5a2: 41 56                        	pushq	%r14
   2d5a4: 41 55                        	pushq	%r13
   2d5a6: 41 54                        	pushq	%r12
   2d5a8: 55                           	pushq	%rbp
   2d5a9: 53                           	pushq	%rbx
   2d5aa: 48 81 ec d8 00 00 00         	subq	$216, %rsp
   2d5b1: 48 89 74 24 18               	movq	%rsi, 24(%rsp)
;       return __open_alias (__path, __oflag, __va_arg_pack ());
   2d5b6: be 00 00 08 00               	movl	$524288, %esi           # imm = 0x80000
; static struct btf *btf_parse_elf(const char *path, struct btf *base_btf,
   2d5bb: 48 89 7c 24 10               	movq	%rdi, 16(%rsp)
   2d5c0: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
   2d5c5: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2d5ce: 48 89 84 24 c8 00 00 00      	movq	%rax, 200(%rsp)
   2d5d6: 31 c0                        	xorl	%eax, %eax
;       return __open_alias (__path, __oflag, __va_arg_pack ());
   2d5d8: e8 83 85 fd ff               	callq	0x5b60 <.plt.sec+0x4f0>
; 	if (fd < 0) {
   2d5dd: 85 c0                        	testl	%eax, %eax
   2d5df: 0f 88 ab 01 00 00            	js	0x2d790 <btf_parse_elf.part.0+0x1f0>
; 	elf = elf_begin(fd, ELF_C_READ, NULL);
   2d5e5: 31 d2                        	xorl	%edx, %edx
   2d5e7: be 01 00 00 00               	movl	$1, %esi
   2d5ec: 89 c7                        	movl	%eax, %edi
   2d5ee: 41 89 c6                     	movl	%eax, %r14d
   2d5f1: e8 0a 85 fd ff               	callq	0x5b00 <.plt.sec+0x490>
   2d5f6: 49 89 c4                     	movq	%rax, %r12
; 	if (!elf) {
   2d5f9: 48 85 c0                     	testq	%rax, %rax
   2d5fc: 0f 84 46 02 00 00            	je	0x2d848 <btf_parse_elf.part.0+0x2a8>
; 	if (!gelf_getehdr(elf, &ehdr)) {
   2d602: 48 8d b4 24 80 00 00 00      	leaq	128(%rsp), %rsi
   2d60a: 48 89 c7                     	movq	%rax, %rdi
   2d60d: e8 7e 80 fd ff               	callq	0x5690 <.plt.sec+0x20>
; 		pr_warn("failed to get EHDR from %s\n", path);
   2d612: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2d617: 48 8d 35 22 df 00 00         	leaq	57122(%rip), %rsi       # 0x3b540 <CSWTCH.126+0x1c40>
; 	if (!gelf_getehdr(elf, &ehdr)) {
   2d61e: 48 85 c0                     	testq	%rax, %rax
   2d621: 0f 84 d5 01 00 00            	je	0x2d7fc <btf_parse_elf.part.0+0x25c>
; 	if (elf_getshdrstrndx(elf, &shstrndx)) {
   2d627: 48 8d 74 24 38               	leaq	56(%rsp), %rsi
   2d62c: 4c 89 e7                     	movq	%r12, %rdi
   2d62f: e8 1c 86 fd ff               	callq	0x5c50 <.plt.sec+0x5e0>
   2d634: 41 89 c5                     	movl	%eax, %r13d
   2d637: 85 c0                        	testl	%eax, %eax
   2d639: 0f 85 e9 01 00 00            	jne	0x2d828 <btf_parse_elf.part.0+0x288>
; 	if (!elf_rawdata(elf_getscn(elf, shstrndx), NULL)) {
   2d63f: 48 8b 74 24 38               	movq	56(%rsp), %rsi
   2d644: 4c 89 e7                     	movq	%r12, %rdi
; 	Elf_Scn *scn = NULL;
   2d647: 31 ed                        	xorl	%ebp, %ebp
; 		if (gelf_getshdr(scn, &sh) != &sh) {
   2d649: 48 8d 5c 24 40               	leaq	64(%rsp), %rbx
; 	if (!elf_rawdata(elf_getscn(elf, shstrndx), NULL)) {
   2d64e: e8 ad 85 fd ff               	callq	0x5c00 <.plt.sec+0x590>
   2d653: 31 f6                        	xorl	%esi, %esi
   2d655: 48 89 c7                     	movq	%rax, %rdi
   2d658: e8 73 84 fd ff               	callq	0x5ad0 <.plt.sec+0x460>
; 	Elf_Data *btf_data = NULL, *btf_ext_data = NULL;
   2d65d: 48 c7 44 24 28 00 00 00 00   	movq	$0, 40(%rsp)
   2d666: 48 c7 44 24 20 00 00 00 00   	movq	$0, 32(%rsp)
; 	if (!elf_rawdata(elf_getscn(elf, shstrndx), NULL)) {
   2d66f: 48 85 c0                     	testq	%rax, %rax
   2d672: 0f 84 78 01 00 00            	je	0x2d7f0 <btf_parse_elf.part.0+0x250>
   2d678: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	while ((scn = elf_nextscn(elf, scn)) != NULL) {
   2d680: 48 89 ee                     	movq	%rbp, %rsi
   2d683: 4c 89 e7                     	movq	%r12, %rdi
   2d686: e8 05 85 fd ff               	callq	0x5b90 <.plt.sec+0x520>
   2d68b: 48 89 c5                     	movq	%rax, %rbp
   2d68e: 48 85 c0                     	testq	%rax, %rax
   2d691: 0f 84 e1 01 00 00            	je	0x2d878 <btf_parse_elf.part.0+0x2d8>
; 		if (gelf_getshdr(scn, &sh) != &sh) {
   2d697: 48 89 de                     	movq	%rbx, %rsi
   2d69a: 48 89 ef                     	movq	%rbp, %rdi
; 		idx++;
   2d69d: 41 83 c5 01                  	addl	$1, %r13d
; 		if (gelf_getshdr(scn, &sh) != &sh) {
   2d6a1: e8 3a 80 fd ff               	callq	0x56e0 <.plt.sec+0x70>
   2d6a6: 48 39 c3                     	cmpq	%rax, %rbx
   2d6a9: 0f 85 89 02 00 00            	jne	0x2d938 <btf_parse_elf.part.0+0x398>
; 		name = elf_strptr(elf, shstrndx, sh.sh_name);
   2d6af: 8b 54 24 40                  	movl	64(%rsp), %edx
   2d6b3: 48 8b 74 24 38               	movq	56(%rsp), %rsi
   2d6b8: 4c 89 e7                     	movq	%r12, %rdi
   2d6bb: e8 b0 81 fd ff               	callq	0x5870 <.plt.sec+0x200>
   2d6c0: 49 89 c7                     	movq	%rax, %r15
; 		if (!name) {
   2d6c3: 48 85 c0                     	testq	%rax, %rax
   2d6c6: 0f 84 8c 02 00 00            	je	0x2d958 <btf_parse_elf.part.0+0x3b8>
; 		if (strcmp(name, BTF_ELF_SEC) == 0) {
   2d6cc: 48 8d 35 8b 47 00 00         	leaq	18315(%rip), %rsi       # 0x31e5e <_IO_stdin_used+0x1e5e>
   2d6d3: 48 89 c7                     	movq	%rax, %rdi
   2d6d6: e8 d5 82 fd ff               	callq	0x59b0 <.plt.sec+0x340>
   2d6db: 85 c0                        	testl	%eax, %eax
   2d6dd: 0f 84 8d 00 00 00            	je	0x2d770 <btf_parse_elf.part.0+0x1d0>
; 		} else if (btf_ext && strcmp(name, BTF_EXT_ELF_SEC) == 0) {
   2d6e3: 48 83 7c 24 08 00            	cmpq	$0, 8(%rsp)
   2d6e9: 74 95                        	je	0x2d680 <btf_parse_elf.part.0+0xe0>
   2d6eb: 48 8d 35 71 47 00 00         	leaq	18289(%rip), %rsi       # 0x31e63 <_IO_stdin_used+0x1e63>
   2d6f2: 4c 89 ff                     	movq	%r15, %rdi
   2d6f5: e8 b6 82 fd ff               	callq	0x59b0 <.plt.sec+0x340>
   2d6fa: 85 c0                        	testl	%eax, %eax
   2d6fc: 75 82                        	jne	0x2d680 <btf_parse_elf.part.0+0xe0>
; 			btf_ext_data = elf_getdata(scn, 0);
   2d6fe: 31 f6                        	xorl	%esi, %esi
   2d700: 48 89 ef                     	movq	%rbp, %rdi
   2d703: e8 38 82 fd ff               	callq	0x5940 <.plt.sec+0x2d0>
   2d708: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 			if (!btf_ext_data) {
   2d70d: 48 85 c0                     	testq	%rax, %rax
   2d710: 0f 85 6a ff ff ff            	jne	0x2d680 <btf_parse_elf.part.0+0xe0>
; 				pr_warn("failed to get section(%d, %s) data from %s\n",
   2d716: 4c 8b 44 24 10               	movq	16(%rsp), %r8
   2d71b: 4c 89 f9                     	movq	%r15, %rcx
   2d71e: 44 89 ea                     	movl	%r13d, %edx
   2d721: 31 ff                        	xorl	%edi, %edi
   2d723: 48 8d 35 16 df 00 00         	leaq	57110(%rip), %rsi       # 0x3b640 <CSWTCH.126+0x1d40>
   2d72a: e8 a1 a9 fd ff               	callq	0x80d0 <libbpf_print>
; 		elf_end(elf);
   2d72f: 4c 89 e7                     	movq	%r12, %rdi
; 	close(fd);
   2d732: 49 c7 c5 5f f0 ff ff         	movq	$-4001, %r13            # imm = 0xF05F
; 	struct btf *btf = NULL;
   2d739: 45 31 e4                     	xorl	%r12d, %r12d
; 		elf_end(elf);
   2d73c: e8 ef 82 fd ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   2d741: 44 89 f7                     	movl	%r14d, %edi
   2d744: e8 b7 81 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (btf_ext)
   2d749: 48 83 7c 24 08 00            	cmpq	$0, 8(%rsp)
   2d74f: 74 0d                        	je	0x2d75e <btf_parse_elf.part.0+0x1be>
; 		btf_ext__free(*btf_ext);
   2d751: 48 8b 44 24 08               	movq	8(%rsp), %rax
   2d756: 48 8b 38                     	movq	(%rax), %rdi
   2d759: e8 42 fb ff ff               	callq	0x2d2a0 <btf_ext__free>
; 	btf__free(btf);
   2d75e: 4c 89 e7                     	movq	%r12, %rdi
   2d761: e8 8a d0 ff ff               	callq	0x2a7f0 <btf__free>
; 	return ERR_PTR(err);
   2d766: eb 56                        	jmp	0x2d7be <btf_parse_elf.part.0+0x21e>
   2d768: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 			btf_data = elf_getdata(scn, 0);
   2d770: 31 f6                        	xorl	%esi, %esi
   2d772: 48 89 ef                     	movq	%rbp, %rdi
   2d775: e8 c6 81 fd ff               	callq	0x5940 <.plt.sec+0x2d0>
   2d77a: 48 89 44 24 20               	movq	%rax, 32(%rsp)
; 			if (!btf_data) {
   2d77f: 48 85 c0                     	testq	%rax, %rax
   2d782: 0f 85 f8 fe ff ff            	jne	0x2d680 <btf_parse_elf.part.0+0xe0>
   2d788: eb 8c                        	jmp	0x2d716 <btf_parse_elf.part.0+0x176>
   2d78a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		err = -errno;
   2d790: e8 5b 7f fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2d795: 44 8b 28                     	movl	(%rax), %r13d
; 		pr_warn("failed to open %s: %s\n", path, strerror(errno));
   2d798: 44 89 ef                     	movl	%r13d, %edi
; 		err = -errno;
   2d79b: 41 f7 dd                     	negl	%r13d
; 		pr_warn("failed to open %s: %s\n", path, strerror(errno));
   2d79e: e8 7d 84 fd ff               	callq	0x5c20 <.plt.sec+0x5b0>
   2d7a3: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2d7a8: 31 ff                        	xorl	%edi, %edi
; 		return ERR_PTR(err);
   2d7aa: 4d 63 ed                     	movslq	%r13d, %r13
; 		pr_warn("failed to open %s: %s\n", path, strerror(errno));
   2d7ad: 48 89 c1                     	movq	%rax, %rcx
   2d7b0: 48 8d 35 81 99 00 00         	leaq	39297(%rip), %rsi       # 0x37138 <strs.2+0x42a8>
   2d7b7: 31 c0                        	xorl	%eax, %eax
   2d7b9: e8 12 a9 fd ff               	callq	0x80d0 <libbpf_print>
; }
   2d7be: 48 8b 84 24 c8 00 00 00      	movq	200(%rsp), %rax
   2d7c6: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2d7cf: 0f 85 f8 01 00 00            	jne	0x2d9cd <btf_parse_elf.part.0+0x42d>
   2d7d5: 48 81 c4 d8 00 00 00         	addq	$216, %rsp
   2d7dc: 4c 89 e8                     	movq	%r13, %rax
   2d7df: 5b                           	popq	%rbx
   2d7e0: 5d                           	popq	%rbp
   2d7e1: 41 5c                        	popq	%r12
   2d7e3: 41 5d                        	popq	%r13
   2d7e5: 41 5e                        	popq	%r14
   2d7e7: 41 5f                        	popq	%r15
   2d7e9: c3                           	retq
   2d7ea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("failed to get e_shstrndx from %s\n", path);
   2d7f0: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2d7f5: 48 8d 35 ac dd 00 00         	leaq	56748(%rip), %rsi       # 0x3b5a8 <CSWTCH.126+0x1ca8>
   2d7fc: 31 ff                        	xorl	%edi, %edi
; 	close(fd);
   2d7fe: 49 c7 c5 5f f0 ff ff         	movq	$-4001, %r13            # imm = 0xF05F
; 		pr_warn("failed to get e_shstrndx from %s\n", path);
   2d805: e8 c6 a8 fd ff               	callq	0x80d0 <libbpf_print>
; 		elf_end(elf);
   2d80a: 4c 89 e7                     	movq	%r12, %rdi
; 	struct btf *btf = NULL;
   2d80d: 45 31 e4                     	xorl	%r12d, %r12d
; 		elf_end(elf);
   2d810: e8 1b 82 fd ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   2d815: 44 89 f7                     	movl	%r14d, %edi
   2d818: e8 e3 80 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (!err)
   2d81d: e9 27 ff ff ff               	jmp	0x2d749 <btf_parse_elf.part.0+0x1a9>
   2d822: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("failed to get section names section index for %s\n",
   2d828: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2d82d: 48 8d 35 34 dd 00 00         	leaq	56628(%rip), %rsi       # 0x3b568 <CSWTCH.126+0x1c68>
   2d834: 31 ff                        	xorl	%edi, %edi
   2d836: 31 c0                        	xorl	%eax, %eax
   2d838: e8 93 a8 fd ff               	callq	0x80d0 <libbpf_print>
; 		elf_end(elf);
   2d83d: e9 ed fe ff ff               	jmp	0x2d72f <btf_parse_elf.part.0+0x18f>
   2d842: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		pr_warn("failed to open %s as ELF file\n", path);
   2d848: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2d84d: 48 8d 35 c4 dc 00 00         	leaq	56516(%rip), %rsi       # 0x3b518 <CSWTCH.126+0x1c18>
   2d854: 31 ff                        	xorl	%edi, %edi
   2d856: 31 c0                        	xorl	%eax, %eax
; 	close(fd);
   2d858: 49 c7 c5 5f f0 ff ff         	movq	$-4001, %r13            # imm = 0xF05F
; 		pr_warn("failed to open %s as ELF file\n", path);
   2d85f: e8 6c a8 fd ff               	callq	0x80d0 <libbpf_print>
; 	close(fd);
   2d864: 44 89 f7                     	movl	%r14d, %edi
   2d867: e8 94 80 fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (!err)
   2d86c: e9 d8 fe ff ff               	jmp	0x2d749 <btf_parse_elf.part.0+0x1a9>
   2d871: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 	if (!btf_data) {
   2d878: 48 8b 44 24 20               	movq	32(%rsp), %rax
   2d87d: 48 85 c0                     	testq	%rax, %rax
   2d880: 0f 84 61 01 00 00            	je	0x2d9e7 <btf_parse_elf.part.0+0x447>
; 	btf = btf_new(btf_data->d_buf, btf_data->d_size, base_btf);
   2d886: 48 8b 54 24 18               	movq	24(%rsp), %rdx
   2d88b: 8b 70 10                     	movl	16(%rax), %esi
   2d88e: 48 8b 38                     	movq	(%rax), %rdi
   2d891: e8 fa cf ff ff               	callq	0x2a890 <btf_new>
; 	err = libbpf_get_error(btf);
   2d896: 48 89 c7                     	movq	%rax, %rdi
; 	btf = btf_new(btf_data->d_buf, btf_data->d_size, base_btf);
   2d899: 49 89 c5                     	movq	%rax, %r13
; 	err = libbpf_get_error(btf);
   2d89c: e8 4f 7a fe ff               	callq	0x152f0 <libbpf_get_error>
; 		elf_end(elf);
   2d8a1: 4c 89 e7                     	movq	%r12, %rdi
; 	err = libbpf_get_error(btf);
   2d8a4: 48 89 c3                     	movq	%rax, %rbx
; 	if (err)
   2d8a7: 85 c0                        	testl	%eax, %eax
   2d8a9: 0f 85 c6 00 00 00            	jne	0x2d975 <btf_parse_elf.part.0+0x3d5>
; 	switch (gelf_getclass(elf)) {
   2d8af: e8 ac 7f fd ff               	callq	0x5860 <.plt.sec+0x1f0>
   2d8b4: 83 f8 01                     	cmpl	$1, %eax
   2d8b7: 0f 84 03 01 00 00            	je	0x2d9c0 <btf_parse_elf.part.0+0x420>
   2d8bd: 83 f8 02                     	cmpl	$2, %eax
   2d8c0: 0f 84 ed 00 00 00            	je	0x2d9b3 <btf_parse_elf.part.0+0x413>
; 		pr_warn("failed to get ELF class (bitness) for %s\n", path);
   2d8c6: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2d8cb: 48 8d 35 a6 dd 00 00         	leaq	56742(%rip), %rsi       # 0x3b678 <CSWTCH.126+0x1d78>
   2d8d2: 31 ff                        	xorl	%edi, %edi
   2d8d4: 31 c0                        	xorl	%eax, %eax
   2d8d6: e8 f5 a7 fd ff               	callq	0x80d0 <libbpf_print>
; 	if (btf_ext && btf_ext_data) {
   2d8db: 48 8b 5c 24 08               	movq	8(%rsp), %rbx
   2d8e0: 48 85 db                     	testq	%rbx, %rbx
   2d8e3: 0f 84 e9 00 00 00            	je	0x2d9d2 <btf_parse_elf.part.0+0x432>
   2d8e9: 48 8b 44 24 28               	movq	40(%rsp), %rax
   2d8ee: 48 85 c0                     	testq	%rax, %rax
   2d8f1: 0f 84 96 00 00 00            	je	0x2d98d <btf_parse_elf.part.0+0x3ed>
; 		*btf_ext = btf_ext__new(btf_ext_data->d_buf, btf_ext_data->d_size);
   2d8f7: 8b 70 10                     	movl	16(%rax), %esi
   2d8fa: 48 8b 38                     	movq	(%rax), %rdi
   2d8fd: e8 fe f9 ff ff               	callq	0x2d300 <btf_ext__new>
   2d902: 48 89 03                     	movq	%rax, (%rbx)
   2d905: 48 89 c7                     	movq	%rax, %rdi
; 		err = libbpf_get_error(*btf_ext);
   2d908: e8 e3 79 fe ff               	callq	0x152f0 <libbpf_get_error>
; 		elf_end(elf);
   2d90d: 4c 89 e7                     	movq	%r12, %rdi
; 		err = libbpf_get_error(*btf_ext);
   2d910: 48 89 c3                     	movq	%rax, %rbx
; 		elf_end(elf);
   2d913: e8 18 81 fd ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   2d918: 44 89 f7                     	movl	%r14d, %edi
   2d91b: e8 e0 7f fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (!err)
   2d920: 85 db                        	testl	%ebx, %ebx
   2d922: 0f 84 96 fe ff ff            	je	0x2d7be <btf_parse_elf.part.0+0x21e>
; 	btf = btf_new(btf_data->d_buf, btf_data->d_size, base_btf);
   2d928: 4d 89 ec                     	movq	%r13, %r12
; 	return (void *) error_;
   2d92b: 4c 63 eb                     	movslq	%ebx, %r13
   2d92e: e9 1e fe ff ff               	jmp	0x2d751 <btf_parse_elf.part.0+0x1b1>
   2d933: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			pr_warn("failed to get section(%d) header from %s\n",
   2d938: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   2d93d: 44 89 ea                     	movl	%r13d, %edx
   2d940: 31 ff                        	xorl	%edi, %edi
   2d942: 31 c0                        	xorl	%eax, %eax
   2d944: 48 8d 35 8d dc 00 00         	leaq	56461(%rip), %rsi       # 0x3b5d8 <CSWTCH.126+0x1cd8>
   2d94b: e8 80 a7 fd ff               	callq	0x80d0 <libbpf_print>
; 			goto done;
   2d950: e9 da fd ff ff               	jmp	0x2d72f <btf_parse_elf.part.0+0x18f>
   2d955: 0f 1f 00                     	nopl	(%rax)
; 			pr_warn("failed to get section(%d) name from %s\n",
   2d958: 48 8b 4c 24 10               	movq	16(%rsp), %rcx
   2d95d: 44 89 ea                     	movl	%r13d, %edx
   2d960: 31 ff                        	xorl	%edi, %edi
   2d962: 31 c0                        	xorl	%eax, %eax
   2d964: 48 8d 35 a5 dc 00 00         	leaq	56485(%rip), %rsi       # 0x3b610 <CSWTCH.126+0x1d10>
   2d96b: e8 60 a7 fd ff               	callq	0x80d0 <libbpf_print>
; 			goto done;
   2d970: e9 ba fd ff ff               	jmp	0x2d72f <btf_parse_elf.part.0+0x18f>
; 		elf_end(elf);
   2d975: e8 b6 80 fd ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   2d97a: 44 89 f7                     	movl	%r14d, %edi
; 	btf = btf_new(btf_data->d_buf, btf_data->d_size, base_btf);
   2d97d: 4d 89 ec                     	movq	%r13, %r12
; 	return (void *) error_;
   2d980: 4c 63 eb                     	movslq	%ebx, %r13
; 	close(fd);
   2d983: e8 78 7f fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (!err)
   2d988: e9 bc fd ff ff               	jmp	0x2d749 <btf_parse_elf.part.0+0x1a9>
; 	} else if (btf_ext) {
   2d98d: 48 8b 44 24 08               	movq	8(%rsp), %rax
   2d992: 48 85 c0                     	testq	%rax, %rax
   2d995: 74 3b                        	je	0x2d9d2 <btf_parse_elf.part.0+0x432>
; 		*btf_ext = NULL;
   2d997: 48 c7 00 00 00 00 00         	movq	$0, (%rax)
; 		elf_end(elf);
   2d99e: 4c 89 e7                     	movq	%r12, %rdi
   2d9a1: e8 8a 80 fd ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   2d9a6: 44 89 f7                     	movl	%r14d, %edi
   2d9a9: e8 52 7f fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (!err)
   2d9ae: e9 0b fe ff ff               	jmp	0x2d7be <btf_parse_elf.part.0+0x21e>
; 	btf->ptr_sz = ptr_sz;
   2d9b3: 41 c7 45 70 08 00 00 00      	movl	$8, 112(%r13)
; 	return 0;
   2d9bb: e9 1b ff ff ff               	jmp	0x2d8db <btf_parse_elf.part.0+0x33b>
; 	btf->ptr_sz = ptr_sz;
   2d9c0: 41 c7 45 70 04 00 00 00      	movl	$4, 112(%r13)
; 	return 0;
   2d9c8: e9 0e ff ff ff               	jmp	0x2d8db <btf_parse_elf.part.0+0x33b>
; }
   2d9cd: e8 2e 7e fd ff               	callq	0x5800 <.plt.sec+0x190>
; 		elf_end(elf);
   2d9d2: 4c 89 e7                     	movq	%r12, %rdi
   2d9d5: e8 56 80 fd ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   2d9da: 44 89 f7                     	movl	%r14d, %edi
   2d9dd: e8 1e 7f fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (!err)
   2d9e2: e9 d7 fd ff ff               	jmp	0x2d7be <btf_parse_elf.part.0+0x21e>
; 		elf_end(elf);
   2d9e7: 4c 89 e7                     	movq	%r12, %rdi
; 	close(fd);
   2d9ea: 49 c7 c5 fe ff ff ff         	movq	$-2, %r13
; 	struct btf *btf = NULL;
   2d9f1: 45 31 e4                     	xorl	%r12d, %r12d
; 		elf_end(elf);
   2d9f4: e8 37 80 fd ff               	callq	0x5a30 <.plt.sec+0x3c0>
; 	close(fd);
   2d9f9: 44 89 f7                     	movl	%r14d, %edi
   2d9fc: e8 ff 7e fd ff               	callq	0x5900 <.plt.sec+0x290>
; 	if (!err)
   2da01: e9 43 fd ff ff               	jmp	0x2d749 <btf_parse_elf.part.0+0x1a9>
   2da06: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000002da10 <btf__parse_elf>:
; {
   2da10: f3 0f 1e fa                  	endbr64
   2da14: 41 54                        	pushq	%r12
   2da16: 49 89 f4                     	movq	%rsi, %r12
   2da19: 55                           	pushq	%rbp
   2da1a: 48 89 fd                     	movq	%rdi, %rbp
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   2da1d: bf 01 00 00 00               	movl	$1, %edi
; {
   2da22: 53                           	pushq	%rbx
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   2da23: e8 e8 7c fd ff               	callq	0x5710 <.plt.sec+0xa0>
   2da28: 85 c0                        	testl	%eax, %eax
   2da2a: 74 24                        	je	0x2da50 <btf__parse_elf+0x40>
   2da2c: 31 f6                        	xorl	%esi, %esi
   2da2e: 4c 89 e2                     	movq	%r12, %rdx
   2da31: 48 89 ef                     	movq	%rbp, %rdi
   2da34: e8 67 fb ff ff               	callq	0x2d5a0 <btf_parse_elf.part.0>
; 	if (IS_ERR(ret))
   2da39: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2da3f: 77 37                        	ja	0x2da78 <btf__parse_elf+0x68>
; }
   2da41: 5b                           	popq	%rbx
   2da42: 5d                           	popq	%rbp
   2da43: 41 5c                        	popq	%r12
   2da45: c3                           	retq
   2da46: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("failed to init libelf for %s\n", path);
   2da50: 48 89 ea                     	movq	%rbp, %rdx
   2da53: 48 8d 35 b6 91 00 00         	leaq	37302(%rip), %rsi       # 0x36c10 <strs.2+0x3d80>
   2da5a: 31 ff                        	xorl	%edi, %edi
   2da5c: bb a0 0f 00 00               	movl	$4000, %ebx             # imm = 0xFA0
   2da61: e8 6a a6 fd ff               	callq	0x80d0 <libbpf_print>
; 		errno = -PTR_ERR(ret);
   2da66: e8 85 7c fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2da6b: 89 18                        	movl	%ebx, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2da6d: 31 c0                        	xorl	%eax, %eax
; }
   2da6f: 5b                           	popq	%rbx
   2da70: 5d                           	popq	%rbp
   2da71: 41 5c                        	popq	%r12
   2da73: c3                           	retq
   2da74: 0f 1f 40 00                  	nopl	(%rax)
; 		errno = -PTR_ERR(ret);
   2da78: 89 c3                        	movl	%eax, %ebx
   2da7a: f7 db                        	negl	%ebx
   2da7c: eb e8                        	jmp	0x2da66 <btf__parse_elf+0x56>
   2da7e: 66 90                        	nop

000000000002da80 <btf__parse_elf_split>:
; {
   2da80: f3 0f 1e fa                  	endbr64
   2da84: 41 54                        	pushq	%r12
   2da86: 49 89 f4                     	movq	%rsi, %r12
   2da89: 55                           	pushq	%rbp
   2da8a: 48 89 fd                     	movq	%rdi, %rbp
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   2da8d: bf 01 00 00 00               	movl	$1, %edi
; {
   2da92: 53                           	pushq	%rbx
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   2da93: e8 78 7c fd ff               	callq	0x5710 <.plt.sec+0xa0>
   2da98: 85 c0                        	testl	%eax, %eax
   2da9a: 74 24                        	je	0x2dac0 <btf__parse_elf_split+0x40>
   2da9c: 31 d2                        	xorl	%edx, %edx
   2da9e: 4c 89 e6                     	movq	%r12, %rsi
   2daa1: 48 89 ef                     	movq	%rbp, %rdi
   2daa4: e8 f7 fa ff ff               	callq	0x2d5a0 <btf_parse_elf.part.0>
; 	if (IS_ERR(ret))
   2daa9: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2daaf: 77 37                        	ja	0x2dae8 <btf__parse_elf_split+0x68>
; }
   2dab1: 5b                           	popq	%rbx
   2dab2: 5d                           	popq	%rbp
   2dab3: 41 5c                        	popq	%r12
   2dab5: c3                           	retq
   2dab6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		pr_warn("failed to init libelf for %s\n", path);
   2dac0: 48 89 ea                     	movq	%rbp, %rdx
   2dac3: 48 8d 35 46 91 00 00         	leaq	37190(%rip), %rsi       # 0x36c10 <strs.2+0x3d80>
   2daca: 31 ff                        	xorl	%edi, %edi
   2dacc: bb a0 0f 00 00               	movl	$4000, %ebx             # imm = 0xFA0
   2dad1: e8 fa a5 fd ff               	callq	0x80d0 <libbpf_print>
; 		errno = -PTR_ERR(ret);
   2dad6: e8 15 7c fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2dadb: 89 18                        	movl	%ebx, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2dadd: 31 c0                        	xorl	%eax, %eax
; }
   2dadf: 5b                           	popq	%rbx
   2dae0: 5d                           	popq	%rbp
   2dae1: 41 5c                        	popq	%r12
   2dae3: c3                           	retq
   2dae4: 0f 1f 40 00                  	nopl	(%rax)
; 		errno = -PTR_ERR(ret);
   2dae8: 89 c3                        	movl	%eax, %ebx
   2daea: f7 db                        	negl	%ebx
   2daec: eb e8                        	jmp	0x2dad6 <btf__parse_elf_split+0x56>
   2daee: 66 90                        	nop

000000000002daf0 <btf__parse_split>:
; {
   2daf0: f3 0f 1e fa                  	endbr64
   2daf4: 41 55                        	pushq	%r13
   2daf6: 49 89 f5                     	movq	%rsi, %r13
   2daf9: 41 54                        	pushq	%r12
   2dafb: 55                           	pushq	%rbp
   2dafc: 48 89 fd                     	movq	%rdi, %rbp
; 	btf = btf_parse_raw(path, base_btf);
   2daff: e8 9c d1 ff ff               	callq	0x2aca0 <btf_parse_raw>
; 	err = libbpf_get_error(btf);
   2db04: 48 89 c7                     	movq	%rax, %rdi
; 	btf = btf_parse_raw(path, base_btf);
   2db07: 49 89 c4                     	movq	%rax, %r12
; 	err = libbpf_get_error(btf);
   2db0a: e8 e1 77 fe ff               	callq	0x152f0 <libbpf_get_error>
; 	if (!err)
   2db0f: 85 c0                        	testl	%eax, %eax
   2db11: 74 08                        	je	0x2db1b <btf__parse_split+0x2b>
; 		return ERR_PTR(err);
   2db13: 4c 63 e0                     	movslq	%eax, %r12
; 	if (err != -EPROTO)
   2db16: 83 f8 b9                     	cmpl	$-71, %eax
   2db19: 74 35                        	je	0x2db50 <btf__parse_split+0x60>
; 	if (IS_ERR(ret))
   2db1b: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2db22: 77 0c                        	ja	0x2db30 <btf__parse_split+0x40>
; }
   2db24: 4c 89 e0                     	movq	%r12, %rax
   2db27: 5d                           	popq	%rbp
   2db28: 41 5c                        	popq	%r12
   2db2a: 41 5d                        	popq	%r13
   2db2c: c3                           	retq
   2db2d: 0f 1f 00                     	nopl	(%rax)
; 		errno = -PTR_ERR(ret);
   2db30: 41 f7 dc                     	negl	%r12d
   2db33: e8 b8 7b fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2db38: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2db3b: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2db3e: 5d                           	popq	%rbp
   2db3f: 4c 89 e0                     	movq	%r12, %rax
   2db42: 41 5c                        	popq	%r12
   2db44: 41 5d                        	popq	%r13
   2db46: c3                           	retq
   2db47: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   2db50: bf 01 00 00 00               	movl	$1, %edi
   2db55: e8 b6 7b fd ff               	callq	0x5710 <.plt.sec+0xa0>
   2db5a: 85 c0                        	testl	%eax, %eax
   2db5c: 74 22                        	je	0x2db80 <btf__parse_split+0x90>
   2db5e: 31 d2                        	xorl	%edx, %edx
   2db60: 4c 89 ee                     	movq	%r13, %rsi
   2db63: 48 89 ef                     	movq	%rbp, %rdi
   2db66: e8 35 fa ff ff               	callq	0x2d5a0 <btf_parse_elf.part.0>
   2db6b: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   2db6e: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2db75: 76 ad                        	jbe	0x2db24 <btf__parse_split+0x34>
   2db77: eb b7                        	jmp	0x2db30 <btf__parse_split+0x40>
   2db79: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("failed to init libelf for %s\n", path);
   2db80: 48 89 ea                     	movq	%rbp, %rdx
   2db83: 48 8d 35 86 90 00 00         	leaq	36998(%rip), %rsi       # 0x36c10 <strs.2+0x3d80>
   2db8a: 31 ff                        	xorl	%edi, %edi
   2db8c: 41 bc a0 0f 00 00            	movl	$4000, %r12d            # imm = 0xFA0
   2db92: e8 39 a5 fd ff               	callq	0x80d0 <libbpf_print>
; 	return IS_ERR_VALUE((unsigned long)ptr);
   2db97: eb 9a                        	jmp	0x2db33 <btf__parse_split+0x43>
   2db99: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002dba0 <btf__parse>:
; {
   2dba0: f3 0f 1e fa                  	endbr64
   2dba4: 41 55                        	pushq	%r13
   2dba6: 49 89 f5                     	movq	%rsi, %r13
   2dba9: 41 54                        	pushq	%r12
   2dbab: 55                           	pushq	%rbp
   2dbac: 48 89 fd                     	movq	%rdi, %rbp
; 	if (btf_ext)
   2dbaf: 48 85 f6                     	testq	%rsi, %rsi
   2dbb2: 74 07                        	je	0x2dbbb <btf__parse+0x1b>
; 		*btf_ext = NULL;
   2dbb4: 48 c7 06 00 00 00 00         	movq	$0, (%rsi)
; 	btf = btf_parse_raw(path, base_btf);
   2dbbb: 31 f6                        	xorl	%esi, %esi
   2dbbd: 48 89 ef                     	movq	%rbp, %rdi
   2dbc0: e8 db d0 ff ff               	callq	0x2aca0 <btf_parse_raw>
; 	err = libbpf_get_error(btf);
   2dbc5: 48 89 c7                     	movq	%rax, %rdi
; 	btf = btf_parse_raw(path, base_btf);
   2dbc8: 49 89 c4                     	movq	%rax, %r12
; 	err = libbpf_get_error(btf);
   2dbcb: e8 20 77 fe ff               	callq	0x152f0 <libbpf_get_error>
; 	if (!err)
   2dbd0: 85 c0                        	testl	%eax, %eax
   2dbd2: 74 08                        	je	0x2dbdc <btf__parse+0x3c>
; 		return ERR_PTR(err);
   2dbd4: 4c 63 e0                     	movslq	%eax, %r12
; 	if (err != -EPROTO)
   2dbd7: 83 f8 b9                     	cmpl	$-71, %eax
   2dbda: 74 34                        	je	0x2dc10 <btf__parse+0x70>
; 	if (IS_ERR(ret))
   2dbdc: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2dbe3: 77 0b                        	ja	0x2dbf0 <btf__parse+0x50>
; }
   2dbe5: 4c 89 e0                     	movq	%r12, %rax
   2dbe8: 5d                           	popq	%rbp
   2dbe9: 41 5c                        	popq	%r12
   2dbeb: 41 5d                        	popq	%r13
   2dbed: c3                           	retq
   2dbee: 66 90                        	nop
; 		errno = -PTR_ERR(ret);
   2dbf0: 41 f7 dc                     	negl	%r12d
   2dbf3: e8 f8 7a fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2dbf8: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2dbfb: 45 31 e4                     	xorl	%r12d, %r12d
; }
   2dbfe: 5d                           	popq	%rbp
   2dbff: 4c 89 e0                     	movq	%r12, %rax
   2dc02: 41 5c                        	popq	%r12
   2dc04: 41 5d                        	popq	%r13
   2dc06: c3                           	retq
   2dc07: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   2dc10: bf 01 00 00 00               	movl	$1, %edi
   2dc15: e8 f6 7a fd ff               	callq	0x5710 <.plt.sec+0xa0>
   2dc1a: 85 c0                        	testl	%eax, %eax
   2dc1c: 74 22                        	je	0x2dc40 <btf__parse+0xa0>
   2dc1e: 4c 89 ea                     	movq	%r13, %rdx
   2dc21: 31 f6                        	xorl	%esi, %esi
   2dc23: 48 89 ef                     	movq	%rbp, %rdi
   2dc26: e8 75 f9 ff ff               	callq	0x2d5a0 <btf_parse_elf.part.0>
   2dc2b: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   2dc2e: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2dc35: 76 ae                        	jbe	0x2dbe5 <btf__parse+0x45>
   2dc37: eb b7                        	jmp	0x2dbf0 <btf__parse+0x50>
   2dc39: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("failed to init libelf for %s\n", path);
   2dc40: 48 89 ea                     	movq	%rbp, %rdx
   2dc43: 48 8d 35 c6 8f 00 00         	leaq	36806(%rip), %rsi       # 0x36c10 <strs.2+0x3d80>
   2dc4a: 31 ff                        	xorl	%edi, %edi
   2dc4c: 41 bc a0 0f 00 00            	movl	$4000, %r12d            # imm = 0xFA0
   2dc52: e8 79 a4 fd ff               	callq	0x80d0 <libbpf_print>
; 	return IS_ERR_VALUE((unsigned long)ptr);
   2dc57: eb 9a                        	jmp	0x2dbf3 <btf__parse+0x53>
   2dc59: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002dc60 <btf_ext__get_raw_data>:
; {
   2dc60: f3 0f 1e fa                  	endbr64
; 	*size = btf_ext->data_size;
   2dc64: 8b 47 68                     	movl	104(%rdi), %eax
   2dc67: 89 06                        	movl	%eax, (%rsi)
; 	return btf_ext->data;
   2dc69: 48 8b 07                     	movq	(%rdi), %rax
; }
   2dc6c: c3                           	retq
   2dc6d: 0f 1f 00                     	nopl	(%rax)

000000000002dc70 <libbpf_find_kernel_btf>:
; {
   2dc70: f3 0f 1e fa                  	endbr64
   2dc74: 41 57                        	pushq	%r15
   2dc76: 41 56                        	pushq	%r14
   2dc78: 41 55                        	pushq	%r13
   2dc7a: 41 54                        	pushq	%r12
   2dc7c: 55                           	pushq	%rbp
   2dc7d: 53                           	pushq	%rbx
   2dc7e: 48 81 ec 00 10 00 00         	subq	$4096, %rsp             # imm = 0x1000
   2dc85: 48 83 0c 24 00               	orq	$0, (%rsp)
   2dc8a: 48 81 ec 38 02 00 00         	subq	$568, %rsp              # imm = 0x238
; 	} locations[] = {
   2dc91: b9 0f 00 00 00               	movl	$15, %ecx
; 		pr_debug("loading kernel BTF '%s': %d\n", path, err);
   2dc96: 4c 8d 2d f3 da 00 00         	leaq	56051(%rip), %r13       # 0x3b790 <CSWTCH.126+0x1e90>
; {
   2dc9d: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2dca6: 48 89 84 24 28 12 00 00      	movq	%rax, 4648(%rsp)
   2dcae: 31 c0                        	xorl	%eax, %eax
; 	} locations[] = {
   2dcb0: 48 8d 7c 24 18               	leaq	24(%rsp), %rdi
   2dcb5: 48 8d 6c 24 18               	leaq	24(%rsp), %rbp
   2dcba: 4c 8d a4 24 12 01 00 00      	leaq	274(%rsp), %r12
   2dcc2: 48 8d 9c 24 20 02 00 00      	leaq	544(%rsp), %rbx
   2dcca: f3 48 ab                     	rep		stosq	%rax, %es:(%rdi)
   2dccd: 48 8d 05 1c df 00 00         	leaq	57116(%rip), %rax       # 0x3bbf0 <CSWTCH.126+0x22f0>
; 	uname(&buf);
   2dcd4: 48 8d bc 24 90 00 00 00      	leaq	144(%rsp), %rdi
; 	} locations[] = {
   2dcdc: c6 44 24 18 01               	movb	$1, 24(%rsp)
   2dce1: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   2dce6: 48 8d 05 c3 d9 00 00         	leaq	55747(%rip), %rax       # 0x3b6b0 <CSWTCH.126+0x1db0>
   2dced: 48 89 44 24 30               	movq	%rax, 48(%rsp)
   2dcf2: 48 8d 05 d7 d9 00 00         	leaq	55767(%rip), %rax       # 0x3b6d0 <CSWTCH.126+0x1dd0>
   2dcf9: 48 89 44 24 40               	movq	%rax, 64(%rsp)
   2dcfe: 48 8d 05 eb d9 00 00         	leaq	55787(%rip), %rax       # 0x3b6f0 <CSWTCH.126+0x1df0>
   2dd05: 48 89 44 24 50               	movq	%rax, 80(%rsp)
   2dd0a: 48 8d 05 07 da 00 00         	leaq	55815(%rip), %rax       # 0x3b718 <CSWTCH.126+0x1e18>
   2dd11: 48 89 44 24 60               	movq	%rax, 96(%rsp)
   2dd16: 48 8d 05 23 da 00 00         	leaq	55843(%rip), %rax       # 0x3b740 <CSWTCH.126+0x1e40>
   2dd1d: 48 89 44 24 70               	movq	%rax, 112(%rsp)
   2dd22: 48 8d 05 3f da 00 00         	leaq	55871(%rip), %rax       # 0x3b768 <CSWTCH.126+0x1e68>
   2dd29: 48 89 84 24 80 00 00 00      	movq	%rax, 128(%rsp)
; 	uname(&buf);
   2dd31: e8 4a 7b fd ff               	callq	0x5880 <.plt.sec+0x210>
; 	for (i = 0; i < ARRAY_SIZE(locations); i++) {
   2dd36: 48 8d 84 24 98 00 00 00      	leaq	152(%rsp), %rax
; 	uname(&buf);
   2dd3e: 4c 8d 05 93 de 00 00         	leaq	56979(%rip), %r8        # 0x3bbd8 <CSWTCH.126+0x22d8>
   2dd45: 48 89 44 24 08               	movq	%rax, 8(%rsp)
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   2dd4a: be 00 10 00 00               	movl	$4096, %esi             # imm = 0x1000
   2dd4f: 48 89 df                     	movq	%rbx, %rdi
   2dd52: 31 c0                        	xorl	%eax, %eax
   2dd54: 4d 89 e1                     	movq	%r12, %r9
   2dd57: b9 01 10 00 00               	movl	$4097, %ecx             # imm = 0x1001
   2dd5c: ba 01 00 00 00               	movl	$1, %edx
   2dd61: e8 4a 79 fd ff               	callq	0x56b0 <.plt.sec+0x40>
; 		if (access(path, R_OK))
   2dd66: be 04 00 00 00               	movl	$4, %esi
   2dd6b: 48 89 df                     	movq	%rbx, %rdi
   2dd6e: e8 2d 7e fd ff               	callq	0x5ba0 <.plt.sec+0x530>
   2dd73: 85 c0                        	testl	%eax, %eax
   2dd75: 75 79                        	jne	0x2ddf0 <libbpf_find_kernel_btf+0x180>
; 		if (locations[i].raw_btf)
   2dd77: 80 7d 00 00                  	cmpb	$0, (%rbp)
   2dd7b: 0f 84 87 00 00 00            	je	0x2de08 <libbpf_find_kernel_btf+0x198>
; 	return libbpf_ptr(btf_parse_raw(path, NULL));
   2dd81: 31 f6                        	xorl	%esi, %esi
   2dd83: 48 89 df                     	movq	%rbx, %rdi
   2dd86: e8 15 cf ff ff               	callq	0x2aca0 <btf_parse_raw>
   2dd8b: 49 89 c7                     	movq	%rax, %r15
; 	if (IS_ERR(ret))
   2dd8e: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2dd94: 0f 87 a6 00 00 00            	ja	0x2de40 <libbpf_find_kernel_btf+0x1d0>
; 		err = libbpf_get_error(btf);
   2dd9a: 4c 89 ff                     	movq	%r15, %rdi
   2dd9d: e8 4e 75 fe ff               	callq	0x152f0 <libbpf_get_error>
; 		pr_debug("loading kernel BTF '%s': %d\n", path, err);
   2dda2: 48 89 da                     	movq	%rbx, %rdx
   2dda5: 4c 89 ee                     	movq	%r13, %rsi
   2dda8: bf 02 00 00 00               	movl	$2, %edi
; 		err = libbpf_get_error(btf);
   2ddad: 49 89 c6                     	movq	%rax, %r14
   2ddb0: 89 c1                        	movl	%eax, %ecx
; 		pr_debug("loading kernel BTF '%s': %d\n", path, err);
   2ddb2: 31 c0                        	xorl	%eax, %eax
   2ddb4: e8 17 a3 fd ff               	callq	0x80d0 <libbpf_print>
; 		if (err)
   2ddb9: 45 85 f6                     	testl	%r14d, %r14d
   2ddbc: 75 32                        	jne	0x2ddf0 <libbpf_find_kernel_btf+0x180>
; }
   2ddbe: 48 8b 84 24 28 12 00 00      	movq	4648(%rsp), %rax
   2ddc6: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2ddcf: 0f 85 da 00 00 00            	jne	0x2deaf <libbpf_find_kernel_btf+0x23f>
   2ddd5: 48 81 c4 38 12 00 00         	addq	$4664, %rsp             # imm = 0x1238
   2dddc: 4c 89 f8                     	movq	%r15, %rax
   2dddf: 5b                           	popq	%rbx
   2dde0: 5d                           	popq	%rbp
   2dde1: 41 5c                        	popq	%r12
   2dde3: 41 5d                        	popq	%r13
   2dde5: 41 5e                        	popq	%r14
   2dde7: 41 5f                        	popq	%r15
   2dde9: c3                           	retq
   2ddea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	for (i = 0; i < ARRAY_SIZE(locations); i++) {
   2ddf0: 48 83 c5 10                  	addq	$16, %rbp
   2ddf4: 48 3b 6c 24 08               	cmpq	8(%rsp), %rbp
   2ddf9: 74 65                        	je	0x2de60 <libbpf_find_kernel_btf+0x1f0>
; 		snprintf(path, PATH_MAX, locations[i].path_fmt, buf.release);
   2ddfb: 4c 8b 45 f8                  	movq	-8(%rbp), %r8
   2ddff: e9 46 ff ff ff               	jmp	0x2dd4a <libbpf_find_kernel_btf+0xda>
   2de04: 0f 1f 40 00                  	nopl	(%rax)
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   2de08: bf 01 00 00 00               	movl	$1, %edi
   2de0d: e8 fe 78 fd ff               	callq	0x5710 <.plt.sec+0xa0>
   2de12: 85 c0                        	testl	%eax, %eax
   2de14: 74 72                        	je	0x2de88 <libbpf_find_kernel_btf+0x218>
   2de16: 31 d2                        	xorl	%edx, %edx
   2de18: 31 f6                        	xorl	%esi, %esi
   2de1a: 48 89 df                     	movq	%rbx, %rdi
   2de1d: e8 7e f7 ff ff               	callq	0x2d5a0 <btf_parse_elf.part.0>
   2de22: 49 89 c7                     	movq	%rax, %r15
; 	if (IS_ERR(ret))
   2de25: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2de2b: 0f 86 69 ff ff ff            	jbe	0x2dd9a <libbpf_find_kernel_btf+0x12a>
; 		errno = -PTR_ERR(ret);
   2de31: 41 f7 df                     	negl	%r15d
   2de34: eb 69                        	jmp	0x2de9f <libbpf_find_kernel_btf+0x22f>
   2de36: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   2de40: e8 ab 78 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2de45: 45 89 f8                     	movl	%r15d, %r8d
; 	return IS_ERR(ret) ? NULL : ret;
   2de48: 45 31 ff                     	xorl	%r15d, %r15d
; 		errno = -PTR_ERR(ret);
   2de4b: 41 f7 d8                     	negl	%r8d
   2de4e: 44 89 00                     	movl	%r8d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2de51: e9 44 ff ff ff               	jmp	0x2dd9a <libbpf_find_kernel_btf+0x12a>
   2de56: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	pr_warn("failed to find valid kernel BTF\n");
   2de60: 48 8d 35 51 d9 00 00         	leaq	55633(%rip), %rsi       # 0x3b7b8 <CSWTCH.126+0x1eb8>
   2de67: 31 ff                        	xorl	%edi, %edi
   2de69: 31 c0                        	xorl	%eax, %eax
; 	return libbpf_err_ptr(-ESRCH);
   2de6b: 45 31 ff                     	xorl	%r15d, %r15d
; 	pr_warn("failed to find valid kernel BTF\n");
   2de6e: e8 5d a2 fd ff               	callq	0x80d0 <libbpf_print>
; 	errno = -err;
   2de73: e8 78 78 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2de78: c7 00 03 00 00 00            	movl	$3, (%rax)
; 	return libbpf_err_ptr(-ESRCH);
   2de7e: e9 3b ff ff ff               	jmp	0x2ddbe <libbpf_find_kernel_btf+0x14e>
   2de83: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		pr_warn("failed to init libelf for %s\n", path);
   2de88: 48 89 da                     	movq	%rbx, %rdx
   2de8b: 48 8d 35 7e 8d 00 00         	leaq	36222(%rip), %rsi       # 0x36c10 <strs.2+0x3d80>
   2de92: 31 ff                        	xorl	%edi, %edi
   2de94: 41 bf a0 0f 00 00            	movl	$4000, %r15d            # imm = 0xFA0
   2de9a: e8 31 a2 fd ff               	callq	0x80d0 <libbpf_print>
; 		errno = -PTR_ERR(ret);
   2de9f: e8 4c 78 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2dea4: 44 89 38                     	movl	%r15d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2dea7: 45 31 ff                     	xorl	%r15d, %r15d
   2deaa: e9 eb fe ff ff               	jmp	0x2dd9a <libbpf_find_kernel_btf+0x12a>
; }
   2deaf: e8 4c 79 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2deb4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2debf: 90                           	nop

000000000002dec0 <btf__load_module_btf>:
; {
   2dec0: f3 0f 1e fa                  	endbr64
   2dec4: 41 55                        	pushq	%r13
   2dec6: 49 89 f9                     	movq	%rdi, %r9
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   2dec9: b9 50 00 00 00               	movl	$80, %ecx
   2dece: ba 01 00 00 00               	movl	$1, %edx
; {
   2ded3: 41 54                        	pushq	%r12
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   2ded5: 4c 8d 05 27 dd 00 00         	leaq	56615(%rip), %r8        # 0x3bc03 <CSWTCH.126+0x2303>
; {
   2dedc: 55                           	pushq	%rbp
   2dedd: 48 89 f5                     	movq	%rsi, %rbp
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   2dee0: be 50 00 00 00               	movl	$80, %esi
; {
   2dee5: 48 83 ec 60                  	subq	$96, %rsp
   2dee9: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2def2: 48 89 44 24 58               	movq	%rax, 88(%rsp)
   2def7: 31 c0                        	xorl	%eax, %eax
;   return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
   2def9: 49 89 e5                     	movq	%rsp, %r13
   2defc: 4c 89 ef                     	movq	%r13, %rdi
   2deff: e8 ac 77 fd ff               	callq	0x56b0 <.plt.sec+0x40>
; 	btf = btf_parse_raw(path, base_btf);
   2df04: 4c 89 ef                     	movq	%r13, %rdi
   2df07: 48 89 ee                     	movq	%rbp, %rsi
   2df0a: e8 91 cd ff ff               	callq	0x2aca0 <btf_parse_raw>
; 	err = libbpf_get_error(btf);
   2df0f: 48 89 c7                     	movq	%rax, %rdi
; 	btf = btf_parse_raw(path, base_btf);
   2df12: 49 89 c4                     	movq	%rax, %r12
; 	err = libbpf_get_error(btf);
   2df15: e8 d6 73 fe ff               	callq	0x152f0 <libbpf_get_error>
; 	if (!err)
   2df1a: 85 c0                        	testl	%eax, %eax
   2df1c: 74 08                        	je	0x2df26 <btf__load_module_btf+0x66>
; 		return ERR_PTR(err);
   2df1e: 4c 63 e0                     	movslq	%eax, %r12
; 	if (err != -EPROTO)
   2df21: 83 f8 b9                     	cmpl	$-71, %eax
   2df24: 74 3a                        	je	0x2df60 <btf__load_module_btf+0xa0>
; 	if (IS_ERR(ret))
   2df26: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2df2d: 77 21                        	ja	0x2df50 <btf__load_module_btf+0x90>
; }
   2df2f: 48 8b 44 24 58               	movq	88(%rsp), %rax
   2df34: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2df3d: 75 6a                        	jne	0x2dfa9 <btf__load_module_btf+0xe9>
   2df3f: 48 83 c4 60                  	addq	$96, %rsp
   2df43: 4c 89 e0                     	movq	%r12, %rax
   2df46: 5d                           	popq	%rbp
   2df47: 41 5c                        	popq	%r12
   2df49: 41 5d                        	popq	%r13
   2df4b: c3                           	retq
   2df4c: 0f 1f 40 00                  	nopl	(%rax)
; 		errno = -PTR_ERR(ret);
   2df50: 41 f7 dc                     	negl	%r12d
   2df53: e8 98 77 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2df58: 44 89 20                     	movl	%r12d, (%rax)
; 	return IS_ERR(ret) ? NULL : ret;
   2df5b: 45 31 e4                     	xorl	%r12d, %r12d
; 	return btf__parse_split(path, vmlinux_btf);
   2df5e: eb cf                        	jmp	0x2df2f <btf__load_module_btf+0x6f>
; 	if (elf_version(EV_CURRENT) == EV_NONE) {
   2df60: bf 01 00 00 00               	movl	$1, %edi
   2df65: e8 a6 77 fd ff               	callq	0x5710 <.plt.sec+0xa0>
   2df6a: 85 c0                        	testl	%eax, %eax
   2df6c: 74 22                        	je	0x2df90 <btf__load_module_btf+0xd0>
   2df6e: 31 d2                        	xorl	%edx, %edx
   2df70: 48 89 ee                     	movq	%rbp, %rsi
   2df73: 4c 89 ef                     	movq	%r13, %rdi
   2df76: e8 25 f6 ff ff               	callq	0x2d5a0 <btf_parse_elf.part.0>
   2df7b: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(ret))
   2df7e: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2df85: 76 a8                        	jbe	0x2df2f <btf__load_module_btf+0x6f>
   2df87: eb c7                        	jmp	0x2df50 <btf__load_module_btf+0x90>
   2df89: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		pr_warn("failed to init libelf for %s\n", path);
   2df90: 4c 89 ea                     	movq	%r13, %rdx
   2df93: 48 8d 35 76 8c 00 00         	leaq	35958(%rip), %rsi       # 0x36c10 <strs.2+0x3d80>
   2df9a: 31 ff                        	xorl	%edi, %edi
   2df9c: 41 bc a0 0f 00 00            	movl	$4000, %r12d            # imm = 0xFA0
   2dfa2: e8 29 a1 fd ff               	callq	0x80d0 <libbpf_print>
; 	return IS_ERR_VALUE((unsigned long)ptr);
   2dfa7: eb aa                        	jmp	0x2df53 <btf__load_module_btf+0x93>
; }
   2dfa9: e8 52 78 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2dfae: 66 90                        	nop

000000000002dfb0 <btf_type_visit_type_ids>:
; {
   2dfb0: f3 0f 1e fa                  	endbr64
   2dfb4: 41 55                        	pushq	%r13
   2dfb6: 41 54                        	pushq	%r12
   2dfb8: 55                           	pushq	%rbp
   2dfb9: 48 89 d5                     	movq	%rdx, %rbp
   2dfbc: 53                           	pushq	%rbx
   2dfbd: 48 83 ec 08                  	subq	$8, %rsp
; 	return BTF_INFO_KIND(t->info);
   2dfc1: 8b 57 04                     	movl	4(%rdi), %edx
   2dfc4: 89 d0                        	movl	%edx, %eax
   2dfc6: c1 e8 18                     	shrl	$24, %eax
   2dfc9: 83 e0 1f                     	andl	$31, %eax
; 	switch (btf_kind(t)) {
   2dfcc: 66 83 f8 13                  	cmpw	$19, %ax
   2dfd0: 0f 87 18 01 00 00            	ja	0x2e0ee <btf_type_visit_type_ids+0x13e>
   2dfd6: 48 8d 0d af da 00 00         	leaq	55983(%rip), %rcx       # 0x3ba8c <CSWTCH.126+0x218c>
   2dfdd: 0f b7 c0                     	movzwl	%ax, %eax
   2dfe0: 49 89 fc                     	movq	%rdi, %r12
   2dfe3: 48 89 f3                     	movq	%rsi, %rbx
   2dfe6: 48 63 04 81                  	movslq	(%rcx,%rax,4), %rax
   2dfea: 48 01 c8                     	addq	%rcx, %rax
   2dfed: 3e ff e0                     	jmpq	*%rax
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2dff0: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   2dff6: 74 30                        	je	0x2e028 <btf_type_visit_type_ids+0x78>
   2dff8: 8d 42 ff                     	leal	-1(%rdx), %eax
   2dffb: 4c 8d 6f 10                  	leaq	16(%rdi), %r13
   2dfff: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   2e003: 4c 8d 64 87 1c               	leaq	28(%rdi,%rax,4), %r12
   2e008: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 			err = visit(&m->type, ctx);
   2e010: 48 89 ee                     	movq	%rbp, %rsi
   2e013: 4c 89 ef                     	movq	%r13, %rdi
   2e016: ff d3                        	callq	*%rbx
; 			if (err)
   2e018: 85 c0                        	testl	%eax, %eax
   2e01a: 75 0e                        	jne	0x2e02a <btf_type_visit_type_ids+0x7a>
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e01c: 49 83 c5 0c                  	addq	$12, %r13
   2e020: 4d 39 e5                     	cmpq	%r12, %r13
   2e023: 75 eb                        	jne	0x2e010 <btf_type_visit_type_ids+0x60>
   2e025: 0f 1f 00                     	nopl	(%rax)
; 		return 0;
   2e028: 31 c0                        	xorl	%eax, %eax
; }
   2e02a: 48 83 c4 08                  	addq	$8, %rsp
   2e02e: 5b                           	popq	%rbx
   2e02f: 5d                           	popq	%rbp
   2e030: 41 5c                        	popq	%r12
   2e032: 41 5d                        	popq	%r13
   2e034: c3                           	retq
   2e035: 0f 1f 00                     	nopl	(%rax)
; 		return visit(&t->type, ctx);
   2e038: 48 8d 7f 08                  	leaq	8(%rdi), %rdi
; }
   2e03c: 48 83 c4 08                  	addq	$8, %rsp
; 		err = err ?: visit(&a->index_type, ctx);
   2e040: 48 89 ee                     	movq	%rbp, %rsi
   2e043: 48 89 d8                     	movq	%rbx, %rax
; }
   2e046: 5b                           	popq	%rbx
   2e047: 5d                           	popq	%rbp
   2e048: 41 5c                        	popq	%r12
   2e04a: 41 5d                        	popq	%r13
; 		err = err ?: visit(&a->index_type, ctx);
   2e04c: ff e0                        	jmpq	*%rax
   2e04e: 66 90                        	nop
; 		err = visit(&a->type, ctx);
   2e050: 48 8d 7f 0c                  	leaq	12(%rdi), %rdi
   2e054: 48 89 ee                     	movq	%rbp, %rsi
   2e057: ff d3                        	callq	*%rbx
; 		err = err ?: visit(&a->index_type, ctx);
   2e059: 85 c0                        	testl	%eax, %eax
   2e05b: 75 cd                        	jne	0x2e02a <btf_type_visit_type_ids+0x7a>
   2e05d: 49 8d 7c 24 10               	leaq	16(%r12), %rdi
   2e062: eb d8                        	jmp	0x2e03c <btf_type_visit_type_ids+0x8c>
   2e064: 0f 1f 40 00                  	nopl	(%rax)
; 		err = visit(&t->type, ctx);
   2e068: 48 8d 7f 08                  	leaq	8(%rdi), %rdi
   2e06c: 48 89 ee                     	movq	%rbp, %rsi
   2e06f: ff d3                        	callq	*%rbx
; 		if (err)
   2e071: 85 c0                        	testl	%eax, %eax
   2e073: 75 b5                        	jne	0x2e02a <btf_type_visit_type_ids+0x7a>
; 	return BTF_INFO_VLEN(t->info);
   2e075: 41 0f b7 44 24 04            	movzwl	4(%r12), %eax
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e07b: 85 c0                        	testl	%eax, %eax
   2e07d: 74 a9                        	je	0x2e028 <btf_type_visit_type_ids+0x78>
   2e07f: 83 e8 01                     	subl	$1, %eax
   2e082: 4d 8d 6c 24 10               	leaq	16(%r12), %r13
   2e087: 4d 8d 64 c4 18               	leaq	24(%r12,%rax,8), %r12
   2e08c: 0f 1f 40 00                  	nopl	(%rax)
; 			err = visit(&m->type, ctx);
   2e090: 48 89 ee                     	movq	%rbp, %rsi
   2e093: 4c 89 ef                     	movq	%r13, %rdi
   2e096: ff d3                        	callq	*%rbx
; 			if (err)
   2e098: 85 c0                        	testl	%eax, %eax
   2e09a: 75 8e                        	jne	0x2e02a <btf_type_visit_type_ids+0x7a>
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e09c: 49 83 c5 08                  	addq	$8, %r13
   2e0a0: 4d 39 e5                     	cmpq	%r12, %r13
   2e0a3: 75 eb                        	jne	0x2e090 <btf_type_visit_type_ids+0xe0>
   2e0a5: eb 81                        	jmp	0x2e028 <btf_type_visit_type_ids+0x78>
   2e0a7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	return (struct btf_var_secinfo *)(t + 1);
   2e0b0: 4c 8d 6f 0c                  	leaq	12(%rdi), %r13
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e0b4: 81 e2 ff ff 00 00            	andl	$65535, %edx            # imm = 0xFFFF
   2e0ba: 0f 84 68 ff ff ff            	je	0x2e028 <btf_type_visit_type_ids+0x78>
   2e0c0: 8d 42 ff                     	leal	-1(%rdx), %eax
   2e0c3: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   2e0c7: 4c 8d 64 87 18               	leaq	24(%rdi,%rax,4), %r12
   2e0cc: 0f 1f 40 00                  	nopl	(%rax)
; 			err = visit(&m->type, ctx);
   2e0d0: 48 89 ee                     	movq	%rbp, %rsi
   2e0d3: 4c 89 ef                     	movq	%r13, %rdi
   2e0d6: ff d3                        	callq	*%rbx
; 			if (err)
   2e0d8: 85 c0                        	testl	%eax, %eax
   2e0da: 0f 85 4a ff ff ff            	jne	0x2e02a <btf_type_visit_type_ids+0x7a>
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e0e0: 49 83 c5 0c                  	addq	$12, %r13
   2e0e4: 4d 39 e5                     	cmpq	%r12, %r13
   2e0e7: 75 e7                        	jne	0x2e0d0 <btf_type_visit_type_ids+0x120>
   2e0e9: e9 3a ff ff ff               	jmp	0x2e028 <btf_type_visit_type_ids+0x78>
; 	switch (btf_kind(t)) {
   2e0ee: b8 ea ff ff ff               	movl	$4294967274, %eax       # imm = 0xFFFFFFEA
   2e0f3: e9 32 ff ff ff               	jmp	0x2e02a <btf_type_visit_type_ids+0x7a>
   2e0f8: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000002e100 <btf_type_visit_str_offs>:
; {
   2e100: f3 0f 1e fa                  	endbr64
   2e104: 41 56                        	pushq	%r14
   2e106: 41 55                        	pushq	%r13
   2e108: 41 54                        	pushq	%r12
   2e10a: 49 89 fc                     	movq	%rdi, %r12
   2e10d: 55                           	pushq	%rbp
   2e10e: 48 89 d5                     	movq	%rdx, %rbp
   2e111: 53                           	pushq	%rbx
   2e112: 48 89 f3                     	movq	%rsi, %rbx
; 	err = visit(&t->name_off, ctx);
   2e115: 48 89 d6                     	movq	%rdx, %rsi
   2e118: ff d3                        	callq	*%rbx
   2e11a: 41 89 c5                     	movl	%eax, %r13d
; 	if (err)
   2e11d: 85 c0                        	testl	%eax, %eax
   2e11f: 75 5f                        	jne	0x2e180 <btf_type_visit_str_offs+0x80>
; 	return BTF_INFO_KIND(t->info);
   2e121: 41 8b 44 24 04               	movl	4(%r12), %eax
   2e126: 89 c1                        	movl	%eax, %ecx
   2e128: c1 e9 18                     	shrl	$24, %ecx
   2e12b: 89 ca                        	movl	%ecx, %edx
   2e12d: 83 e2 1f                     	andl	$31, %edx
; 	switch (btf_kind(t)) {
   2e130: 66 83 fa 0d                  	cmpw	$13, %dx
   2e134: 0f 84 d6 00 00 00            	je	0x2e210 <btf_type_visit_str_offs+0x110>
   2e13a: 0f 87 90 00 00 00            	ja	0x2e1d0 <btf_type_visit_str_offs+0xd0>
   2e140: 66 83 fa 05                  	cmpw	$5, %dx
   2e144: 76 4a                        	jbe	0x2e190 <btf_type_visit_str_offs+0x90>
   2e146: 66 83 fa 06                  	cmpw	$6, %dx
   2e14a: 75 34                        	jne	0x2e180 <btf_type_visit_str_offs+0x80>
; 	return (struct btf_enum *)(t + 1);
   2e14c: 4d 8d 74 24 0c               	leaq	12(%r12), %r14
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e151: 25 ff ff 00 00               	andl	$65535, %eax            # imm = 0xFFFF
   2e156: 74 28                        	je	0x2e180 <btf_type_visit_str_offs+0x80>
   2e158: 83 e8 01                     	subl	$1, %eax
   2e15b: 4d 8d 64 c4 14               	leaq	20(%r12,%rax,8), %r12
   2e160: eb 0f                        	jmp	0x2e171 <btf_type_visit_str_offs+0x71>
   2e162: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2e168: 49 83 c6 08                  	addq	$8, %r14
   2e16c: 4d 39 f4                     	cmpq	%r14, %r12
   2e16f: 74 0f                        	je	0x2e180 <btf_type_visit_str_offs+0x80>
; 			err = visit(&m->name_off, ctx);
   2e171: 48 89 ee                     	movq	%rbp, %rsi
   2e174: 4c 89 f7                     	movq	%r14, %rdi
   2e177: ff d3                        	callq	*%rbx
; 			if (err)
   2e179: 85 c0                        	testl	%eax, %eax
   2e17b: 74 eb                        	je	0x2e168 <btf_type_visit_str_offs+0x68>
   2e17d: 41 89 c5                     	movl	%eax, %r13d
; }
   2e180: 5b                           	popq	%rbx
   2e181: 44 89 e8                     	movl	%r13d, %eax
   2e184: 5d                           	popq	%rbp
   2e185: 41 5c                        	popq	%r12
   2e187: 41 5d                        	popq	%r13
   2e189: 41 5e                        	popq	%r14
   2e18b: c3                           	retq
   2e18c: 0f 1f 40 00                  	nopl	(%rax)
; 	switch (btf_kind(t)) {
   2e190: 83 e1 1c                     	andl	$28, %ecx
   2e193: 74 eb                        	je	0x2e180 <btf_type_visit_str_offs+0x80>
; 	return (struct btf_member *)(t + 1);
   2e195: 4d 8d 74 24 0c               	leaq	12(%r12), %r14
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e19a: 25 ff ff 00 00               	andl	$65535, %eax            # imm = 0xFFFF
   2e19f: 74 df                        	je	0x2e180 <btf_type_visit_str_offs+0x80>
   2e1a1: 83 e8 01                     	subl	$1, %eax
   2e1a4: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   2e1a8: 4d 8d 64 84 18               	leaq	24(%r12,%rax,4), %r12
   2e1ad: eb 0a                        	jmp	0x2e1b9 <btf_type_visit_str_offs+0xb9>
   2e1af: 90                           	nop
   2e1b0: 49 83 c6 0c                  	addq	$12, %r14
   2e1b4: 4d 39 e6                     	cmpq	%r12, %r14
   2e1b7: 74 c7                        	je	0x2e180 <btf_type_visit_str_offs+0x80>
; 			err = visit(&m->name_off, ctx);
   2e1b9: 48 89 ee                     	movq	%rbp, %rsi
   2e1bc: 4c 89 f7                     	movq	%r14, %rdi
   2e1bf: ff d3                        	callq	*%rbx
; 			if (err)
   2e1c1: 85 c0                        	testl	%eax, %eax
   2e1c3: 74 eb                        	je	0x2e1b0 <btf_type_visit_str_offs+0xb0>
   2e1c5: eb b6                        	jmp	0x2e17d <btf_type_visit_str_offs+0x7d>
   2e1c7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 	switch (btf_kind(t)) {
   2e1d0: 66 83 fa 13                  	cmpw	$19, %dx
   2e1d4: 75 aa                        	jne	0x2e180 <btf_type_visit_str_offs+0x80>
; 	return (struct btf_enum64 *)(t + 1);
   2e1d6: 4d 8d 74 24 0c               	leaq	12(%r12), %r14
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e1db: 25 ff ff 00 00               	andl	$65535, %eax            # imm = 0xFFFF
   2e1e0: 74 9e                        	je	0x2e180 <btf_type_visit_str_offs+0x80>
   2e1e2: 83 e8 01                     	subl	$1, %eax
   2e1e5: 48 8d 04 40                  	leaq	(%rax,%rax,2), %rax
   2e1e9: 4d 8d 64 84 18               	leaq	24(%r12,%rax,4), %r12
   2e1ee: eb 0d                        	jmp	0x2e1fd <btf_type_visit_str_offs+0xfd>
   2e1f0: 49 83 c6 0c                  	addq	$12, %r14
   2e1f4: 4d 39 e6                     	cmpq	%r12, %r14
   2e1f7: 0f 84 83 ff ff ff            	je	0x2e180 <btf_type_visit_str_offs+0x80>
; 			err = visit(&m->name_off, ctx);
   2e1fd: 48 89 ee                     	movq	%rbp, %rsi
   2e200: 4c 89 f7                     	movq	%r14, %rdi
   2e203: ff d3                        	callq	*%rbx
; 			if (err)
   2e205: 85 c0                        	testl	%eax, %eax
   2e207: 74 e7                        	je	0x2e1f0 <btf_type_visit_str_offs+0xf0>
   2e209: e9 6f ff ff ff               	jmp	0x2e17d <btf_type_visit_str_offs+0x7d>
   2e20e: 66 90                        	nop
; 	return (struct btf_param *)(t + 1);
   2e210: 4d 8d 74 24 0c               	leaq	12(%r12), %r14
; 		for (i = 0, n = btf_vlen(t); i < n; i++, m++) {
   2e215: 25 ff ff 00 00               	andl	$65535, %eax            # imm = 0xFFFF
   2e21a: 0f 84 60 ff ff ff            	je	0x2e180 <btf_type_visit_str_offs+0x80>
   2e220: 83 e8 01                     	subl	$1, %eax
   2e223: 4d 8d 64 c4 14               	leaq	20(%r12,%rax,8), %r12
   2e228: eb 13                        	jmp	0x2e23d <btf_type_visit_str_offs+0x13d>
   2e22a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2e230: 49 83 c6 08                  	addq	$8, %r14
   2e234: 4d 39 f4                     	cmpq	%r14, %r12
   2e237: 0f 84 43 ff ff ff            	je	0x2e180 <btf_type_visit_str_offs+0x80>
; 			err = visit(&m->name_off, ctx);
   2e23d: 48 89 ee                     	movq	%rbp, %rsi
   2e240: 4c 89 f7                     	movq	%r14, %rdi
   2e243: ff d3                        	callq	*%rbx
; 			if (err)
   2e245: 85 c0                        	testl	%eax, %eax
   2e247: 74 e7                        	je	0x2e230 <btf_type_visit_str_offs+0x130>
   2e249: e9 2f ff ff ff               	jmp	0x2e17d <btf_type_visit_str_offs+0x7d>
   2e24e: 66 90                        	nop

000000000002e250 <btf__add_type>:
; {
   2e250: f3 0f 1e fa                  	endbr64
   2e254: 41 56                        	pushq	%r14
   2e256: 41 55                        	pushq	%r13
   2e258: 49 89 d5                     	movq	%rdx, %r13
   2e25b: 41 54                        	pushq	%r12
   2e25d: 55                           	pushq	%rbp
   2e25e: 48 89 fd                     	movq	%rdi, %rbp
   2e261: 48 83 ec 28                  	subq	$40, %rsp
   2e265: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2e26e: 48 89 44 24 18               	movq	%rax, 24(%rsp)
   2e273: 31 c0                        	xorl	%eax, %eax
; 	struct btf_pipe p = { .src = src_btf, .dst = btf };
   2e275: 48 89 7c 24 08               	movq	%rdi, 8(%rsp)
; 	sz = btf_type_size(src_type);
   2e27a: 8b 7a 04                     	movl	4(%rdx), %edi
; 	struct btf_pipe p = { .src = src_btf, .dst = btf };
   2e27d: 48 c7 44 24 10 00 00 00 00   	movq	$0, 16(%rsp)
   2e286: 48 89 34 24                  	movq	%rsi, (%rsp)
; 	sz = btf_type_size(src_type);
   2e28a: e8 21 b0 ff ff               	callq	0x292b0 <btf_type_size.isra.0>
   2e28f: 41 89 c4                     	movl	%eax, %r12d
; 	if (sz < 0)
   2e292: 85 c0                        	testl	%eax, %eax
   2e294: 0f 88 a6 00 00 00            	js	0x2e340 <btf__add_type+0xf0>
; 	if (btf_ensure_modifiable(btf))
   2e29a: 48 89 ef                     	movq	%rbp, %rdi
   2e29d: e8 fe b0 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2e2a2: 85 c0                        	testl	%eax, %eax
   2e2a4: 0f 85 ae 00 00 00            	jne	0x2e358 <btf__add_type+0x108>
; 			      btf->hdr->type_len, UINT_MAX, add_sz);
   2e2aa: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	t = btf_add_type_mem(btf, sz);
   2e2ae: 4d 63 f4                     	movslq	%r12d, %r14
; 	return libbpf_add_mem(&btf->types_data, &btf->types_data_cap, 1,
   2e2b1: 48 8d 7d 20                  	leaq	32(%rbp), %rdi
   2e2b5: 48 8d 75 28                  	leaq	40(%rbp), %rsi
   2e2b9: 4d 89 f1                     	movq	%r14, %r9
   2e2bc: 41 b8 ff ff ff ff            	movl	$4294967295, %r8d       # imm = 0xFFFFFFFF
   2e2c2: ba 01 00 00 00               	movl	$1, %edx
   2e2c7: 8b 48 0c                     	movl	12(%rax), %ecx
   2e2ca: e8 d1 ba ff ff               	callq	0x29da0 <libbpf_add_mem>
   2e2cf: 48 89 c7                     	movq	%rax, %rdi
; 	if (!t)
   2e2d2: 48 85 c0                     	testq	%rax, %rax
   2e2d5: 0f 84 7d 00 00 00            	je	0x2e358 <btf__add_type+0x108>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2e2db: 4c 89 ee                     	movq	%r13, %rsi
   2e2de: 4c 89 f2                     	movq	%r14, %rdx
   2e2e1: e8 5a 77 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	err = btf_type_visit_str_offs(t, btf_rewrite_str, &p);
   2e2e6: 48 89 e2                     	movq	%rsp, %rdx
   2e2e9: 48 8d 35 c0 db ff ff         	leaq	-9280(%rip), %rsi       # 0x2beb0 <btf_rewrite_str>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2e2f0: 48 89 c7                     	movq	%rax, %rdi
; 	err = btf_type_visit_str_offs(t, btf_rewrite_str, &p);
   2e2f3: e8 08 fe ff ff               	callq	0x2e100 <btf_type_visit_str_offs>
   2e2f8: 41 89 c5                     	movl	%eax, %r13d
; 	if (err)
   2e2fb: 85 c0                        	testl	%eax, %eax
   2e2fd: 74 11                        	je	0x2e310 <btf__add_type+0xc0>
; 	if (ret < 0)
   2e2ff: 79 1d                        	jns	0x2e31e <btf__add_type+0xce>
; 		errno = -ret;
   2e301: e8 ea 73 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2e306: 44 89 ea                     	movl	%r13d, %edx
   2e309: f7 da                        	negl	%edx
   2e30b: 89 10                        	movl	%edx, (%rax)
   2e30d: eb 0f                        	jmp	0x2e31e <btf__add_type+0xce>
   2e30f: 90                           	nop
; 	return btf_commit_type(btf, sz);
   2e310: 44 89 e6                     	movl	%r12d, %esi
   2e313: 48 89 ef                     	movq	%rbp, %rdi
   2e316: e8 65 b3 ff ff               	callq	0x29680 <btf_commit_type>
   2e31b: 41 89 c5                     	movl	%eax, %r13d
; }
   2e31e: 48 8b 44 24 18               	movq	24(%rsp), %rax
   2e323: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2e32c: 75 3d                        	jne	0x2e36b <btf__add_type+0x11b>
   2e32e: 48 83 c4 28                  	addq	$40, %rsp
   2e332: 44 89 e8                     	movl	%r13d, %eax
   2e335: 5d                           	popq	%rbp
   2e336: 41 5c                        	popq	%r12
   2e338: 41 5d                        	popq	%r13
   2e33a: 41 5e                        	popq	%r14
   2e33c: c3                           	retq
   2e33d: 0f 1f 00                     	nopl	(%rax)
; 		errno = -ret;
   2e340: e8 ab 73 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2e345: 44 89 e2                     	movl	%r12d, %edx
   2e348: 45 89 e5                     	movl	%r12d, %r13d
   2e34b: f7 da                        	negl	%edx
   2e34d: 89 10                        	movl	%edx, (%rax)
   2e34f: eb cd                        	jmp	0x2e31e <btf__add_type+0xce>
   2e351: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   2e358: e8 93 73 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOMEM);
   2e35d: 41 bd f4 ff ff ff            	movl	$4294967284, %r13d      # imm = 0xFFFFFFF4
; 		errno = -ret;
   2e363: c7 00 0c 00 00 00            	movl	$12, (%rax)
   2e369: eb b3                        	jmp	0x2e31e <btf__add_type+0xce>
; }
   2e36b: e8 90 74 fd ff               	callq	0x5800 <.plt.sec+0x190>

000000000002e370 <btf__add_btf>:
; {
   2e370: f3 0f 1e fa                  	endbr64
   2e374: 41 57                        	pushq	%r15
   2e376: 41 56                        	pushq	%r14
   2e378: 41 55                        	pushq	%r13
   2e37a: 41 54                        	pushq	%r12
   2e37c: 55                           	pushq	%rbp
   2e37d: 53                           	pushq	%rbx
   2e37e: 48 83 ec 48                  	subq	$72, %rsp
   2e382: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2e38b: 48 89 44 24 38               	movq	%rax, 56(%rsp)
   2e390: 31 c0                        	xorl	%eax, %eax
; 	if (src_btf->base_btf)
   2e392: 48 83 7e 48 00               	cmpq	$0, 72(%rsi)
; 	struct btf_pipe p = { .src = src_btf, .dst = btf };
   2e397: 48 89 74 24 20               	movq	%rsi, 32(%rsp)
   2e39c: 48 c7 44 24 30 00 00 00 00   	movq	$0, 48(%rsp)
   2e3a5: 48 89 7c 24 28               	movq	%rdi, 40(%rsp)
; 	if (src_btf->base_btf)
   2e3aa: 0f 85 22 02 00 00            	jne	0x2e5d2 <btf__add_btf+0x262>
   2e3b0: 48 89 fd                     	movq	%rdi, %rbp
   2e3b3: 49 89 f4                     	movq	%rsi, %r12
; 	if (btf_ensure_modifiable(btf))
   2e3b6: e8 e5 af ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2e3bb: 85 c0                        	testl	%eax, %eax
   2e3bd: 0f 85 f9 01 00 00            	jne	0x2e5bc <btf__add_btf+0x24c>
; 	old_strs_len = btf->hdr->str_len;
   2e3c3: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	cnt = btf__type_cnt(src_btf) - 1;
   2e3c7: 41 8b 54 24 40               	movl	64(%r12), %edx
; 	t = btf_add_type_mem(btf, data_sz);
   2e3cc: 48 89 ef                     	movq	%rbp, %rdi
; 	old_strs_len = btf->hdr->str_len;
   2e3cf: 8b 40 14                     	movl	20(%rax), %eax
   2e3d2: 89 44 24 18                  	movl	%eax, 24(%rsp)
; 	data_sz = src_btf->hdr->type_len;
   2e3d6: 49 8b 44 24 18               	movq	24(%r12), %rax
   2e3db: 8b 48 0c                     	movl	12(%rax), %ecx
; 	cnt = btf__type_cnt(src_btf) - 1;
   2e3de: 41 8b 44 24 50               	movl	80(%r12), %eax
   2e3e3: 8d 44 02 ff                  	leal	-1(%rdx,%rax), %eax
; 	data_sz = src_btf->hdr->type_len;
   2e3e7: 89 4c 24 1c                  	movl	%ecx, 28(%rsp)
; 	cnt = btf__type_cnt(src_btf) - 1;
   2e3eb: 89 44 24 0c                  	movl	%eax, 12(%rsp)
; 	t = btf_add_type_mem(btf, data_sz);
   2e3ef: 48 63 c1                     	movslq	%ecx, %rax
   2e3f2: 48 89 c6                     	movq	%rax, %rsi
   2e3f5: 48 89 44 24 10               	movq	%rax, 16(%rsp)
   2e3fa: e8 b1 b1 ff ff               	callq	0x295b0 <btf_add_type_mem>
   2e3ff: 49 89 c7                     	movq	%rax, %r15
; 	if (!t)
   2e402: 48 85 c0                     	testq	%rax, %rax
   2e405: 0f 84 b1 01 00 00            	je	0x2e5bc <btf__add_btf+0x24c>
; 	return libbpf_add_mem((void **)&btf->type_offs, &btf->type_offs_cap, sizeof(__u32),
   2e40b: 8b 4d 40                     	movl	64(%rbp), %ecx
   2e40e: 4c 63 4c 24 0c               	movslq	12(%rsp), %r9
   2e413: 48 8d 75 38                  	leaq	56(%rbp), %rsi
   2e417: 48 8d 7d 30                  	leaq	48(%rbp), %rdi
   2e41b: 41 b8 ff ff ff 7f            	movl	$2147483647, %r8d       # imm = 0x7FFFFFFF
   2e421: ba 04 00 00 00               	movl	$4, %edx
   2e426: e8 75 b9 ff ff               	callq	0x29da0 <libbpf_add_mem>
   2e42b: 48 89 c3                     	movq	%rax, %rbx
; 	if (!off)
   2e42e: 48 85 c0                     	testq	%rax, %rax
   2e431: 0f 84 85 01 00 00            	je	0x2e5bc <btf__add_btf+0x24c>
; 	p.str_off_map = hashmap__new(btf_dedup_identity_hash_fn, btf_dedup_equal_fn, NULL);
   2e437: 31 d2                        	xorl	%edx, %edx
   2e439: 48 8d 35 70 a5 ff ff         	leaq	-23184(%rip), %rsi      # 0x289b0 <btf_dedup_equal_fn>
   2e440: 48 8d 3d 49 a5 ff ff         	leaq	-23223(%rip), %rdi      # 0x28990 <btf_dedup_identity_hash_fn>
   2e447: e8 84 ff fe ff               	callq	0x1e3d0 <hashmap__new>
   2e44c: 48 89 44 24 30               	movq	%rax, 48(%rsp)
; 	if (IS_ERR(p.str_off_map))
   2e451: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2e457: 0f 87 5f 01 00 00            	ja	0x2e5bc <btf__add_btf+0x24c>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2e45d: 49 8b 74 24 20               	movq	32(%r12), %rsi
   2e462: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2e467: 4c 89 ff                     	movq	%r15, %rdi
   2e46a: e8 d1 75 fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	for (i = 0; i < cnt; i++) {
   2e46f: 8b 44 24 0c                  	movl	12(%rsp), %eax
   2e473: 85 c0                        	testl	%eax, %eax
   2e475: 0f 8e 15 01 00 00            	jle	0x2e590 <btf__add_btf+0x220>
   2e47b: 48 8d 04 83                  	leaq	(%rbx,%rax,4), %rax
; 		err = btf_type_visit_str_offs(t, btf_rewrite_str, &p);
   2e47f: 4c 8d 74 24 20               	leaq	32(%rsp), %r14
   2e484: 48 89 04 24                  	movq	%rax, (%rsp)
   2e488: 4c 8d 2d 21 da ff ff         	leaq	-9695(%rip), %r13       # 0x2beb0 <btf_rewrite_str>
   2e48f: eb 51                        	jmp	0x2e4e2 <btf__add_btf+0x172>
   2e491: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		*off = t - btf->types_data;
   2e498: 4c 89 f8                     	movq	%r15, %rax
   2e49b: 48 2b 45 20                  	subq	32(%rbp), %rax
; 		err = btf_type_visit_str_offs(t, btf_rewrite_str, &p);
   2e49f: 4c 89 f2                     	movq	%r14, %rdx
   2e4a2: 4c 89 ee                     	movq	%r13, %rsi
; 		*off = t - btf->types_data;
   2e4a5: 89 03                        	movl	%eax, (%rbx)
; 		err = btf_type_visit_str_offs(t, btf_rewrite_str, &p);
   2e4a7: 4c 89 ff                     	movq	%r15, %rdi
   2e4aa: e8 51 fc ff ff               	callq	0x2e100 <btf_type_visit_str_offs>
; 		if (err)
   2e4af: 85 c0                        	testl	%eax, %eax
   2e4b1: 0f 85 c9 00 00 00            	jne	0x2e580 <btf__add_btf+0x210>
; 		err = btf_type_visit_type_ids(t, btf_rewrite_type_ids, btf);
   2e4b7: 48 89 ea                     	movq	%rbp, %rdx
   2e4ba: 48 8d 35 af a4 ff ff         	leaq	-23377(%rip), %rsi      # 0x28970 <btf_rewrite_type_ids>
   2e4c1: 4c 89 ff                     	movq	%r15, %rdi
   2e4c4: e8 e7 fa ff ff               	callq	0x2dfb0 <btf_type_visit_type_ids>
; 		if (err)
   2e4c9: 85 c0                        	testl	%eax, %eax
   2e4cb: 0f 85 af 00 00 00            	jne	0x2e580 <btf__add_btf+0x210>
; 		t += sz;
   2e4d1: 4d 01 e7                     	addq	%r12, %r15
; 		off++;
   2e4d4: 48 83 c3 04                  	addq	$4, %rbx
; 	for (i = 0; i < cnt; i++) {
   2e4d8: 48 3b 1c 24                  	cmpq	(%rsp), %rbx
   2e4dc: 0f 84 ae 00 00 00            	je	0x2e590 <btf__add_btf+0x220>
; 		sz = btf_type_size(t);
   2e4e2: 41 8b 7f 04                  	movl	4(%r15), %edi
   2e4e6: e8 c5 ad ff ff               	callq	0x292b0 <btf_type_size.isra.0>
   2e4eb: 4c 63 e0                     	movslq	%eax, %r12
; 		if (sz < 0) {
   2e4ee: 45 85 e4                     	testl	%r12d, %r12d
   2e4f1: 79 a5                        	jns	0x2e498 <btf__add_btf+0x128>
; 	memset(btf->types_data + btf->hdr->type_len, 0, data_sz);
   2e4f3: 48 8b 45 18                  	movq	24(%rbp), %rax
;   return __builtin___memset_chk (__dest, __ch, __len,
   2e4f7: 48 8b 54 24 10               	movq	16(%rsp), %rdx
   2e4fc: 31 f6                        	xorl	%esi, %esi
; 	memset(btf->types_data + btf->hdr->type_len, 0, data_sz);
   2e4fe: 8b 78 0c                     	movl	12(%rax), %edi
   2e501: 48 03 7d 20                  	addq	32(%rbp), %rdi
;   return __builtin___memset_chk (__dest, __ch, __len,
   2e505: e8 b6 73 fd ff               	callq	0x58c0 <.plt.sec+0x250>
; 	memset(btf->strs_data + old_strs_len, 0, btf->hdr->str_len - old_strs_len);
   2e50a: 48 8b 45 18                  	movq	24(%rbp), %rax
   2e50e: 48 63 7c 24 18               	movslq	24(%rsp), %rdi
;   return __builtin___memset_chk (__dest, __ch, __len,
   2e513: 31 f6                        	xorl	%esi, %esi
; 	memset(btf->strs_data + old_strs_len, 0, btf->hdr->str_len - old_strs_len);
   2e515: 8b 50 14                     	movl	20(%rax), %edx
   2e518: 48 89 fb                     	movq	%rdi, %rbx
   2e51b: 29 fa                        	subl	%edi, %edx
   2e51d: 48 03 7d 58                  	addq	88(%rbp), %rdi
;   return __builtin___memset_chk (__dest, __ch, __len,
   2e521: e8 9a 73 fd ff               	callq	0x58c0 <.plt.sec+0x250>
; 	btf->hdr->str_len = old_strs_len;
   2e526: 48 8b 45 18                  	movq	24(%rbp), %rax
; 	hashmap__free(p.str_off_map);
   2e52a: 48 8b 7c 24 30               	movq	48(%rsp), %rdi
; 	btf->hdr->str_len = old_strs_len;
   2e52f: 89 58 14                     	movl	%ebx, 20(%rax)
; 	hashmap__free(p.str_off_map);
   2e532: e8 79 ff fe ff               	callq	0x1e4b0 <hashmap__free>
; 	if (ret < 0)
   2e537: 45 85 e4                     	testl	%r12d, %r12d
   2e53a: 78 2c                        	js	0x2e568 <btf__add_btf+0x1f8>
; }
   2e53c: 48 8b 44 24 38               	movq	56(%rsp), %rax
   2e541: 64 48 2b 04 25 28 00 00 00   	subq	%fs:40, %rax
   2e54a: 0f 85 98 00 00 00            	jne	0x2e5e8 <btf__add_btf+0x278>
   2e550: 48 83 c4 48                  	addq	$72, %rsp
   2e554: 44 89 e0                     	movl	%r12d, %eax
   2e557: 5b                           	popq	%rbx
   2e558: 5d                           	popq	%rbp
   2e559: 41 5c                        	popq	%r12
   2e55b: 41 5d                        	popq	%r13
   2e55d: 41 5e                        	popq	%r14
   2e55f: 41 5f                        	popq	%r15
   2e561: c3                           	retq
   2e562: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		errno = -ret;
   2e568: e8 83 71 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2e56d: 44 89 e2                     	movl	%r12d, %edx
   2e570: f7 da                        	negl	%edx
   2e572: 89 10                        	movl	%edx, (%rax)
   2e574: eb c6                        	jmp	0x2e53c <btf__add_btf+0x1cc>
   2e576: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   2e580: 41 89 c4                     	movl	%eax, %r12d
   2e583: e9 6b ff ff ff               	jmp	0x2e4f3 <btf__add_btf+0x183>
   2e588: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 	btf->hdr->type_len += data_sz;
   2e590: 48 8b 45 18                  	movq	24(%rbp), %rax
   2e594: 8b 4c 24 1c                  	movl	28(%rsp), %ecx
; 	btf->nr_types += cnt;
   2e598: 8b 5c 24 0c                  	movl	12(%rsp), %ebx
; 	hashmap__free(p.str_off_map);
   2e59c: 48 8b 7c 24 30               	movq	48(%rsp), %rdi
; 	btf->hdr->type_len += data_sz;
   2e5a1: 01 48 0c                     	addl	%ecx, 12(%rax)
; 	btf->hdr->str_off += data_sz;
   2e5a4: 01 48 10                     	addl	%ecx, 16(%rax)
; 	btf->nr_types += cnt;
   2e5a7: 01 5d 40                     	addl	%ebx, 64(%rbp)
; 	hashmap__free(p.str_off_map);
   2e5aa: e8 01 ff fe ff               	callq	0x1e4b0 <hashmap__free>
; 	return btf->start_id + btf->nr_types - cnt;
   2e5af: 44 8b 65 40                  	movl	64(%rbp), %r12d
   2e5b3: 44 03 65 50                  	addl	80(%rbp), %r12d
   2e5b7: 41 29 dc                     	subl	%ebx, %r12d
   2e5ba: eb 80                        	jmp	0x2e53c <btf__add_btf+0x1cc>
; 		errno = -ret;
   2e5bc: e8 2f 71 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOMEM);
   2e5c1: 41 bc f4 ff ff ff            	movl	$4294967284, %r12d      # imm = 0xFFFFFFF4
; 		errno = -ret;
   2e5c7: c7 00 0c 00 00 00            	movl	$12, (%rax)
   2e5cd: e9 6a ff ff ff               	jmp	0x2e53c <btf__add_btf+0x1cc>
   2e5d2: e8 19 71 fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-ENOTSUP);
   2e5d7: 41 bc a1 ff ff ff            	movl	$4294967201, %r12d      # imm = 0xFFFFFFA1
; 		errno = -ret;
   2e5dd: c7 00 5f 00 00 00            	movl	$95, (%rax)
   2e5e3: e9 54 ff ff ff               	jmp	0x2e53c <btf__add_btf+0x1cc>
; }
   2e5e8: e8 13 72 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2e5ed: 0f 1f 00                     	nopl	(%rax)

000000000002e5f0 <btf_ext_visit_type_ids>:
; {
   2e5f0: f3 0f 1e fa                  	endbr64
   2e5f4: 41 57                        	pushq	%r15
   2e5f6: 41 56                        	pushq	%r14
   2e5f8: 41 55                        	pushq	%r13
   2e5fa: 41 54                        	pushq	%r12
   2e5fc: 49 89 d4                     	movq	%rdx, %r12
   2e5ff: 55                           	pushq	%rbp
   2e600: 48 89 f5                     	movq	%rsi, %rbp
   2e603: 53                           	pushq	%rbx
   2e604: 48 89 fb                     	movq	%rdi, %rbx
   2e607: 48 83 ec 08                  	subq	$8, %rsp
; 	for_each_btf_ext_sec(seg, sec) {
   2e60b: 48 8b 57 08                  	movq	8(%rdi), %rdx
   2e60f: 8b 4f 14                     	movl	20(%rdi), %ecx
   2e612: 48 8d 04 0a                  	leaq	(%rdx,%rcx), %rax
   2e616: 49 89 d5                     	movq	%rdx, %r13
   2e619: 48 39 c2                     	cmpq	%rax, %rdx
   2e61c: 73 6c                        	jae	0x2e68a <btf_ext_visit_type_ids+0x9a>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e61e: 41 8b 75 04                  	movl	4(%r13), %esi
   2e622: 4d 8d 75 08                  	leaq	8(%r13), %r14
   2e626: 85 f6                        	testl	%esi, %esi
   2e628: 0f 84 aa 00 00 00            	je	0x2e6d8 <btf_ext_visit_type_ids+0xe8>
   2e62e: 45 31 ff                     	xorl	%r15d, %r15d
   2e631: eb 1b                        	jmp	0x2e64e <btf_ext_visit_type_ids+0x5e>
   2e633: 0f 1f 44 00 00               	nopl	(%rax,%rax)
   2e638: 8b 53 10                     	movl	16(%rbx), %edx
   2e63b: 41 83 c7 01                  	addl	$1, %r15d
   2e63f: 48 89 d0                     	movq	%rdx, %rax
   2e642: 49 01 d6                     	addq	%rdx, %r14
   2e645: 41 8b 55 04                  	movl	4(%r13), %edx
   2e649: 44 39 fa                     	cmpl	%r15d, %edx
   2e64c: 76 22                        	jbe	0x2e670 <btf_ext_visit_type_ids+0x80>
; 			err = visit(&rec->type_id, ctx);
   2e64e: 49 8d 7e 04                  	leaq	4(%r14), %rdi
   2e652: 4c 89 e6                     	movq	%r12, %rsi
   2e655: ff d5                        	callq	*%rbp
; 			if (err < 0)
   2e657: 85 c0                        	testl	%eax, %eax
   2e659: 79 dd                        	jns	0x2e638 <btf_ext_visit_type_ids+0x48>
; }
   2e65b: 48 83 c4 08                  	addq	$8, %rsp
   2e65f: 5b                           	popq	%rbx
   2e660: 5d                           	popq	%rbp
   2e661: 41 5c                        	popq	%r12
   2e663: 41 5d                        	popq	%r13
   2e665: 41 5e                        	popq	%r14
   2e667: 41 5f                        	popq	%r15
   2e669: c3                           	retq
   2e66a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	for_each_btf_ext_sec(seg, sec) {
   2e670: 0f af c2                     	imull	%edx, %eax
   2e673: 8b 4b 14                     	movl	20(%rbx), %ecx
   2e676: 48 8b 53 08                  	movq	8(%rbx), %rdx
   2e67a: 48 83 c0 08                  	addq	$8, %rax
   2e67e: 49 01 c5                     	addq	%rax, %r13
   2e681: 48 8d 04 0a                  	leaq	(%rdx,%rcx), %rax
   2e685: 49 39 c5                     	cmpq	%rax, %r13
   2e688: 72 94                        	jb	0x2e61e <btf_ext_visit_type_ids+0x2e>
; 	for_each_btf_ext_sec(seg, sec) {
   2e68a: 48 8b 53 48                  	movq	72(%rbx), %rdx
   2e68e: 8b 4b 54                     	movl	84(%rbx), %ecx
   2e691: 48 8d 04 0a                  	leaq	(%rdx,%rcx), %rax
   2e695: 49 89 d5                     	movq	%rdx, %r13
   2e698: 48 39 c2                     	cmpq	%rax, %rdx
   2e69b: 73 5c                        	jae	0x2e6f9 <btf_ext_visit_type_ids+0x109>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e69d: 41 8b 45 04                  	movl	4(%r13), %eax
   2e6a1: 4d 8d 75 08                  	leaq	8(%r13), %r14
   2e6a5: 85 c0                        	testl	%eax, %eax
   2e6a7: 74 57                        	je	0x2e700 <btf_ext_visit_type_ids+0x110>
   2e6a9: 45 31 ff                     	xorl	%r15d, %r15d
   2e6ac: eb 18                        	jmp	0x2e6c6 <btf_ext_visit_type_ids+0xd6>
   2e6ae: 66 90                        	nop
   2e6b0: 8b 53 50                     	movl	80(%rbx), %edx
   2e6b3: 41 83 c7 01                  	addl	$1, %r15d
   2e6b7: 48 89 d0                     	movq	%rdx, %rax
   2e6ba: 49 01 d6                     	addq	%rdx, %r14
   2e6bd: 41 8b 55 04                  	movl	4(%r13), %edx
   2e6c1: 44 39 fa                     	cmpl	%r15d, %edx
   2e6c4: 76 19                        	jbe	0x2e6df <btf_ext_visit_type_ids+0xef>
; 			err = visit(&rec->type_id, ctx);
   2e6c6: 49 8d 7e 04                  	leaq	4(%r14), %rdi
   2e6ca: 4c 89 e6                     	movq	%r12, %rsi
   2e6cd: ff d5                        	callq	*%rbp
; 			if (err < 0)
   2e6cf: 85 c0                        	testl	%eax, %eax
   2e6d1: 79 dd                        	jns	0x2e6b0 <btf_ext_visit_type_ids+0xc0>
   2e6d3: e9 83 ff ff ff               	jmp	0x2e65b <btf_ext_visit_type_ids+0x6b>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e6d8: b8 08 00 00 00               	movl	$8, %eax
   2e6dd: eb 9f                        	jmp	0x2e67e <btf_ext_visit_type_ids+0x8e>
; 	for_each_btf_ext_sec(seg, sec) {
   2e6df: 0f af c2                     	imull	%edx, %eax
   2e6e2: 8b 4b 54                     	movl	84(%rbx), %ecx
   2e6e5: 48 8b 53 48                  	movq	72(%rbx), %rdx
   2e6e9: 48 83 c0 08                  	addq	$8, %rax
   2e6ed: 49 01 c5                     	addq	%rax, %r13
   2e6f0: 48 8d 04 0a                  	leaq	(%rdx,%rcx), %rax
   2e6f4: 49 39 c5                     	cmpq	%rax, %r13
   2e6f7: 72 a4                        	jb	0x2e69d <btf_ext_visit_type_ids+0xad>
; 	return 0;
   2e6f9: 31 c0                        	xorl	%eax, %eax
   2e6fb: e9 5b ff ff ff               	jmp	0x2e65b <btf_ext_visit_type_ids+0x6b>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e700: b8 08 00 00 00               	movl	$8, %eax
   2e705: eb e6                        	jmp	0x2e6ed <btf_ext_visit_type_ids+0xfd>
   2e707: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)

000000000002e710 <btf_ext_visit_str_offs>:
; {
   2e710: f3 0f 1e fa                  	endbr64
   2e714: 41 57                        	pushq	%r15
   2e716: 41 56                        	pushq	%r14
   2e718: 41 55                        	pushq	%r13
   2e71a: 41 54                        	pushq	%r12
   2e71c: 49 89 d4                     	movq	%rdx, %r12
   2e71f: 55                           	pushq	%rbp
   2e720: 48 89 f5                     	movq	%rsi, %rbp
   2e723: 53                           	pushq	%rbx
   2e724: 48 89 fb                     	movq	%rdi, %rbx
   2e727: 48 83 ec 08                  	subq	$8, %rsp
; 	for_each_btf_ext_sec(seg, sec) {
   2e72b: 4c 8b 6f 08                  	movq	8(%rdi), %r13
   2e72f: 8b 47 14                     	movl	20(%rdi), %eax
   2e732: 4c 01 e8                     	addq	%r13, %rax
   2e735: 49 39 c5                     	cmpq	%rax, %r13
   2e738: 72 1f                        	jb	0x2e759 <btf_ext_visit_str_offs+0x49>
   2e73a: eb 3c                        	jmp	0x2e778 <btf_ext_visit_str_offs+0x68>
   2e73c: 0f 1f 40 00                  	nopl	(%rax)
   2e740: 8b 43 10                     	movl	16(%rbx), %eax
   2e743: 41 0f af 45 04               	imull	4(%r13), %eax
   2e748: 4d 8d 6c 05 08               	leaq	8(%r13,%rax), %r13
   2e74d: 8b 43 14                     	movl	20(%rbx), %eax
   2e750: 48 03 43 08                  	addq	8(%rbx), %rax
   2e754: 49 39 c5                     	cmpq	%rax, %r13
   2e757: 73 1f                        	jae	0x2e778 <btf_ext_visit_str_offs+0x68>
; 		err = visit(&sec->sec_name_off, ctx);
   2e759: 4c 89 e6                     	movq	%r12, %rsi
   2e75c: 4c 89 ef                     	movq	%r13, %rdi
   2e75f: ff d5                        	callq	*%rbp
; 		if (err)
   2e761: 85 c0                        	testl	%eax, %eax
   2e763: 74 db                        	je	0x2e740 <btf_ext_visit_str_offs+0x30>
; }
   2e765: 48 83 c4 08                  	addq	$8, %rsp
   2e769: 5b                           	popq	%rbx
   2e76a: 5d                           	popq	%rbp
   2e76b: 41 5c                        	popq	%r12
   2e76d: 41 5d                        	popq	%r13
   2e76f: 41 5e                        	popq	%r14
   2e771: 41 5f                        	popq	%r15
   2e773: c3                           	retq
   2e774: 0f 1f 40 00                  	nopl	(%rax)
; 	for_each_btf_ext_sec(seg, sec) {
   2e778: 4c 8b 7b 28                  	movq	40(%rbx), %r15
   2e77c: 8b 43 34                     	movl	52(%rbx), %eax
   2e77f: 4c 01 f8                     	addq	%r15, %rax
   2e782: 49 39 c7                     	cmpq	%rax, %r15
   2e785: 73 7f                        	jae	0x2e806 <btf_ext_visit_str_offs+0xf6>
; 		err = visit(&sec->sec_name_off, ctx);
   2e787: 4c 89 e6                     	movq	%r12, %rsi
   2e78a: 4c 89 ff                     	movq	%r15, %rdi
   2e78d: ff d5                        	callq	*%rbp
   2e78f: 41 89 c6                     	movl	%eax, %r14d
; 		if (err)
   2e792: 85 c0                        	testl	%eax, %eax
   2e794: 0f 85 cd 00 00 00            	jne	0x2e867 <btf_ext_visit_str_offs+0x157>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e79a: 41 8b 57 04                  	movl	4(%r15), %edx
   2e79e: 4d 8d 6f 08                  	leaq	8(%r15), %r13
   2e7a2: 85 d2                        	testl	%edx, %edx
   2e7a4: 75 2d                        	jne	0x2e7d3 <btf_ext_visit_str_offs+0xc3>
   2e7a6: e9 b5 00 00 00               	jmp	0x2e860 <btf_ext_visit_str_offs+0x150>
   2e7ab: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 			err = visit(&rec->line_off, ctx);
   2e7b0: 49 8d 7d 08                  	leaq	8(%r13), %rdi
   2e7b4: 4c 89 e6                     	movq	%r12, %rsi
   2e7b7: ff d5                        	callq	*%rbp
; 			if (err)
   2e7b9: 85 c0                        	testl	%eax, %eax
   2e7bb: 75 a8                        	jne	0x2e765 <btf_ext_visit_str_offs+0x55>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e7bd: 8b 53 30                     	movl	48(%rbx), %edx
   2e7c0: 41 83 c6 01                  	addl	$1, %r14d
   2e7c4: 48 89 d0                     	movq	%rdx, %rax
   2e7c7: 49 01 d5                     	addq	%rdx, %r13
   2e7ca: 41 8b 57 04                  	movl	4(%r15), %edx
   2e7ce: 44 39 f2                     	cmpl	%r14d, %edx
   2e7d1: 76 1d                        	jbe	0x2e7f0 <btf_ext_visit_str_offs+0xe0>
; 			err = visit(&rec->file_name_off, ctx);
   2e7d3: 49 8d 7d 04                  	leaq	4(%r13), %rdi
   2e7d7: 4c 89 e6                     	movq	%r12, %rsi
   2e7da: ff d5                        	callq	*%rbp
; 			if (err)
   2e7dc: 85 c0                        	testl	%eax, %eax
   2e7de: 74 d0                        	je	0x2e7b0 <btf_ext_visit_str_offs+0xa0>
; }
   2e7e0: 48 83 c4 08                  	addq	$8, %rsp
   2e7e4: 5b                           	popq	%rbx
   2e7e5: 5d                           	popq	%rbp
   2e7e6: 41 5c                        	popq	%r12
   2e7e8: 41 5d                        	popq	%r13
   2e7ea: 41 5e                        	popq	%r14
   2e7ec: 41 5f                        	popq	%r15
   2e7ee: c3                           	retq
   2e7ef: 90                           	nop
; 	for_each_btf_ext_sec(seg, sec) {
   2e7f0: 0f af c2                     	imull	%edx, %eax
   2e7f3: 48 83 c0 08                  	addq	$8, %rax
   2e7f7: 49 01 c7                     	addq	%rax, %r15
   2e7fa: 8b 43 34                     	movl	52(%rbx), %eax
   2e7fd: 48 03 43 28                  	addq	40(%rbx), %rax
   2e801: 49 39 c7                     	cmpq	%rax, %r15
   2e804: 72 81                        	jb	0x2e787 <btf_ext_visit_str_offs+0x77>
; 	for_each_btf_ext_sec(seg, sec) {
   2e806: 4c 8b 6b 48                  	movq	72(%rbx), %r13
   2e80a: 8b 43 54                     	movl	84(%rbx), %eax
   2e80d: 4c 01 e8                     	addq	%r13, %rax
   2e810: 49 39 c5                     	cmpq	%rax, %r13
   2e813: 73 70                        	jae	0x2e885 <btf_ext_visit_str_offs+0x175>
; 		err = visit(&sec->sec_name_off, ctx);
   2e815: 4c 89 e6                     	movq	%r12, %rsi
   2e818: 4c 89 ef                     	movq	%r13, %rdi
   2e81b: ff d5                        	callq	*%rbp
   2e81d: 41 89 c6                     	movl	%eax, %r14d
; 		if (err)
   2e820: 85 c0                        	testl	%eax, %eax
   2e822: 75 43                        	jne	0x2e867 <btf_ext_visit_str_offs+0x157>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e824: 41 8b 45 04                  	movl	4(%r13), %eax
   2e828: 4d 8d 7d 08                  	leaq	8(%r13), %r15
   2e82c: 85 c0                        	testl	%eax, %eax
   2e82e: 75 1e                        	jne	0x2e84e <btf_ext_visit_str_offs+0x13e>
   2e830: eb 5a                        	jmp	0x2e88c <btf_ext_visit_str_offs+0x17c>
   2e832: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2e838: 8b 53 50                     	movl	80(%rbx), %edx
   2e83b: 41 83 c6 01                  	addl	$1, %r14d
   2e83f: 48 89 d0                     	movq	%rdx, %rax
   2e842: 49 01 d7                     	addq	%rdx, %r15
   2e845: 41 8b 55 04                  	movl	4(%r13), %edx
   2e849: 44 39 f2                     	cmpl	%r14d, %edx
   2e84c: 76 21                        	jbe	0x2e86f <btf_ext_visit_str_offs+0x15f>
; 			err = visit(&rec->access_str_off, ctx);
   2e84e: 49 8d 7f 08                  	leaq	8(%r15), %rdi
   2e852: 4c 89 e6                     	movq	%r12, %rsi
   2e855: ff d5                        	callq	*%rbp
; 			if (err)
   2e857: 85 c0                        	testl	%eax, %eax
   2e859: 74 dd                        	je	0x2e838 <btf_ext_visit_str_offs+0x128>
   2e85b: e9 05 ff ff ff               	jmp	0x2e765 <btf_ext_visit_str_offs+0x55>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e860: b8 08 00 00 00               	movl	$8, %eax
   2e865: eb 90                        	jmp	0x2e7f7 <btf_ext_visit_str_offs+0xe7>
   2e867: 44 89 f0                     	movl	%r14d, %eax
   2e86a: e9 f6 fe ff ff               	jmp	0x2e765 <btf_ext_visit_str_offs+0x55>
; 	for_each_btf_ext_sec(seg, sec) {
   2e86f: 0f af c2                     	imull	%edx, %eax
   2e872: 48 83 c0 08                  	addq	$8, %rax
   2e876: 49 01 c5                     	addq	%rax, %r13
   2e879: 8b 43 54                     	movl	84(%rbx), %eax
   2e87c: 48 03 43 48                  	addq	72(%rbx), %rax
   2e880: 49 39 c5                     	cmpq	%rax, %r13
   2e883: 72 90                        	jb	0x2e815 <btf_ext_visit_str_offs+0x105>
; 	return 0;
   2e885: 31 c0                        	xorl	%eax, %eax
   2e887: e9 d9 fe ff ff               	jmp	0x2e765 <btf_ext_visit_str_offs+0x55>
; 		for_each_btf_ext_rec(seg, sec, i, rec) {
   2e88c: b8 08 00 00 00               	movl	$8, %eax
   2e891: eb e3                        	jmp	0x2e876 <btf_ext_visit_str_offs+0x166>
   2e893: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2e89e: 66 90                        	nop

000000000002e8a0 <btf__dedup>:
; {
   2e8a0: f3 0f 1e fa                  	endbr64
   2e8a4: 41 57                        	pushq	%r15
   2e8a6: 41 56                        	pushq	%r14
   2e8a8: 41 55                        	pushq	%r13
   2e8aa: 41 54                        	pushq	%r12
   2e8ac: 55                           	pushq	%rbp
   2e8ad: 48 89 fd                     	movq	%rdi, %rbp
   2e8b0: 53                           	pushq	%rbx
   2e8b1: 48 89 f3                     	movq	%rsi, %rbx
   2e8b4: 48 83 ec 68                  	subq	$104, %rsp
; 	if (!OPTS_VALID(opts, btf_dedup_opts))
   2e8b8: 48 85 f6                     	testq	%rsi, %rsi
   2e8bb: 0f 84 d8 0c 00 00            	je	0x2f599 <btf__dedup+0xcf9>
   2e8c1: 4c 8b 26                     	movq	(%rsi), %r12
; 	if (user_sz < sizeof(size_t)) {
   2e8c4: 49 83 fc 07                  	cmpq	$7, %r12
   2e8c8: 0f 86 75 0e 00 00            	jbe	0x2f743 <btf__dedup+0xea3>
; 	if (!libbpf_is_mem_zeroed(opts + opts_sz, (ssize_t)user_sz - opts_sz)) {
   2e8ce: 49 8d 54 24 ef               	leaq	-17(%r12), %rdx
   2e8d3: 48 8d 46 11                  	leaq	17(%rsi), %rax
; 	while (len > 0) {
   2e8d7: 48 85 d2                     	testq	%rdx, %rdx
   2e8da: 7e 4c                        	jle	0x2e928 <btf__dedup+0x88>
   2e8dc: 4a 8d 14 26                  	leaq	(%rsi,%r12), %rdx
   2e8e0: eb 0f                        	jmp	0x2e8f1 <btf__dedup+0x51>
   2e8e2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		p++;
   2e8e8: 48 83 c0 01                  	addq	$1, %rax
; 	while (len > 0) {
   2e8ec: 48 39 d0                     	cmpq	%rdx, %rax
   2e8ef: 74 37                        	je	0x2e928 <btf__dedup+0x88>
; 		if (*p)
   2e8f1: 80 38 00                     	cmpb	$0, (%rax)
   2e8f4: 74 f2                        	je	0x2e8e8 <btf__dedup+0x48>
; 		pr_warn("%s has non-zero extra bytes\n", type_name);
   2e8f6: 48 8d 15 19 d3 00 00         	leaq	54041(%rip), %rdx       # 0x3bc16 <CSWTCH.126+0x2316>
   2e8fd: 48 8d 35 0c 57 00 00         	leaq	22284(%rip), %rsi       # 0x34010 <strs.2+0x1180>
   2e904: 31 ff                        	xorl	%edi, %edi
   2e906: 31 c0                        	xorl	%eax, %eax
   2e908: e8 c3 97 fd ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   2e90d: e8 de 6d fd ff               	callq	0x56f0 <.plt.sec+0x80>
; 		return libbpf_err(-EINVAL);
   2e912: 41 be ea ff ff ff            	movl	$4294967274, %r14d      # imm = 0xFFFFFFEA
; 		errno = -ret;
   2e918: c7 00 16 00 00 00            	movl	$22, (%rax)
   2e91e: e9 7b 0b 00 00               	jmp	0x2f49e <btf__dedup+0xbfe>
   2e923: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 	struct btf_dedup *d = calloc(1, sizeof(struct btf_dedup));
   2e928: be 68 00 00 00               	movl	$104, %esi
   2e92d: bf 01 00 00 00               	movl	$1, %edi
   2e932: e8 59 70 fd ff               	callq	0x5990 <.plt.sec+0x320>
   2e937: 49 89 c7                     	movq	%rax, %r15
; 	if (!d)
   2e93a: 48 85 c0                     	testq	%rax, %rax
   2e93d: 0f 84 84 12 00 00            	je	0x2fbc7 <btf__dedup+0x1327>
; 	if (OPTS_GET(opts, force_collisions, false))
   2e943: 49 83 fc 10                  	cmpq	$16, %r12
   2e947: 0f 86 35 0c 00 00            	jbe	0x2f582 <btf__dedup+0xce2>
; 		hash_fn = btf_dedup_collision_hash_fn;
   2e94d: 80 7b 10 00                  	cmpb	$0, 16(%rbx)
   2e951: 48 8d 3d 38 a0 ff ff         	leaq	-24520(%rip), %rdi      # 0x28990 <btf_dedup_identity_hash_fn>
   2e958: 48 8d 05 41 a0 ff ff         	leaq	-24511(%rip), %rax      # 0x289a0 <btf_dedup_collision_hash_fn>
; 	d->btf = btf;
   2e95f: 49 89 2f                     	movq	%rbp, (%r15)
; 		hash_fn = btf_dedup_collision_hash_fn;
   2e962: 48 0f 45 f8                  	cmovneq	%rax, %rdi
; 	d->btf_ext = OPTS_GET(opts, btf_ext, NULL);
   2e966: 48 8b 5b 08                  	movq	8(%rbx), %rbx
   2e96a: 49 89 5f 08                  	movq	%rbx, 8(%r15)
; 	d->dedup_table = hashmap__new(hash_fn, btf_dedup_equal_fn, NULL);
   2e96e: 31 d2                        	xorl	%edx, %edx
   2e970: 48 8d 35 39 a0 ff ff         	leaq	-24519(%rip), %rsi      # 0x289b0 <btf_dedup_equal_fn>
   2e977: e8 54 fa fe ff               	callq	0x1e3d0 <hashmap__new>
   2e97c: 49 89 47 10                  	movq	%rax, 16(%r15)
   2e980: 49 89 c4                     	movq	%rax, %r12
; 	if (IS_ERR(d->dedup_table)) {
   2e983: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2e989: 0f 86 21 0b 00 00            	jbe	0x2f4b0 <btf__dedup+0xc10>
; 		d->dedup_table = NULL;
   2e98f: 49 c7 47 10 00 00 00 00      	movq	$0, 16(%r15)
; 		err = PTR_ERR(d->dedup_table);
   2e997: 89 c3                        	movl	%eax, %ebx
; 	if (err) {
   2e999: 85 c0                        	testl	%eax, %eax
   2e99b: 74 31                        	je	0x2e9ce <btf__dedup+0x12e>
   2e99d: 45 31 e4                     	xorl	%r12d, %r12d
; 	hashmap__free(d->dedup_table);
   2e9a0: 4c 89 e7                     	movq	%r12, %rdi
   2e9a3: e8 08 fb fe ff               	callq	0x1e4b0 <hashmap__free>
; 	free(d->map);
   2e9a8: 49 8b 7f 18                  	movq	24(%r15), %rdi
   2e9ac: e8 0f 6d fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d->hypot_map);
   2e9b1: 49 8b 7f 20                  	movq	32(%r15), %rdi
   2e9b5: e8 06 6d fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d->hypot_list);
   2e9ba: 49 8b 7f 28                  	movq	40(%r15), %rdi
   2e9be: e8 fd 6c fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d);
   2e9c3: 4c 89 ff                     	movq	%r15, %rdi
; 		return ERR_PTR(err);
   2e9c6: 4c 63 fb                     	movslq	%ebx, %r15
; 	free(d);
   2e9c9: e8 f2 6c fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (IS_ERR(d)) {
   2e9ce: 49 81 ff 00 f0 ff ff         	cmpq	$-4096, %r15            # imm = 0xF000
   2e9d5: 0f 87 87 11 00 00            	ja	0x2fb62 <btf__dedup+0x12c2>
; 	if (btf_ensure_modifiable(btf)) {
   2e9db: 48 89 ef                     	movq	%rbp, %rdi
   2e9de: e8 bd a9 ff ff               	callq	0x293a0 <btf_ensure_modifiable>
   2e9e3: 85 c0                        	testl	%eax, %eax
   2e9e5: 0f 85 75 0a 00 00            	jne	0x2f460 <btf__dedup+0xbc0>
; 	if (!d->btf->base_btf)
   2e9eb: 4d 8b 1f                     	movq	(%r15), %r11
   2e9ee: 49 83 7b 48 00               	cmpq	$0, 72(%r11)
   2e9f3: 4c 89 d8                     	movq	%r11, %rax
   2e9f6: 0f 84 c8 00 00 00            	je	0x2eac4 <btf__dedup+0x224>
; 	for (type_id = 1; type_id < d->btf->start_id; type_id++) {
   2e9fc: 41 8b 53 50                  	movl	80(%r11), %edx
   2ea00: 83 fa 01                     	cmpl	$1, %edx
   2ea03: 0f 8e bb 00 00 00            	jle	0x2eac4 <btf__dedup+0x224>
   2ea09: bb 01 00 00 00               	movl	$1, %ebx
; 		switch (btf_kind(t)) {
   2ea0e: 48 8d 2d c7 d0 00 00         	leaq	53447(%rip), %rbp       # 0x3badc <CSWTCH.126+0x21dc>
   2ea15: 0f 1f 00                     	nopl	(%rax)
   2ea18: 89 d9                        	movl	%ebx, %ecx
   2ea1a: 41 89 d8                     	movl	%ebx, %r8d
; 	if (type_id < btf->start_id)
   2ea1d: 39 da                        	cmpl	%ebx, %edx
   2ea1f: 76 12                        	jbe	0x2ea33 <btf__dedup+0x193>
   2ea21: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2ea28: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2ea2c: 8b 50 50                     	movl	80(%rax), %edx
   2ea2f: 39 ca                        	cmpl	%ecx, %edx
   2ea31: 77 f5                        	ja	0x2ea28 <btf__dedup+0x188>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2ea33: 89 ce                        	movl	%ecx, %esi
   2ea35: 29 d6                        	subl	%edx, %esi
   2ea37: 48 8b 50 30                  	movq	48(%rax), %rdx
   2ea3b: 8b 3c b2                     	movl	(%rdx,%rsi,4), %edi
   2ea3e: 48 03 78 20                  	addq	32(%rax), %rdi
; 		d->map[type_id] = type_id;
   2ea42: 49 8b 47 18                  	movq	24(%r15), %rax
   2ea46: 89 0c 98                     	movl	%ecx, (%rax,%rbx,4)
; 	return BTF_INFO_KIND(t->info);
   2ea49: 8b 4f 04                     	movl	4(%rdi), %ecx
   2ea4c: 89 c8                        	movl	%ecx, %eax
   2ea4e: c1 e8 18                     	shrl	$24, %eax
   2ea51: 83 e0 1f                     	andl	$31, %eax
; 		switch (btf_kind(t)) {
   2ea54: 66 83 f8 13                  	cmpw	$19, %ax
   2ea58: 0f 87 65 0b 00 00            	ja	0x2f5c3 <btf__dedup+0xd23>
   2ea5e: 0f b7 d0                     	movzwl	%ax, %edx
   2ea61: 48 63 54 95 00               	movslq	(%rbp,%rdx,4), %rdx
   2ea66: 48 01 ea                     	addq	%rbp, %rdx
   2ea69: 3e ff e2                     	jmpq	*%rdx
   2ea6c: 0f 1f 40 00                  	nopl	(%rax)
; 	h = hash_combine(0, t->name_off);
   2ea70: 8b 17                        	movl	(%rdi), %edx
; 	return h * 31 + value;
   2ea72: 48 89 d0                     	movq	%rdx, %rax
   2ea75: 48 c1 e0 05                  	shlq	$5, %rax
   2ea79: 48 29 d0                     	subq	%rdx, %rax
   2ea7c: 48 01 c8                     	addq	%rcx, %rax
   2ea7f: 48 89 c6                     	movq	%rax, %rsi
   2ea82: 48 c1 e6 05                  	shlq	$5, %rsi
   2ea86: 48 29 c6                     	subq	%rax, %rsi
; 	h = hash_combine(h, t->size);
   2ea89: 8b 47 08                     	movl	8(%rdi), %eax
; 	return h * 31 + value;
   2ea8c: 48 01 c6                     	addq	%rax, %rsi
; 	return hashmap__insert(map, key, value, HASHMAP_APPEND, NULL, NULL);
   2ea8f: 49 8b 7f 10                  	movq	16(%r15), %rdi
   2ea93: 45 31 c9                     	xorl	%r9d, %r9d
   2ea96: 45 31 c0                     	xorl	%r8d, %r8d
   2ea99: b9 03 00 00 00               	movl	$3, %ecx
   2ea9e: 48 89 da                     	movq	%rbx, %rdx
   2eaa1: e8 6a fa fe ff               	callq	0x1e510 <hashmap__insert>
; 		if (btf_dedup_table_add(d, h, type_id))
   2eaa6: 85 c0                        	testl	%eax, %eax
   2eaa8: 0f 85 4a 10 00 00            	jne	0x2faf8 <btf__dedup+0x1258>
   2eaae: 4d 8b 1f                     	movq	(%r15), %r11
; 	for (type_id = 1; type_id < d->btf->start_id; type_id++) {
   2eab1: 41 8b 53 50                  	movl	80(%r11), %edx
   2eab5: 48 83 c3 01                  	addq	$1, %rbx
   2eab9: 4c 89 d8                     	movq	%r11, %rax
   2eabc: 39 da                        	cmpl	%ebx, %edx
   2eabe: 0f 8f 54 ff ff ff            	jg	0x2ea18 <btf__dedup+0x178>
; 	if (d->btf->strs_deduped)
   2eac4: 41 80 7b 68 00               	cmpb	$0, 104(%r11)
   2eac9: 0f 84 33 0b 00 00            	je	0x2f602 <btf__dedup+0xd62>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2eacf: 41 8b 73 40                  	movl	64(%r11), %esi
   2ead3: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 		return &btf_void;
   2eadb: 4c 8d 35 ae 87 01 00         	leaq	100270(%rip), %r14      # 0x47290 <btf_void>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2eae2: 85 f6                        	testl	%esi, %esi
   2eae4: 0f 84 f2 0c 00 00            	je	0x2f7dc <btf__dedup+0xf3c>
   2eaea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		err = btf_dedup_prim_type(d, d->btf->start_id + i);
   2eaf0: 41 8b 53 50                  	movl	80(%r11), %edx
; 	if (type_id == 0)
   2eaf4: 8b 5c 24 08                  	movl	8(%rsp), %ebx
; 		return &btf_void;
   2eaf8: 4d 89 f4                     	movq	%r14, %r12
; 	if (type_id == 0)
   2eafb: 01 d3                        	addl	%edx, %ebx
   2eafd: 75 10                        	jne	0x2eb0f <btf__dedup+0x26f>
   2eaff: eb 22                        	jmp	0x2eb23 <btf__dedup+0x283>
   2eb01: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2eb08: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2eb0c: 8b 50 50                     	movl	80(%rax), %edx
   2eb0f: 39 d3                        	cmpl	%edx, %ebx
   2eb11: 72 f5                        	jb	0x2eb08 <btf__dedup+0x268>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2eb13: 89 d9                        	movl	%ebx, %ecx
   2eb15: 29 d1                        	subl	%edx, %ecx
   2eb17: 48 8b 50 30                  	movq	48(%rax), %rdx
   2eb1b: 44 8b 24 8a                  	movl	(%rdx,%rcx,4), %r12d
   2eb1f: 4c 03 60 20                  	addq	32(%rax), %r12
; 	return BTF_INFO_KIND(t->info);
   2eb23: 41 8b 54 24 04               	movl	4(%r12), %edx
   2eb28: 89 d0                        	movl	%edx, %eax
   2eb2a: c1 e8 18                     	shrl	$24, %eax
   2eb2d: 83 e0 1f                     	andl	$31, %eax
; 	switch (btf_kind(t)) {
   2eb30: 66 83 f8 13                  	cmpw	$19, %ax
   2eb34: 0f 87 96 10 00 00            	ja	0x2fbd0 <btf__dedup+0x1330>
   2eb3a: 48 8d 3d eb cf 00 00         	leaq	53227(%rip), %rdi       # 0x3bb2c <CSWTCH.126+0x222c>
   2eb41: 0f b7 c0                     	movzwl	%ax, %eax
   2eb44: 48 63 04 87                  	movslq	(%rdi,%rax,4), %rax
   2eb48: 48 01 f8                     	addq	%rdi, %rax
   2eb4b: 3e ff e0                     	jmpq	*%rax
; 	h = hash_combine(0, t->name_off);
   2eb4e: 8b 07                        	movl	(%rdi), %eax
; 	return h * 31 + value;
   2eb50: 48 89 c2                     	movq	%rax, %rdx
   2eb53: 48 c1 e2 05                  	shlq	$5, %rdx
   2eb57: 48 29 c2                     	subq	%rax, %rdx
   2eb5a: 48 01 ca                     	addq	%rcx, %rdx
   2eb5d: 48 89 d0                     	movq	%rdx, %rax
   2eb60: 48 c1 e0 05                  	shlq	$5, %rax
   2eb64: 48 29 d0                     	subq	%rdx, %rax
; 	h = hash_combine(h, t->size);
   2eb67: 8b 57 08                     	movl	8(%rdi), %edx
; 	return h * 31 + value;
   2eb6a: 48 01 d0                     	addq	%rdx, %rax
   2eb6d: 48 89 c6                     	movq	%rax, %rsi
   2eb70: 48 c1 e6 05                  	shlq	$5, %rsi
   2eb74: 48 29 c6                     	subq	%rax, %rsi
; 	h = hash_combine(h, info);
   2eb77: 8b 47 0c                     	movl	12(%rdi), %eax
; 	return h * 31 + value;
   2eb7a: 48 01 c6                     	addq	%rax, %rsi
; 			break;
   2eb7d: e9 0d ff ff ff               	jmp	0x2ea8f <btf__dedup+0x1ef>
; 	h = hash_combine(0, t->name_off);
   2eb82: 8b 17                        	movl	(%rdi), %edx
; 	h = hash_combine(h, t->info & ~0xffff);
   2eb84: 81 e1 00 00 ff ff            	andl	$4294901760, %ecx       # imm = 0xFFFF0000
; 	return h * 31 + value;
   2eb8a: 48 89 d0                     	movq	%rdx, %rax
   2eb8d: 48 c1 e0 05                  	shlq	$5, %rax
   2eb91: 48 29 d0                     	subq	%rdx, %rax
   2eb94: e9 e3 fe ff ff               	jmp	0x2ea7c <btf__dedup+0x1dc>
; 			h = btf_hash_struct(t);
   2eb99: e8 22 9e ff ff               	callq	0x289c0 <btf_hash_struct>
   2eb9e: 48 89 c6                     	movq	%rax, %rsi
; 			break;
   2eba1: e9 e9 fe ff ff               	jmp	0x2ea8f <btf__dedup+0x1ef>
; 	h = hash_combine(0, t->name_off);
   2eba6: 8b 07                        	movl	(%rdi), %eax
; 	return h * 31 + value;
   2eba8: 48 89 c2                     	movq	%rax, %rdx
   2ebab: 48 c1 e2 05                  	shlq	$5, %rdx
   2ebaf: 48 29 c2                     	subq	%rax, %rdx
   2ebb2: 48 01 ca                     	addq	%rcx, %rdx
   2ebb5: 48 89 d0                     	movq	%rdx, %rax
   2ebb8: 48 c1 e0 05                  	shlq	$5, %rax
   2ebbc: 48 29 d0                     	subq	%rdx, %rax
; 	h = hash_combine(h, t->size);
   2ebbf: 8b 57 08                     	movl	8(%rdi), %edx
; 	return h * 31 + value;
   2ebc2: 48 01 d0                     	addq	%rdx, %rax
   2ebc5: 48 89 c2                     	movq	%rax, %rdx
   2ebc8: 48 c1 e2 05                  	shlq	$5, %rdx
   2ebcc: 48 29 c2                     	subq	%rax, %rdx
; 	h = hash_combine(h, info->type);
   2ebcf: 8b 47 0c                     	movl	12(%rdi), %eax
; 	return h * 31 + value;
   2ebd2: 48 01 c2                     	addq	%rax, %rdx
   2ebd5: 48 89 d0                     	movq	%rdx, %rax
   2ebd8: 48 c1 e0 05                  	shlq	$5, %rax
   2ebdc: 48 29 d0                     	subq	%rdx, %rax
; 	h = hash_combine(h, info->index_type);
   2ebdf: 8b 57 10                     	movl	16(%rdi), %edx
; 	return h * 31 + value;
   2ebe2: 48 01 d0                     	addq	%rdx, %rax
   2ebe5: 48 89 c6                     	movq	%rax, %rsi
   2ebe8: 48 c1 e6 05                  	shlq	$5, %rsi
   2ebec: 48 29 c6                     	subq	%rax, %rsi
; 	h = hash_combine(h, info->nelems);
   2ebef: 8b 47 14                     	movl	20(%rdi), %eax
; 	return h * 31 + value;
   2ebf2: 48 01 c6                     	addq	%rax, %rsi
; 			break;
   2ebf5: e9 95 fe ff ff               	jmp	0x2ea8f <btf__dedup+0x1ef>
; 			h = btf_hash_fnproto(t);
   2ebfa: e8 31 9e ff ff               	callq	0x28a30 <btf_hash_fnproto>
   2ebff: 48 89 c6                     	movq	%rax, %rsi
; 			break;
   2ec02: e9 88 fe ff ff               	jmp	0x2ea8f <btf__dedup+0x1ef>
; 	h = hash_combine(0, t->name_off);
   2ec07: 41 8b 0c 24                  	movl	(%r12), %ecx
; 		for_each_dedup_cand(d, hash_entry, h) {
   2ec0b: 4d 8b 57 10                  	movq	16(%r15), %r10
; 	return h * 31 + value;
   2ec0f: 48 89 c8                     	movq	%rcx, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   2ec12: 4d 8b 6a 18                  	movq	24(%r10), %r13
; 	return h * 31 + value;
   2ec16: 48 c1 e0 05                  	shlq	$5, %rax
   2ec1a: 48 29 c8                     	subq	%rcx, %rax
   2ec1d: 48 01 c2                     	addq	%rax, %rdx
   2ec20: 48 89 d0                     	movq	%rdx, %rax
   2ec23: 48 c1 e0 05                  	shlq	$5, %rax
   2ec27: 48 29 d0                     	subq	%rdx, %rax
; 	h = hash_combine(h, t->size);
   2ec2a: 41 8b 54 24 08               	movl	8(%r12), %edx
; 	return h * 31 + value;
   2ec2f: 48 01 d0                     	addq	%rdx, %rax
   2ec32: 48 89 c5                     	movq	%rax, %rbp
   2ec35: 48 c1 e5 05                  	shlq	$5, %rbp
   2ec39: 48 29 c5                     	subq	%rax, %rbp
; 	h = hash_combine(h, info);
   2ec3c: 41 8b 44 24 0c               	movl	12(%r12), %eax
; 	return h * 31 + value;
   2ec41: 48 01 c5                     	addq	%rax, %rbp
; 		for_each_dedup_cand(d, hash_entry, h) {
   2ec44: 4d 85 ed                     	testq	%r13, %r13
   2ec47: 0f 84 77 05 00 00            	je	0x2f1c4 <btf__dedup+0x924>
   2ec4d: 4d 8b 42 28                  	movq	40(%r10), %r8
   2ec51: 49 8b 72 10                  	movq	16(%r10), %rsi
   2ec55: 48 89 ef                     	movq	%rbp, %rdi
   2ec58: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
   2ec5d: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   2ec60: 4c 8b 44 24 10               	movq	16(%rsp), %r8
   2ec65: 45 85 c0                     	testl	%r8d, %r8d
   2ec68: 74 1e                        	je	0x2ec88 <btf__dedup+0x3e8>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   2ec6a: 48 bf 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdi # imm = 0x9E3779B97F4A7C15
   2ec74: b9 40 00 00 00               	movl	$64, %ecx
   2ec79: 48 0f af c7                  	imulq	%rdi, %rax
   2ec7d: 44 29 c1                     	subl	%r8d, %ecx
   2ec80: 48 d3 e8                     	shrq	%cl, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   2ec83: 4d 8d 6c c5 00               	leaq	(%r13,%rax,8), %r13
   2ec88: 4d 8b 6d 00                  	movq	(%r13), %r13
   2ec8c: 4d 8b 57 10                  	movq	16(%r15), %r10
   2ec90: 4d 85 ed                     	testq	%r13, %r13
   2ec93: 75 18                        	jne	0x2ecad <btf__dedup+0x40d>
   2ec95: e9 2a 05 00 00               	jmp	0x2f1c4 <btf__dedup+0x924>
   2ec9a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2eca0: 4d 8b 6d 10                  	movq	16(%r13), %r13
   2eca4: 4d 85 ed                     	testq	%r13, %r13
   2eca7: 0f 84 13 05 00 00            	je	0x2f1c0 <btf__dedup+0x920>
   2ecad: 49 8b 47 10                  	movq	16(%r15), %rax
   2ecb1: 49 8b 7d 00                  	movq	(%r13), %rdi
   2ecb5: 48 89 ee                     	movq	%rbp, %rsi
   2ecb8: 48 8b 50 10                  	movq	16(%rax), %rdx
   2ecbc: ff 50 08                     	callq	*8(%rax)
   2ecbf: 84 c0                        	testb	%al, %al
   2ecc1: 74 dd                        	je	0x2eca0 <btf__dedup+0x400>
; 			cand_id = (__u32)(long)hash_entry->value;
   2ecc3: 49 8b 75 08                  	movq	8(%r13), %rsi
; 			cand = btf_type_by_id(d->btf, cand_id);
   2ecc7: 4d 8b 1f                     	movq	(%r15), %r11
; 		return &btf_void;
   2ecca: 4c 89 f2                     	movq	%r14, %rdx
; 			cand_id = (__u32)(long)hash_entry->value;
   2eccd: 41 89 f1                     	movl	%esi, %r9d
; 			cand = btf_type_by_id(d->btf, cand_id);
   2ecd0: 4c 89 d8                     	movq	%r11, %rax
; 	if (type_id == 0)
   2ecd3: 85 f6                        	testl	%esi, %esi
   2ecd5: 75 0d                        	jne	0x2ece4 <btf__dedup+0x444>
   2ecd7: eb 20                        	jmp	0x2ecf9 <btf__dedup+0x459>
   2ecd9: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2ece0: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2ece4: 8b 50 50                     	movl	80(%rax), %edx
   2ece7: 41 39 d1                     	cmpl	%edx, %r9d
   2ecea: 72 f4                        	jb	0x2ece0 <btf__dedup+0x440>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2ecec: 29 d6                        	subl	%edx, %esi
   2ecee: 48 8b 50 30                  	movq	48(%rax), %rdx
   2ecf2: 8b 14 b2                     	movl	(%rdx,%rsi,4), %edx
   2ecf5: 48 03 50 20                  	addq	32(%rax), %rdx
; 	       t1->info == t2->info &&
   2ecf9: 8b 02                        	movl	(%rdx), %eax
   2ecfb: 41 39 04 24                  	cmpl	%eax, (%r12)
   2ecff: 75 9f                        	jne	0x2eca0 <btf__dedup+0x400>
; 	return t1->name_off == t2->name_off &&
   2ed01: 8b 42 04                     	movl	4(%rdx), %eax
   2ed04: 41 39 44 24 04               	cmpl	%eax, 4(%r12)
   2ed09: 75 95                        	jne	0x2eca0 <btf__dedup+0x400>
; 	       t1->info == t2->info &&
   2ed0b: 8b 42 08                     	movl	8(%rdx), %eax
   2ed0e: 41 39 44 24 08               	cmpl	%eax, 8(%r12)
   2ed13: 75 8b                        	jne	0x2eca0 <btf__dedup+0x400>
; 			if (btf_equal_int_tag(t, cand)) {
   2ed15: 8b 42 0c                     	movl	12(%rdx), %eax
   2ed18: 41 39 44 24 0c               	cmpl	%eax, 12(%r12)
   2ed1d: 75 81                        	jne	0x2eca0 <btf__dedup+0x400>
   2ed1f: 90                           	nop
; 	d->map[type_id] = new_id;
   2ed20: 49 8b 47 18                  	movq	24(%r15), %rax
   2ed24: 89 da                        	movl	%ebx, %edx
   2ed26: 44 89 0c 90                  	movl	%r9d, (%rax,%rdx,4)
; 	if (type_id == new_id && btf_dedup_table_add(d, h, type_id))
   2ed2a: 44 39 cb                     	cmpl	%r9d, %ebx
   2ed2d: 0f 84 b4 0e 00 00            	je	0x2fbe7 <btf__dedup+0x1347>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2ed33: 83 44 24 08 01               	addl	$1, 8(%rsp)
   2ed38: 41 8b 53 40                  	movl	64(%r11), %edx
   2ed3c: 4c 89 d8                     	movq	%r11, %rax
   2ed3f: 8b 5c 24 08                  	movl	8(%rsp), %ebx
   2ed43: 39 da                        	cmpl	%ebx, %edx
   2ed45: 0f 87 a5 fd ff ff            	ja	0x2eaf0 <btf__dedup+0x250>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2ed4b: 85 d2                        	testl	%edx, %edx
   2ed4d: 0f 84 89 0a 00 00            	je	0x2f7dc <btf__dedup+0xf3c>
   2ed53: c7 44 24 08 00 00 00 00      	movl	$0, 8(%rsp)
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   2ed5b: 4c 89 de                     	movq	%r11, %rsi
   2ed5e: eb 17                        	jmp	0x2ed77 <btf__dedup+0x4d7>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2ed60: 83 44 24 08 01               	addl	$1, 8(%rsp)
   2ed65: 8b 56 40                     	movl	64(%rsi), %edx
   2ed68: 48 89 f0                     	movq	%rsi, %rax
   2ed6b: 8b 5c 24 08                  	movl	8(%rsp), %ebx
   2ed6f: 39 da                        	cmpl	%ebx, %edx
   2ed71: 0f 86 af 0b 00 00            	jbe	0x2f926 <btf__dedup+0x1086>
; 		err = btf_dedup_struct_type(d, d->btf->start_id + i);
   2ed77: 8b 56 50                     	movl	80(%rsi), %edx
   2ed7a: 8b 5c 24 08                  	movl	8(%rsp), %ebx
; 	if (d->map[type_id] <= BTF_MAX_NR_TYPES)
   2ed7e: 4d 8b 47 18                  	movq	24(%r15), %r8
; 		err = btf_dedup_struct_type(d, d->btf->start_id + i);
   2ed82: 01 d3                        	addl	%edx, %ebx
   2ed84: 89 db                        	movl	%ebx, %ebx
; 	if (d->map[type_id] <= BTF_MAX_NR_TYPES)
   2ed86: 48 89 5c 24 40               	movq	%rbx, 64(%rsp)
; 		err = btf_dedup_struct_type(d, d->btf->start_id + i);
   2ed8b: 49 89 de                     	movq	%rbx, %r14
; 	if (d->map[type_id] <= BTF_MAX_NR_TYPES)
   2ed8e: 48 c1 e3 02                  	shlq	$2, %rbx
   2ed92: 49 01 d8                     	addq	%rbx, %r8
   2ed95: 48 89 5c 24 48               	movq	%rbx, 72(%rsp)
   2ed9a: 41 8b 08                     	movl	(%r8), %ecx
   2ed9d: 85 c9                        	testl	%ecx, %ecx
   2ed9f: 79 bf                        	jns	0x2ed60 <btf__dedup+0x4c0>
; 		return &btf_void;
   2eda1: 48 8d 1d e8 84 01 00         	leaq	99560(%rip), %rbx       # 0x47290 <btf_void>
   2eda8: 48 89 5c 24 18               	movq	%rbx, 24(%rsp)
; 	if (type_id == 0)
   2edad: 45 85 f6                     	testl	%r14d, %r14d
   2edb0: 75 0d                        	jne	0x2edbf <btf__dedup+0x51f>
   2edb2: eb 25                        	jmp	0x2edd9 <btf__dedup+0x539>
   2edb4: 0f 1f 40 00                  	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2edb8: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2edbc: 8b 50 50                     	movl	80(%rax), %edx
   2edbf: 41 39 d6                     	cmpl	%edx, %r14d
   2edc2: 72 f4                        	jb	0x2edb8 <btf__dedup+0x518>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2edc4: 44 89 f1                     	movl	%r14d, %ecx
   2edc7: 29 d1                        	subl	%edx, %ecx
   2edc9: 48 8b 50 30                  	movq	48(%rax), %rdx
   2edcd: 8b 14 8a                     	movl	(%rdx,%rcx,4), %edx
   2edd0: 48 03 50 20                  	addq	32(%rax), %rdx
   2edd4: 48 89 54 24 18               	movq	%rdx, 24(%rsp)
; 	return BTF_INFO_KIND(t->info);
   2edd9: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
   2edde: 0f b6 47 07                  	movzbl	7(%rdi), %eax
   2ede2: 83 e0 1f                     	andl	$31, %eax
; 	if (kind != BTF_KIND_STRUCT && kind != BTF_KIND_UNION)
   2ede5: 83 e8 04                     	subl	$4, %eax
   2ede8: 66 83 f8 01                  	cmpw	$1, %ax
   2edec: 0f 87 6e ff ff ff            	ja	0x2ed60 <btf__dedup+0x4c0>
; 	h = btf_hash_struct(t);
   2edf2: e8 c9 9b ff ff               	callq	0x289c0 <btf_hash_struct>
; 	for_each_dedup_cand(d, hash_entry, h) {
   2edf7: 4d 8b 57 10                  	movq	16(%r15), %r10
; 	h = btf_hash_struct(t);
   2edfb: 48 89 44 24 10               	movq	%rax, 16(%rsp)
; 	for_each_dedup_cand(d, hash_entry, h) {
   2ee00: 49 8b 5a 18                  	movq	24(%r10), %rbx
   2ee04: 48 85 db                     	testq	%rbx, %rbx
   2ee07: 0f 84 67 09 00 00            	je	0x2f774 <btf__dedup+0xed4>
   2ee0d: 49 8b 6a 28                  	movq	40(%r10), %rbp
   2ee11: 49 8b 72 10                  	movq	16(%r10), %rsi
   2ee15: 48 89 c7                     	movq	%rax, %rdi
   2ee18: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   2ee1b: 85 ed                        	testl	%ebp, %ebp
   2ee1d: 74 1c                        	je	0x2ee3b <btf__dedup+0x59b>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   2ee1f: 48 bf 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdi # imm = 0x9E3779B97F4A7C15
   2ee29: b9 40 00 00 00               	movl	$64, %ecx
   2ee2e: 48 0f af c7                  	imulq	%rdi, %rax
   2ee32: 29 e9                        	subl	%ebp, %ecx
   2ee34: 48 d3 e8                     	shrq	%cl, %rax
; 	for_each_dedup_cand(d, hash_entry, h) {
   2ee37: 48 8d 1c c3                  	leaq	(%rbx,%rax,8), %rbx
   2ee3b: 4c 8b 2b                     	movq	(%rbx), %r13
   2ee3e: 4d 8b 57 10                  	movq	16(%r15), %r10
   2ee42: 4d 85 ed                     	testq	%r13, %r13
   2ee45: 0f 84 48 0d 00 00            	je	0x2fb93 <btf__dedup+0x12f3>
   2ee4b: 44 89 74 24 54               	movl	%r14d, 84(%rsp)
   2ee50: eb 13                        	jmp	0x2ee65 <btf__dedup+0x5c5>
   2ee52: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2ee58: 4d 8b 6d 10                  	movq	16(%r13), %r13
   2ee5c: 4d 85 ed                     	testq	%r13, %r13
   2ee5f: 0f 84 fd 08 00 00            	je	0x2f762 <btf__dedup+0xec2>
   2ee65: 49 8b 47 10                  	movq	16(%r15), %rax
   2ee69: 48 8b 74 24 10               	movq	16(%rsp), %rsi
   2ee6e: 49 8b 7d 00                  	movq	(%r13), %rdi
   2ee72: 48 8b 50 10                  	movq	16(%rax), %rdx
   2ee76: ff 50 08                     	callq	*8(%rax)
   2ee79: 84 c0                        	testb	%al, %al
   2ee7b: 74 db                        	je	0x2ee58 <btf__dedup+0x5b8>
; 		__u32 cand_id = (__u32)(long)hash_entry->value;
   2ee7d: 49 8b 4d 08                  	movq	8(%r13), %rcx
; 		cand_type = btf_type_by_id(d->btf, cand_id);
   2ee81: 49 8b 07                     	movq	(%r15), %rax
; 		return &btf_void;
   2ee84: 48 8d 35 05 84 01 00         	leaq	99333(%rip), %rsi       # 0x47290 <btf_void>
; 		__u32 cand_id = (__u32)(long)hash_entry->value;
   2ee8b: 41 89 cc                     	movl	%ecx, %r12d
; 	if (type_id == 0)
   2ee8e: 85 c9                        	testl	%ecx, %ecx
   2ee90: 75 0a                        	jne	0x2ee9c <btf__dedup+0x5fc>
   2ee92: eb 1d                        	jmp	0x2eeb1 <btf__dedup+0x611>
   2ee94: 0f 1f 40 00                  	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2ee98: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2ee9c: 8b 50 50                     	movl	80(%rax), %edx
   2ee9f: 41 39 d4                     	cmpl	%edx, %r12d
   2eea2: 72 f4                        	jb	0x2ee98 <btf__dedup+0x5f8>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2eea4: 29 d1                        	subl	%edx, %ecx
   2eea6: 48 8b 50 30                  	movq	48(%rax), %rdx
   2eeaa: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2eead: 48 03 70 20                  	addq	32(%rax), %rsi
; 		if (!btf_shallow_equal_struct(t, cand_type))
   2eeb1: 48 8b 7c 24 18               	movq	24(%rsp), %rdi
   2eeb6: e8 95 a1 ff ff               	callq	0x29050 <btf_shallow_equal_struct>
   2eebb: 84 c0                        	testb	%al, %al
   2eebd: 74 99                        	je	0x2ee58 <btf__dedup+0x5b8>
; 	for (i = 0; i < d->hypot_cnt; i++)
   2eebf: 49 8b 57 30                  	movq	48(%r15), %rdx
   2eec3: 48 85 d2                     	testq	%rdx, %rdx
   2eec6: 74 22                        	je	0x2eeea <btf__dedup+0x64a>
   2eec8: 49 8b 47 28                  	movq	40(%r15), %rax
; 		d->hypot_map[d->hypot_list[i]] = BTF_UNPROCESSED_ID;
   2eecc: 49 8b 77 20                  	movq	32(%r15), %rsi
   2eed0: 48 8d 0c 90                  	leaq	(%rax,%rdx,4), %rcx
   2eed4: 0f 1f 40 00                  	nopl	(%rax)
   2eed8: 8b 10                        	movl	(%rax), %edx
; 	for (i = 0; i < d->hypot_cnt; i++)
   2eeda: 48 83 c0 04                  	addq	$4, %rax
; 		d->hypot_map[d->hypot_list[i]] = BTF_UNPROCESSED_ID;
   2eede: c7 04 96 ff ff ff ff         	movl	$4294967295, (%rsi,%rdx,4) # imm = 0xFFFFFFFF
; 	for (i = 0; i < d->hypot_cnt; i++)
   2eee5: 48 39 c1                     	cmpq	%rax, %rcx
   2eee8: 75 ee                        	jne	0x2eed8 <btf__dedup+0x638>
; 	d->hypot_adjust_canon = false;
   2eeea: 41 c6 47 40 00               	movb	$0, 64(%r15)
; 		eq = btf_dedup_is_equiv(d, type_id, cand_id);
   2eeef: 8b 74 24 54                  	movl	84(%rsp), %esi
   2eef3: 44 89 e2                     	movl	%r12d, %edx
   2eef6: 4c 89 ff                     	movq	%r15, %rdi
; 	d->hypot_cnt = 0;
   2eef9: 49 c7 47 30 00 00 00 00      	movq	$0, 48(%r15)
; 		eq = btf_dedup_is_equiv(d, type_id, cand_id);
   2ef01: e8 fa b0 ff ff               	callq	0x2a000 <btf_dedup_is_equiv>
; 		if (eq < 0)
   2ef06: 85 c0                        	testl	%eax, %eax
   2ef08: 0f 88 3a 0c 00 00            	js	0x2fb48 <btf__dedup+0x12a8>
; 		if (!eq)
   2ef0e: 0f 84 44 ff ff ff            	je	0x2ee58 <btf__dedup+0x5b8>
; 	for (i = 0; i < d->hypot_cnt; i++) {
   2ef14: 49 8b 47 30                  	movq	48(%r15), %rax
   2ef18: 48 89 44 24 20               	movq	%rax, 32(%rsp)
   2ef1d: 48 85 c0                     	testq	%rax, %rax
   2ef20: 0f 84 69 01 00 00            	je	0x2f08f <btf__dedup+0x7ef>
; 		canon_type_id = d->hypot_list[i];
   2ef26: 49 8b 47 28                  	movq	40(%r15), %rax
; 	d->map[type_id] = new_id;
   2ef2a: 49 8b 6f 18                  	movq	24(%r15), %rbp
; 		t_kind = btf_kind(btf__type_by_id(d->btf, t_id));
   2ef2e: 4c 89 6c 24 58               	movq	%r13, 88(%rsp)
   2ef33: 45 31 f6                     	xorl	%r14d, %r14d
   2ef36: 49 8b 1f                     	movq	(%r15), %rbx
   2ef39: 45 89 e5                     	movl	%r12d, %r13d
; 		canon_type_id = d->hypot_list[i];
   2ef3c: 48 89 44 24 28               	movq	%rax, 40(%rsp)
; 		targ_type_id = d->hypot_map[canon_type_id];
   2ef41: 49 8b 47 20                  	movq	32(%r15), %rax
   2ef45: 48 89 44 24 30               	movq	%rax, 48(%rsp)
   2ef4a: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		canon_type_id = d->hypot_list[i];
   2ef50: 48 8b 44 24 28               	movq	40(%rsp), %rax
; 		targ_type_id = d->hypot_map[canon_type_id];
   2ef55: 48 8b 7c 24 30               	movq	48(%rsp), %rdi
; 		canon_type_id = d->hypot_list[i];
   2ef5a: 42 8b 34 b0                  	movl	(%rax,%r14,4), %esi
; 		targ_type_id = d->hypot_map[canon_type_id];
   2ef5e: 8b 14 b7                     	movl	(%rdi,%rsi,4), %edx
; 		canon_type_id = d->hypot_list[i];
   2ef61: 48 89 f0                     	movq	%rsi, %rax
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2ef64: eb 0e                        	jmp	0x2ef74 <btf__dedup+0x6d4>
   2ef66: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
   2ef70: 85 d2                        	testl	%edx, %edx
   2ef72: 78 2a                        	js	0x2ef9e <btf__dedup+0x6fe>
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2ef74: 89 d1                        	movl	%edx, %ecx
   2ef76: 4c 8d 44 8d 00               	leaq	(%rbp,%rcx,4), %r8
   2ef7b: 89 d1                        	movl	%edx, %ecx
   2ef7d: 41 8b 10                     	movl	(%r8), %edx
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2ef80: 39 d1                        	cmpl	%edx, %ecx
   2ef82: 75 ec                        	jne	0x2ef70 <btf__dedup+0x6d0>
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2ef84: 48 8d 7c b5 00               	leaq	(%rbp,%rsi,4), %rdi
   2ef89: 89 c6                        	movl	%eax, %esi
   2ef8b: 8b 07                        	movl	(%rdi), %eax
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2ef8d: 39 c6                        	cmpl	%eax, %esi
   2ef8f: 74 1a                        	je	0x2efab <btf__dedup+0x70b>
   2ef91: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   2ef98: 85 c0                        	testl	%eax, %eax
   2ef9a: 78 0f                        	js	0x2efab <btf__dedup+0x70b>
   2ef9c: 89 c6                        	movl	%eax, %esi
; 	return d->map[type_id] <= BTF_MAX_NR_TYPES;
   2ef9e: 48 8d 7c b5 00               	leaq	(%rbp,%rsi,4), %rdi
   2efa3: 89 c6                        	movl	%eax, %esi
   2efa5: 8b 07                        	movl	(%rdi), %eax
; 	while (is_type_mapped(d, type_id) && d->map[type_id] != type_id)
   2efa7: 39 c6                        	cmpl	%eax, %esi
   2efa9: 75 ed                        	jne	0x2ef98 <btf__dedup+0x6f8>
; 	if (type_id >= btf->start_id + btf->nr_types)
   2efab: 44 8b 53 50                  	movl	80(%rbx), %r10d
   2efaf: 44 8b 63 40                  	movl	64(%rbx), %r12d
   2efb3: 45 01 d4                     	addl	%r10d, %r12d
   2efb6: 44 39 e1                     	cmpl	%r12d, %ecx
   2efb9: 0f 83 77 6d fd ff            	jae	0x5d36 <btf__dedup.cold+0x14>
; 		return &btf_void;
   2efbf: 4c 8d 1d ca 82 01 00         	leaq	99018(%rip), %r11       # 0x47290 <btf_void>
; 	if (type_id == 0)
   2efc6: 85 c9                        	testl	%ecx, %ecx
   2efc8: 74 3c                        	je	0x2f006 <btf__dedup+0x766>
   2efca: 45 89 d3                     	movl	%r10d, %r11d
   2efcd: 49 89 d9                     	movq	%rbx, %r9
   2efd0: eb 0e                        	jmp	0x2efe0 <btf__dedup+0x740>
   2efd2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2efd8: 4d 8b 49 48                  	movq	72(%r9), %r9
; 	if (type_id < btf->start_id)
   2efdc: 45 8b 59 50                  	movl	80(%r9), %r11d
   2efe0: 44 39 d9                     	cmpl	%r11d, %ecx
   2efe3: 72 f3                        	jb	0x2efd8 <btf__dedup+0x738>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2efe5: 4c 89 4c 24 38               	movq	%r9, 56(%rsp)
   2efea: 41 89 c9                     	movl	%ecx, %r9d
   2efed: 45 29 d9                     	subl	%r11d, %r9d
   2eff0: 4c 8b 5c 24 38               	movq	56(%rsp), %r11
   2eff5: 4d 8b 5b 30                  	movq	48(%r11), %r11
   2eff9: 47 8b 1c 8b                  	movl	(%r11,%r9,4), %r11d
   2effd: 4c 8b 4c 24 38               	movq	56(%rsp), %r9
   2f002: 4d 03 59 20                  	addq	32(%r9), %r11
; 	return BTF_INFO_KIND(t->info);
   2f006: 45 0f b6 5b 07               	movzbl	7(%r11), %r11d
   2f00b: 41 83 e3 1f                  	andl	$31, %r11d
; 	if (type_id >= btf->start_id + btf->nr_types)
   2f00f: 44 39 e6                     	cmpl	%r12d, %esi
   2f012: 0f 83 0a 6d fd ff            	jae	0x5d22 <btf__dedup.cold>
; 		return &btf_void;
   2f018: 4c 8d 0d 71 82 01 00         	leaq	98929(%rip), %r9        # 0x47290 <btf_void>
; 	if (type_id == 0)
   2f01f: 85 f6                        	testl	%esi, %esi
   2f021: 74 2f                        	je	0x2f052 <btf__dedup+0x7b2>
   2f023: 49 89 d9                     	movq	%rbx, %r9
   2f026: eb 10                        	jmp	0x2f038 <btf__dedup+0x798>
   2f028: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2f030: 4d 8b 49 48                  	movq	72(%r9), %r9
; 	if (type_id < btf->start_id)
   2f034: 45 8b 51 50                  	movl	80(%r9), %r10d
   2f038: 44 39 d6                     	cmpl	%r10d, %esi
   2f03b: 72 f3                        	jb	0x2f030 <btf__dedup+0x790>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2f03d: 41 89 f4                     	movl	%esi, %r12d
   2f040: 45 29 d4                     	subl	%r10d, %r12d
   2f043: 4d 8b 51 30                  	movq	48(%r9), %r10
   2f047: 47 8b 14 a2                  	movl	(%r10,%r12,4), %r10d
   2f04b: 4d 03 51 20                  	addq	32(%r9), %r10
   2f04f: 4d 89 d1                     	movq	%r10, %r9
; 	return BTF_INFO_KIND(t->info);
   2f052: 45 0f b6 49 07               	movzbl	7(%r9), %r9d
; 		if (d->hypot_adjust_canon) /* not really equivalent */
   2f057: 45 0f b6 57 40               	movzbl	64(%r15), %r10d
; 	return BTF_INFO_KIND(t->info);
   2f05c: 41 83 e1 1f                  	andl	$31, %r9d
; 		if (t_kind != BTF_KIND_FWD && c_kind == BTF_KIND_FWD)
   2f060: 66 41 83 fb 07               	cmpw	$7, %r11w
   2f065: 0f 84 95 06 00 00            	je	0x2f700 <btf__dedup+0xe60>
   2f06b: 66 41 83 f9 07               	cmpw	$7, %r9w
   2f070: 0f 85 8a 06 00 00            	jne	0x2f700 <btf__dedup+0xe60>
; 			d->map[c_id] = t_id;
   2f076: 89 0f                        	movl	%ecx, (%rdi)
; 	for (i = 0; i < d->hypot_cnt; i++) {
   2f078: 49 83 c6 01                  	addq	$1, %r14
   2f07c: 4c 39 74 24 20               	cmpq	%r14, 32(%rsp)
   2f081: 0f 85 c9 fe ff ff            	jne	0x2ef50 <btf__dedup+0x6b0>
   2f087: 45 89 ec                     	movl	%r13d, %r12d
   2f08a: 4c 8b 6c 24 58               	movq	88(%rsp), %r13
; 		if (d->hypot_adjust_canon) /* not really equivalent */
   2f08f: 41 80 7f 40 00               	cmpb	$0, 64(%r15)
   2f094: 0f 85 be fd ff ff            	jne	0x2ee58 <btf__dedup+0x5b8>
   2f09a: 44 8b 74 24 54               	movl	84(%rsp), %r14d
   2f09f: 49 8b 6f 18                  	movq	24(%r15), %rbp
; 	d->map[type_id] = new_id;
   2f0a3: 48 8b 44 24 40               	movq	64(%rsp), %rax
   2f0a8: 44 89 64 85 00               	movl	%r12d, (%rbp,%rax,4)
; 	if (type_id == new_id && btf_dedup_table_add(d, h, type_id))
   2f0ad: 45 39 e6                     	cmpl	%r12d, %r14d
   2f0b0: 0f 84 3a 0b 00 00            	je	0x2fbf0 <btf__dedup+0x1350>
   2f0b6: 49 8b 37                     	movq	(%r15), %rsi
   2f0b9: e9 a2 fc ff ff               	jmp	0x2ed60 <btf__dedup+0x4c0>
; 	h = hash_combine(0, t->name_off);
   2f0be: 41 8b 0c 24                  	movl	(%r12), %ecx
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f0c2: 4d 8b 57 10                  	movq	16(%r15), %r10
; 	return h * 31 + value;
   2f0c6: 48 89 c8                     	movq	%rcx, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f0c9: 4d 8b 6a 18                  	movq	24(%r10), %r13
; 	return h * 31 + value;
   2f0cd: 48 c1 e0 05                  	shlq	$5, %rax
   2f0d1: 48 29 c8                     	subq	%rcx, %rax
   2f0d4: 48 01 d0                     	addq	%rdx, %rax
   2f0d7: 48 89 c5                     	movq	%rax, %rbp
   2f0da: 48 c1 e5 05                  	shlq	$5, %rbp
   2f0de: 48 29 c5                     	subq	%rax, %rbp
; 	h = hash_combine(h, t->size);
   2f0e1: 41 8b 44 24 08               	movl	8(%r12), %eax
; 	return h * 31 + value;
   2f0e6: 48 01 c5                     	addq	%rax, %rbp
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f0e9: 4d 85 ed                     	testq	%r13, %r13
   2f0ec: 0f 84 d2 00 00 00            	je	0x2f1c4 <btf__dedup+0x924>
   2f0f2: 4d 8b 42 28                  	movq	40(%r10), %r8
   2f0f6: 49 8b 72 10                  	movq	16(%r10), %rsi
   2f0fa: 48 89 ef                     	movq	%rbp, %rdi
   2f0fd: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
   2f102: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   2f105: 4c 8b 44 24 10               	movq	16(%rsp), %r8
   2f10a: 45 85 c0                     	testl	%r8d, %r8d
   2f10d: 74 1e                        	je	0x2f12d <btf__dedup+0x88d>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   2f10f: 48 bf 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdi # imm = 0x9E3779B97F4A7C15
   2f119: b9 40 00 00 00               	movl	$64, %ecx
   2f11e: 48 0f af c7                  	imulq	%rdi, %rax
   2f122: 44 29 c1                     	subl	%r8d, %ecx
   2f125: 48 d3 e8                     	shrq	%cl, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f128: 4d 8d 6c c5 00               	leaq	(%r13,%rax,8), %r13
   2f12d: 4d 8b 6d 00                  	movq	(%r13), %r13
   2f131: 4d 8b 57 10                  	movq	16(%r15), %r10
   2f135: 4d 85 ed                     	testq	%r13, %r13
   2f138: 75 0f                        	jne	0x2f149 <btf__dedup+0x8a9>
   2f13a: e9 85 00 00 00               	jmp	0x2f1c4 <btf__dedup+0x924>
   2f13f: 90                           	nop
   2f140: 4d 8b 6d 10                  	movq	16(%r13), %r13
   2f144: 4d 85 ed                     	testq	%r13, %r13
   2f147: 74 77                        	je	0x2f1c0 <btf__dedup+0x920>
   2f149: 49 8b 47 10                  	movq	16(%r15), %rax
   2f14d: 49 8b 7d 00                  	movq	(%r13), %rdi
   2f151: 48 89 ee                     	movq	%rbp, %rsi
   2f154: 48 8b 50 10                  	movq	16(%rax), %rdx
   2f158: ff 50 08                     	callq	*8(%rax)
   2f15b: 84 c0                        	testb	%al, %al
   2f15d: 74 e1                        	je	0x2f140 <btf__dedup+0x8a0>
; 			cand_id = (__u32)(long)hash_entry->value;
   2f15f: 49 8b 75 08                  	movq	8(%r13), %rsi
; 			cand = btf_type_by_id(d->btf, cand_id);
   2f163: 4d 8b 1f                     	movq	(%r15), %r11
; 		return &btf_void;
   2f166: 4c 89 f2                     	movq	%r14, %rdx
; 			cand_id = (__u32)(long)hash_entry->value;
   2f169: 41 89 f1                     	movl	%esi, %r9d
; 			cand = btf_type_by_id(d->btf, cand_id);
   2f16c: 4c 89 d8                     	movq	%r11, %rax
; 	if (type_id == 0)
   2f16f: 85 f6                        	testl	%esi, %esi
   2f171: 75 09                        	jne	0x2f17c <btf__dedup+0x8dc>
   2f173: eb 1c                        	jmp	0x2f191 <btf__dedup+0x8f1>
   2f175: 0f 1f 00                     	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2f178: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2f17c: 8b 50 50                     	movl	80(%rax), %edx
   2f17f: 41 39 d1                     	cmpl	%edx, %r9d
   2f182: 72 f4                        	jb	0x2f178 <btf__dedup+0x8d8>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2f184: 29 d6                        	subl	%edx, %esi
   2f186: 48 8b 50 30                  	movq	48(%rax), %rdx
   2f18a: 8b 14 b2                     	movl	(%rdx,%rsi,4), %edx
   2f18d: 48 03 50 20                  	addq	32(%rax), %rdx
; 	       t1->info == t2->info &&
   2f191: 8b 02                        	movl	(%rdx), %eax
   2f193: 41 39 04 24                  	cmpl	%eax, (%r12)
   2f197: 75 a7                        	jne	0x2f140 <btf__dedup+0x8a0>
; 	return t1->name_off == t2->name_off &&
   2f199: 8b 42 04                     	movl	4(%rdx), %eax
   2f19c: 41 39 44 24 04               	cmpl	%eax, 4(%r12)
   2f1a1: 75 9d                        	jne	0x2f140 <btf__dedup+0x8a0>
; 	       t1->info == t2->info &&
   2f1a3: 8b 42 08                     	movl	8(%rdx), %eax
   2f1a6: 41 39 44 24 08               	cmpl	%eax, 8(%r12)
   2f1ab: 0f 84 6f fb ff ff            	je	0x2ed20 <btf__dedup+0x480>
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f1b1: 4d 8b 6d 10                  	movq	16(%r13), %r13
   2f1b5: 4d 85 ed                     	testq	%r13, %r13
   2f1b8: 75 8f                        	jne	0x2f149 <btf__dedup+0x8a9>
   2f1ba: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2f1c0: 4d 8b 57 10                  	movq	16(%r15), %r10
; 	d->map[type_id] = new_id;
   2f1c4: 49 8b 47 18                  	movq	24(%r15), %rax
   2f1c8: 89 da                        	movl	%ebx, %edx
   2f1ca: 89 1c 90                     	movl	%ebx, (%rax,%rdx,4)
; 	return hashmap__insert(map, key, value, HASHMAP_APPEND, NULL, NULL);
   2f1cd: 45 31 c9                     	xorl	%r9d, %r9d
   2f1d0: 45 31 c0                     	xorl	%r8d, %r8d
   2f1d3: b9 03 00 00 00               	movl	$3, %ecx
   2f1d8: 48 89 ee                     	movq	%rbp, %rsi
   2f1db: 4c 89 d7                     	movq	%r10, %rdi
   2f1de: e8 2d f3 fe ff               	callq	0x1e510 <hashmap__insert>
; 	if (type_id == new_id && btf_dedup_table_add(d, h, type_id))
   2f1e3: 85 c0                        	testl	%eax, %eax
   2f1e5: 0f 85 b6 09 00 00            	jne	0x2fba1 <btf__dedup+0x1301>
   2f1eb: 4d 8b 1f                     	movq	(%r15), %r11
   2f1ee: e9 40 fb ff ff               	jmp	0x2ed33 <btf__dedup+0x493>
; 	h = hash_combine(0, t->name_off);
   2f1f3: 41 8b 0c 24                  	movl	(%r12), %ecx
; 	h = hash_combine(h, t->info & ~0xffff);
   2f1f7: 81 e2 00 00 ff ff            	andl	$4294901760, %edx       # imm = 0xFFFF0000
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f1fd: 4d 8b 57 10                  	movq	16(%r15), %r10
; 	return h * 31 + value;
   2f201: 48 89 c8                     	movq	%rcx, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f204: 4d 8b 6a 18                  	movq	24(%r10), %r13
; 	return h * 31 + value;
   2f208: 48 c1 e0 05                  	shlq	$5, %rax
   2f20c: 48 29 c8                     	subq	%rcx, %rax
   2f20f: 48 01 d0                     	addq	%rdx, %rax
   2f212: 48 89 c5                     	movq	%rax, %rbp
   2f215: 48 c1 e5 05                  	shlq	$5, %rbp
   2f219: 48 29 c5                     	subq	%rax, %rbp
; 	h = hash_combine(h, t->size);
   2f21c: 41 8b 44 24 08               	movl	8(%r12), %eax
; 	return h * 31 + value;
   2f221: 48 01 c5                     	addq	%rax, %rbp
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f224: 4d 85 ed                     	testq	%r13, %r13
   2f227: 74 9b                        	je	0x2f1c4 <btf__dedup+0x924>
   2f229: 4d 8b 42 28                  	movq	40(%r10), %r8
   2f22d: 49 8b 72 10                  	movq	16(%r10), %rsi
   2f231: 48 89 ef                     	movq	%rbp, %rdi
   2f234: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
   2f239: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   2f23c: 4c 8b 44 24 10               	movq	16(%rsp), %r8
   2f241: 45 85 c0                     	testl	%r8d, %r8d
   2f244: 74 1e                        	je	0x2f264 <btf__dedup+0x9c4>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   2f246: 48 bf 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdi # imm = 0x9E3779B97F4A7C15
   2f250: b9 40 00 00 00               	movl	$64, %ecx
   2f255: 48 0f af c7                  	imulq	%rdi, %rax
   2f259: 44 29 c1                     	subl	%r8d, %ecx
   2f25c: 48 d3 e8                     	shrq	%cl, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f25f: 4d 8d 6c c5 00               	leaq	(%r13,%rax,8), %r13
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f264: 4d 8b 6d 00                  	movq	(%r13), %r13
   2f268: 4d 85 ed                     	testq	%r13, %r13
   2f26b: 75 18                        	jne	0x2f285 <btf__dedup+0x9e5>
   2f26d: e9 4e ff ff ff               	jmp	0x2f1c0 <btf__dedup+0x920>
   2f272: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2f278: 4d 8b 6d 10                  	movq	16(%r13), %r13
   2f27c: 4d 85 ed                     	testq	%r13, %r13
   2f27f: 0f 84 3b ff ff ff            	je	0x2f1c0 <btf__dedup+0x920>
   2f285: 49 8b 47 10                  	movq	16(%r15), %rax
   2f289: 49 8b 7d 00                  	movq	(%r13), %rdi
   2f28d: 48 89 ee                     	movq	%rbp, %rsi
   2f290: 48 8b 50 10                  	movq	16(%rax), %rdx
   2f294: ff 50 08                     	callq	*8(%rax)
   2f297: 84 c0                        	testb	%al, %al
   2f299: 74 dd                        	je	0x2f278 <btf__dedup+0x9d8>
; 			cand_id = (__u32)(long)hash_entry->value;
   2f29b: 4d 8b 55 08                  	movq	8(%r13), %r10
; 			cand = btf_type_by_id(d->btf, cand_id);
   2f29f: 4d 8b 1f                     	movq	(%r15), %r11
; 		return &btf_void;
   2f2a2: 4d 89 f0                     	movq	%r14, %r8
; 			cand_id = (__u32)(long)hash_entry->value;
   2f2a5: 45 89 d1                     	movl	%r10d, %r9d
; 			cand = btf_type_by_id(d->btf, cand_id);
   2f2a8: 4c 89 d8                     	movq	%r11, %rax
; 	if (type_id == 0)
   2f2ab: 45 85 d2                     	testl	%r10d, %r10d
   2f2ae: 75 0c                        	jne	0x2f2bc <btf__dedup+0xa1c>
   2f2b0: eb 23                        	jmp	0x2f2d5 <btf__dedup+0xa35>
   2f2b2: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2f2b8: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2f2bc: 8b 50 50                     	movl	80(%rax), %edx
   2f2bf: 41 39 d1                     	cmpl	%edx, %r9d
   2f2c2: 72 f4                        	jb	0x2f2b8 <btf__dedup+0xa18>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2f2c4: 44 89 d6                     	movl	%r10d, %esi
   2f2c7: 29 d6                        	subl	%edx, %esi
   2f2c9: 48 8b 50 30                  	movq	48(%rax), %rdx
   2f2cd: 44 8b 04 b2                  	movl	(%rdx,%rsi,4), %r8d
   2f2d1: 4c 03 40 20                  	addq	32(%rax), %r8
; 			if (btf_equal_enum(t, cand)) {
   2f2d5: 4c 89 c6                     	movq	%r8, %rsi
   2f2d8: 4c 89 e7                     	movq	%r12, %rdi
   2f2db: e8 80 9c ff ff               	callq	0x28f60 <btf_equal_enum>
   2f2e0: 84 c0                        	testb	%al, %al
   2f2e2: 0f 85 38 fa ff ff            	jne	0x2ed20 <btf__dedup+0x480>
; 			if (btf_compat_enum(t, cand)) {
   2f2e8: 4c 89 c6                     	movq	%r8, %rsi
   2f2eb: 4c 89 e7                     	movq	%r12, %rdi
   2f2ee: e8 4d a2 ff ff               	callq	0x29540 <btf_compat_enum>
   2f2f3: 84 c0                        	testb	%al, %al
   2f2f5: 74 81                        	je	0x2f278 <btf__dedup+0x9d8>
; 				if (btf_is_enum_fwd(t)) {
   2f2f7: 41 8b 54 24 04               	movl	4(%r12), %edx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   2f2fc: be 40 00 08 00               	movl	$524352, %esi           # imm = 0x80040
; 	return BTF_INFO_KIND(t->info);
   2f301: 89 d0                        	movl	%edx, %eax
   2f303: c1 e8 18                     	shrl	$24, %eax
; 	return btf_is_enum(t) || btf_is_enum64(t);
   2f306: 83 e0 1f                     	andl	$31, %eax
   2f309: 48 0f a3 c6                  	btq	%rax, %rsi
   2f30d: 73 09                        	jae	0x2f318 <btf__dedup+0xa78>
; 	return btf_is_any_enum(t) && btf_vlen(t) == 0;
   2f30f: 66 85 d2                     	testw	%dx, %dx
   2f312: 0f 84 08 fa ff ff            	je	0x2ed20 <btf__dedup+0x480>
; 				d->map[cand_id] = type_id;
   2f318: 49 8b 47 18                  	movq	24(%r15), %rax
   2f31c: 45 89 d2                     	movl	%r10d, %r10d
   2f31f: 42 89 1c 90                  	movl	%ebx, (%rax,%r10,4)
   2f323: e9 50 ff ff ff               	jmp	0x2f278 <btf__dedup+0x9d8>
; 	h = hash_combine(0, t->name_off);
   2f328: 41 8b 0c 24                  	movl	(%r12), %ecx
; 	h = hash_combine(h, t->info & ~0xffff);
   2f32c: 81 e2 00 00 ff ff            	andl	$4294901760, %edx       # imm = 0xFFFF0000
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f332: 4d 8b 57 10                  	movq	16(%r15), %r10
; 	return h * 31 + value;
   2f336: 48 89 c8                     	movq	%rcx, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f339: 4d 8b 6a 18                  	movq	24(%r10), %r13
; 	return h * 31 + value;
   2f33d: 48 c1 e0 05                  	shlq	$5, %rax
   2f341: 48 29 c8                     	subq	%rcx, %rax
   2f344: 48 01 d0                     	addq	%rdx, %rax
   2f347: 48 89 c5                     	movq	%rax, %rbp
   2f34a: 48 c1 e5 05                  	shlq	$5, %rbp
   2f34e: 48 29 c5                     	subq	%rax, %rbp
; 	h = hash_combine(h, t->size);
   2f351: 41 8b 44 24 08               	movl	8(%r12), %eax
; 	return h * 31 + value;
   2f356: 48 01 c5                     	addq	%rax, %rbp
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f359: 4d 85 ed                     	testq	%r13, %r13
   2f35c: 0f 84 62 fe ff ff            	je	0x2f1c4 <btf__dedup+0x924>
   2f362: 4d 8b 42 28                  	movq	40(%r10), %r8
   2f366: 49 8b 72 10                  	movq	16(%r10), %rsi
   2f36a: 48 89 ef                     	movq	%rbp, %rdi
   2f36d: 4c 89 44 24 10               	movq	%r8, 16(%rsp)
   2f372: 41 ff 12                     	callq	*(%r10)
; 	if (bits == 0)
   2f375: 4c 8b 44 24 10               	movq	16(%rsp), %r8
   2f37a: 45 85 c0                     	testl	%r8d, %r8d
   2f37d: 74 1e                        	je	0x2f39d <btf__dedup+0xafd>
; 	return (h * 11400714819323198485llu) >> (__SIZEOF_LONG_LONG__ * 8 - bits);
   2f37f: 48 bf 15 7c 4a 7f b9 79 37 9e	movabsq	$-7046029254386353131, %rdi # imm = 0x9E3779B97F4A7C15
   2f389: b9 40 00 00 00               	movl	$64, %ecx
   2f38e: 48 0f af c7                  	imulq	%rdi, %rax
   2f392: 44 29 c1                     	subl	%r8d, %ecx
   2f395: 48 d3 e8                     	shrq	%cl, %rax
; 		for_each_dedup_cand(d, hash_entry, h) {
   2f398: 4d 8d 6c c5 00               	leaq	(%r13,%rax,8), %r13
   2f39d: 4d 8b 6d 00                  	movq	(%r13), %r13
   2f3a1: 4d 8b 57 10                  	movq	16(%r15), %r10
   2f3a5: 4d 85 ed                     	testq	%r13, %r13
   2f3a8: 75 13                        	jne	0x2f3bd <btf__dedup+0xb1d>
   2f3aa: e9 15 fe ff ff               	jmp	0x2f1c4 <btf__dedup+0x924>
   2f3af: 90                           	nop
   2f3b0: 4d 8b 6d 10                  	movq	16(%r13), %r13
   2f3b4: 4d 85 ed                     	testq	%r13, %r13
   2f3b7: 0f 84 03 fe ff ff            	je	0x2f1c0 <btf__dedup+0x920>
   2f3bd: 49 8b 47 10                  	movq	16(%r15), %rax
   2f3c1: 49 8b 7d 00                  	movq	(%r13), %rdi
   2f3c5: 48 89 ee                     	movq	%rbp, %rsi
   2f3c8: 48 8b 50 10                  	movq	16(%rax), %rdx
   2f3cc: ff 50 08                     	callq	*8(%rax)
   2f3cf: 84 c0                        	testb	%al, %al
   2f3d1: 74 dd                        	je	0x2f3b0 <btf__dedup+0xb10>
; 			cand_id = (__u32)(long)hash_entry->value;
   2f3d3: 4d 8b 55 08                  	movq	8(%r13), %r10
; 			cand = btf_type_by_id(d->btf, cand_id);
   2f3d7: 4d 8b 1f                     	movq	(%r15), %r11
; 		return &btf_void;
   2f3da: 4d 89 f0                     	movq	%r14, %r8
; 			cand_id = (__u32)(long)hash_entry->value;
   2f3dd: 45 89 d1                     	movl	%r10d, %r9d
; 			cand = btf_type_by_id(d->btf, cand_id);
   2f3e0: 4c 89 d8                     	movq	%r11, %rax
; 	if (type_id == 0)
   2f3e3: 45 85 d2                     	testl	%r10d, %r10d
   2f3e6: 75 0c                        	jne	0x2f3f4 <btf__dedup+0xb54>
   2f3e8: eb 23                        	jmp	0x2f40d <btf__dedup+0xb6d>
   2f3ea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2f3f0: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2f3f4: 8b 50 50                     	movl	80(%rax), %edx
   2f3f7: 41 39 d1                     	cmpl	%edx, %r9d
   2f3fa: 72 f4                        	jb	0x2f3f0 <btf__dedup+0xb50>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2f3fc: 44 89 d6                     	movl	%r10d, %esi
   2f3ff: 29 d6                        	subl	%edx, %esi
   2f401: 48 8b 50 30                  	movq	48(%rax), %rdx
   2f405: 44 8b 04 b2                  	movl	(%rdx,%rsi,4), %r8d
   2f409: 4c 03 40 20                  	addq	32(%rax), %r8
; 			if (btf_equal_enum64(t, cand)) {
   2f40d: 4c 89 c6                     	movq	%r8, %rsi
   2f410: 4c 89 e7                     	movq	%r12, %rdi
   2f413: e8 b8 9b ff ff               	callq	0x28fd0 <btf_equal_enum64>
   2f418: 84 c0                        	testb	%al, %al
   2f41a: 0f 85 00 f9 ff ff            	jne	0x2ed20 <btf__dedup+0x480>
; 			if (btf_compat_enum64(t, cand)) {
   2f420: 4c 89 c6                     	movq	%r8, %rsi
   2f423: 4c 89 e7                     	movq	%r12, %rdi
   2f426: e8 a5 a0 ff ff               	callq	0x294d0 <btf_compat_enum64>
   2f42b: 84 c0                        	testb	%al, %al
   2f42d: 74 81                        	je	0x2f3b0 <btf__dedup+0xb10>
; 				if (btf_is_enum_fwd(t)) {
   2f42f: 41 8b 54 24 04               	movl	4(%r12), %edx
; 	return btf_is_enum(t) || btf_is_enum64(t);
   2f434: be 40 00 08 00               	movl	$524352, %esi           # imm = 0x80040
; 	return BTF_INFO_KIND(t->info);
   2f439: 89 d0                        	movl	%edx, %eax
   2f43b: c1 e8 18                     	shrl	$24, %eax
; 	return btf_is_enum(t) || btf_is_enum64(t);
   2f43e: 83 e0 1f                     	andl	$31, %eax
   2f441: 48 0f a3 c6                  	btq	%rax, %rsi
   2f445: 73 09                        	jae	0x2f450 <btf__dedup+0xbb0>
; 	return btf_is_any_enum(t) && btf_vlen(t) == 0;
   2f447: 66 85 d2                     	testw	%dx, %dx
   2f44a: 0f 84 d0 f8 ff ff            	je	0x2ed20 <btf__dedup+0x480>
; 				d->map[cand_id] = type_id;
   2f450: 49 8b 47 18                  	movq	24(%r15), %rax
   2f454: 45 89 d2                     	movl	%r10d, %r10d
   2f457: 42 89 1c 90                  	movl	%ebx, (%rax,%r10,4)
   2f45b: e9 50 ff ff ff               	jmp	0x2f3b0 <btf__dedup+0xb10>
   2f460: bb 0c 00 00 00               	movl	$12, %ebx
; 		err = -ENOMEM;
   2f465: 41 be f4 ff ff ff            	movl	$4294967284, %r14d      # imm = 0xFFFFFFF4
; 	hashmap__free(d->dedup_table);
   2f46b: 49 8b 7f 10                  	movq	16(%r15), %rdi
   2f46f: e8 3c f0 fe ff               	callq	0x1e4b0 <hashmap__free>
; 	free(d->map);
   2f474: 49 8b 7f 18                  	movq	24(%r15), %rdi
   2f478: e8 43 62 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d->hypot_map);
   2f47d: 49 8b 7f 20                  	movq	32(%r15), %rdi
   2f481: e8 3a 62 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d->hypot_list);
   2f486: 49 8b 7f 28                  	movq	40(%r15), %rdi
   2f48a: e8 31 62 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d);
   2f48f: 4c 89 ff                     	movq	%r15, %rdi
   2f492: e8 29 62 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 		errno = -ret;
   2f497: e8 54 62 fd ff               	callq	0x56f0 <.plt.sec+0x80>
   2f49c: 89 18                        	movl	%ebx, (%rax)
; }
   2f49e: 48 83 c4 68                  	addq	$104, %rsp
   2f4a2: 44 89 f0                     	movl	%r14d, %eax
   2f4a5: 5b                           	popq	%rbx
   2f4a6: 5d                           	popq	%rbp
   2f4a7: 41 5c                        	popq	%r12
   2f4a9: 41 5d                        	popq	%r13
   2f4ab: 41 5e                        	popq	%r14
   2f4ad: 41 5f                        	popq	%r15
   2f4af: c3                           	retq
; 	return btf->start_id + btf->nr_types;
   2f4b0: 8b 5d 40                     	movl	64(%rbp), %ebx
   2f4b3: 03 5d 50                     	addl	80(%rbp), %ebx
; 	d->map = malloc(sizeof(__u32) * type_cnt);
   2f4b6: 4c 63 eb                     	movslq	%ebx, %r13
   2f4b9: 49 c1 e5 02                  	shlq	$2, %r13
   2f4bd: 4c 89 ef                     	movq	%r13, %rdi
   2f4c0: e8 cb 65 fd ff               	callq	0x5a90 <.plt.sec+0x420>
   2f4c5: 49 89 47 18                  	movq	%rax, 24(%r15)
   2f4c9: 49 89 c0                     	movq	%rax, %r8
; 	if (!d->map) {
   2f4cc: 48 85 c0                     	testq	%rax, %rax
   2f4cf: 0f 84 08 07 00 00            	je	0x2fbdd <btf__dedup+0x133d>
; 	d->map[0] = 0;
   2f4d5: c7 00 00 00 00 00            	movl	$0, (%rax)
; 	for (i = 1; i < type_cnt; i++) {
   2f4db: 83 fb 01                     	cmpl	$1, %ebx
   2f4de: 0f 8e e7 05 00 00            	jle	0x2facb <btf__dedup+0x122b>
; 		struct btf_type *t = btf_type_by_id(d->btf, i);
   2f4e4: 49 8b 3f                     	movq	(%r15), %rdi
   2f4e7: 41 89 da                     	movl	%ebx, %r10d
   2f4ea: be 01 00 00 00               	movl	$1, %esi
   2f4ef: 41 b9 ff ff ff ff            	movl	$4294967295, %r9d       # imm = 0xFFFFFFFF
   2f4f5: 0f 1f 00                     	nopl	(%rax)
; 	if (type_id < btf->start_id)
   2f4f8: 8b 57 50                     	movl	80(%rdi), %edx
   2f4fb: 89 f1                        	movl	%esi, %ecx
   2f4fd: 48 89 f8                     	movq	%rdi, %rax
   2f500: 39 f2                        	cmpl	%esi, %edx
   2f502: 76 0f                        	jbe	0x2f513 <btf__dedup+0xc73>
   2f504: 0f 1f 40 00                  	nopl	(%rax)
; 		return btf_type_by_id(btf->base_btf, type_id);
   2f508: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2f50c: 8b 50 50                     	movl	80(%rax), %edx
   2f50f: 39 ca                        	cmpl	%ecx, %edx
   2f511: 77 f5                        	ja	0x2f508 <btf__dedup+0xc68>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2f513: 41 89 cb                     	movl	%ecx, %r11d
   2f516: 41 29 d3                     	subl	%edx, %r11d
   2f519: 48 8b 50 30                  	movq	48(%rax), %rdx
; 	return BTF_INFO_KIND(t->info);
   2f51d: 48 8b 40 20                  	movq	32(%rax), %rax
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2f521: 42 8b 14 9a                  	movl	(%rdx,%r11,4), %edx
; 	return BTF_INFO_KIND(t->info);
   2f525: 0f b6 44 10 07               	movzbl	7(%rax,%rdx), %eax
   2f52a: 83 e0 1f                     	andl	$31, %eax
; 		if (btf_is_var(t) || btf_is_datasec(t))
   2f52d: 83 e8 0e                     	subl	$14, %eax
   2f530: 66 83 f8 02                  	cmpw	$2, %ax
   2f534: 41 0f 43 c9                  	cmovael	%r9d, %ecx
; 			d->map[i] = i;
   2f538: 41 89 0c b0                  	movl	%ecx, (%r8,%rsi,4)
; 	for (i = 1; i < type_cnt; i++) {
   2f53c: 48 83 c6 01                  	addq	$1, %rsi
   2f540: 49 39 f2                     	cmpq	%rsi, %r10
   2f543: 75 b3                        	jne	0x2f4f8 <btf__dedup+0xc58>
; 	d->hypot_map = malloc(sizeof(__u32) * type_cnt);
   2f545: 4c 89 ef                     	movq	%r13, %rdi
   2f548: e8 43 65 fd ff               	callq	0x5a90 <.plt.sec+0x420>
   2f54d: 49 89 47 20                  	movq	%rax, 32(%r15)
   2f551: 48 89 c7                     	movq	%rax, %rdi
; 	if (!d->hypot_map) {
   2f554: 48 85 c0                     	testq	%rax, %rax
   2f557: 0f 84 80 06 00 00            	je	0x2fbdd <btf__dedup+0x133d>
; 		d->hypot_map[i] = BTF_UNPROCESSED_ID;
   2f55d: 8d 43 ff                     	leal	-1(%rbx), %eax
   2f560: 85 db                        	testl	%ebx, %ebx
   2f562: be ff 00 00 00               	movl	$255, %esi
   2f567: 48 8d 14 85 04 00 00 00      	leaq	4(,%rax,4), %rdx
   2f56f: b8 04 00 00 00               	movl	$4, %eax
   2f574: 48 0f 4e d0                  	cmovleq	%rax, %rdx
   2f578: e8 43 63 fd ff               	callq	0x58c0 <.plt.sec+0x250>
   2f57d: e9 4c f4 ff ff               	jmp	0x2e9ce <btf__dedup+0x12e>
; 	d->btf = btf;
   2f582: 49 89 2f                     	movq	%rbp, (%r15)
; 	hashmap_hash_fn hash_fn = btf_dedup_identity_hash_fn;
   2f585: 48 8d 3d 04 94 ff ff         	leaq	-27644(%rip), %rdi      # 0x28990 <btf_dedup_identity_hash_fn>
; 	d->btf_ext = OPTS_GET(opts, btf_ext, NULL);
   2f58c: 0f 84 d4 f3 ff ff            	je	0x2e966 <btf__dedup+0xc6>
   2f592: 31 db                        	xorl	%ebx, %ebx
   2f594: e9 d1 f3 ff ff               	jmp	0x2e96a <btf__dedup+0xca>
; 	struct btf_dedup *d = calloc(1, sizeof(struct btf_dedup));
   2f599: be 68 00 00 00               	movl	$104, %esi
   2f59e: bf 01 00 00 00               	movl	$1, %edi
   2f5a3: e8 e8 63 fd ff               	callq	0x5990 <.plt.sec+0x320>
   2f5a8: 49 89 c7                     	movq	%rax, %r15
; 	if (!d)
   2f5ab: 48 85 c0                     	testq	%rax, %rax
   2f5ae: 0f 84 13 06 00 00            	je	0x2fbc7 <btf__dedup+0x1327>
; 	d->btf = btf;
   2f5b4: 49 89 2f                     	movq	%rbp, (%r15)
; 	hashmap_hash_fn hash_fn = btf_dedup_identity_hash_fn;
   2f5b7: 48 8d 3d d2 93 ff ff         	leaq	-27694(%rip), %rdi      # 0x28990 <btf_dedup_identity_hash_fn>
   2f5be: e9 a7 f3 ff ff               	jmp	0x2e96a <btf__dedup+0xca>
; 		switch (btf_kind(t)) {
   2f5c3: 0f b7 d0                     	movzwl	%ax, %edx
; 			pr_debug("unknown kind %d for type [%d]\n", btf_kind(t), type_id);
   2f5c6: 44 89 c1                     	movl	%r8d, %ecx
   2f5c9: 48 8d 35 40 c2 00 00         	leaq	49728(%rip), %rsi       # 0x3b810 <CSWTCH.126+0x1f10>
   2f5d0: 31 c0                        	xorl	%eax, %eax
   2f5d2: bf 02 00 00 00               	movl	$2, %edi
   2f5d7: bb 16 00 00 00               	movl	$22, %ebx
; 			return -EINVAL;
   2f5dc: 41 be ea ff ff ff            	movl	$4294967274, %r14d      # imm = 0xFFFFFFEA
; 			pr_debug("unknown kind %d for type [%d]\n", btf_kind(t), type_id);
   2f5e2: e8 e9 8a fd ff               	callq	0x80d0 <libbpf_print>
; 		pr_debug("btf_dedup_prep failed:%d\n", err);
   2f5e7: 44 89 f2                     	movl	%r14d, %edx
   2f5ea: 48 8d 35 47 c2 00 00         	leaq	49735(%rip), %rsi       # 0x3b838 <CSWTCH.126+0x1f38>
   2f5f1: bf 02 00 00 00               	movl	$2, %edi
   2f5f6: 31 c0                        	xorl	%eax, %eax
   2f5f8: e8 d3 8a fd ff               	callq	0x80d0 <libbpf_print>
; 		goto done;
   2f5fd: e9 69 fe ff ff               	jmp	0x2f46b <btf__dedup+0xbcb>
; 	d->strs_set = strset__new(BTF_MAX_STR_OFFSET, NULL, 0);
   2f602: bf ff ff ff 7f               	movl	$2147483647, %edi       # imm = 0x7FFFFFFF
   2f607: 31 d2                        	xorl	%edx, %edx
   2f609: 31 f6                        	xorl	%esi, %esi
   2f60b: e8 60 06 00 00               	callq	0x2fc70 <strset__new>
   2f610: 49 89 47 60                  	movq	%rax, 96(%r15)
   2f614: 48 89 c7                     	movq	%rax, %rdi
; 		err = PTR_ERR(d->strs_set);
   2f617: 41 89 c6                     	movl	%eax, %r14d
; 	if (IS_ERR(d->strs_set)) {
   2f61a: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2f620: 0f 87 5b 03 00 00            	ja	0x2f981 <btf__dedup+0x10e1>
; 	if (!d->btf->base_btf) {
   2f626: 4d 8b 1f                     	movq	(%r15), %r11
   2f629: 49 83 7b 48 00               	cmpq	$0, 72(%r11)
   2f62e: 4c 89 da                     	movq	%r11, %rdx
   2f631: 0f 84 e8 04 00 00            	je	0x2fb1f <btf__dedup+0x127f>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2f637: 41 8b 7b 40                  	movl	64(%r11), %edi
   2f63b: 45 31 e4                     	xorl	%r12d, %r12d
   2f63e: 48 8d 2d 6b c7 ff ff         	leaq	-14485(%rip), %rbp      # 0x2bdb0 <strs_dedup_remap_str_off>
; 		return &btf_void;
   2f645: 48 8d 1d 44 7c 01 00         	leaq	97348(%rip), %rbx       # 0x47290 <btf_void>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2f64c: 85 ff                        	testl	%edi, %edi
   2f64e: 74 4b                        	je	0x2f69b <btf__dedup+0xdfb>
; 		struct btf_type *t = btf_type_by_id(d->btf, d->btf->start_id + i);
   2f650: 41 8b 43 50                  	movl	80(%r11), %eax
; 		return &btf_void;
   2f654: 48 89 df                     	movq	%rbx, %rdi
; 	if (type_id == 0)
   2f657: 89 c1                        	movl	%eax, %ecx
   2f659: 44 01 e1                     	addl	%r12d, %ecx
   2f65c: 75 09                        	jne	0x2f667 <btf__dedup+0xdc7>
   2f65e: eb 18                        	jmp	0x2f678 <btf__dedup+0xdd8>
; 		return btf_type_by_id(btf->base_btf, type_id);
   2f660: 48 8b 52 48                  	movq	72(%rdx), %rdx
; 	if (type_id < btf->start_id)
   2f664: 8b 42 50                     	movl	80(%rdx), %eax
   2f667: 39 c1                        	cmpl	%eax, %ecx
   2f669: 72 f5                        	jb	0x2f660 <btf__dedup+0xdc0>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2f66b: 29 c1                        	subl	%eax, %ecx
   2f66d: 48 8b 42 30                  	movq	48(%rdx), %rax
   2f671: 8b 3c 88                     	movl	(%rax,%rcx,4), %edi
   2f674: 48 03 7a 20                  	addq	32(%rdx), %rdi
; 		r = btf_type_visit_str_offs(t, fn, ctx);
   2f678: 4c 89 fa                     	movq	%r15, %rdx
   2f67b: 48 89 ee                     	movq	%rbp, %rsi
   2f67e: e8 7d ea ff ff               	callq	0x2e100 <btf_type_visit_str_offs>
; 		if (r)
   2f683: 85 c0                        	testl	%eax, %eax
   2f685: 0f 85 ef 02 00 00            	jne	0x2f97a <btf__dedup+0x10da>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2f68b: 4d 8b 1f                     	movq	(%r15), %r11
   2f68e: 41 83 c4 01                  	addl	$1, %r12d
   2f692: 4c 89 da                     	movq	%r11, %rdx
   2f695: 45 39 63 40                  	cmpl	%r12d, 64(%r11)
   2f699: 77 b5                        	ja	0x2f650 <btf__dedup+0xdb0>
; 	if (!d->btf_ext)
   2f69b: 49 8b 7f 08                  	movq	8(%r15), %rdi
   2f69f: 48 85 ff                     	testq	%rdi, %rdi
   2f6a2: 74 1d                        	je	0x2f6c1 <btf__dedup+0xe21>
; 	r = btf_ext_visit_str_offs(d->btf_ext, fn, ctx);
   2f6a4: 4c 89 fa                     	movq	%r15, %rdx
   2f6a7: 48 8d 35 02 c7 ff ff         	leaq	-14590(%rip), %rsi      # 0x2bdb0 <strs_dedup_remap_str_off>
   2f6ae: e8 5d f0 ff ff               	callq	0x2e710 <btf_ext_visit_str_offs>
   2f6b3: 41 89 c6                     	movl	%eax, %r14d
; 	if (r)
   2f6b6: 85 c0                        	testl	%eax, %eax
   2f6b8: 0f 85 bf 02 00 00            	jne	0x2f97d <btf__dedup+0x10dd>
   2f6be: 4d 8b 1f                     	movq	(%r15), %r11
; 	strset__free(d->btf->strs_set);
   2f6c1: 49 8b 7b 60                  	movq	96(%r11), %rdi
   2f6c5: e8 e6 06 00 00               	callq	0x2fdb0 <strset__free>
; 	d->btf->hdr->str_len = strset__data_size(d->strs_set);
   2f6ca: 49 8b 7f 60                  	movq	96(%r15), %rdi
   2f6ce: e8 2d 07 00 00               	callq	0x2fe00 <strset__data_size>
   2f6d3: 4d 8b 1f                     	movq	(%r15), %r11
   2f6d6: 49 89 c0                     	movq	%rax, %r8
   2f6d9: 49 8b 53 18                  	movq	24(%r11), %rdx
   2f6dd: 4c 89 d8                     	movq	%r11, %rax
   2f6e0: 44 89 42 14                  	movl	%r8d, 20(%rdx)
; 	d->btf->strs_set = d->strs_set;
   2f6e4: 49 8b 57 60                  	movq	96(%r15), %rdx
   2f6e8: 49 89 53 60                  	movq	%rdx, 96(%r11)
; 	d->strs_set = NULL;
   2f6ec: 49 c7 47 60 00 00 00 00      	movq	$0, 96(%r15)
; 	d->btf->strs_deduped = true;
   2f6f4: 41 c6 43 68 01               	movb	$1, 104(%r11)
; 	if (err < 0) {
   2f6f9: e9 d1 f3 ff ff               	jmp	0x2eacf <btf__dedup+0x22f>
   2f6fe: 66 90                        	nop
; 		if (d->hypot_adjust_canon)
   2f700: 45 84 d2                     	testb	%r10b, %r10b
   2f703: 0f 85 6f f9 ff ff            	jne	0x2f078 <btf__dedup+0x7d8>
; 		if (t_kind == BTF_KIND_FWD && c_kind != BTF_KIND_FWD)
   2f709: 66 41 83 f9 07               	cmpw	$7, %r9w
   2f70e: 0f 95 c1                     	setne	%cl
   2f711: 66 41 83 fb 07               	cmpw	$7, %r11w
   2f716: 0f 85 94 00 00 00            	jne	0x2f7b0 <btf__dedup+0xf10>
   2f71c: 84 c9                        	testb	%cl, %cl
   2f71e: 0f 84 8c 00 00 00            	je	0x2f7b0 <btf__dedup+0xf10>
; 			d->map[t_id] = c_id;
   2f724: 41 89 30                     	movl	%esi, (%r8)
; 	for (i = 0; i < d->hypot_cnt; i++) {
   2f727: 49 83 c6 01                  	addq	$1, %r14
   2f72b: 4c 39 74 24 20               	cmpq	%r14, 32(%rsp)
   2f730: 0f 85 1a f8 ff ff            	jne	0x2ef50 <btf__dedup+0x6b0>
   2f736: 44 8b 74 24 54               	movl	84(%rsp), %r14d
   2f73b: 45 89 ec                     	movl	%r13d, %r12d
   2f73e: e9 60 f9 ff ff               	jmp	0x2f0a3 <btf__dedup+0x803>
; 		pr_warn("%s size (%zu) is too small\n", type_name, user_sz);
   2f743: 4c 89 e1                     	movq	%r12, %rcx
   2f746: 48 8d 15 c9 c4 00 00         	leaq	50377(%rip), %rdx       # 0x3bc16 <CSWTCH.126+0x2316>
   2f74d: 31 ff                        	xorl	%edi, %edi
   2f74f: 31 c0                        	xorl	%eax, %eax
   2f751: 48 8d 35 60 48 00 00         	leaq	18528(%rip), %rsi       # 0x33fb8 <strs.2+0x1128>
   2f758: e8 73 89 fd ff               	callq	0x80d0 <libbpf_print>
; 		return false;
   2f75d: e9 ab f1 ff ff               	jmp	0x2e90d <btf__dedup+0x6d>
   2f762: 44 8b 74 24 54               	movl	84(%rsp), %r14d
   2f767: 4d 8b 57 10                  	movq	16(%r15), %r10
; 	d->map[type_id] = new_id;
   2f76b: 4c 8b 44 24 48               	movq	72(%rsp), %r8
   2f770: 4d 03 47 18                  	addq	24(%r15), %r8
   2f774: 45 89 30                     	movl	%r14d, (%r8)
; 	return hashmap__insert(map, key, value, HASHMAP_APPEND, NULL, NULL);
   2f777: 48 8b 54 24 40               	movq	64(%rsp), %rdx
   2f77c: 48 8b 74 24 10               	movq	16(%rsp), %rsi
   2f781: 45 31 c9                     	xorl	%r9d, %r9d
   2f784: 45 31 c0                     	xorl	%r8d, %r8d
   2f787: b9 03 00 00 00               	movl	$3, %ecx
   2f78c: 4c 89 d7                     	movq	%r10, %rdi
   2f78f: e8 7c ed fe ff               	callq	0x1e510 <hashmap__insert>
; 	if (type_id == new_id && btf_dedup_table_add(d, h, type_id))
   2f794: 85 c0                        	testl	%eax, %eax
   2f796: 0f 84 1a f9 ff ff            	je	0x2f0b6 <btf__dedup+0x816>
; 		return -ENOMEM;
   2f79c: 41 be f4 ff ff ff            	movl	$4294967284, %r14d      # imm = 0xFFFFFFF4
   2f7a2: e9 a4 03 00 00               	jmp	0x2fb4b <btf__dedup+0x12ab>
   2f7a7: 66 0f 1f 84 00 00 00 00 00   	nopw	(%rax,%rax)
; 		if ((t_kind == BTF_KIND_STRUCT || t_kind == BTF_KIND_UNION) &&
   2f7b0: 41 83 eb 04                  	subl	$4, %r11d
   2f7b4: 66 41 83 fb 01               	cmpw	$1, %r11w
   2f7b9: 0f 87 68 ff ff ff            	ja	0x2f727 <btf__dedup+0xe87>
   2f7bf: 84 c9                        	testb	%cl, %cl
   2f7c1: 0f 84 60 ff ff ff            	je	0x2f727 <btf__dedup+0xe87>
; 		    c_kind != BTF_KIND_FWD &&
   2f7c7: 85 c0                        	testl	%eax, %eax
   2f7c9: 0f 88 58 ff ff ff            	js	0x2f727 <btf__dedup+0xe87>
; 		    is_type_mapped(d, c_id) &&
   2f7cf: 85 d2                        	testl	%edx, %edx
   2f7d1: 0f 89 50 ff ff ff            	jns	0x2f727 <btf__dedup+0xe87>
   2f7d7: e9 48 ff ff ff               	jmp	0x2f724 <btf__dedup+0xe84>
; 	hashmap__free(d->dedup_table);
   2f7dc: 49 8b 7f 10                  	movq	16(%r15), %rdi
   2f7e0: e8 cb ec fe ff               	callq	0x1e4b0 <hashmap__free>
; 	__u32 next_type_id = d->btf->start_id;
   2f7e5: 4d 8b 1f                     	movq	(%r15), %r11
; 	d->hypot_map[0] = 0;
   2f7e8: 4d 8b 47 20                  	movq	32(%r15), %r8
; 	d->dedup_table = NULL;
   2f7ec: 49 c7 47 10 00 00 00 00      	movq	$0, 16(%r15)
; 	for (id = 1; id < d->btf->start_id; id++)
   2f7f4: ba 01 00 00 00               	movl	$1, %edx
; 	__u32 next_type_id = d->btf->start_id;
   2f7f9: 41 8b 5b 50                  	movl	80(%r11), %ebx
; 	d->hypot_map[0] = 0;
   2f7fd: 41 c7 00 00 00 00 00         	movl	$0, (%r8)
; 	__u32 next_type_id = d->btf->start_id;
   2f804: 4c 89 d8                     	movq	%r11, %rax
; 	for (id = 1; id < d->btf->start_id; id++)
   2f807: 49 63 7b 50                  	movslq	80(%r11), %rdi
   2f80b: 83 ff 01                     	cmpl	$1, %edi
   2f80e: 7e 10                        	jle	0x2f820 <btf__dedup+0xf80>
; 		d->hypot_map[id] = id;
   2f810: 41 89 14 90                  	movl	%edx, (%r8,%rdx,4)
; 	for (id = 1; id < d->btf->start_id; id++)
   2f814: 49 63 7b 50                  	movslq	80(%r11), %rdi
   2f818: 48 83 c2 01                  	addq	$1, %rdx
   2f81c: 39 d7                        	cmpl	%edx, %edi
   2f81e: 7f f0                        	jg	0x2f810 <btf__dedup+0xf70>
; 	for (i = 0, id = d->btf->start_id; i < d->btf->nr_types; i++, id++)
   2f820: 41 8b 73 40                  	movl	64(%r11), %esi
; 	p = d->btf->types_data;
   2f824: 49 8b 4b 20                  	movq	32(%r11), %rcx
; 	for (i = 0, id = d->btf->start_id; i < d->btf->nr_types; i++, id++)
   2f828: 85 f6                        	testl	%esi, %esi
   2f82a: 0f 84 7a 01 00 00            	je	0x2f9aa <btf__dedup+0x110a>
   2f830: 49 8d 3c b8                  	leaq	(%r8,%rdi,4), %rdi
   2f834: 31 d2                        	xorl	%edx, %edx
   2f836: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		d->hypot_map[id] = BTF_UNPROCESSED_ID;
   2f840: c7 04 97 ff ff ff ff         	movl	$4294967295, (%rdi,%rdx,4) # imm = 0xFFFFFFFF
; 	for (i = 0, id = d->btf->start_id; i < d->btf->nr_types; i++, id++)
   2f847: 41 8b 73 40                  	movl	64(%r11), %esi
   2f84b: 48 83 c2 01                  	addq	$1, %rdx
   2f84f: 39 d6                        	cmpl	%edx, %esi
   2f851: 77 ed                        	ja	0x2f840 <btf__dedup+0xfa0>
; 	for (i = 0, id = d->btf->start_id; i < d->btf->nr_types; i++, id++) {
   2f853: 41 8b 6b 50                  	movl	80(%r11), %ebp
   2f857: 85 f6                        	testl	%esi, %esi
   2f859: 0f 84 4b 01 00 00            	je	0x2f9aa <btf__dedup+0x110a>
   2f85f: 4c 63 e5                     	movslq	%ebp, %r12
   2f862: 45 31 ed                     	xorl	%r13d, %r13d
; 		return &btf_void;
   2f865: 49 89 ce                     	movq	%rcx, %r14
   2f868: 49 c1 e4 02                  	shlq	$2, %r12
   2f86c: eb 1d                        	jmp	0x2f88b <btf__dedup+0xfeb>
   2f86e: 66 90                        	nop
; 	for (i = 0, id = d->btf->start_id; i < d->btf->nr_types; i++, id++) {
   2f870: 4c 89 d8                     	movq	%r11, %rax
   2f873: 41 8b 73 40                  	movl	64(%r11), %esi
   2f877: 41 83 c5 01                  	addl	$1, %r13d
   2f87b: 83 c5 01                     	addl	$1, %ebp
   2f87e: 49 83 c4 04                  	addq	$4, %r12
   2f882: 44 39 ee                     	cmpl	%r13d, %esi
   2f885: 0f 86 18 01 00 00            	jbe	0x2f9a3 <btf__dedup+0x1103>
; 		if (d->map[id] != id)
   2f88b: 49 8b 57 18                  	movq	24(%r15), %rdx
   2f88f: 42 39 2c 22                  	cmpl	%ebp, (%rdx,%r12)
   2f893: 75 db                        	jne	0x2f870 <btf__dedup+0xfd0>
; 	if (type_id >= btf->start_id + btf->nr_types)
   2f895: 41 8b 53 50                  	movl	80(%r11), %edx
   2f899: 01 d6                        	addl	%edx, %esi
   2f89b: 39 ee                        	cmpl	%ebp, %esi
   2f89d: 0f 86 a7 64 fd ff            	jbe	0x5d4a <btf__dedup.cold+0x28>
; 		return &btf_void;
   2f8a3: 48 8d 35 e6 79 01 00         	leaq	96742(%rip), %rsi       # 0x47290 <btf_void>
; 	if (type_id == 0)
   2f8aa: 85 ed                        	testl	%ebp, %ebp
   2f8ac: 75 09                        	jne	0x2f8b7 <btf__dedup+0x1017>
   2f8ae: eb 1a                        	jmp	0x2f8ca <btf__dedup+0x102a>
; 		return btf_type_by_id(btf->base_btf, type_id);
   2f8b0: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2f8b4: 8b 50 50                     	movl	80(%rax), %edx
   2f8b7: 39 ea                        	cmpl	%ebp, %edx
   2f8b9: 77 f5                        	ja	0x2f8b0 <btf__dedup+0x1010>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2f8bb: 89 e9                        	movl	%ebp, %ecx
   2f8bd: 29 d1                        	subl	%edx, %ecx
   2f8bf: 48 8b 50 30                  	movq	48(%rax), %rdx
   2f8c3: 8b 34 8a                     	movl	(%rdx,%rcx,4), %esi
   2f8c6: 48 03 70 20                  	addq	32(%rax), %rsi
; 		len = btf_type_size(t);
   2f8ca: 8b 7e 04                     	movl	4(%rsi), %edi
   2f8cd: 48 89 74 24 10               	movq	%rsi, 16(%rsp)
   2f8d2: e8 d9 99 ff ff               	callq	0x292b0 <btf_type_size.isra.0>
; 		if (len < 0)
   2f8d7: 85 c0                        	testl	%eax, %eax
   2f8d9: 0f 88 7b 02 00 00            	js	0x2fb5a <btf__dedup+0x12ba>
;   return __builtin___memmove_chk (__dest, __src, __len,
   2f8df: 48 8b 74 24 10               	movq	16(%rsp), %rsi
; 		memmove(p, t, len);
   2f8e4: 48 63 d0                     	movslq	%eax, %rdx
;   return __builtin___memmove_chk (__dest, __src, __len,
   2f8e7: 4c 89 f7                     	movq	%r14, %rdi
   2f8ea: 48 89 54 24 08               	movq	%rdx, 8(%rsp)
   2f8ef: e8 8c 62 fd ff               	callq	0x5b80 <.plt.sec+0x510>
; 		d->btf->type_offs[next_type_id - d->btf->start_id] = p - d->btf->types_data;
   2f8f4: 4d 8b 1f                     	movq	(%r15), %r11
; 		d->hypot_map[id] = next_type_id;
   2f8f7: 49 8b 47 20                  	movq	32(%r15), %rax
; 		d->btf->type_offs[next_type_id - d->btf->start_id] = p - d->btf->types_data;
   2f8fb: 89 de                        	movl	%ebx, %esi
; 		p += len;
   2f8fd: 48 8b 54 24 08               	movq	8(%rsp), %rdx
; 		d->btf->type_offs[next_type_id - d->btf->start_id] = p - d->btf->types_data;
   2f902: 4c 89 f7                     	movq	%r14, %rdi
   2f905: 49 8b 4b 30                  	movq	48(%r11), %rcx
   2f909: 49 2b 7b 20                  	subq	32(%r11), %rdi
; 		d->hypot_map[id] = next_type_id;
   2f90d: 42 89 1c 20                  	movl	%ebx, (%rax,%r12)
; 		d->btf->type_offs[next_type_id - d->btf->start_id] = p - d->btf->types_data;
   2f911: 4c 89 d8                     	movq	%r11, %rax
   2f914: 41 2b 73 50                  	subl	80(%r11), %esi
; 		p += len;
   2f918: 49 01 d6                     	addq	%rdx, %r14
; 		next_type_id++;
   2f91b: 83 c3 01                     	addl	$1, %ebx
; 		d->btf->type_offs[next_type_id - d->btf->start_id] = p - d->btf->types_data;
   2f91e: 89 3c b1                     	movl	%edi, (%rcx,%rsi,4)
; 		next_type_id++;
   2f921: e9 4d ff ff ff               	jmp	0x2f873 <btf__dedup+0xfd3>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2f926: 85 d2                        	testl	%edx, %edx
   2f928: 0f 84 ae fe ff ff            	je	0x2f7dc <btf__dedup+0xf3c>
   2f92e: 31 db                        	xorl	%ebx, %ebx
   2f930: eb 15                        	jmp	0x2f947 <btf__dedup+0x10a7>
   2f932: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2f938: 49 8b 07                     	movq	(%r15), %rax
   2f93b: 83 c3 01                     	addl	$1, %ebx
   2f93e: 39 58 40                     	cmpl	%ebx, 64(%rax)
   2f941: 0f 86 95 fe ff ff            	jbe	0x2f7dc <btf__dedup+0xf3c>
; 		err = btf_dedup_ref_type(d, d->btf->start_id + i);
   2f947: 8b 70 50                     	movl	80(%rax), %esi
   2f94a: 4c 89 ff                     	movq	%r15, %rdi
   2f94d: 01 de                        	addl	%ebx, %esi
   2f94f: e8 3c 9e ff ff               	callq	0x29790 <btf_dedup_ref_type>
; 		if (err < 0)
   2f954: 85 c0                        	testl	%eax, %eax
   2f956: 79 e0                        	jns	0x2f938 <btf__dedup+0x1098>
; 		pr_debug("btf_dedup_ref_types failed:%d\n", err);
   2f958: 41 89 c6                     	movl	%eax, %r14d
   2f95b: 89 c2                        	movl	%eax, %edx
   2f95d: 48 8d 35 24 bf 00 00         	leaq	48932(%rip), %rsi       # 0x3b888 <CSWTCH.126+0x1f88>
; 		pr_debug("btf_dedup_remap_types failed:%d\n", err);
   2f964: bf 02 00 00 00               	movl	$2, %edi
   2f969: 31 c0                        	xorl	%eax, %eax
; 		errno = -ret;
   2f96b: 44 89 f3                     	movl	%r14d, %ebx
; 		pr_debug("btf_dedup_remap_types failed:%d\n", err);
   2f96e: e8 5d 87 fd ff               	callq	0x80d0 <libbpf_print>
; 		errno = -ret;
   2f973: f7 db                        	negl	%ebx
; 		goto done;
   2f975: e9 f1 fa ff ff               	jmp	0x2f46b <btf__dedup+0xbcb>
; 	strset__free(d->strs_set);
   2f97a: 41 89 c6                     	movl	%eax, %r14d
   2f97d: 49 8b 7f 60                  	movq	96(%r15), %rdi
   2f981: e8 2a 04 00 00               	callq	0x2fdb0 <strset__free>
; 	d->strs_set = NULL;
   2f986: 49 c7 47 60 00 00 00 00      	movq	$0, 96(%r15)
; 	if (err < 0) {
   2f98e: 45 85 f6                     	testl	%r14d, %r14d
   2f991: 0f 89 a6 01 00 00            	jns	0x2fb3d <btf__dedup+0x129d>
; 		pr_debug("btf_dedup_strings failed:%d\n", err);
   2f997: 44 89 f2                     	movl	%r14d, %edx
   2f99a: 48 8d 35 bf be 00 00         	leaq	48831(%rip), %rsi       # 0x3b860 <CSWTCH.126+0x1f60>
   2f9a1: eb c1                        	jmp	0x2f964 <btf__dedup+0x10c4>
; 	d->btf->hdr->type_len = p - d->btf->types_data;
   2f9a3: 44 89 f6                     	movl	%r14d, %esi
   2f9a6: 41 2b 73 20                  	subl	32(%r11), %esi
   2f9aa: 49 8b 53 18                  	movq	24(%r11), %rdx
; 	d->btf->nr_types = next_type_id - d->btf->start_id;
   2f9ae: 89 d8                        	movl	%ebx, %eax
   2f9b0: 41 2b 43 50                  	subl	80(%r11), %eax
   2f9b4: 41 89 43 40                  	movl	%eax, 64(%r11)
; 	return realloc(ptr, total);
   2f9b8: 49 8b 7b 30                  	movq	48(%r11), %rdi
; 	d->btf->type_offs_cap = d->btf->nr_types;
   2f9bc: 49 89 43 38                  	movq	%rax, 56(%r11)
; 	d->btf->hdr->type_len = p - d->btf->types_data;
   2f9c0: 89 72 0c                     	movl	%esi, 12(%rdx)
; 	if (unlikely(__builtin_mul_overflow(nmemb, size, &total)))
   2f9c3: 48 8d 34 85 00 00 00 00      	leaq	(,%rax,4), %rsi
; 	return realloc(ptr, total);
   2f9cb: e8 50 61 fd ff               	callq	0x5b20 <.plt.sec+0x4b0>
   2f9d0: 48 89 c2                     	movq	%rax, %rdx
; 	if (d->btf->type_offs_cap && !new_offs)
   2f9d3: 49 8b 07                     	movq	(%r15), %rax
   2f9d6: 48 83 78 38 00               	cmpq	$0, 56(%rax)
   2f9db: 74 1a                        	je	0x2f9f7 <btf__dedup+0x1157>
   2f9dd: 48 85 d2                     	testq	%rdx, %rdx
   2f9e0: 75 15                        	jne	0x2f9f7 <btf__dedup+0x1157>
; 		return -ENOMEM;
   2f9e2: 41 be f4 ff ff ff            	movl	$4294967284, %r14d      # imm = 0xFFFFFFF4
; 		pr_debug("btf_dedup_compact_types failed:%d\n", err);
   2f9e8: 44 89 f2                     	movl	%r14d, %edx
   2f9eb: 48 8d 35 be be 00 00         	leaq	48830(%rip), %rsi       # 0x3b8b0 <CSWTCH.126+0x1fb0>
   2f9f2: e9 6d ff ff ff               	jmp	0x2f964 <btf__dedup+0x10c4>
; 	d->btf->hdr->str_off = d->btf->hdr->type_len;
   2f9f7: 48 8b 48 18                  	movq	24(%rax), %rcx
; 	d->btf->type_offs = new_offs;
   2f9fb: 48 89 50 30                  	movq	%rdx, 48(%rax)
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2f9ff: 45 31 e4                     	xorl	%r12d, %r12d
   2fa02: 48 8d 2d 97 90 ff ff         	leaq	-28521(%rip), %rbp      # 0x28aa0 <btf_dedup_remap_type_id>
; 		return &btf_void;
   2fa09: 48 8d 1d 80 78 01 00         	leaq	96384(%rip), %rbx       # 0x47290 <btf_void>
; 	d->btf->hdr->str_off = d->btf->hdr->type_len;
   2fa10: 8b 51 0c                     	movl	12(%rcx), %edx
   2fa13: 89 51 10                     	movl	%edx, 16(%rcx)
; 	d->btf->raw_size = d->btf->hdr->hdr_len + d->btf->hdr->type_len + d->btf->hdr->str_len;
   2fa16: 03 51 04                     	addl	4(%rcx), %edx
   2fa19: 03 51 14                     	addl	20(%rcx), %edx
   2fa1c: 89 50 10                     	movl	%edx, 16(%rax)
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2fa1f: 8b 50 40                     	movl	64(%rax), %edx
   2fa22: 85 d2                        	testl	%edx, %edx
   2fa24: 74 52                        	je	0x2fa78 <btf__dedup+0x11d8>
   2fa26: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 		struct btf_type *t = btf_type_by_id(d->btf, d->btf->start_id + i);
   2fa30: 8b 50 50                     	movl	80(%rax), %edx
; 	if (type_id == 0)
   2fa33: 44 89 e1                     	movl	%r12d, %ecx
; 		return &btf_void;
   2fa36: 48 89 df                     	movq	%rbx, %rdi
; 	if (type_id == 0)
   2fa39: 01 d1                        	addl	%edx, %ecx
   2fa3b: 75 0a                        	jne	0x2fa47 <btf__dedup+0x11a7>
   2fa3d: eb 19                        	jmp	0x2fa58 <btf__dedup+0x11b8>
   2fa3f: 90                           	nop
; 		return btf_type_by_id(btf->base_btf, type_id);
   2fa40: 48 8b 40 48                  	movq	72(%rax), %rax
; 	if (type_id < btf->start_id)
   2fa44: 8b 50 50                     	movl	80(%rax), %edx
   2fa47: 39 d1                        	cmpl	%edx, %ecx
   2fa49: 72 f5                        	jb	0x2fa40 <btf__dedup+0x11a0>
; 	return btf->types_data + btf->type_offs[type_id - btf->start_id];
   2fa4b: 29 d1                        	subl	%edx, %ecx
   2fa4d: 48 8b 50 30                  	movq	48(%rax), %rdx
   2fa51: 8b 3c 8a                     	movl	(%rdx,%rcx,4), %edi
   2fa54: 48 03 78 20                  	addq	32(%rax), %rdi
; 		r = btf_type_visit_type_ids(t, btf_dedup_remap_type_id, d);
   2fa58: 4c 89 fa                     	movq	%r15, %rdx
   2fa5b: 48 89 ee                     	movq	%rbp, %rsi
   2fa5e: e8 4d e5 ff ff               	callq	0x2dfb0 <btf_type_visit_type_ids>
; 		if (r)
   2fa63: 85 c0                        	testl	%eax, %eax
   2fa65: 0f 85 9d 00 00 00            	jne	0x2fb08 <btf__dedup+0x1268>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2fa6b: 49 8b 07                     	movq	(%r15), %rax
   2fa6e: 41 83 c4 01                  	addl	$1, %r12d
   2fa72: 44 39 60 40                  	cmpl	%r12d, 64(%rax)
   2fa76: 77 b8                        	ja	0x2fa30 <btf__dedup+0x1190>
; 	if (!d->btf_ext)
   2fa78: 49 8b 7f 08                  	movq	8(%r15), %rdi
   2fa7c: 48 85 ff                     	testq	%rdi, %rdi
   2fa7f: 74 16                        	je	0x2fa97 <btf__dedup+0x11f7>
; 	r = btf_ext_visit_type_ids(d->btf_ext, btf_dedup_remap_type_id, d);
   2fa81: 4c 89 fa                     	movq	%r15, %rdx
   2fa84: 48 8d 35 15 90 ff ff         	leaq	-28651(%rip), %rsi      # 0x28aa0 <btf_dedup_remap_type_id>
   2fa8b: e8 60 eb ff ff               	callq	0x2e5f0 <btf_ext_visit_type_ids>
   2fa90: 41 89 c6                     	movl	%eax, %r14d
; 	if (r)
   2fa93: 85 c0                        	testl	%eax, %eax
   2fa95: 75 74                        	jne	0x2fb0b <btf__dedup+0x126b>
; 		return 0;
   2fa97: 45 31 f6                     	xorl	%r14d, %r14d
; 	hashmap__free(d->dedup_table);
   2fa9a: 49 8b 7f 10                  	movq	16(%r15), %rdi
   2fa9e: e8 0d ea fe ff               	callq	0x1e4b0 <hashmap__free>
; 	free(d->map);
   2faa3: 49 8b 7f 18                  	movq	24(%r15), %rdi
   2faa7: e8 14 5c fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d->hypot_map);
   2faac: 49 8b 7f 20                  	movq	32(%r15), %rdi
   2fab0: e8 0b 5c fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d->hypot_list);
   2fab5: 49 8b 7f 28                  	movq	40(%r15), %rdi
   2fab9: e8 02 5c fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(d);
   2fabe: 4c 89 ff                     	movq	%r15, %rdi
   2fac1: e8 fa 5b fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	if (ret < 0)
   2fac6: e9 d3 f9 ff ff               	jmp	0x2f49e <btf__dedup+0xbfe>
; 	d->hypot_map = malloc(sizeof(__u32) * type_cnt);
   2facb: 4c 89 ef                     	movq	%r13, %rdi
   2face: e8 bd 5f fd ff               	callq	0x5a90 <.plt.sec+0x420>
   2fad3: 49 89 47 20                  	movq	%rax, 32(%r15)
   2fad7: 48 89 c7                     	movq	%rax, %rdi
; 	if (!d->hypot_map) {
   2fada: 48 85 c0                     	testq	%rax, %rax
   2fadd: 0f 84 fa 00 00 00            	je	0x2fbdd <btf__dedup+0x133d>
; 	for (i = 0; i < type_cnt; i++)
   2fae3: 83 fb 01                     	cmpl	$1, %ebx
   2fae6: 0f 85 e2 ee ff ff            	jne	0x2e9ce <btf__dedup+0x12e>
   2faec: e9 6c fa ff ff               	jmp	0x2f55d <btf__dedup+0xcbd>
   2faf1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
   2faf8: bb 0c 00 00 00               	movl	$12, %ebx
; 			return -ENOMEM;
   2fafd: 41 be f4 ff ff ff            	movl	$4294967284, %r14d      # imm = 0xFFFFFFF4
   2fb03: e9 df fa ff ff               	jmp	0x2f5e7 <btf__dedup+0xd47>
   2fb08: 41 89 c6                     	movl	%eax, %r14d
; 	if (err < 0) {
   2fb0b: 45 85 f6                     	testl	%r14d, %r14d
   2fb0e: 79 8a                        	jns	0x2fa9a <btf__dedup+0x11fa>
; 		pr_debug("btf_dedup_remap_types failed:%d\n", err);
   2fb10: 44 89 f2                     	movl	%r14d, %edx
   2fb13: 48 8d 35 c6 bd 00 00         	leaq	48582(%rip), %rsi       # 0x3b8e0 <CSWTCH.126+0x1fe0>
   2fb1a: e9 45 fe ff ff               	jmp	0x2f964 <btf__dedup+0x10c4>
; 		err = strset__add_str(d->strs_set, "");
   2fb1f: 48 8d 35 37 23 00 00         	leaq	9015(%rip), %rsi        # 0x31e5d <_IO_stdin_used+0x1e5d>
   2fb26: e8 a5 03 00 00               	callq	0x2fed0 <strset__add_str>
   2fb2b: 41 89 c6                     	movl	%eax, %r14d
; 		if (err < 0)
   2fb2e: 85 c0                        	testl	%eax, %eax
   2fb30: 78 4b                        	js	0x2fb7d <btf__dedup+0x12dd>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2fb32: 4d 8b 1f                     	movq	(%r15), %r11
   2fb35: 4c 89 da                     	movq	%r11, %rdx
   2fb38: e9 fa fa ff ff               	jmp	0x2f637 <btf__dedup+0xd97>
; 	for (i = 0; i < d->btf->nr_types; i++) {
   2fb3d: 4d 8b 1f                     	movq	(%r15), %r11
   2fb40: 4c 89 d8                     	movq	%r11, %rax
   2fb43: e9 87 ef ff ff               	jmp	0x2eacf <btf__dedup+0x22f>
   2fb48: 41 89 c6                     	movl	%eax, %r14d
; 		pr_debug("btf_dedup_struct_types failed:%d\n", err);
   2fb4b: 44 89 f2                     	movl	%r14d, %edx
   2fb4e: 48 8d 35 bb bd 00 00         	leaq	48571(%rip), %rsi       # 0x3b910 <CSWTCH.126+0x2010>
   2fb55: e9 0a fe ff ff               	jmp	0x2f964 <btf__dedup+0x10c4>
   2fb5a: 41 89 c6                     	movl	%eax, %r14d
   2fb5d: e9 86 fe ff ff               	jmp	0x2f9e8 <btf__dedup+0x1148>
; 	return (long) ptr;
   2fb62: 4c 89 fa                     	movq	%r15, %rdx
; 		pr_debug("btf_dedup_new failed: %ld", PTR_ERR(d));
   2fb65: 48 8d 35 7c bc 00 00         	leaq	48252(%rip), %rsi       # 0x3b7e8 <CSWTCH.126+0x1ee8>
   2fb6c: bf 02 00 00 00               	movl	$2, %edi
   2fb71: 31 c0                        	xorl	%eax, %eax
   2fb73: e8 58 85 fd ff               	callq	0x80d0 <libbpf_print>
   2fb78: e9 90 ed ff ff               	jmp	0x2e90d <btf__dedup+0x6d>
; 	strset__free(d->strs_set);
   2fb7d: 49 8b 7f 60                  	movq	96(%r15), %rdi
   2fb81: e8 2a 02 00 00               	callq	0x2fdb0 <strset__free>
; 	d->strs_set = NULL;
   2fb86: 49 c7 47 60 00 00 00 00      	movq	$0, 96(%r15)
; 	if (err < 0) {
   2fb8e: e9 04 fe ff ff               	jmp	0x2f997 <btf__dedup+0x10f7>
; 	d->map[type_id] = new_id;
   2fb93: 4c 8b 44 24 48               	movq	72(%rsp), %r8
   2fb98: 4d 03 47 18                  	addq	24(%r15), %r8
   2fb9c: e9 d3 fb ff ff               	jmp	0x2f774 <btf__dedup+0xed4>
   2fba1: bb 0c 00 00 00               	movl	$12, %ebx
; 		return -ENOMEM;
   2fba6: 41 be f4 ff ff ff            	movl	$4294967284, %r14d      # imm = 0xFFFFFFF4
; 		pr_debug("btf_dedup_prim_types failed:%d\n", err);
   2fbac: 44 89 f2                     	movl	%r14d, %edx
   2fbaf: 48 8d 35 8a bd 00 00         	leaq	48522(%rip), %rsi       # 0x3b940 <CSWTCH.126+0x2040>
   2fbb6: bf 02 00 00 00               	movl	$2, %edi
   2fbbb: 31 c0                        	xorl	%eax, %eax
   2fbbd: e8 0e 85 fd ff               	callq	0x80d0 <libbpf_print>
; 		goto done;
   2fbc2: e9 a4 f8 ff ff               	jmp	0x2f46b <btf__dedup+0xbcb>
; 		err = -ENOMEM;
   2fbc7: 48 c7 c2 f4 ff ff ff         	movq	$-12, %rdx
   2fbce: eb 95                        	jmp	0x2fb65 <btf__dedup+0x12c5>
; 	switch (btf_kind(t)) {
   2fbd0: bb 16 00 00 00               	movl	$22, %ebx
   2fbd5: 41 be ea ff ff ff            	movl	$4294967274, %r14d      # imm = 0xFFFFFFEA
   2fbdb: eb cf                        	jmp	0x2fbac <btf__dedup+0x130c>
; 		err = -ENOMEM;
   2fbdd: bb f4 ff ff ff               	movl	$4294967284, %ebx       # imm = 0xFFFFFFF4
   2fbe2: e9 b9 ed ff ff               	jmp	0x2e9a0 <btf__dedup+0x100>
   2fbe7: 4d 8b 57 10                  	movq	16(%r15), %r10
   2fbeb: e9 dd f5 ff ff               	jmp	0x2f1cd <btf__dedup+0x92d>
   2fbf0: 4d 8b 57 10                  	movq	16(%r15), %r10
   2fbf4: e9 7e fb ff ff               	jmp	0x2f777 <btf__dedup+0xed7>
   2fbf9: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002fc00 <strset_hash_fn>:
; {
   2fc00: f3 0f 1e fa                  	endbr64
; 	const char *str = s->strs_data + (long)key;
   2fc04: 48 03 3e                     	addq	(%rsi), %rdi
; 	size_t h = 0;
   2fc07: 45 31 c0                     	xorl	%r8d, %r8d
; 	while (*s) {
   2fc0a: 48 0f be 07                  	movsbq	(%rdi), %rax
   2fc0e: 84 c0                        	testb	%al, %al
   2fc10: 74 20                        	je	0x2fc32 <strset_hash_fn+0x32>
   2fc12: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 		h = h * 31 + *s;
   2fc18: 4c 89 c2                     	movq	%r8, %rdx
; 		s++;
   2fc1b: 48 83 c7 01                  	addq	$1, %rdi
; 		h = h * 31 + *s;
   2fc1f: 48 c1 e2 05                  	shlq	$5, %rdx
   2fc23: 4c 29 c2                     	subq	%r8, %rdx
   2fc26: 4c 8d 04 10                  	leaq	(%rax,%rdx), %r8
; 	while (*s) {
   2fc2a: 48 0f be 07                  	movsbq	(%rdi), %rax
   2fc2e: 84 c0                        	testb	%al, %al
   2fc30: 75 e6                        	jne	0x2fc18 <strset_hash_fn+0x18>
; }
   2fc32: 4c 89 c0                     	movq	%r8, %rax
   2fc35: c3                           	retq
   2fc36: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000002fc40 <strset_equal_fn>:
; {
   2fc40: f3 0f 1e fa                  	endbr64
   2fc44: 48 83 ec 08                  	subq	$8, %rsp
   2fc48: 49 89 f8                     	movq	%rdi, %r8
; 	const char *str1 = s->strs_data + (long)key1;
   2fc4b: 48 8b 3a                     	movq	(%rdx), %rdi
; 	const char *str2 = s->strs_data + (long)key2;
   2fc4e: 48 01 fe                     	addq	%rdi, %rsi
; 	const char *str1 = s->strs_data + (long)key1;
   2fc51: 4c 01 c7                     	addq	%r8, %rdi
; 	return strcmp(str1, str2) == 0;
   2fc54: e8 57 5d fd ff               	callq	0x59b0 <.plt.sec+0x340>
   2fc59: 85 c0                        	testl	%eax, %eax
   2fc5b: 0f 94 c0                     	sete	%al
; }
   2fc5e: 48 83 c4 08                  	addq	$8, %rsp
   2fc62: c3                           	retq
   2fc63: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2fc6e: 66 90                        	nop

000000000002fc70 <strset__new>:
; {
   2fc70: f3 0f 1e fa                  	endbr64
   2fc74: 41 56                        	pushq	%r14
   2fc76: 49 89 fe                     	movq	%rdi, %r14
; 	struct strset *set = calloc(1, sizeof(*set));
   2fc79: bf 01 00 00 00               	movl	$1, %edi
; {
   2fc7e: 41 55                        	pushq	%r13
   2fc80: 49 89 f5                     	movq	%rsi, %r13
; 	struct strset *set = calloc(1, sizeof(*set));
   2fc83: be 28 00 00 00               	movl	$40, %esi
; {
   2fc88: 41 54                        	pushq	%r12
   2fc8a: 55                           	pushq	%rbp
   2fc8b: 53                           	pushq	%rbx
   2fc8c: 48 89 d3                     	movq	%rdx, %rbx
; 	struct strset *set = calloc(1, sizeof(*set));
   2fc8f: e8 fc 5c fd ff               	callq	0x5990 <.plt.sec+0x320>
; 	if (!set)
   2fc94: 48 85 c0                     	testq	%rax, %rax
   2fc97: 0f 84 00 01 00 00            	je	0x2fd9d <strset__new+0x12d>
; 	hash = hashmap__new(strset_hash_fn, strset_equal_fn, set);
   2fc9d: 48 89 c2                     	movq	%rax, %rdx
   2fca0: 48 8d 35 99 ff ff ff         	leaq	-103(%rip), %rsi        # 0x2fc40 <strset_equal_fn>
   2fca7: 48 8d 3d 52 ff ff ff         	leaq	-174(%rip), %rdi        # 0x2fc00 <strset_hash_fn>
   2fcae: 49 89 c4                     	movq	%rax, %r12
   2fcb1: e8 1a e7 fe ff               	callq	0x1e3d0 <hashmap__new>
   2fcb6: 48 89 c5                     	movq	%rax, %rbp
; 	if (IS_ERR(hash))
   2fcb9: 48 3d 00 f0 ff ff            	cmpq	$-4096, %rax            # imm = 0xF000
   2fcbf: 0f 87 93 00 00 00            	ja	0x2fd58 <strset__new+0xe8>
; 	set->strs_data_max_len = max_data_sz;
   2fcc5: 4d 89 74 24 18               	movq	%r14, 24(%r12)
; 	set->strs_hash = hash;
   2fcca: 49 89 44 24 20               	movq	%rax, 32(%r12)
; 	if (init_data) {
   2fccf: 4d 85 ed                     	testq	%r13, %r13
   2fcd2: 74 73                        	je	0x2fd47 <strset__new+0xd7>
; 		set->strs_data = malloc(init_data_sz);
   2fcd4: 48 89 df                     	movq	%rbx, %rdi
   2fcd7: e8 b4 5d fd ff               	callq	0x5a90 <.plt.sec+0x420>
   2fcdc: 49 89 04 24                  	movq	%rax, (%r12)
   2fce0: 48 89 c7                     	movq	%rax, %rdi
; 		if (!set->strs_data)
   2fce3: 48 85 c0                     	testq	%rax, %rax
   2fce6: 74 70                        	je	0x2fd58 <strset__new+0xe8>
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2fce8: 48 89 da                     	movq	%rbx, %rdx
   2fceb: 4c 89 ee                     	movq	%r13, %rsi
   2fcee: e8 4d 5d fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 		set->strs_data_len = init_data_sz;
   2fcf3: 49 89 5c 24 08               	movq	%rbx, 8(%r12)
; 		set->strs_data_cap = init_data_sz;
   2fcf8: 49 89 5c 24 10               	movq	%rbx, 16(%r12)
; 		for (off = 0; off < set->strs_data_len; off += strlen(set->strs_data + off) + 1) {
   2fcfd: 48 85 db                     	testq	%rbx, %rbx
   2fd00: 74 45                        	je	0x2fd47 <strset__new+0xd7>
   2fd02: 31 f6                        	xorl	%esi, %esi
   2fd04: 31 db                        	xorl	%ebx, %ebx
   2fd06: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)
; 	return hashmap__insert(map, key, value, HASHMAP_ADD, NULL, NULL);
   2fd10: 45 31 c9                     	xorl	%r9d, %r9d
   2fd13: 45 31 c0                     	xorl	%r8d, %r8d
   2fd16: 31 c9                        	xorl	%ecx, %ecx
   2fd18: 48 89 f2                     	movq	%rsi, %rdx
   2fd1b: 48 89 ef                     	movq	%rbp, %rdi
   2fd1e: e8 ed e7 fe ff               	callq	0x1e510 <hashmap__insert>
; 			if (err)
   2fd23: 85 c0                        	testl	%eax, %eax
   2fd25: 74 05                        	je	0x2fd2c <strset__new+0xbc>
   2fd27: 83 f8 ef                     	cmpl	$-17, %eax
   2fd2a: 75 6c                        	jne	0x2fd98 <strset__new+0x128>
; 		for (off = 0; off < set->strs_data_len; off += strlen(set->strs_data + off) + 1) {
   2fd2c: 49 8b 3c 24                  	movq	(%r12), %rdi
   2fd30: 48 01 df                     	addq	%rbx, %rdi
   2fd33: e8 a8 5a fd ff               	callq	0x57e0 <.plt.sec+0x170>
   2fd38: 48 8d 5c 03 01               	leaq	1(%rbx,%rax), %rbx
   2fd3d: 48 89 de                     	movq	%rbx, %rsi
   2fd40: 49 3b 5c 24 08               	cmpq	8(%r12), %rbx
   2fd45: 72 c9                        	jb	0x2fd10 <strset__new+0xa0>
; }
   2fd47: 5b                           	popq	%rbx
   2fd48: 4c 89 e0                     	movq	%r12, %rax
   2fd4b: 5d                           	popq	%rbp
   2fd4c: 41 5c                        	popq	%r12
   2fd4e: 41 5d                        	popq	%r13
   2fd50: 41 5e                        	popq	%r14
   2fd52: c3                           	retq
   2fd53: 0f 1f 44 00 00               	nopl	(%rax,%rax)
; 		for (off = 0; off < set->strs_data_len; off += strlen(set->strs_data + off) + 1) {
   2fd58: 48 c7 c3 f4 ff ff ff         	movq	$-12, %rbx
; 	if (IS_ERR_OR_NULL(set))
   2fd5f: 49 81 fc 00 f0 ff ff         	cmpq	$-4096, %r12            # imm = 0xF000
   2fd66: 77 1b                        	ja	0x2fd83 <strset__new+0x113>
; 	hashmap__free(set->strs_hash);
   2fd68: 49 8b 7c 24 20               	movq	32(%r12), %rdi
   2fd6d: e8 3e e7 fe ff               	callq	0x1e4b0 <hashmap__free>
; 	free(set->strs_data);
   2fd72: 49 8b 3c 24                  	movq	(%r12), %rdi
   2fd76: e8 45 59 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(set);
   2fd7b: 4c 89 e7                     	movq	%r12, %rdi
   2fd7e: e8 3d 59 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	return ERR_PTR(err);
   2fd83: 49 89 dc                     	movq	%rbx, %r12
; }
   2fd86: 5b                           	popq	%rbx
   2fd87: 5d                           	popq	%rbp
   2fd88: 4c 89 e0                     	movq	%r12, %rax
   2fd8b: 41 5c                        	popq	%r12
   2fd8d: 41 5d                        	popq	%r13
   2fd8f: 41 5e                        	popq	%r14
   2fd91: c3                           	retq
   2fd92: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
; 	return ERR_PTR(err);
   2fd98: 48 63 d8                     	movslq	%eax, %rbx
   2fd9b: eb c2                        	jmp	0x2fd5f <strset__new+0xef>
; 		return ERR_PTR(-ENOMEM);
   2fd9d: 49 c7 c4 f4 ff ff ff         	movq	$-12, %r12
   2fda4: eb a1                        	jmp	0x2fd47 <strset__new+0xd7>
   2fda6: 66 2e 0f 1f 84 00 00 00 00 00	nopw	%cs:(%rax,%rax)

000000000002fdb0 <strset__free>:
; {
   2fdb0: f3 0f 1e fa                  	endbr64
; 	if (IS_ERR_OR_NULL(set))
   2fdb4: 48 85 ff                     	testq	%rdi, %rdi
   2fdb7: 74 37                        	je	0x2fdf0 <strset__free+0x40>
; {
   2fdb9: 55                           	pushq	%rbp
   2fdba: 48 89 fd                     	movq	%rdi, %rbp
; 	if (IS_ERR_OR_NULL(set))
   2fdbd: 48 81 ff 00 f0 ff ff         	cmpq	$-4096, %rdi            # imm = 0xF000
   2fdc4: 77 22                        	ja	0x2fde8 <strset__free+0x38>
; 	hashmap__free(set->strs_hash);
   2fdc6: 48 8b 7f 20                  	movq	32(%rdi), %rdi
   2fdca: e8 e1 e6 fe ff               	callq	0x1e4b0 <hashmap__free>
; 	free(set->strs_data);
   2fdcf: 48 8b 7d 00                  	movq	(%rbp), %rdi
   2fdd3: e8 e8 58 fd ff               	callq	0x56c0 <.plt.sec+0x50>
; 	free(set);
   2fdd8: 48 89 ef                     	movq	%rbp, %rdi
; }
   2fddb: 5d                           	popq	%rbp
; 	free(set);
   2fddc: e9 df 58 fd ff               	jmp	0x56c0 <.plt.sec+0x50>
   2fde1: 0f 1f 80 00 00 00 00         	nopl	(%rax)
; }
   2fde8: 5d                           	popq	%rbp
   2fde9: c3                           	retq
   2fdea: 66 0f 1f 44 00 00            	nopw	(%rax,%rax)
   2fdf0: c3                           	retq
   2fdf1: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2fdfc: 0f 1f 40 00                  	nopl	(%rax)

000000000002fe00 <strset__data_size>:
; {
   2fe00: f3 0f 1e fa                  	endbr64
; 	return set->strs_data_len;
   2fe04: 48 8b 47 08                  	movq	8(%rdi), %rax
; }
   2fe08: c3                           	retq
   2fe09: 0f 1f 80 00 00 00 00         	nopl	(%rax)

000000000002fe10 <strset__data>:
; {
   2fe10: f3 0f 1e fa                  	endbr64
; 	return set->strs_data;
   2fe14: 48 8b 07                     	movq	(%rdi), %rax
; }
   2fe17: c3                           	retq
   2fe18: 0f 1f 84 00 00 00 00 00      	nopl	(%rax,%rax)

000000000002fe20 <strset__find_str>:
; {
   2fe20: f3 0f 1e fa                  	endbr64
   2fe24: 41 55                        	pushq	%r13
   2fe26: 41 54                        	pushq	%r12
   2fe28: 55                           	pushq	%rbp
   2fe29: 48 89 f5                     	movq	%rsi, %rbp
   2fe2c: 53                           	pushq	%rbx
   2fe2d: 48 89 fb                     	movq	%rdi, %rbx
; 	len = strlen(s) + 1;
   2fe30: 48 89 f7                     	movq	%rsi, %rdi
; {
   2fe33: 48 83 ec 18                  	subq	$24, %rsp
   2fe37: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2fe40: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   2fe45: 31 c0                        	xorl	%eax, %eax
; 	len = strlen(s) + 1;
   2fe47: e8 94 59 fd ff               	callq	0x57e0 <.plt.sec+0x170>
; 	return libbpf_add_mem(&set->strs_data, &set->strs_data_cap, 1,
   2fe4c: 48 8b 4b 08                  	movq	8(%rbx), %rcx
   2fe50: 4c 8b 43 18                  	movq	24(%rbx), %r8
   2fe54: 48 89 df                     	movq	%rbx, %rdi
; 	len = strlen(s) + 1;
   2fe57: 4c 8d 60 01                  	leaq	1(%rax), %r12
; 	return libbpf_add_mem(&set->strs_data, &set->strs_data_cap, 1,
   2fe5b: 48 8d 73 10                  	leaq	16(%rbx), %rsi
   2fe5f: ba 01 00 00 00               	movl	$1, %edx
   2fe64: 4d 89 e1                     	movq	%r12, %r9
   2fe67: e8 34 9f ff ff               	callq	0x29da0 <libbpf_add_mem>
; 	if (!p)
   2fe6c: 48 85 c0                     	testq	%rax, %rax
   2fe6f: 74 47                        	je	0x2feb8 <strset__find_str+0x98>
; 	new_off = set->strs_data_len;
   2fe71: 4c 8b 6b 08                  	movq	8(%rbx), %r13
   2fe75: 48 89 c7                     	movq	%rax, %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2fe78: 4c 89 e2                     	movq	%r12, %rdx
   2fe7b: 48 89 ee                     	movq	%rbp, %rsi
   2fe7e: e8 bd 5b fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	if (hashmap__find(set->strs_hash, (void *)new_off, (void **)&old_off))
   2fe83: 48 8b 7b 20                  	movq	32(%rbx), %rdi
   2fe87: 48 89 e2                     	movq	%rsp, %rdx
   2fe8a: 4c 89 ee                     	movq	%r13, %rsi
   2fe8d: e8 ae e9 fe ff               	callq	0x1e840 <hashmap__find>
   2fe92: 84 c0                        	testb	%al, %al
; 		return old_off;
   2fe94: b8 fe ff ff ff               	movl	$4294967294, %eax       # imm = 0xFFFFFFFE
   2fe99: 0f 45 04 24                  	cmovnel	(%rsp), %eax
; }
   2fe9d: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   2fea2: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   2feab: 75 12                        	jne	0x2febf <strset__find_str+0x9f>
   2fead: 48 83 c4 18                  	addq	$24, %rsp
   2feb1: 5b                           	popq	%rbx
   2feb2: 5d                           	popq	%rbp
   2feb3: 41 5c                        	popq	%r12
   2feb5: 41 5d                        	popq	%r13
   2feb7: c3                           	retq
; 		return -ENOMEM;
   2feb8: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2febd: eb de                        	jmp	0x2fe9d <strset__find_str+0x7d>
; }
   2febf: e8 3c 59 fd ff               	callq	0x5800 <.plt.sec+0x190>
   2fec4: 66 66 2e 0f 1f 84 00 00 00 00 00     	nopw	%cs:(%rax,%rax)
   2fecf: 90                           	nop

000000000002fed0 <strset__add_str>:
; {
   2fed0: f3 0f 1e fa                  	endbr64
   2fed4: 41 55                        	pushq	%r13
   2fed6: 41 54                        	pushq	%r12
   2fed8: 49 89 f4                     	movq	%rsi, %r12
   2fedb: 55                           	pushq	%rbp
   2fedc: 53                           	pushq	%rbx
   2fedd: 48 89 fb                     	movq	%rdi, %rbx
; 	len = strlen(s) + 1;
   2fee0: 48 89 f7                     	movq	%rsi, %rdi
; {
   2fee3: 48 83 ec 18                  	subq	$24, %rsp
   2fee7: 64 48 8b 04 25 28 00 00 00   	movq	%fs:40, %rax
   2fef0: 48 89 44 24 08               	movq	%rax, 8(%rsp)
   2fef5: 31 c0                        	xorl	%eax, %eax
; 	len = strlen(s) + 1;
   2fef7: e8 e4 58 fd ff               	callq	0x57e0 <.plt.sec+0x170>
; 	return libbpf_add_mem(&set->strs_data, &set->strs_data_cap, 1,
   2fefc: 48 8b 4b 08                  	movq	8(%rbx), %rcx
   2ff00: 4c 8b 43 18                  	movq	24(%rbx), %r8
   2ff04: 48 89 df                     	movq	%rbx, %rdi
; 	len = strlen(s) + 1;
   2ff07: 48 8d 68 01                  	leaq	1(%rax), %rbp
; 	return libbpf_add_mem(&set->strs_data, &set->strs_data_cap, 1,
   2ff0b: 48 8d 73 10                  	leaq	16(%rbx), %rsi
   2ff0f: ba 01 00 00 00               	movl	$1, %edx
   2ff14: 49 89 e9                     	movq	%rbp, %r9
   2ff17: e8 84 9e ff ff               	callq	0x29da0 <libbpf_add_mem>
; 	if (!p)
   2ff1c: 48 85 c0                     	testq	%rax, %rax
   2ff1f: 74 5c                        	je	0x2ff7d <strset__add_str+0xad>
; 	new_off = set->strs_data_len;
   2ff21: 4c 8b 6b 08                  	movq	8(%rbx), %r13
   2ff25: 48 89 c7                     	movq	%rax, %rdi
;   return __builtin___memcpy_chk (__dest, __src, __len,
   2ff28: 48 89 ea                     	movq	%rbp, %rdx
   2ff2b: 4c 89 e6                     	movq	%r12, %rsi
   2ff2e: e8 0d 5b fd ff               	callq	0x5a40 <.plt.sec+0x3d0>
; 	err = hashmap__insert(set->strs_hash, (void *)new_off, (void *)new_off,
   2ff33: 48 8b 7b 20                  	movq	32(%rbx), %rdi
   2ff37: 45 31 c9                     	xorl	%r9d, %r9d
   2ff3a: 31 c9                        	xorl	%ecx, %ecx
   2ff3c: 49 89 e0                     	movq	%rsp, %r8
   2ff3f: 4c 89 ea                     	movq	%r13, %rdx
   2ff42: 4c 89 ee                     	movq	%r13, %rsi
   2ff45: e8 c6 e5 fe ff               	callq	0x1e510 <hashmap__insert>
; 	if (err == -EEXIST)
   2ff4a: 83 f8 ef                     	cmpl	$-17, %eax
   2ff4d: 74 29                        	je	0x2ff78 <strset__add_str+0xa8>
; 	if (err)
   2ff4f: 85 c0                        	testl	%eax, %eax
   2ff51: 75 07                        	jne	0x2ff5a <strset__add_str+0x8a>
; 	set->strs_data_len += len; /* new unique string, adjust data length */
   2ff53: 48 01 6b 08                  	addq	%rbp, 8(%rbx)
; 	return new_off;
   2ff57: 44 89 e8                     	movl	%r13d, %eax
; }
   2ff5a: 48 8b 54 24 08               	movq	8(%rsp), %rdx
   2ff5f: 64 48 2b 14 25 28 00 00 00   	subq	%fs:40, %rdx
   2ff68: 75 1a                        	jne	0x2ff84 <strset__add_str+0xb4>
   2ff6a: 48 83 c4 18                  	addq	$24, %rsp
   2ff6e: 5b                           	popq	%rbx
   2ff6f: 5d                           	popq	%rbp
   2ff70: 41 5c                        	popq	%r12
   2ff72: 41 5d                        	popq	%r13
   2ff74: c3                           	retq
   2ff75: 0f 1f 00                     	nopl	(%rax)
; 		return old_off; /* duplicated string, return existing offset */
   2ff78: 8b 04 24                     	movl	(%rsp), %eax
   2ff7b: eb dd                        	jmp	0x2ff5a <strset__add_str+0x8a>
; 		return -ENOMEM;
   2ff7d: b8 f4 ff ff ff               	movl	$4294967284, %eax       # imm = 0xFFFFFFF4
   2ff82: eb d6                        	jmp	0x2ff5a <strset__add_str+0x8a>
; }
   2ff84: e8 77 58 fd ff               	callq	0x5800 <.plt.sec+0x190>

Disassembly of section .fini:

000000000002ff8c <_fini>:
   2ff8c: f3 0f 1e fa                  	endbr64
   2ff90: 48 83 ec 08                  	subq	$8, %rsp
   2ff94: 48 83 c4 08                  	addq	$8, %rsp
   2ff98: c3                           	retq
